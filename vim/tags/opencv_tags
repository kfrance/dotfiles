!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	contrib/contrib.hpp	/^        CvMat** A;$/;"	m	class:cv::LevMarqSparse	access:public
ABSOLUTE_LOSS	ml/ml.hpp	/^    enum {SQUARED_LOSS=0, ABSOLUTE_LOSS, HUBER_LOSS=3, DEVIANCE_LOSS};$/;"	e	enum:CvGBTrees::__anon81
ADAPTIVE_THRESH_GAUSSIAN_C	imgproc/imgproc.hpp	/^enum { ADAPTIVE_THRESH_MEAN_C=0, ADAPTIVE_THRESH_GAUSSIAN_C=1 };$/;"	e	enum:cv::__anon17
ADAPTIVE_THRESH_MEAN_C	imgproc/imgproc.hpp	/^enum { ADAPTIVE_THRESH_MEAN_C=0, ADAPTIVE_THRESH_GAUSSIAN_C=1 };$/;"	e	enum:cv::__anon17
ALLOC_PAGE_LOCKED	gpu/gpu.hpp	/^            enum  { ALLOC_PAGE_LOCKED = 1, ALLOC_ZEROCOPY = 2, ALLOC_WRITE_COMBINED = 4 };$/;"	e	enum:cv::gpu::CudaMem::__anon54
ALLOC_WRITE_COMBINED	gpu/gpu.hpp	/^            enum  { ALLOC_PAGE_LOCKED = 1, ALLOC_ZEROCOPY = 2, ALLOC_WRITE_COMBINED = 4 };$/;"	e	enum:cv::gpu::CudaMem::__anon54
ALLOC_ZEROCOPY	gpu/gpu.hpp	/^            enum  { ALLOC_PAGE_LOCKED = 1, ALLOC_ZEROCOPY = 2, ALLOC_WRITE_COMBINED = 4 };$/;"	e	enum:cv::gpu::CudaMem::__anon54
ANN_MLP_TrainParams	ml/ml.hpp	/^typedef CvANN_MLP_TrainParams ANN_MLP_TrainParams;$/;"	t	namespace:cv
APPEND	core/core.hpp	/^        APPEND=2 \/\/! append mode$/;"	e	enum:cv::FileStorage::__anon147
AUTOTUNED	flann/defines.h	/^    AUTOTUNED = 255$/;"	e	enum:cvflann::flann_algorithm_t
AUTO_STEP	core/core.hpp	/^    enum { MAGIC_VAL=0x42FF0000, AUTO_STEP=0, CONTINUOUS_FLAG=CV_MAT_CONT_FLAG, SUBMATRIX_FLAG=CV_SUBMAT_FLAG };$/;"	e	enum:cv::Mat::__anon137
AVERAGE_ANGLE	features2d/features2d.hpp	/^        enum { FIRST_ANGLE = 0, AVERAGE_ANGLE = 1 };$/;"	e	enum:cv::SIFT::CommonParams::__anon190
Accumulator	features2d/features2d.hpp	/^struct CV_EXPORTS Accumulator$/;"	s	namespace:cv
Accumulator	features2d/features2d.hpp	/^template<> struct Accumulator<char>   { typedef float Type; };$/;"	s	namespace:cv
Accumulator	features2d/features2d.hpp	/^template<> struct Accumulator<short>  { typedef float Type; };$/;"	s	namespace:cv
Accumulator	features2d/features2d.hpp	/^template<> struct Accumulator<unsigned char>  { typedef float Type; };$/;"	s	namespace:cv
Accumulator	features2d/features2d.hpp	/^template<> struct Accumulator<unsigned short> { typedef float Type; };$/;"	s	namespace:cv
Accumulator	flann/dist.h	/^struct Accumulator { typedef T Type; };$/;"	s	namespace:cvflann
Accumulator	flann/dist.h	/^struct Accumulator<char>   { typedef float Type; };$/;"	s	namespace:cvflann
Accumulator	flann/dist.h	/^struct Accumulator<int> { typedef float Type; };$/;"	s	namespace:cvflann
Accumulator	flann/dist.h	/^struct Accumulator<short>  { typedef float Type; };$/;"	s	namespace:cvflann
Accumulator	flann/dist.h	/^struct Accumulator<unsigned char>  { typedef float Type; };$/;"	s	namespace:cvflann
Accumulator	flann/dist.h	/^struct Accumulator<unsigned int> { typedef float Type; };$/;"	s	namespace:cvflann
Accumulator	flann/dist.h	/^struct Accumulator<unsigned short> { typedef float Type; };$/;"	s	namespace:cvflann
AddBlob	legacy/blobtrack.hpp	/^    virtual CvBlob* AddBlob(CvBlob* pBlob, IplImage* pImg, IplImage* pImgFG = NULL ) = 0;$/;"	p	class:CvBlobTracker	access:public	signature:(CvBlob* pBlob, IplImage* pImg, IplImage* pImgFG = NULL )
AddBlob	legacy/blobtrack.hpp	/^    virtual void    AddBlob(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackAnalysis	access:public	signature:(CvBlob* pBlob)
AddBlob	legacy/blobtrack.hpp	/^    virtual void    AddBlob(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackFVGen	access:public	signature:(CvBlob* pBlob)
AddBlob	legacy/blobtrack.hpp	/^    virtual void    AddBlob(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackGen	access:public	signature:(CvBlob* pBlob)
AddBlob	legacy/blobtrack.hpp	/^    virtual void    AddBlob(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackPostProc	access:public	signature:(CvBlob* pBlob)
AddBlob	legacy/blobtrack.hpp	/^    virtual void AddBlob(CvBlob* pB)$/;"	f	class:CvBlobSeq	access:public	signature:(CvBlob* pB)
AddBlobTrack	legacy/blobtrack.hpp	/^    virtual void AddBlobTrack(int TrackID, int StartFrame = 0);$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackID, int StartFrame = 0)
AddFeature	legacy/blobtrack.hpp	/^    virtual void AddFeature(float W, int* comps, int x =0, int y = 0) = 0;$/;"	p	class:CvProb	access:public	signature:(float W, int* comps, int x =0, int y = 0)
AddFormat	legacy/blobtrack.hpp	/^    void AddFormat(const char* str){strcat(m_pElemFormat,str);}$/;"	f	class:CvBlobSeq	access:public	signature:(const char* str)
AddParam	legacy/blobtrack.hpp	/^    void AddParam(const char* name);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name)
AddParam	legacy/blobtrack.hpp	/^    void AddParam(const char* name, const char** pAddr);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name, const char** pAddr)
AddParam	legacy/blobtrack.hpp	/^    void AddParam(const char* name, double* pAddr);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name, double* pAddr)
AddParam	legacy/blobtrack.hpp	/^    void AddParam(const char* name, float* pAddr);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name, float* pAddr)
AddParam	legacy/blobtrack.hpp	/^    void AddParam(const char* name, int* pAddr);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name, int* pAddr)
AdjusterAdapter	features2d/features2d.hpp	/^class CV_EXPORTS AdjusterAdapter: public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
All	legacy/legacy.hpp	/^    int** All;$/;"	m	struct:CvCliqueFinder	access:public
Allocate	core/wimage.hpp	/^    void Allocate(int width, int height);$/;"	p	class:cv::WImageBufferC	access:public	signature:(int width, int height)
Allocate	core/wimage.hpp	/^    void Allocate(int width, int height, int nchannels);$/;"	p	class:cv::WImageBuffer	access:public	signature:(int width, int height, int nchannels)
Allocate	core/wimage.hpp	/^inline void WImageBuffer<T>::Allocate(int width, int height, int nchannels)$/;"	f	class:cv::WImageBuffer	signature:(int width, int height, int nchannels)
Allocate	core/wimage.hpp	/^inline void WImageBufferC<T, C>::Allocate(int width, int height)$/;"	f	class:cv::WImageBufferC	signature:(int width, int height)
Allocate	features2d/features2d.hpp	/^    void Allocate(int pose_count, CvSize size, int nChannels);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int pose_count, CvSize size, int nChannels)
Allocate	features2d/features2d.hpp	/^    void Allocate(int train_feature_count);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(int train_feature_count)
Allocate	features2d/features2d.hpp	/^    void Allocate(int train_feature_count, int object_feature_count);$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(int train_feature_count, int object_feature_count)
AllocatePCADescriptors	features2d/features2d.hpp	/^    void AllocatePCADescriptors();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
Allocator	core/core.hpp	/^    explicit Allocator() {}$/;"	f	class:cv::Allocator	access:public	signature:()
Allocator	core/core.hpp	/^    explicit Allocator(Allocator const&) {}$/;"	f	class:cv::Allocator	access:public	signature:(Allocator const&)
Allocator	core/core.hpp	/^    explicit Allocator(Allocator<U> const&) {}$/;"	f	class:cv::Allocator	access:public	signature:(Allocator<U> const&)
Allocator	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Allocator$/;"	c	namespace:cv
AutoBuffer	core/core.hpp	/^    AutoBuffer();$/;"	p	class:cv::AutoBuffer	access:public	signature:()
AutoBuffer	core/core.hpp	/^    AutoBuffer(size_t _size);$/;"	p	class:cv::AutoBuffer	access:public	signature:(size_t _size)
AutoBuffer	core/core.hpp	/^template<typename _Tp, size_t fixed_size=4096\/sizeof(_Tp)+8> class CV_EXPORTS AutoBuffer$/;"	c	namespace:cv
AutoBuffer	core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::AutoBuffer()$/;"	f	class:cv::AutoBuffer	signature:()
AutoBuffer	core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::AutoBuffer(size_t _size)$/;"	f	class:cv::AutoBuffer	signature:(size_t _size)
AutotunedIndex	flann/autotuned_index.h	/^    AutotunedIndex(const AutotunedIndex&);$/;"	p	class:cvflann::AutotunedIndex	access:public	signature:(const AutotunedIndex&)
AutotunedIndex	flann/autotuned_index.h	/^    AutotunedIndex(const Matrix<ElementType>& inputData, const IndexParams& params = AutotunedIndexParams(), Distance d = Distance()) :$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:(const Matrix<ElementType>& inputData, const IndexParams& params = AutotunedIndexParams(), Distance d = Distance())
AutotunedIndex	flann/autotuned_index.h	/^class AutotunedIndex : public NNIndex<Distance>$/;"	c	namespace:cvflann	inherits:NNIndex
AutotunedIndexParams	flann/autotuned_index.h	/^    AutotunedIndexParams(float target_precision = 0.8, float build_weight = 0.01, float memory_weight = 0, float sample_fraction = 0.1)$/;"	f	struct:cvflann::AutotunedIndexParams	access:public	signature:(float target_precision = 0.8, float build_weight = 0.01, float memory_weight = 0, float sample_fraction = 0.1)
AutotunedIndexParams	flann/autotuned_index.h	/^struct AutotunedIndexParams : public IndexParams$/;"	s	namespace:cvflann	inherits:IndexParams
AutotunedIndexParams	flann/miniflann.hpp	/^    AutotunedIndexParams(float target_precision = 0.8, float build_weight = 0.01,$/;"	p	struct:cv::flann::AutotunedIndexParams	access:public	signature:(float target_precision = 0.8, float build_weight = 0.01, float memory_weight = 0, float sample_fraction = 0.1)
AutotunedIndexParams	flann/miniflann.hpp	/^struct CV_EXPORTS AutotunedIndexParams : public IndexParams$/;"	s	namespace:cv::flann	inherits:IndexParams
B	contrib/contrib.hpp	/^        CvMat** B;$/;"	m	class:cv::LevMarqSparse	access:public
BACKPROP	ml/ml.hpp	/^    enum { BACKPROP=0, RPROP=1 };$/;"	e	enum:CvANN_MLP_TrainParams::__anon82
BASIC_PRESET	calib3d/calib3d.hpp	/^        BASIC_PRESET=0, FISH_EYE_PRESET=1, NARROW_PRESET=2 };$/;"	e	enum:cv::StereoBM::__anon92
BASIC_PRESET	gpu/gpu.hpp	/^            enum { BASIC_PRESET = 0, PREFILTER_XSOBEL = 1 };$/;"	e	enum:cv::gpu::StereoBM_GPU::__anon55
BLOCKSIZE	flann/allocator.h	/^const  size_t     BLOCKSIZE=8192;$/;"	m	namespace:cvflann
BOOST	objdetect/objdetect.hpp	/^    enum { BOOST = 0 };$/;"	e	enum:cv::CascadeClassifier::__anon200
BORDER_CONSTANT	imgproc/imgproc.hpp	/^enum { BORDER_REPLICATE=IPL_BORDER_REPLICATE, BORDER_CONSTANT=IPL_BORDER_CONSTANT,$/;"	e	enum:cv::__anon10
BORDER_DEFAULT	imgproc/imgproc.hpp	/^       BORDER_DEFAULT=BORDER_REFLECT_101, BORDER_ISOLATED=16 };$/;"	e	enum:cv::__anon10
BORDER_ISOLATED	imgproc/imgproc.hpp	/^       BORDER_DEFAULT=BORDER_REFLECT_101, BORDER_ISOLATED=16 };$/;"	e	enum:cv::__anon10
BORDER_REFLECT	imgproc/imgproc.hpp	/^       BORDER_REFLECT=IPL_BORDER_REFLECT, BORDER_WRAP=IPL_BORDER_WRAP, $/;"	e	enum:cv::__anon10
BORDER_REFLECT101	imgproc/imgproc.hpp	/^       BORDER_REFLECT_101=IPL_BORDER_REFLECT_101, BORDER_REFLECT101=BORDER_REFLECT_101,$/;"	e	enum:cv::__anon10
BORDER_REFLECT_101	imgproc/imgproc.hpp	/^       BORDER_REFLECT_101=IPL_BORDER_REFLECT_101, BORDER_REFLECT101=BORDER_REFLECT_101,$/;"	e	enum:cv::__anon10
BORDER_REPLICATE	imgproc/imgproc.hpp	/^enum { BORDER_REPLICATE=IPL_BORDER_REPLICATE, BORDER_CONSTANT=IPL_BORDER_CONSTANT,$/;"	e	enum:cv::__anon10
BORDER_SIZE	features2d/features2d.hpp	/^    static const int BORDER_SIZE = 16;$/;"	m	class:cv::CalonderDescriptorExtractor	access:protected
BORDER_TRANSPARENT	imgproc/imgproc.hpp	/^       BORDER_TRANSPARENT=IPL_BORDER_TRANSPARENT,$/;"	e	enum:cv::__anon10
BORDER_WRAP	imgproc/imgproc.hpp	/^       BORDER_REFLECT=IPL_BORDER_REFLECT, BORDER_WRAP=IPL_BORDER_WRAP, $/;"	e	enum:cv::__anon10
BOWImgDescriptorExtractor	features2d/features2d.hpp	/^    BOWImgDescriptorExtractor( const Ptr<DescriptorExtractor>& dextractor,$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:( const Ptr<DescriptorExtractor>& dextractor, const Ptr<DescriptorMatcher>& dmatcher )
BOWImgDescriptorExtractor	features2d/features2d.hpp	/^class CV_EXPORTS BOWImgDescriptorExtractor$/;"	c	namespace:cv
BOWKMeansTrainer	features2d/features2d.hpp	/^    BOWKMeansTrainer( int clusterCount, const TermCriteria& termcrit=TermCriteria(),$/;"	p	class:cv::BOWKMeansTrainer	access:public	signature:( int clusterCount, const TermCriteria& termcrit=TermCriteria(), int attempts=3, int flags=KMEANS_PP_CENTERS )
BOWKMeansTrainer	features2d/features2d.hpp	/^class CV_EXPORTS BOWKMeansTrainer : public BOWTrainer$/;"	c	namespace:cv	inherits:BOWTrainer
BOWTrainer	features2d/features2d.hpp	/^    BOWTrainer();$/;"	p	class:cv::BOWTrainer	access:public	signature:()
BOWTrainer	features2d/features2d.hpp	/^class CV_EXPORTS BOWTrainer$/;"	c	namespace:cv
BackgroundSubtractor	video/background_segm.hpp	/^class CV_EXPORTS_W BackgroundSubtractor$/;"	c	namespace:cv
BackgroundSubtractorMOG	video/background_segm.hpp	/^    CV_WRAP BackgroundSubtractorMOG();$/;"	p	class:cv::BackgroundSubtractorMOG	access:public	signature:()
BackgroundSubtractorMOG	video/background_segm.hpp	/^    CV_WRAP BackgroundSubtractorMOG(int history, int nmixtures, double backgroundRatio, double noiseSigma=0);$/;"	p	class:cv::BackgroundSubtractorMOG	access:public	signature:(int history, int nmixtures, double backgroundRatio, double noiseSigma=0)
BackgroundSubtractorMOG	video/background_segm.hpp	/^class CV_EXPORTS_W BackgroundSubtractorMOG : public BackgroundSubtractor$/;"	c	namespace:cv	inherits:BackgroundSubtractor
BackgroundSubtractorMOG2	video/background_segm.hpp	/^    BackgroundSubtractorMOG2();$/;"	p	class:cv::BackgroundSubtractorMOG2	access:public	signature:()
BackgroundSubtractorMOG2	video/background_segm.hpp	/^    BackgroundSubtractorMOG2(int history,  float varThreshold, bool bShadowDetection=1);$/;"	p	class:cv::BackgroundSubtractorMOG2	access:public	signature:(int history, float varThreshold, bool bShadowDetection=1)
BackgroundSubtractorMOG2	video/background_segm.hpp	/^class CV_EXPORTS BackgroundSubtractorMOG2 : public BackgroundSubtractor$/;"	c	namespace:cv	inherits:BackgroundSubtractor
BaseColumnFilter	imgproc/imgproc.hpp	/^    BaseColumnFilter();$/;"	p	class:cv::BaseColumnFilter	access:public	signature:()
BaseColumnFilter	imgproc/imgproc.hpp	/^class CV_EXPORTS BaseColumnFilter$/;"	c	namespace:cv
BaseColumnFilter_GPU	gpu/gpu.hpp	/^            BaseColumnFilter_GPU(int ksize_, int anchor_) : ksize(ksize_), anchor(anchor_) {}$/;"	f	class:cv::gpu::BaseColumnFilter_GPU	access:public	signature:(int ksize_, int anchor_)
BaseColumnFilter_GPU	gpu/gpu.hpp	/^        class CV_EXPORTS BaseColumnFilter_GPU$/;"	c	namespace:cv::gpu
BaseFilter	imgproc/imgproc.hpp	/^    BaseFilter();$/;"	p	class:cv::BaseFilter	access:public	signature:()
BaseFilter	imgproc/imgproc.hpp	/^class CV_EXPORTS BaseFilter$/;"	c	namespace:cv
BaseFilter_GPU	gpu/gpu.hpp	/^            BaseFilter_GPU(const Size& ksize_, const Point& anchor_) : ksize(ksize_), anchor(anchor_) {}$/;"	f	class:cv::gpu::BaseFilter_GPU	access:public	signature:(const Size& ksize_, const Point& anchor_)
BaseFilter_GPU	gpu/gpu.hpp	/^        class CV_EXPORTS BaseFilter_GPU$/;"	c	namespace:cv::gpu
BaseKeypoint	features2d/features2d.hpp	/^  BaseKeypoint()$/;"	f	struct:cv::BaseKeypoint	access:public	signature:()
BaseKeypoint	features2d/features2d.hpp	/^  BaseKeypoint(int x, int y, IplImage* image)$/;"	f	struct:cv::BaseKeypoint	access:public	signature:(int x, int y, IplImage* image)
BaseKeypoint	features2d/features2d.hpp	/^struct CV_EXPORTS BaseKeypoint$/;"	s	namespace:cv
BaseRowFilter	imgproc/imgproc.hpp	/^    BaseRowFilter();$/;"	p	class:cv::BaseRowFilter	access:public	signature:()
BaseRowFilter	imgproc/imgproc.hpp	/^class CV_EXPORTS BaseRowFilter$/;"	c	namespace:cv
BaseRowFilter_GPU	gpu/gpu.hpp	/^            BaseRowFilter_GPU(int ksize_, int anchor_) : ksize(ksize_), anchor(anchor_) {}$/;"	f	class:cv::gpu::BaseRowFilter_GPU	access:public	signature:(int ksize_, int anchor_)
BaseRowFilter_GPU	gpu/gpu.hpp	/^        class CV_EXPORTS BaseRowFilter_GPU$/;"	c	namespace:cv::gpu
BaseType	core/wimage.hpp	/^    typedef T BaseType;$/;"	t	class:cv::WImage	access:public
BaseType	core/wimage.hpp	/^    typedef typename WImage<T>::BaseType BaseType;$/;"	t	class:cv::WImageBuffer	access:public
BaseType	core/wimage.hpp	/^    typedef typename WImage<T>::BaseType BaseType;$/;"	t	class:cv::WImageBufferC	access:public
BaseType	core/wimage.hpp	/^    typedef typename WImage<T>::BaseType BaseType;$/;"	t	class:cv::WImageC	access:public
BaseType	core/wimage.hpp	/^    typedef typename WImage<T>::BaseType BaseType;$/;"	t	class:cv::WImageView	access:public
BaseType	core/wimage.hpp	/^    typedef typename WImage<T>::BaseType BaseType;$/;"	t	class:cv::WImageViewC	access:public
BlockedRange	core/internal.hpp	/^        typedef tbb::blocked_range<int> BlockedRange;$/;"	t	namespace:cv
Boost	ml/ml.hpp	/^typedef CvBoost Boost;$/;"	t	namespace:cv
BoostParams	ml/ml.hpp	/^typedef CvBoostParams BoostParams;$/;"	t	namespace:cv
BoostTree	ml/ml.hpp	/^typedef CvBoostTree BoostTree;$/;"	t	namespace:cv
BorderConst	core/types_c.h	/^    int  BorderConst[4];    \/* Ditto.                                 *\/$/;"	m	struct:_IplImage	access:public
BorderMode	core/types_c.h	/^    int  BorderMode[4];     \/* Ignored by OpenCV.                     *\/$/;"	m	struct:_IplImage	access:public
BoundingBox	flann/kdtree_single_index.h	/^    typedef std::vector<Interval> BoundingBox;$/;"	t	class:cvflann::KDTreeSingleIndex	access:private
Branch	flann/kdtree_index.h	/^    typedef BranchSt* Branch;$/;"	t	class:cvflann::KDTreeIndex	access:private
Branch	flann/kdtree_single_index.h	/^    typedef BranchSt* Branch;$/;"	t	class:cvflann::KDTreeSingleIndex	access:private
BranchSt	flann/hierarchical_clustering_index.h	/^    typedef BranchStruct<NodePtr, DistanceType> BranchSt;$/;"	t	class:cvflann::HierarchicalClusteringIndex	access:private
BranchSt	flann/kdtree_index.h	/^    typedef BranchStruct<NodePtr, DistanceType> BranchSt;$/;"	t	class:cvflann::KDTreeIndex	access:private
BranchSt	flann/kdtree_single_index.h	/^    typedef BranchStruct<NodePtr, DistanceType> BranchSt;$/;"	t	class:cvflann::KDTreeSingleIndex	access:private
BranchSt	flann/kmeans_index.h	/^    typedef BranchStruct<KMeansNodePtr, DistanceType> BranchSt;$/;"	t	class:cvflann::KMeansIndex	access:private
BranchStruct	flann/result_set.h	/^    BranchStruct() {}$/;"	f	struct:cvflann::BranchStruct	access:public	signature:()
BranchStruct	flann/result_set.h	/^    BranchStruct(const T& aNode, DistanceType dist) : node(aNode), mindist(dist) {}$/;"	f	struct:cvflann::BranchStruct	access:public	signature:(const T& aNode, DistanceType dist)
BranchStruct	flann/result_set.h	/^struct BranchStruct$/;"	s	namespace:cvflann
BriefDescriptorExtractor	features2d/features2d.hpp	/^    BriefDescriptorExtractor( int bytes = 32 );$/;"	p	class:cv::BriefDescriptorExtractor	access:public	signature:( int bytes = 32 )
BriefDescriptorExtractor	features2d/features2d.hpp	/^class CV_EXPORTS BriefDescriptorExtractor : public DescriptorExtractor$/;"	c	namespace:cv	inherits:DescriptorExtractor
BruteForceMatcher	features2d/features2d.hpp	/^    BruteForceMatcher( Distance d = Distance() ) : distance(d) {}$/;"	f	class:cv::BruteForceMatcher	access:public	signature:( Distance d = Distance() )
BruteForceMatcher	features2d/features2d.hpp	/^class CV_EXPORTS BruteForceMatcher : public DescriptorMatcher$/;"	c	namespace:cv	inherits:DescriptorMatcher
BruteForceMatcher_GPU	gpu/gpu.hpp	/^            explicit BruteForceMatcher_GPU() : BruteForceMatcher_GPU_base(HammingDist) {}$/;"	f	class:cv::gpu::BruteForceMatcher_GPU	access:public	signature:()
BruteForceMatcher_GPU	gpu/gpu.hpp	/^            explicit BruteForceMatcher_GPU() : BruteForceMatcher_GPU_base(L1Dist) {}$/;"	f	class:cv::gpu::BruteForceMatcher_GPU	access:public	signature:()
BruteForceMatcher_GPU	gpu/gpu.hpp	/^            explicit BruteForceMatcher_GPU() : BruteForceMatcher_GPU_base(L2Dist) {}$/;"	f	class:cv::gpu::BruteForceMatcher_GPU	access:public	signature:()
BruteForceMatcher_GPU	gpu/gpu.hpp	/^            explicit BruteForceMatcher_GPU(Hamming \/*d*\/) : BruteForceMatcher_GPU_base(HammingDist) {}$/;"	f	class:cv::gpu::BruteForceMatcher_GPU	access:public	signature:(Hamming )
BruteForceMatcher_GPU	gpu/gpu.hpp	/^            explicit BruteForceMatcher_GPU(HammingLUT \/*d*\/) : BruteForceMatcher_GPU_base(HammingDist) {}$/;"	f	class:cv::gpu::BruteForceMatcher_GPU	access:public	signature:(HammingLUT )
BruteForceMatcher_GPU	gpu/gpu.hpp	/^            explicit BruteForceMatcher_GPU(L1<T> \/*d*\/) : BruteForceMatcher_GPU_base(L1Dist) {}$/;"	f	class:cv::gpu::BruteForceMatcher_GPU	access:public	signature:(L1<T> )
BruteForceMatcher_GPU	gpu/gpu.hpp	/^            explicit BruteForceMatcher_GPU(L2<T> \/*d*\/) : BruteForceMatcher_GPU_base(L2Dist) {}$/;"	f	class:cv::gpu::BruteForceMatcher_GPU	access:public	signature:(L2<T> )
BruteForceMatcher_GPU	gpu/gpu.hpp	/^        class CV_EXPORTS BruteForceMatcher_GPU;$/;"	m	namespace:cv::gpu	typeref:class:cv::gpu::CV_EXPORTS
BruteForceMatcher_GPU	gpu/gpu.hpp	/^        class CV_EXPORTS BruteForceMatcher_GPU< L1<T> > : public BruteForceMatcher_GPU_base$/;"	c	namespace:cv::gpu	inherits:BruteForceMatcher_GPU_base
BruteForceMatcher_GPU	gpu/gpu.hpp	/^        class CV_EXPORTS BruteForceMatcher_GPU< L2<T> > : public BruteForceMatcher_GPU_base$/;"	c	namespace:cv::gpu	inherits:BruteForceMatcher_GPU_base
BruteForceMatcher_GPU	gpu/gpu.hpp	/^        template <> class CV_EXPORTS BruteForceMatcher_GPU< Hamming > : public BruteForceMatcher_GPU_base$/;"	c	namespace:cv::gpu	inherits:BruteForceMatcher_GPU_base
BruteForceMatcher_GPU	gpu/gpu.hpp	/^        template <> class CV_EXPORTS BruteForceMatcher_GPU< HammingLUT > : public BruteForceMatcher_GPU_base$/;"	c	namespace:cv::gpu	inherits:BruteForceMatcher_GPU_base
BruteForceMatcher_GPU_base	gpu/gpu.hpp	/^            explicit BruteForceMatcher_GPU_base(DistType distType = L2Dist);$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(DistType distType = L2Dist)
BruteForceMatcher_GPU_base	gpu/gpu.hpp	/^        class CV_EXPORTS BruteForceMatcher_GPU_base$/;"	c	namespace:cv::gpu
Bucket	flann/lsh_table.h	/^typedef std::vector<FeatureIndex> Bucket;$/;"	t	namespace:cvflann::lsh
BucketKey	flann/lsh_table.h	/^typedef unsigned int BucketKey;$/;"	t	namespace:cvflann::lsh
BucketsSpace	flann/lsh_table.h	/^    typedef std::unordered_map<BucketKey, Bucket> BucketsSpace;$/;"	t	class:cvflann::lsh::LshTable	access:public
BucketsSpeed	flann/lsh_table.h	/^    typedef std::vector<Bucket> BucketsSpeed;$/;"	t	class:cvflann::lsh::LshTable	access:public
BundleAdjustCallback	contrib/contrib.hpp	/^    typedef bool (*BundleAdjustCallback)(int iteration, double norm_error, void* user_data);$/;"	t	namespace:cv
ButtonCallback	highgui/highgui.hpp	/^typedef void (CV_CDECL *ButtonCallback)(int state, void* userdata);$/;"	t	namespace:cv
C	ml/ml.hpp	/^    CV_PROP_RW double      C;  \/\/ for CV_SVM_C_SVC, CV_SVM_EPS_SVR and CV_SVM_NU_SVR$/;"	m	struct:CvSVMParams	access:public
C	ml/ml.hpp	/^    double C[2];  \/\/ C[0] == Cn, C[1] == Cp$/;"	m	class:CvSVMSolver	access:public
C	ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon74
CALC_J	calib3d/calib3d.hpp	/^    enum { DONE=0, STARTED=1, CALC_J=2, CHECK_ERR=3 };$/;"	e	enum:CvLevMarq::__anon86
CALIB_CB_ADAPTIVE_THRESH	calib3d/calib3d.hpp	/^enum { CALIB_CB_ADAPTIVE_THRESH = 1, CALIB_CB_NORMALIZE_IMAGE = 2,$/;"	e	enum:cv::__anon88
CALIB_CB_ASYMMETRIC_GRID	calib3d/calib3d.hpp	/^enum { CALIB_CB_SYMMETRIC_GRID = 1, CALIB_CB_ASYMMETRIC_GRID = 2,$/;"	e	enum:cv::__anon89
CALIB_CB_CLUSTERING	calib3d/calib3d.hpp	/^       CALIB_CB_CLUSTERING = 4 };$/;"	e	enum:cv::__anon89
CALIB_CB_FAST_CHECK	calib3d/calib3d.hpp	/^       CALIB_CB_FILTER_QUADS = 4, CALIB_CB_FAST_CHECK = 8 };$/;"	e	enum:cv::__anon88
CALIB_CB_FILTER_QUADS	calib3d/calib3d.hpp	/^       CALIB_CB_FILTER_QUADS = 4, CALIB_CB_FAST_CHECK = 8 };$/;"	e	enum:cv::__anon88
CALIB_CB_NORMALIZE_IMAGE	calib3d/calib3d.hpp	/^enum { CALIB_CB_ADAPTIVE_THRESH = 1, CALIB_CB_NORMALIZE_IMAGE = 2,$/;"	e	enum:cv::__anon88
CALIB_CB_SYMMETRIC_GRID	calib3d/calib3d.hpp	/^enum { CALIB_CB_SYMMETRIC_GRID = 1, CALIB_CB_ASYMMETRIC_GRID = 2,$/;"	e	enum:cv::__anon89
CALIB_FIX_ASPECT_RATIO	calib3d/calib3d.hpp	/^    CALIB_FIX_ASPECT_RATIO = CV_CALIB_FIX_ASPECT_RATIO,$/;"	e	enum:cv::__anon90
CALIB_FIX_FOCAL_LENGTH	calib3d/calib3d.hpp	/^    CALIB_FIX_FOCAL_LENGTH = CV_CALIB_FIX_FOCAL_LENGTH,$/;"	e	enum:cv::__anon90
CALIB_FIX_INTRINSIC	calib3d/calib3d.hpp	/^    CALIB_FIX_INTRINSIC = CV_CALIB_FIX_INTRINSIC,$/;"	e	enum:cv::__anon90
CALIB_FIX_K1	calib3d/calib3d.hpp	/^    CALIB_FIX_K1 = CV_CALIB_FIX_K1,$/;"	e	enum:cv::__anon90
CALIB_FIX_K2	calib3d/calib3d.hpp	/^    CALIB_FIX_K2 = CV_CALIB_FIX_K2,$/;"	e	enum:cv::__anon90
CALIB_FIX_K3	calib3d/calib3d.hpp	/^    CALIB_FIX_K3 = CV_CALIB_FIX_K3,$/;"	e	enum:cv::__anon90
CALIB_FIX_K4	calib3d/calib3d.hpp	/^    CALIB_FIX_K4 = CV_CALIB_FIX_K4,$/;"	e	enum:cv::__anon90
CALIB_FIX_K5	calib3d/calib3d.hpp	/^    CALIB_FIX_K5 = CV_CALIB_FIX_K5,$/;"	e	enum:cv::__anon90
CALIB_FIX_K6	calib3d/calib3d.hpp	/^    CALIB_FIX_K6 = CV_CALIB_FIX_K6,$/;"	e	enum:cv::__anon90
CALIB_FIX_PRINCIPAL_POINT	calib3d/calib3d.hpp	/^    CALIB_FIX_PRINCIPAL_POINT = CV_CALIB_FIX_PRINCIPAL_POINT,$/;"	e	enum:cv::__anon90
CALIB_RATIONAL_MODEL	calib3d/calib3d.hpp	/^    CALIB_RATIONAL_MODEL = CV_CALIB_RATIONAL_MODEL,$/;"	e	enum:cv::__anon90
CALIB_SAME_FOCAL_LENGTH	calib3d/calib3d.hpp	/^    CALIB_SAME_FOCAL_LENGTH = CV_CALIB_SAME_FOCAL_LENGTH,$/;"	e	enum:cv::__anon90
CALIB_USE_INTRINSIC_GUESS	calib3d/calib3d.hpp	/^    CALIB_USE_INTRINSIC_GUESS = CV_CALIB_USE_INTRINSIC_GUESS,$/;"	e	enum:cv::__anon90
CALIB_ZERO_DISPARITY	calib3d/calib3d.hpp	/^    CALIB_ZERO_DISPARITY = CV_CALIB_ZERO_DISPARITY$/;"	e	enum:cv::__anon90
CALIB_ZERO_TANGENT_DIST	calib3d/calib3d.hpp	/^    CALIB_ZERO_TANGENT_DIST = CV_CALIB_ZERO_TANGENT_DIST,$/;"	e	enum:cv::__anon90
CASCADE_DO_CANNY_PRUNING	objdetect/objdetect.hpp	/^	CASCADE_DO_CANNY_PRUNING=1,$/;"	e	enum:cv::__anon199
CASCADE_DO_ROUGH_SEARCH	objdetect/objdetect.hpp	/^	CASCADE_DO_ROUGH_SEARCH=8$/;"	e	enum:cv::__anon199
CASCADE_FIND_BIGGEST_OBJECT	objdetect/objdetect.hpp	/^	CASCADE_FIND_BIGGEST_OBJECT=4,$/;"	e	enum:cv::__anon199
CASCADE_SCALE_IMAGE	objdetect/objdetect.hpp	/^	CASCADE_SCALE_IMAGE=2,$/;"	e	enum:cv::__anon199
CENTERS_GONZALES	flann/defines.h	/^    CENTERS_GONZALES = 1,$/;"	e	enum:cvflann::flann_centers_init_t
CENTERS_KMEANSPP	flann/defines.h	/^    CENTERS_KMEANSPP = 2$/;"	e	enum:cvflann::flann_centers_init_t
CENTERS_RANDOM	flann/defines.h	/^    CENTERS_RANDOM = 0,$/;"	e	enum:cvflann::flann_centers_init_t
CHAIN_APPROX_NONE	imgproc/imgproc.hpp	/^    CHAIN_APPROX_NONE=CV_CHAIN_APPROX_NONE,$/;"	e	enum:cv::__anon26
CHAIN_APPROX_SIMPLE	imgproc/imgproc.hpp	/^    CHAIN_APPROX_SIMPLE=CV_CHAIN_APPROX_SIMPLE,$/;"	e	enum:cv::__anon26
CHAIN_APPROX_TC89_KCOS	imgproc/imgproc.hpp	/^    CHAIN_APPROX_TC89_KCOS=CV_CHAIN_APPROX_TC89_KCOS$/;"	e	enum:cv::__anon26
CHAIN_APPROX_TC89_L1	imgproc/imgproc.hpp	/^    CHAIN_APPROX_TC89_L1=CV_CHAIN_APPROX_TC89_L1,$/;"	e	enum:cv::__anon26
CHECK_ERR	calib3d/calib3d.hpp	/^    enum { DONE=0, STARTED=1, CALC_J=2, CHECK_ERR=3 };$/;"	e	enum:CvLevMarq::__anon86
CHECK_ERROR	flann/hdf5.h	75;"	d
CLIQUE_END	legacy/legacy.hpp	355;"	d
CLIQUE_FOUND	legacy/legacy.hpp	354;"	d
CLIQUE_TIME_OFF	legacy/legacy.hpp	353;"	d
CMP_EQ	core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon99
CMP_GE	core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon99
CMP_GT	core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon99
CMP_LE	core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon99
CMP_LT	core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon99
CMP_NE	core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon99
COEF	ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon74
COLOR_BGR2BGR555	imgproc/imgproc.hpp	/^    COLOR_BGR2BGR555  =22,$/;"	e	enum:cv::__anon23
COLOR_BGR2BGR565	imgproc/imgproc.hpp	/^    COLOR_BGR2BGR565  =12,$/;"	e	enum:cv::__anon23
COLOR_BGR2BGRA	imgproc/imgproc.hpp	/^    COLOR_BGR2BGRA    =0,$/;"	e	enum:cv::__anon23
COLOR_BGR2GRAY	imgproc/imgproc.hpp	/^    COLOR_BGR2GRAY    =6,$/;"	e	enum:cv::__anon23
COLOR_BGR2HLS	imgproc/imgproc.hpp	/^    COLOR_BGR2HLS     =52,$/;"	e	enum:cv::__anon23
COLOR_BGR2HLS_FULL	imgproc/imgproc.hpp	/^    COLOR_BGR2HLS_FULL = 68,$/;"	e	enum:cv::__anon23
COLOR_BGR2HSV	imgproc/imgproc.hpp	/^    COLOR_BGR2HSV     =40,$/;"	e	enum:cv::__anon23
COLOR_BGR2HSV_FULL	imgproc/imgproc.hpp	/^    COLOR_BGR2HSV_FULL = 66,$/;"	e	enum:cv::__anon23
COLOR_BGR2Lab	imgproc/imgproc.hpp	/^    COLOR_BGR2Lab     =44,$/;"	e	enum:cv::__anon23
COLOR_BGR2Luv	imgproc/imgproc.hpp	/^    COLOR_BGR2Luv     =50,$/;"	e	enum:cv::__anon23
COLOR_BGR2RGB	imgproc/imgproc.hpp	/^    COLOR_BGR2RGB     =4,$/;"	e	enum:cv::__anon23
COLOR_BGR2RGBA	imgproc/imgproc.hpp	/^    COLOR_BGR2RGBA    =2,$/;"	e	enum:cv::__anon23
COLOR_BGR2XYZ	imgproc/imgproc.hpp	/^    COLOR_BGR2XYZ     =32,$/;"	e	enum:cv::__anon23
COLOR_BGR2YCrCb	imgproc/imgproc.hpp	/^    COLOR_BGR2YCrCb   =36,$/;"	e	enum:cv::__anon23
COLOR_BGR2YUV	imgproc/imgproc.hpp	/^    COLOR_BGR2YUV      = 82,$/;"	e	enum:cv::__anon23
COLOR_BGR5552BGR	imgproc/imgproc.hpp	/^    COLOR_BGR5552BGR  =24,$/;"	e	enum:cv::__anon23
COLOR_BGR5552BGRA	imgproc/imgproc.hpp	/^    COLOR_BGR5552BGRA =28,$/;"	e	enum:cv::__anon23
COLOR_BGR5552GRAY	imgproc/imgproc.hpp	/^    COLOR_BGR5552GRAY =31,$/;"	e	enum:cv::__anon23
COLOR_BGR5552RGB	imgproc/imgproc.hpp	/^    COLOR_BGR5552RGB  =25,$/;"	e	enum:cv::__anon23
COLOR_BGR5552RGBA	imgproc/imgproc.hpp	/^    COLOR_BGR5552RGBA =29,$/;"	e	enum:cv::__anon23
COLOR_BGR5652BGR	imgproc/imgproc.hpp	/^    COLOR_BGR5652BGR  =14,$/;"	e	enum:cv::__anon23
COLOR_BGR5652BGRA	imgproc/imgproc.hpp	/^    COLOR_BGR5652BGRA =18,$/;"	e	enum:cv::__anon23
COLOR_BGR5652GRAY	imgproc/imgproc.hpp	/^    COLOR_BGR5652GRAY =21,$/;"	e	enum:cv::__anon23
COLOR_BGR5652RGB	imgproc/imgproc.hpp	/^    COLOR_BGR5652RGB  =15,$/;"	e	enum:cv::__anon23
COLOR_BGR5652RGBA	imgproc/imgproc.hpp	/^    COLOR_BGR5652RGBA =19,$/;"	e	enum:cv::__anon23
COLOR_BGRA2BGR	imgproc/imgproc.hpp	/^    COLOR_BGRA2BGR    =1,$/;"	e	enum:cv::__anon23
COLOR_BGRA2BGR555	imgproc/imgproc.hpp	/^    COLOR_BGRA2BGR555 =26,$/;"	e	enum:cv::__anon23
COLOR_BGRA2BGR565	imgproc/imgproc.hpp	/^    COLOR_BGRA2BGR565 =16,$/;"	e	enum:cv::__anon23
COLOR_BGRA2GRAY	imgproc/imgproc.hpp	/^    COLOR_BGRA2GRAY   =10,$/;"	e	enum:cv::__anon23
COLOR_BGRA2RGB	imgproc/imgproc.hpp	/^    COLOR_BGRA2RGB    =COLOR_RGBA2BGR,$/;"	e	enum:cv::__anon23
COLOR_BGRA2RGBA	imgproc/imgproc.hpp	/^    COLOR_BGRA2RGBA   =5,$/;"	e	enum:cv::__anon23
COLOR_BayerBG2BGR	imgproc/imgproc.hpp	/^    COLOR_BayerBG2BGR =46,$/;"	e	enum:cv::__anon23
COLOR_BayerBG2BGR_VNG	imgproc/imgproc.hpp	/^    COLOR_BayerBG2BGR_VNG =62,$/;"	e	enum:cv::__anon23
COLOR_BayerBG2GRAY	imgproc/imgproc.hpp	/^    COLOR_BayerBG2GRAY = 86,$/;"	e	enum:cv::__anon23
COLOR_BayerBG2RGB	imgproc/imgproc.hpp	/^    COLOR_BayerBG2RGB =COLOR_BayerRG2BGR,$/;"	e	enum:cv::__anon23
COLOR_BayerBG2RGB_VNG	imgproc/imgproc.hpp	/^    COLOR_BayerBG2RGB_VNG =COLOR_BayerRG2BGR_VNG,$/;"	e	enum:cv::__anon23
COLOR_BayerGB2BGR	imgproc/imgproc.hpp	/^    COLOR_BayerGB2BGR =47,$/;"	e	enum:cv::__anon23
COLOR_BayerGB2BGR_VNG	imgproc/imgproc.hpp	/^    COLOR_BayerGB2BGR_VNG =63,$/;"	e	enum:cv::__anon23
COLOR_BayerGB2GRAY	imgproc/imgproc.hpp	/^    COLOR_BayerGB2GRAY = 87,$/;"	e	enum:cv::__anon23
COLOR_BayerGB2RGB	imgproc/imgproc.hpp	/^    COLOR_BayerGB2RGB =COLOR_BayerGR2BGR,$/;"	e	enum:cv::__anon23
COLOR_BayerGB2RGB_VNG	imgproc/imgproc.hpp	/^    COLOR_BayerGB2RGB_VNG =COLOR_BayerGR2BGR_VNG,$/;"	e	enum:cv::__anon23
COLOR_BayerGR2BGR	imgproc/imgproc.hpp	/^    COLOR_BayerGR2BGR =49,$/;"	e	enum:cv::__anon23
COLOR_BayerGR2BGR_VNG	imgproc/imgproc.hpp	/^    COLOR_BayerGR2BGR_VNG =65,$/;"	e	enum:cv::__anon23
COLOR_BayerGR2GRAY	imgproc/imgproc.hpp	/^    COLOR_BayerGR2GRAY = 89,$/;"	e	enum:cv::__anon23
COLOR_BayerGR2RGB	imgproc/imgproc.hpp	/^    COLOR_BayerGR2RGB =COLOR_BayerGB2BGR,$/;"	e	enum:cv::__anon23
COLOR_BayerGR2RGB_VNG	imgproc/imgproc.hpp	/^    COLOR_BayerGR2RGB_VNG =COLOR_BayerGB2BGR_VNG,$/;"	e	enum:cv::__anon23
COLOR_BayerRG2BGR	imgproc/imgproc.hpp	/^    COLOR_BayerRG2BGR =48,$/;"	e	enum:cv::__anon23
COLOR_BayerRG2BGR_VNG	imgproc/imgproc.hpp	/^    COLOR_BayerRG2BGR_VNG =64,$/;"	e	enum:cv::__anon23
COLOR_BayerRG2GRAY	imgproc/imgproc.hpp	/^    COLOR_BayerRG2GRAY = 88,$/;"	e	enum:cv::__anon23
COLOR_BayerRG2RGB	imgproc/imgproc.hpp	/^    COLOR_BayerRG2RGB =COLOR_BayerBG2BGR,$/;"	e	enum:cv::__anon23
COLOR_BayerRG2RGB_VNG	imgproc/imgproc.hpp	/^    COLOR_BayerRG2RGB_VNG =COLOR_BayerBG2BGR_VNG,$/;"	e	enum:cv::__anon23
COLOR_COLORCVT_MAX	imgproc/imgproc.hpp	/^    COLOR_COLORCVT_MAX  =100$/;"	e	enum:cv::__anon23
COLOR_GRAY2BGR	imgproc/imgproc.hpp	/^    COLOR_GRAY2BGR    =8,$/;"	e	enum:cv::__anon23
COLOR_GRAY2BGR555	imgproc/imgproc.hpp	/^    COLOR_GRAY2BGR555 =30,$/;"	e	enum:cv::__anon23
COLOR_GRAY2BGR565	imgproc/imgproc.hpp	/^    COLOR_GRAY2BGR565 =20,$/;"	e	enum:cv::__anon23
COLOR_GRAY2BGRA	imgproc/imgproc.hpp	/^    COLOR_GRAY2BGRA   =9,$/;"	e	enum:cv::__anon23
COLOR_GRAY2RGB	imgproc/imgproc.hpp	/^    COLOR_GRAY2RGB    =COLOR_GRAY2BGR,$/;"	e	enum:cv::__anon23
COLOR_GRAY2RGBA	imgproc/imgproc.hpp	/^    COLOR_GRAY2RGBA   =COLOR_GRAY2BGRA,$/;"	e	enum:cv::__anon23
COLOR_HLS2BGR	imgproc/imgproc.hpp	/^    COLOR_HLS2BGR     =60,$/;"	e	enum:cv::__anon23
COLOR_HLS2BGR_FULL	imgproc/imgproc.hpp	/^    COLOR_HLS2BGR_FULL = 72,$/;"	e	enum:cv::__anon23
COLOR_HLS2RGB	imgproc/imgproc.hpp	/^    COLOR_HLS2RGB     =61,$/;"	e	enum:cv::__anon23
COLOR_HLS2RGB_FULL	imgproc/imgproc.hpp	/^    COLOR_HLS2RGB_FULL = 73,$/;"	e	enum:cv::__anon23
COLOR_HSV2BGR	imgproc/imgproc.hpp	/^    COLOR_HSV2BGR     =54,$/;"	e	enum:cv::__anon23
COLOR_HSV2BGR_FULL	imgproc/imgproc.hpp	/^    COLOR_HSV2BGR_FULL = 70,$/;"	e	enum:cv::__anon23
COLOR_HSV2RGB	imgproc/imgproc.hpp	/^    COLOR_HSV2RGB     =55,$/;"	e	enum:cv::__anon23
COLOR_HSV2RGB_FULL	imgproc/imgproc.hpp	/^    COLOR_HSV2RGB_FULL = 71,$/;"	e	enum:cv::__anon23
COLOR_LBGR2Lab	imgproc/imgproc.hpp	/^    COLOR_LBGR2Lab     = 74,$/;"	e	enum:cv::__anon23
COLOR_LBGR2Luv	imgproc/imgproc.hpp	/^    COLOR_LBGR2Luv     = 76,$/;"	e	enum:cv::__anon23
COLOR_LRGB2Lab	imgproc/imgproc.hpp	/^    COLOR_LRGB2Lab     = 75,$/;"	e	enum:cv::__anon23
COLOR_LRGB2Luv	imgproc/imgproc.hpp	/^    COLOR_LRGB2Luv     = 77,$/;"	e	enum:cv::__anon23
COLOR_Lab2BGR	imgproc/imgproc.hpp	/^    COLOR_Lab2BGR     =56,$/;"	e	enum:cv::__anon23
COLOR_Lab2LBGR	imgproc/imgproc.hpp	/^    COLOR_Lab2LBGR     = 78,$/;"	e	enum:cv::__anon23
COLOR_Lab2LRGB	imgproc/imgproc.hpp	/^    COLOR_Lab2LRGB     = 79,$/;"	e	enum:cv::__anon23
COLOR_Lab2RGB	imgproc/imgproc.hpp	/^    COLOR_Lab2RGB     =57,$/;"	e	enum:cv::__anon23
COLOR_Luv2BGR	imgproc/imgproc.hpp	/^    COLOR_Luv2BGR     =58,$/;"	e	enum:cv::__anon23
COLOR_Luv2LBGR	imgproc/imgproc.hpp	/^    COLOR_Luv2LBGR     = 80,$/;"	e	enum:cv::__anon23
COLOR_Luv2LRGB	imgproc/imgproc.hpp	/^    COLOR_Luv2LRGB     = 81,$/;"	e	enum:cv::__anon23
COLOR_Luv2RGB	imgproc/imgproc.hpp	/^    COLOR_Luv2RGB     =59,$/;"	e	enum:cv::__anon23
COLOR_RGB2BGR	imgproc/imgproc.hpp	/^    COLOR_RGB2BGR     =COLOR_BGR2RGB,$/;"	e	enum:cv::__anon23
COLOR_RGB2BGR555	imgproc/imgproc.hpp	/^    COLOR_RGB2BGR555  =23,$/;"	e	enum:cv::__anon23
COLOR_RGB2BGR565	imgproc/imgproc.hpp	/^    COLOR_RGB2BGR565  =13,$/;"	e	enum:cv::__anon23
COLOR_RGB2BGRA	imgproc/imgproc.hpp	/^    COLOR_RGB2BGRA    =COLOR_BGR2RGBA,$/;"	e	enum:cv::__anon23
COLOR_RGB2GRAY	imgproc/imgproc.hpp	/^    COLOR_RGB2GRAY    =7,$/;"	e	enum:cv::__anon23
COLOR_RGB2HLS	imgproc/imgproc.hpp	/^    COLOR_RGB2HLS     =53,$/;"	e	enum:cv::__anon23
COLOR_RGB2HLS_FULL	imgproc/imgproc.hpp	/^    COLOR_RGB2HLS_FULL = 69,$/;"	e	enum:cv::__anon23
COLOR_RGB2HSV	imgproc/imgproc.hpp	/^    COLOR_RGB2HSV     =41,$/;"	e	enum:cv::__anon23
COLOR_RGB2HSV_FULL	imgproc/imgproc.hpp	/^    COLOR_RGB2HSV_FULL = 67,$/;"	e	enum:cv::__anon23
COLOR_RGB2Lab	imgproc/imgproc.hpp	/^    COLOR_RGB2Lab     =45,$/;"	e	enum:cv::__anon23
COLOR_RGB2Luv	imgproc/imgproc.hpp	/^    COLOR_RGB2Luv     =51,$/;"	e	enum:cv::__anon23
COLOR_RGB2RGBA	imgproc/imgproc.hpp	/^    COLOR_RGB2RGBA    =COLOR_BGR2BGRA,$/;"	e	enum:cv::__anon23
COLOR_RGB2XYZ	imgproc/imgproc.hpp	/^    COLOR_RGB2XYZ     =33,$/;"	e	enum:cv::__anon23
COLOR_RGB2YCrCb	imgproc/imgproc.hpp	/^    COLOR_RGB2YCrCb   =37,$/;"	e	enum:cv::__anon23
COLOR_RGB2YUV	imgproc/imgproc.hpp	/^    COLOR_RGB2YUV      = 83,$/;"	e	enum:cv::__anon23
COLOR_RGBA2BGR	imgproc/imgproc.hpp	/^    COLOR_RGBA2BGR    =3,$/;"	e	enum:cv::__anon23
COLOR_RGBA2BGR555	imgproc/imgproc.hpp	/^    COLOR_RGBA2BGR555 =27,$/;"	e	enum:cv::__anon23
COLOR_RGBA2BGR565	imgproc/imgproc.hpp	/^    COLOR_RGBA2BGR565 =17,$/;"	e	enum:cv::__anon23
COLOR_RGBA2BGRA	imgproc/imgproc.hpp	/^    COLOR_RGBA2BGRA   =COLOR_BGRA2RGBA,$/;"	e	enum:cv::__anon23
COLOR_RGBA2GRAY	imgproc/imgproc.hpp	/^    COLOR_RGBA2GRAY   =11,$/;"	e	enum:cv::__anon23
COLOR_RGBA2RGB	imgproc/imgproc.hpp	/^    COLOR_RGBA2RGB    =COLOR_BGRA2BGR,$/;"	e	enum:cv::__anon23
COLOR_XYZ2BGR	imgproc/imgproc.hpp	/^    COLOR_XYZ2BGR     =34,$/;"	e	enum:cv::__anon23
COLOR_XYZ2RGB	imgproc/imgproc.hpp	/^    COLOR_XYZ2RGB     =35,$/;"	e	enum:cv::__anon23
COLOR_YCrCb2BGR	imgproc/imgproc.hpp	/^    COLOR_YCrCb2BGR   =38,$/;"	e	enum:cv::__anon23
COLOR_YCrCb2RGB	imgproc/imgproc.hpp	/^    COLOR_YCrCb2RGB   =39,$/;"	e	enum:cv::__anon23
COLOR_YUV2BGR	imgproc/imgproc.hpp	/^    COLOR_YUV2BGR      = 84,$/;"	e	enum:cv::__anon23
COLOR_YUV2RGB	imgproc/imgproc.hpp	/^    COLOR_YUV2RGB      = 85,$/;"	e	enum:cv::__anon23
COLOR_YUV420i2BGR	imgproc/imgproc.hpp	/^    COLOR_YUV420i2BGR  = 91,$/;"	e	enum:cv::__anon23
COLOR_YUV420i2RGB	imgproc/imgproc.hpp	/^    COLOR_YUV420i2RGB  = 90,$/;"	e	enum:cv::__anon23
COLOR_YUV420sp2BGR	imgproc/imgproc.hpp	/^    COLOR_YUV420sp2BGR = 93,$/;"	e	enum:cv::__anon23
COLOR_YUV420sp2RGB	imgproc/imgproc.hpp	/^    COLOR_YUV420sp2RGB = 92,$/;"	e	enum:cv::__anon23
COMPOSITE	flann/defines.h	/^    COMPOSITE = 3,$/;"	e	enum:cvflann::flann_algorithm_t
COMPRESSION_NONE	features2d/features2d.hpp	/^        COMPRESSION_NONE = 0,$/;"	e	enum:cv::FernClassifier::__anon193
COMPRESSION_PCA	features2d/features2d.hpp	/^        COMPRESSION_PCA = 2,$/;"	e	enum:cv::FernClassifier::__anon193
COMPRESSION_RANDOM_PROJ	features2d/features2d.hpp	/^        COMPRESSION_RANDOM_PROJ = 1,$/;"	e	enum:cv::FernClassifier::__anon193
CONTINUOUS_FLAG	core/core.hpp	/^    enum { MAGIC_VAL=0x42FF0000, AUTO_STEP=0, CONTINUOUS_FLAG=CV_MAT_CONT_FLAG, SUBMATRIX_FLAG=CV_SUBMAT_FLAG };$/;"	e	enum:cv::Mat::__anon137
COUNT	core/core.hpp	/^        COUNT=1, \/\/!< the maximum number of iterations or elements to compute$/;"	e	enum:cv::TermCriteria::__anon139
COVAR_COLS	core/core.hpp	/^	COVAR_COLS=16$/;"	e	enum:cv::__anon141
COVAR_NORMAL	core/core.hpp	/^	COVAR_NORMAL=1,$/;"	e	enum:cv::__anon141
COVAR_ROWS	core/core.hpp	/^	COVAR_ROWS=8,$/;"	e	enum:cv::__anon141
COVAR_SCALE	core/core.hpp	/^	COVAR_SCALE=4,$/;"	e	enum:cv::__anon141
COVAR_SCRAMBLED	core/core.hpp	/^	COVAR_SCRAMBLED=0,$/;"	e	enum:cv::__anon141
COVAR_USE_AVG	core/core.hpp	/^	COVAR_USE_AVG=2,$/;"	e	enum:cv::__anon141
COV_MAT_DIAGONAL	ml/ml.hpp	/^    enum { COV_MAT_SPHERICAL=0, COV_MAT_DIAGONAL=1, COV_MAT_GENERIC=2 };$/;"	e	enum:CvEM::__anon75
COV_MAT_GENERIC	ml/ml.hpp	/^    enum { COV_MAT_SPHERICAL=0, COV_MAT_DIAGONAL=1, COV_MAT_GENERIC=2 };$/;"	e	enum:CvEM::__anon75
COV_MAT_SPHERICAL	ml/ml.hpp	/^    enum { COV_MAT_SPHERICAL=0, COV_MAT_DIAGONAL=1, COV_MAT_GENERIC=2 };$/;"	e	enum:CvEM::__anon75
CP	video/tracking.hpp	/^    int CP;                     \/* number of control vector dimensions *\/$/;"	m	struct:CvKalman	access:public
CPU_HAS_NEON_FEATURE	core/internal.hpp	126;"	d
CPU_HAS_NEON_FEATURE	core/internal.hpp	131;"	d
CS	flann/defines.h	/^    CS         = 7,$/;"	e	enum:cvflann::flann_distance_t
CT_ASSERT_FAILURE	gpu/NCV.hpp	/^    struct CT_ASSERT_FAILURE<true> {};$/;"	s	namespace:NcvCTprep
CVAPI	core/types_c.h	142;"	d
CVAUX_STR	core/version.hpp	55;"	d
CVAUX_STR_EXP	core/version.hpp	54;"	d
CVStatus	core/types_c.h	/^typedef int CVStatus;$/;"	t
CV_16S	core/types_c.h	554;"	d
CV_16SC	core/types_c.h	588;"	d
CV_16SC1	core/types_c.h	584;"	d
CV_16SC2	core/types_c.h	585;"	d
CV_16SC3	core/types_c.h	586;"	d
CV_16SC4	core/types_c.h	587;"	d
CV_16U	core/types_c.h	553;"	d
CV_16UC	core/types_c.h	582;"	d
CV_16UC1	core/types_c.h	578;"	d
CV_16UC2	core/types_c.h	579;"	d
CV_16UC3	core/types_c.h	580;"	d
CV_16UC4	core/types_c.h	581;"	d
CV_1F	core/internal.hpp	343;"	d
CV_32F	core/types_c.h	556;"	d
CV_32FC	core/types_c.h	600;"	d
CV_32FC1	core/types_c.h	596;"	d
CV_32FC2	core/types_c.h	597;"	d
CV_32FC3	core/types_c.h	598;"	d
CV_32FC4	core/types_c.h	599;"	d
CV_32S	core/types_c.h	555;"	d
CV_32SC	core/types_c.h	594;"	d
CV_32SC1	core/types_c.h	590;"	d
CV_32SC2	core/types_c.h	591;"	d
CV_32SC3	core/types_c.h	592;"	d
CV_32SC4	core/types_c.h	593;"	d
CV_64F	core/types_c.h	557;"	d
CV_64FC	core/types_c.h	606;"	d
CV_64FC1	core/types_c.h	602;"	d
CV_64FC2	core/types_c.h	603;"	d
CV_64FC3	core/types_c.h	604;"	d
CV_64FC4	core/types_c.h	605;"	d
CV_8S	core/types_c.h	552;"	d
CV_8SC	core/types_c.h	576;"	d
CV_8SC1	core/types_c.h	572;"	d
CV_8SC2	core/types_c.h	573;"	d
CV_8SC3	core/types_c.h	574;"	d
CV_8SC4	core/types_c.h	575;"	d
CV_8U	core/types_c.h	551;"	d
CV_8UC	core/types_c.h	570;"	d
CV_8UC1	core/types_c.h	566;"	d
CV_8UC2	core/types_c.h	567;"	d
CV_8UC3	core/types_c.h	568;"	d
CV_8UC4	core/types_c.h	569;"	d
CV_AA	core/core_c.h	1267;"	d
CV_ADAPTIVE_THRESH_GAUSSIAN_C	imgproc/types_c.h	/^    CV_ADAPTIVE_THRESH_GAUSSIAN_C  =1$/;"	e	enum:__anon48
CV_ADAPTIVE_THRESH_MEAN_C	imgproc/types_c.h	/^    CV_ADAPTIVE_THRESH_MEAN_C  =0,$/;"	e	enum:__anon48
CV_ADD	core/internal.hpp	349;"	d
CV_AND	core/internal.hpp	352;"	d
CV_ANDN	core/internal.hpp	355;"	d
CV_ARE_CNS_EQ	core/types_c.h	685;"	d
CV_ARE_DEPTHS_EQ	core/types_c.h	688;"	d
CV_ARE_SIZES_EQ	core/types_c.h	691;"	d
CV_ARE_TYPES_EQ	core/types_c.h	682;"	d
CV_ARRAY	legacy/legacy.hpp	815;"	d
CV_ASSERT	core/core_c.h	1847;"	d
CV_AUTOSTEP	core/core_c.h	111;"	d
CV_AUTO_STEP	core/types_c.h	608;"	d
CV_Assert	core/core.hpp	194;"	d
CV_Assert	core/core.hpp	198;"	d
CV_BACK	core/core_c.h	971;"	d
CV_BADARG_ERR	core/internal.hpp	/^    CV_BADARG_ERR      = -49,  \/\/ipp comp$/;"	e	enum:CvStatus
CV_BADCHANNELS_ERR	core/internal.hpp	/^    CV_BADCHANNELS_ERR = -47,  \/\/ipp comp$/;"	e	enum:CvStatus
CV_BADCOEF_ERR	core/internal.hpp	/^    CV_BADCOEF_ERR     =  -10,$/;"	e	enum:CvStatus
CV_BADCONVERGENCE_ERR	core/internal.hpp	/^    CV_BADCONVERGENCE_ERR       = -109,$/;"	e	enum:CvStatus
CV_BADDEPTH_ERR	core/internal.hpp	/^    CV_BADDEPTH_ERR             = -107,$/;"	e	enum:CvStatus
CV_BADFACTOR_ERR	core/internal.hpp	/^    CV_BADFACTOR_ERR   =  -7,$/;"	e	enum:CvStatus
CV_BADFLAG_ERR	core/internal.hpp	/^    CV_BADFLAG_ERR     =  -12,$/;"	e	enum:CvStatus
CV_BADHEADER_ERR	core/internal.hpp	/^    CV_BADHEADER_ERR            = -105,$/;"	e	enum:CvStatus
CV_BADMEMBLOCK_ERR	core/internal.hpp	/^    CV_BADMEMBLOCK_ERR          = -113,$/;"	e	enum:CvStatus
CV_BADPOINT_ERR	core/internal.hpp	/^    CV_BADPOINT_ERR    =  -6,$/;"	e	enum:CvStatus
CV_BADRANGE_ERR	core/internal.hpp	/^    CV_BADRANGE_ERR    = -44,  \/\/ipp comp$/;"	e	enum:CvStatus
CV_BADROI_ERR	core/internal.hpp	/^    CV_BADROI_ERR               = -106,$/;"	e	enum:CvStatus
CV_BADSCALE_ERR	core/internal.hpp	/^    CV_BADSCALE_ERR    =  -4,$/;"	e	enum:CvStatus
CV_BADSIZE_ERR	core/internal.hpp	/^    CV_BADSIZE_ERR     =  -1,$/;"	e	enum:CvStatus
CV_BADSTEP_ERR	core/internal.hpp	/^    CV_BADSTEP_ERR     = -29,  \/\/ipp comp$/;"	e	enum:CvStatus
CV_BGFG_FGD_ALPHA_1	video/background_segm.hpp	147;"	d
CV_BGFG_FGD_ALPHA_2	video/background_segm.hpp	152;"	d
CV_BGFG_FGD_ALPHA_3	video/background_segm.hpp	155;"	d
CV_BGFG_FGD_BG_UPDATE_TRESH	video/background_segm.hpp	163;"	d
CV_BGFG_FGD_DELTA	video/background_segm.hpp	157;"	d
CV_BGFG_FGD_LC	video/background_segm.hpp	138;"	d
CV_BGFG_FGD_LCC	video/background_segm.hpp	142;"	d
CV_BGFG_FGD_MINAREA	video/background_segm.hpp	161;"	d
CV_BGFG_FGD_N1C	video/background_segm.hpp	139;"	d
CV_BGFG_FGD_N1CC	video/background_segm.hpp	143;"	d
CV_BGFG_FGD_N2C	video/background_segm.hpp	140;"	d
CV_BGFG_FGD_N2CC	video/background_segm.hpp	144;"	d
CV_BGFG_FGD_T	video/background_segm.hpp	159;"	d
CV_BGFG_MOG_BACKGROUND_THRESHOLD	video/background_segm.hpp	254;"	d
CV_BGFG_MOG_MAX_NGAUSSIANS	video/background_segm.hpp	251;"	d
CV_BGFG_MOG_MINAREA	video/background_segm.hpp	260;"	d
CV_BGFG_MOG_NCOLORS	video/background_segm.hpp	263;"	d
CV_BGFG_MOG_NGAUSSIANS	video/background_segm.hpp	257;"	d
CV_BGFG_MOG_SIGMA_INIT	video/background_segm.hpp	259;"	d
CV_BGFG_MOG_STD_THRESHOLD	video/background_segm.hpp	255;"	d
CV_BGFG_MOG_WEIGHT_INIT	video/background_segm.hpp	258;"	d
CV_BGFG_MOG_WINDOW_SIZE	video/background_segm.hpp	256;"	d
CV_BGR2BGR555	imgproc/types_c.h	/^    CV_BGR2BGR555  =22,$/;"	e	enum:__anon33
CV_BGR2BGR565	imgproc/types_c.h	/^    CV_BGR2BGR565  =12,$/;"	e	enum:__anon33
CV_BGR2BGRA	imgproc/types_c.h	/^    CV_BGR2BGRA    =0,$/;"	e	enum:__anon33
CV_BGR2GRAY	imgproc/types_c.h	/^    CV_BGR2GRAY    =6,$/;"	e	enum:__anon33
CV_BGR2HLS	imgproc/types_c.h	/^    CV_BGR2HLS     =52,$/;"	e	enum:__anon33
CV_BGR2HLS_FULL	imgproc/types_c.h	/^    CV_BGR2HLS_FULL = 68,$/;"	e	enum:__anon33
CV_BGR2HSV	imgproc/types_c.h	/^    CV_BGR2HSV     =40,$/;"	e	enum:__anon33
CV_BGR2HSV_FULL	imgproc/types_c.h	/^    CV_BGR2HSV_FULL = 66,$/;"	e	enum:__anon33
CV_BGR2Lab	imgproc/types_c.h	/^    CV_BGR2Lab     =44,$/;"	e	enum:__anon33
CV_BGR2Luv	imgproc/types_c.h	/^    CV_BGR2Luv     =50,$/;"	e	enum:__anon33
CV_BGR2RGB	imgproc/types_c.h	/^    CV_BGR2RGB     =4,$/;"	e	enum:__anon33
CV_BGR2RGBA	imgproc/types_c.h	/^    CV_BGR2RGBA    =2,$/;"	e	enum:__anon33
CV_BGR2XYZ	imgproc/types_c.h	/^    CV_BGR2XYZ     =32,$/;"	e	enum:__anon33
CV_BGR2YCrCb	imgproc/types_c.h	/^    CV_BGR2YCrCb   =36,$/;"	e	enum:__anon33
CV_BGR2YUV	imgproc/types_c.h	/^    CV_BGR2YUV      = 82,$/;"	e	enum:__anon33
CV_BGR5552BGR	imgproc/types_c.h	/^    CV_BGR5552BGR  =24,$/;"	e	enum:__anon33
CV_BGR5552BGRA	imgproc/types_c.h	/^    CV_BGR5552BGRA =28,$/;"	e	enum:__anon33
CV_BGR5552GRAY	imgproc/types_c.h	/^    CV_BGR5552GRAY =31,$/;"	e	enum:__anon33
CV_BGR5552RGB	imgproc/types_c.h	/^    CV_BGR5552RGB  =25,$/;"	e	enum:__anon33
CV_BGR5552RGBA	imgproc/types_c.h	/^    CV_BGR5552RGBA =29,$/;"	e	enum:__anon33
CV_BGR5652BGR	imgproc/types_c.h	/^    CV_BGR5652BGR  =14,$/;"	e	enum:__anon33
CV_BGR5652BGRA	imgproc/types_c.h	/^    CV_BGR5652BGRA =18,$/;"	e	enum:__anon33
CV_BGR5652GRAY	imgproc/types_c.h	/^    CV_BGR5652GRAY =21,$/;"	e	enum:__anon33
CV_BGR5652RGB	imgproc/types_c.h	/^    CV_BGR5652RGB  =15,$/;"	e	enum:__anon33
CV_BGR5652RGBA	imgproc/types_c.h	/^    CV_BGR5652RGBA =19,$/;"	e	enum:__anon33
CV_BGRA2BGR	imgproc/types_c.h	/^    CV_BGRA2BGR    =1,$/;"	e	enum:__anon33
CV_BGRA2BGR555	imgproc/types_c.h	/^    CV_BGRA2BGR555 =26,$/;"	e	enum:__anon33
CV_BGRA2BGR565	imgproc/types_c.h	/^    CV_BGRA2BGR565 =16,$/;"	e	enum:__anon33
CV_BGRA2GRAY	imgproc/types_c.h	/^    CV_BGRA2GRAY   =10,$/;"	e	enum:__anon33
CV_BGRA2RGB	imgproc/types_c.h	/^    CV_BGRA2RGB    =CV_RGBA2BGR,$/;"	e	enum:__anon33
CV_BGRA2RGBA	imgproc/types_c.h	/^    CV_BGRA2RGBA   =5,$/;"	e	enum:__anon33
CV_BG_MODEL_FGD	video/background_segm.hpp	86;"	d
CV_BG_MODEL_FGD_SIMPLE	video/background_segm.hpp	88;"	d
CV_BG_MODEL_MOG	video/background_segm.hpp	87;"	d
CV_BG_STAT_MODEL_FIELDS	video/background_segm.hpp	/^    CV_BG_STAT_MODEL_FIELDS();$/;"	p	struct:CvBGStatModel	access:public	signature:()
CV_BG_STAT_MODEL_FIELDS	video/background_segm.hpp	/^    CV_BG_STAT_MODEL_FIELDS();$/;"	p	struct:CvFGDStatModel	access:public	signature:()
CV_BG_STAT_MODEL_FIELDS	video/background_segm.hpp	/^    CV_BG_STAT_MODEL_FIELDS();$/;"	p	struct:CvGaussBGModel	access:public	signature:()
CV_BG_STAT_MODEL_FIELDS	video/background_segm.hpp	96;"	d
CV_BIG_INT	core/types_c.h	148;"	d
CV_BIG_INT	core/types_c.h	153;"	d
CV_BIG_UINT	core/types_c.h	149;"	d
CV_BIG_UINT	core/types_c.h	154;"	d
CV_BILATERAL	imgproc/types_c.h	/^    CV_BILATERAL =4$/;"	e	enum:__anon29
CV_BLOB_CENTER	legacy/blobtrack.hpp	168;"	d
CV_BLOB_ID	legacy/blobtrack.hpp	167;"	d
CV_BLOB_MINH	legacy/blobtrack.hpp	166;"	d
CV_BLOB_MINW	legacy/blobtrack.hpp	165;"	d
CV_BLOB_RECT	legacy/blobtrack.hpp	175;"	d
CV_BLOB_RX	legacy/blobtrack.hpp	173;"	d
CV_BLOB_RY	legacy/blobtrack.hpp	174;"	d
CV_BLOB_WX	legacy/blobtrack.hpp	171;"	d
CV_BLOB_WY	legacy/blobtrack.hpp	172;"	d
CV_BLOB_X	legacy/blobtrack.hpp	169;"	d
CV_BLOB_Y	legacy/blobtrack.hpp	170;"	d
CV_BLUR	imgproc/types_c.h	/^    CV_BLUR  =1,$/;"	e	enum:__anon29
CV_BLUR_NO_SCALE	imgproc/types_c.h	/^    CV_BLUR_NO_SCALE =0,$/;"	e	enum:__anon29
CV_BT_HIST_TYPE_H	legacy/blobtrack.hpp	873;"	d
CV_BT_HIST_TYPE_MG	legacy/blobtrack.hpp	871;"	d
CV_BT_HIST_TYPE_MG2	legacy/blobtrack.hpp	872;"	d
CV_BT_HIST_TYPE_S	legacy/blobtrack.hpp	870;"	d
CV_BadAlign	core/types_c.h	/^ CV_BadAlign=                  -21, \/**\/$/;"	e	enum:__anon150
CV_BadAlphaChannel	core/types_c.h	/^ CV_BadAlphaChannel=           -18, \/**\/$/;"	e	enum:__anon150
CV_BadCOI	core/types_c.h	/^ CV_BadCOI=                    -24, \/**\/$/;"	e	enum:__anon150
CV_BadCallBack	core/types_c.h	/^ CV_BadCallBack=               -22, \/**\/$/;"	e	enum:__anon150
CV_BadDataPtr	core/types_c.h	/^ CV_BadDataPtr=                -12, \/**\/$/;"	e	enum:__anon150
CV_BadDepth	core/types_c.h	/^ CV_BadDepth=                  -17, \/**\/$/;"	e	enum:__anon150
CV_BadImageSize	core/types_c.h	/^ CV_BadImageSize=              -10, \/* image size is invalid           *\/$/;"	e	enum:__anon150
CV_BadModelOrChSeq	core/types_c.h	/^ CV_BadModelOrChSeq=           -14, \/**\/$/;"	e	enum:__anon150
CV_BadNumChannel1U	core/types_c.h	/^ CV_BadNumChannel1U=           -16, \/**\/$/;"	e	enum:__anon150
CV_BadNumChannels	core/types_c.h	/^ CV_BadNumChannels=            -15, \/**\/$/;"	e	enum:__anon150
CV_BadOffset	core/types_c.h	/^ CV_BadOffset=                 -11, \/* offset is invalid               *\/$/;"	e	enum:__anon150
CV_BadOrder	core/types_c.h	/^ CV_BadOrder=                  -19, \/**\/$/;"	e	enum:__anon150
CV_BadOrigin	core/types_c.h	/^ CV_BadOrigin=                 -20, \/**\/$/;"	e	enum:__anon150
CV_BadROISize	core/types_c.h	/^ CV_BadROISize=                -25, \/**\/$/;"	e	enum:__anon150
CV_BadStep	core/types_c.h	/^ CV_BadStep=                   -13, \/**\/$/;"	e	enum:__anon150
CV_BadTileSize	core/types_c.h	/^ CV_BadTileSize=               -23, \/**\/$/;"	e	enum:__anon150
CV_BayerBG2BGR	imgproc/types_c.h	/^    CV_BayerBG2BGR =46,$/;"	e	enum:__anon33
CV_BayerBG2BGR_VNG	imgproc/types_c.h	/^    CV_BayerBG2BGR_VNG =62,$/;"	e	enum:__anon33
CV_BayerBG2GRAY	imgproc/types_c.h	/^    CV_BayerBG2GRAY = 86,$/;"	e	enum:__anon33
CV_BayerBG2RGB	imgproc/types_c.h	/^    CV_BayerBG2RGB =CV_BayerRG2BGR,$/;"	e	enum:__anon33
CV_BayerBG2RGB_VNG	imgproc/types_c.h	/^    CV_BayerBG2RGB_VNG =CV_BayerRG2BGR_VNG,$/;"	e	enum:__anon33
CV_BayerGB2BGR	imgproc/types_c.h	/^    CV_BayerGB2BGR =47,$/;"	e	enum:__anon33
CV_BayerGB2BGR_VNG	imgproc/types_c.h	/^    CV_BayerGB2BGR_VNG =63,$/;"	e	enum:__anon33
CV_BayerGB2GRAY	imgproc/types_c.h	/^    CV_BayerGB2GRAY = 87,$/;"	e	enum:__anon33
CV_BayerGB2RGB	imgproc/types_c.h	/^    CV_BayerGB2RGB =CV_BayerGR2BGR,$/;"	e	enum:__anon33
CV_BayerGB2RGB_VNG	imgproc/types_c.h	/^    CV_BayerGB2RGB_VNG =CV_BayerGR2BGR_VNG,$/;"	e	enum:__anon33
CV_BayerGR2BGR	imgproc/types_c.h	/^    CV_BayerGR2BGR =49,$/;"	e	enum:__anon33
CV_BayerGR2BGR_VNG	imgproc/types_c.h	/^    CV_BayerGR2BGR_VNG =65,$/;"	e	enum:__anon33
CV_BayerGR2GRAY	imgproc/types_c.h	/^    CV_BayerGR2GRAY = 89,$/;"	e	enum:__anon33
CV_BayerGR2RGB	imgproc/types_c.h	/^    CV_BayerGR2RGB =CV_BayerGB2BGR,$/;"	e	enum:__anon33
CV_BayerGR2RGB_VNG	imgproc/types_c.h	/^    CV_BayerGR2RGB_VNG =CV_BayerGB2BGR_VNG,$/;"	e	enum:__anon33
CV_BayerRG2BGR	imgproc/types_c.h	/^    CV_BayerRG2BGR =48,$/;"	e	enum:__anon33
CV_BayerRG2BGR_VNG	imgproc/types_c.h	/^    CV_BayerRG2BGR_VNG =64,$/;"	e	enum:__anon33
CV_BayerRG2GRAY	imgproc/types_c.h	/^    CV_BayerRG2GRAY = 88,$/;"	e	enum:__anon33
CV_BayerRG2RGB	imgproc/types_c.h	/^    CV_BayerRG2RGB =CV_BayerBG2BGR,$/;"	e	enum:__anon33
CV_BayerRG2RGB_VNG	imgproc/types_c.h	/^    CV_BayerRG2RGB_VNG =CV_BayerBG2BGR_VNG,$/;"	e	enum:__anon33
CV_C	core/core_c.h	839;"	d
CV_CALIB_CB_ADAPTIVE_THRESH	calib3d/calib3d.hpp	194;"	d
CV_CALIB_CB_FAST_CHECK	calib3d/calib3d.hpp	197;"	d
CV_CALIB_CB_FILTER_QUADS	calib3d/calib3d.hpp	196;"	d
CV_CALIB_CB_NORMALIZE_IMAGE	calib3d/calib3d.hpp	195;"	d
CV_CALIB_ETALON_CHECKERBOARD	legacy/legacy.hpp	/^    CV_CALIB_ETALON_CHECKERBOARD = CV_CALIB_ETALON_CHESSBOARD$/;"	e	enum:CvCalibEtalonType
CV_CALIB_ETALON_CHESSBOARD	legacy/legacy.hpp	/^    CV_CALIB_ETALON_CHESSBOARD = 0,$/;"	e	enum:CvCalibEtalonType
CV_CALIB_ETALON_USER	legacy/legacy.hpp	/^    CV_CALIB_ETALON_USER = -1,$/;"	e	enum:CvCalibEtalonType
CV_CALIB_FIX_ASPECT_RATIO	calib3d/calib3d.hpp	220;"	d
CV_CALIB_FIX_FOCAL_LENGTH	calib3d/calib3d.hpp	223;"	d
CV_CALIB_FIX_INTRINSIC	calib3d/calib3d.hpp	256;"	d
CV_CALIB_FIX_K1	calib3d/calib3d.hpp	224;"	d
CV_CALIB_FIX_K2	calib3d/calib3d.hpp	225;"	d
CV_CALIB_FIX_K3	calib3d/calib3d.hpp	226;"	d
CV_CALIB_FIX_K4	calib3d/calib3d.hpp	227;"	d
CV_CALIB_FIX_K5	calib3d/calib3d.hpp	228;"	d
CV_CALIB_FIX_K6	calib3d/calib3d.hpp	229;"	d
CV_CALIB_FIX_PRINCIPAL_POINT	calib3d/calib3d.hpp	221;"	d
CV_CALIB_RATIONAL_MODEL	calib3d/calib3d.hpp	230;"	d
CV_CALIB_SAME_FOCAL_LENGTH	calib3d/calib3d.hpp	257;"	d
CV_CALIB_USE_INTRINSIC_GUESS	calib3d/calib3d.hpp	219;"	d
CV_CALIB_ZERO_DISPARITY	calib3d/calib3d.hpp	272;"	d
CV_CALIB_ZERO_TANGENT_DIST	calib3d/calib3d.hpp	222;"	d
CV_CALL	core/core_c.h	1839;"	d
CV_CAMERA_TO_WARP	legacy/legacy.hpp	563;"	d
CV_CANNY_L2_GRADIENT	imgproc/types_c.h	/^    CV_CANNY_L2_GRADIENT  =(1 << 31)$/;"	e	enum:__anon50
CV_CAP_ANDROID	highgui/highgui_c.h	/^    CV_CAP_ANDROID  =1000,  \/\/ Android$/;"	e	enum:__anon171
CV_CAP_ANDROID_COLOR_FRAME	highgui/highgui_c.h	/^  CV_CAP_ANDROID_COLOR_FRAME = CV_CAP_ANDROID_COLOR_FRAME_BGR,$/;"	e	enum:__anon175
CV_CAP_ANDROID_COLOR_FRAME_BGR	highgui/highgui_c.h	/^  CV_CAP_ANDROID_COLOR_FRAME_BGR = 0, \/\/BGR$/;"	e	enum:__anon175
CV_CAP_ANDROID_COLOR_FRAME_BGRA	highgui/highgui_c.h	/^  CV_CAP_ANDROID_COLOR_FRAME_BGRA = 3,$/;"	e	enum:__anon175
CV_CAP_ANDROID_COLOR_FRAME_RGB	highgui/highgui_c.h	/^  CV_CAP_ANDROID_COLOR_FRAME_RGB = 2,$/;"	e	enum:__anon175
CV_CAP_ANDROID_COLOR_FRAME_RGBA	highgui/highgui_c.h	/^  CV_CAP_ANDROID_COLOR_FRAME_RGBA = 4$/;"	e	enum:__anon175
CV_CAP_ANDROID_GREY_FRAME	highgui/highgui_c.h	/^  CV_CAP_ANDROID_GREY_FRAME  = 1,  \/\/Y$/;"	e	enum:__anon175
CV_CAP_ANY	highgui/highgui_c.h	/^    CV_CAP_ANY      =0,     \/\/ autodetect$/;"	e	enum:__anon171
CV_CAP_CMU1394	highgui/highgui_c.h	/^    CV_CAP_CMU1394  =300,$/;"	e	enum:__anon171
CV_CAP_DC1394	highgui/highgui_c.h	/^    CV_CAP_DC1394   =300,$/;"	e	enum:__anon171
CV_CAP_DSHOW	highgui/highgui_c.h	/^    CV_CAP_DSHOW    =700,   \/\/ DirectShow (via videoInput)$/;"	e	enum:__anon171
CV_CAP_FIREWARE	highgui/highgui_c.h	/^    CV_CAP_FIREWARE =300,   \/\/ IEEE 1394 drivers$/;"	e	enum:__anon171
CV_CAP_FIREWIRE	highgui/highgui_c.h	/^    CV_CAP_FIREWIRE =300,$/;"	e	enum:__anon171
CV_CAP_GSTREAMER_QUEUE_LENGTH	highgui/highgui_c.h	/^    CV_CAP_GSTREAMER_QUEUE_LENGTH   = 200, \/\/ default is 1$/;"	e	enum:__anon172
CV_CAP_IEEE1394	highgui/highgui_c.h	/^    CV_CAP_IEEE1394 =300,$/;"	e	enum:__anon171
CV_CAP_MIL	highgui/highgui_c.h	/^    CV_CAP_MIL      =100,   \/\/ MIL proprietary drivers$/;"	e	enum:__anon171
CV_CAP_OPENNI	highgui/highgui_c.h	/^    CV_CAP_OPENNI   =900,   \/\/ OpenNI (for Kinect)$/;"	e	enum:__anon171
CV_CAP_OPENNI_BGR_IMAGE	highgui/highgui_c.h	/^    CV_CAP_OPENNI_BGR_IMAGE                 = 5,$/;"	e	enum:__anon173
CV_CAP_OPENNI_DEPTH_GENERATOR	highgui/highgui_c.h	/^    CV_CAP_OPENNI_DEPTH_GENERATOR = 0,$/;"	e	enum:__anon172
CV_CAP_OPENNI_DEPTH_GENERATOR_BASELINE	highgui/highgui_c.h	/^    CV_CAP_OPENNI_DEPTH_GENERATOR_BASELINE = CV_CAP_OPENNI_DEPTH_GENERATOR + CV_CAP_PROP_OPENNI_BASELINE,$/;"	e	enum:__anon172
CV_CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH	highgui/highgui_c.h	/^    CV_CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH = CV_CAP_OPENNI_DEPTH_GENERATOR + CV_CAP_PROP_OPENNI_FOCAL_LENGTH,$/;"	e	enum:__anon172
CV_CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON	highgui/highgui_c.h	/^    CV_CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON = CV_CAP_OPENNI_DEPTH_GENERATOR + CV_CAP_PROP_OPENNI_REGISTRATION_ON,$/;"	e	enum:__anon172
CV_CAP_OPENNI_DEPTH_MAP	highgui/highgui_c.h	/^    CV_CAP_OPENNI_DEPTH_MAP                 = 0, \/\/ Depth values in mm (CV_16UC1)$/;"	e	enum:__anon173
CV_CAP_OPENNI_DISPARITY_MAP	highgui/highgui_c.h	/^    CV_CAP_OPENNI_DISPARITY_MAP             = 2, \/\/ Disparity in pixels (CV_8UC1)$/;"	e	enum:__anon173
CV_CAP_OPENNI_DISPARITY_MAP_32F	highgui/highgui_c.h	/^    CV_CAP_OPENNI_DISPARITY_MAP_32F         = 3, \/\/ Disparity in pixels (CV_32FC1)$/;"	e	enum:__anon173
CV_CAP_OPENNI_GENERATORS_MASK	highgui/highgui_c.h	/^    CV_CAP_OPENNI_GENERATORS_MASK = 1 << 31,$/;"	e	enum:__anon172
CV_CAP_OPENNI_GRAY_IMAGE	highgui/highgui_c.h	/^    CV_CAP_OPENNI_GRAY_IMAGE                = 6$/;"	e	enum:__anon173
CV_CAP_OPENNI_IMAGE_GENERATOR	highgui/highgui_c.h	/^    CV_CAP_OPENNI_IMAGE_GENERATOR = 1 << 31,$/;"	e	enum:__anon172
CV_CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE	highgui/highgui_c.h	/^    CV_CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE = CV_CAP_OPENNI_IMAGE_GENERATOR + CV_CAP_PROP_OPENNI_OUTPUT_MODE,$/;"	e	enum:__anon172
CV_CAP_OPENNI_POINT_CLOUD_MAP	highgui/highgui_c.h	/^    CV_CAP_OPENNI_POINT_CLOUD_MAP           = 1, \/\/ XYZ in meters (CV_32FC3)$/;"	e	enum:__anon173
CV_CAP_OPENNI_SXGA_15HZ	highgui/highgui_c.h	/^    CV_CAP_OPENNI_SXGA_15HZ    = 1$/;"	e	enum:__anon174
CV_CAP_OPENNI_VALID_DEPTH_MASK	highgui/highgui_c.h	/^    CV_CAP_OPENNI_VALID_DEPTH_MASK          = 4, \/\/ CV_8UC1$/;"	e	enum:__anon173
CV_CAP_OPENNI_VGA_30HZ	highgui/highgui_c.h	/^    CV_CAP_OPENNI_VGA_30HZ     = 0,$/;"	e	enum:__anon174
CV_CAP_PROP_AUTOGRAB	highgui/highgui_c.h	/^    CV_CAP_PROP_AUTOGRAB      =1024, \/\/ property for highgui class CvCapture_Android only$/;"	e	enum:__anon172
CV_CAP_PROP_AUTO_EXPOSURE	highgui/highgui_c.h	/^    CV_CAP_PROP_AUTO_EXPOSURE =21, \/\/ exposure control done by camera,$/;"	e	enum:__anon172
CV_CAP_PROP_BRIGHTNESS	highgui/highgui_c.h	/^    CV_CAP_PROP_BRIGHTNESS    =10,$/;"	e	enum:__anon172
CV_CAP_PROP_CONTRAST	highgui/highgui_c.h	/^    CV_CAP_PROP_CONTRAST      =11,$/;"	e	enum:__anon172
CV_CAP_PROP_CONVERT_RGB	highgui/highgui_c.h	/^    CV_CAP_PROP_CONVERT_RGB   =16,$/;"	e	enum:__anon172
CV_CAP_PROP_DC1394_MODE_AUTO	highgui/highgui_c.h	/^    CV_CAP_PROP_DC1394_MODE_AUTO = -2,$/;"	e	enum:__anon172
CV_CAP_PROP_DC1394_MODE_MANUAL	highgui/highgui_c.h	/^    CV_CAP_PROP_DC1394_MODE_MANUAL = -3, \/\/set automatically when a value of the feature is set by the user$/;"	e	enum:__anon172
CV_CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO	highgui/highgui_c.h	/^    CV_CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO = -1,$/;"	e	enum:__anon172
CV_CAP_PROP_DC1394_OFF	highgui/highgui_c.h	/^    CV_CAP_PROP_DC1394_OFF         = -4,  \/\/turn the feature off (not controlled manually nor automatically)$/;"	e	enum:__anon172
CV_CAP_PROP_EXPOSURE	highgui/highgui_c.h	/^    CV_CAP_PROP_EXPOSURE      =15,$/;"	e	enum:__anon172
CV_CAP_PROP_FORMAT	highgui/highgui_c.h	/^    CV_CAP_PROP_FORMAT         =8,$/;"	e	enum:__anon172
CV_CAP_PROP_FOURCC	highgui/highgui_c.h	/^    CV_CAP_PROP_FOURCC         =6,$/;"	e	enum:__anon172
CV_CAP_PROP_FPS	highgui/highgui_c.h	/^    CV_CAP_PROP_FPS            =5,$/;"	e	enum:__anon172
CV_CAP_PROP_FRAME_COUNT	highgui/highgui_c.h	/^    CV_CAP_PROP_FRAME_COUNT    =7,$/;"	e	enum:__anon172
CV_CAP_PROP_FRAME_HEIGHT	highgui/highgui_c.h	/^    CV_CAP_PROP_FRAME_HEIGHT   =4,$/;"	e	enum:__anon172
CV_CAP_PROP_FRAME_WIDTH	highgui/highgui_c.h	/^    CV_CAP_PROP_FRAME_WIDTH    =3,$/;"	e	enum:__anon172
CV_CAP_PROP_GAIN	highgui/highgui_c.h	/^    CV_CAP_PROP_GAIN          =14,$/;"	e	enum:__anon172
CV_CAP_PROP_GAMMA	highgui/highgui_c.h	/^    CV_CAP_PROP_GAMMA         =22,$/;"	e	enum:__anon172
CV_CAP_PROP_HUE	highgui/highgui_c.h	/^    CV_CAP_PROP_HUE           =13,$/;"	e	enum:__anon172
CV_CAP_PROP_MAX_DC1394	highgui/highgui_c.h	/^    CV_CAP_PROP_MAX_DC1394    =27,$/;"	e	enum:__anon172
CV_CAP_PROP_MODE	highgui/highgui_c.h	/^    CV_CAP_PROP_MODE           =9,$/;"	e	enum:__anon172
CV_CAP_PROP_MONOCROME	highgui/highgui_c.h	/^    CV_CAP_PROP_MONOCROME     =19,$/;"	e	enum:__anon172
CV_CAP_PROP_OPENNI_BASELINE	highgui/highgui_c.h	/^    CV_CAP_PROP_OPENNI_BASELINE         = 102, \/\/ in mm$/;"	e	enum:__anon172
CV_CAP_PROP_OPENNI_FOCAL_LENGTH	highgui/highgui_c.h	/^    CV_CAP_PROP_OPENNI_FOCAL_LENGTH     = 103, \/\/ in pixels$/;"	e	enum:__anon172
CV_CAP_PROP_OPENNI_FRAME_MAX_DEPTH	highgui/highgui_c.h	/^    CV_CAP_PROP_OPENNI_FRAME_MAX_DEPTH  = 101, \/\/ in mm$/;"	e	enum:__anon172
CV_CAP_PROP_OPENNI_OUTPUT_MODE	highgui/highgui_c.h	/^    CV_CAP_PROP_OPENNI_OUTPUT_MODE      = 100,$/;"	e	enum:__anon172
CV_CAP_PROP_OPENNI_REGISTRATION	highgui/highgui_c.h	/^    CV_CAP_PROP_OPENNI_REGISTRATION     = CV_CAP_PROP_OPENNI_REGISTRATION_ON, \/\/ flag that synchronizes the remapping depth map to image map$/;"	e	enum:__anon172
CV_CAP_PROP_OPENNI_REGISTRATION_ON	highgui/highgui_c.h	/^    CV_CAP_PROP_OPENNI_REGISTRATION_ON  = 104, \/\/ flag$/;"	e	enum:__anon172
CV_CAP_PROP_POS_AVI_RATIO	highgui/highgui_c.h	/^    CV_CAP_PROP_POS_AVI_RATIO  =2,$/;"	e	enum:__anon172
CV_CAP_PROP_POS_FRAMES	highgui/highgui_c.h	/^    CV_CAP_PROP_POS_FRAMES     =1,$/;"	e	enum:__anon172
CV_CAP_PROP_POS_MSEC	highgui/highgui_c.h	/^    CV_CAP_PROP_POS_MSEC       =0,$/;"	e	enum:__anon172
CV_CAP_PROP_PREVIEW_FORMAT	highgui/highgui_c.h	/^    CV_CAP_PROP_PREVIEW_FORMAT=1026, \/\/ readonly, tricky property, returns cpnst char* indeed$/;"	e	enum:__anon172
CV_CAP_PROP_PVAPI_MULTICASTIP	highgui/highgui_c.h	/^    CV_CAP_PROP_PVAPI_MULTICASTIP   = 300, \/\/ ip for anable multicast master mode. 0 for disable multicast$/;"	e	enum:__anon172
CV_CAP_PROP_RECTIFICATION	highgui/highgui_c.h	/^    CV_CAP_PROP_RECTIFICATION =18,$/;"	e	enum:__anon172
CV_CAP_PROP_SATURATION	highgui/highgui_c.h	/^    CV_CAP_PROP_SATURATION    =12,$/;"	e	enum:__anon172
CV_CAP_PROP_SHARPNESS	highgui/highgui_c.h	/^    CV_CAP_PROP_SHARPNESS     =20,$/;"	e	enum:__anon172
CV_CAP_PROP_SUPPORTED_PREVIEW_SIZES_STRING	highgui/highgui_c.h	/^    CV_CAP_PROP_SUPPORTED_PREVIEW_SIZES_STRING=1025, \/\/ readonly, tricky property, returns cpnst char* indeed$/;"	e	enum:__anon172
CV_CAP_PROP_TEMPERATURE	highgui/highgui_c.h	/^    CV_CAP_PROP_TEMPERATURE   =23,$/;"	e	enum:__anon172
CV_CAP_PROP_TRIGGER	highgui/highgui_c.h	/^    CV_CAP_PROP_TRIGGER       =24,$/;"	e	enum:__anon172
CV_CAP_PROP_TRIGGER_DELAY	highgui/highgui_c.h	/^    CV_CAP_PROP_TRIGGER_DELAY =25,$/;"	e	enum:__anon172
CV_CAP_PROP_WHITE_BALANCE_BLUE_U	highgui/highgui_c.h	/^    CV_CAP_PROP_WHITE_BALANCE_BLUE_U =17,$/;"	e	enum:__anon172
CV_CAP_PROP_WHITE_BALANCE_RED_V	highgui/highgui_c.h	/^    CV_CAP_PROP_WHITE_BALANCE_RED_V =26,$/;"	e	enum:__anon172
CV_CAP_PROP_XI_AEAG	highgui/highgui_c.h	/^    CV_CAP_PROP_XI_AEAG          = 415,      \/\/ Automatic exposure\/gain$/;"	e	enum:__anon172
CV_CAP_PROP_XI_AEAG_LEVEL	highgui/highgui_c.h	/^    CV_CAP_PROP_XI_AEAG_LEVEL    = 419,       \/\/ Average intensity of output signal AEAG should achieve(in %)$/;"	e	enum:__anon172
CV_CAP_PROP_XI_AE_MAX_LIMIT	highgui/highgui_c.h	/^    CV_CAP_PROP_XI_AE_MAX_LIMIT  = 417,      \/\/ Maximum limit of exposure in AEAG procedure$/;"	e	enum:__anon172
CV_CAP_PROP_XI_AG_MAX_LIMIT	highgui/highgui_c.h	/^    CV_CAP_PROP_XI_AG_MAX_LIMIT  = 418,      \/\/ Maximum limit of gain in AEAG procedure$/;"	e	enum:__anon172
CV_CAP_PROP_XI_AUTO_WB	highgui/highgui_c.h	/^    CV_CAP_PROP_XI_AUTO_WB       = 414,      \/\/ Automatic white balance$/;"	e	enum:__anon172
CV_CAP_PROP_XI_DATA_FORMAT	highgui/highgui_c.h	/^    CV_CAP_PROP_XI_DATA_FORMAT   = 401,       \/\/ Output data format.$/;"	e	enum:__anon172
CV_CAP_PROP_XI_DOWNSAMPLING	highgui/highgui_c.h	/^    CV_CAP_PROP_XI_DOWNSAMPLING  = 400,      \/\/ Change image resolution by binning or skipping.  $/;"	e	enum:__anon172
CV_CAP_PROP_XI_EXP_PRIORITY	highgui/highgui_c.h	/^    CV_CAP_PROP_XI_EXP_PRIORITY  = 416,      \/\/ Exposure priority (0.5 - exposure 50%, gain 50%).$/;"	e	enum:__anon172
CV_CAP_PROP_XI_GPI_LEVEL	highgui/highgui_c.h	/^    CV_CAP_PROP_XI_GPI_LEVEL     = 408,      \/\/ Get general purpose level$/;"	e	enum:__anon172
CV_CAP_PROP_XI_GPI_MODE	highgui/highgui_c.h	/^    CV_CAP_PROP_XI_GPI_MODE      = 407,      \/\/ Set general purpose input mode$/;"	e	enum:__anon172
CV_CAP_PROP_XI_GPI_SELECTOR	highgui/highgui_c.h	/^    CV_CAP_PROP_XI_GPI_SELECTOR  = 406,      \/\/ Selects general purpose input $/;"	e	enum:__anon172
CV_CAP_PROP_XI_GPO_MODE	highgui/highgui_c.h	/^    CV_CAP_PROP_XI_GPO_MODE      = 410,      \/\/ Set general purpose output mode$/;"	e	enum:__anon172
CV_CAP_PROP_XI_GPO_SELECTOR	highgui/highgui_c.h	/^    CV_CAP_PROP_XI_GPO_SELECTOR  = 409,      \/\/ Selects general purpose output $/;"	e	enum:__anon172
CV_CAP_PROP_XI_LED_MODE	highgui/highgui_c.h	/^    CV_CAP_PROP_XI_LED_MODE      = 412,      \/\/ Define camera signalling LED functionality$/;"	e	enum:__anon172
CV_CAP_PROP_XI_LED_SELECTOR	highgui/highgui_c.h	/^    CV_CAP_PROP_XI_LED_SELECTOR  = 411,      \/\/ Selects camera signalling LED $/;"	e	enum:__anon172
CV_CAP_PROP_XI_MANUAL_WB	highgui/highgui_c.h	/^    CV_CAP_PROP_XI_MANUAL_WB     = 413,      \/\/ Calculates White Balance(must be called during acquisition)$/;"	e	enum:__anon172
CV_CAP_PROP_XI_OFFSET_X	highgui/highgui_c.h	/^    CV_CAP_PROP_XI_OFFSET_X      = 402,      \/\/ Horizontal offset from the origin to the area of interest (in pixels).$/;"	e	enum:__anon172
CV_CAP_PROP_XI_OFFSET_Y	highgui/highgui_c.h	/^    CV_CAP_PROP_XI_OFFSET_Y      = 403,      \/\/ Vertical offset from the origin to the area of interest (in pixels).$/;"	e	enum:__anon172
CV_CAP_PROP_XI_TIMEOUT	highgui/highgui_c.h	/^    CV_CAP_PROP_XI_TIMEOUT       = 420       \/\/ Image capture timeout in milliseconds$/;"	e	enum:__anon172
CV_CAP_PROP_XI_TRG_SOFTWARE	highgui/highgui_c.h	/^    CV_CAP_PROP_XI_TRG_SOFTWARE  = 405,      \/\/ Generates an internal trigger. PRM_TRG_SOURCE must be set to TRG_SOFTWARE.$/;"	e	enum:__anon172
CV_CAP_PROP_XI_TRG_SOURCE	highgui/highgui_c.h	/^    CV_CAP_PROP_XI_TRG_SOURCE    = 404,      \/\/ Defines source of trigger.$/;"	e	enum:__anon172
CV_CAP_PVAPI	highgui/highgui_c.h	/^    CV_CAP_PVAPI    =800,   \/\/ PvAPI, Prosilica GigE SDK$/;"	e	enum:__anon171
CV_CAP_QT	highgui/highgui_c.h	/^    CV_CAP_QT       =500,   \/\/ QuickTime$/;"	e	enum:__anon171
CV_CAP_STEREO	highgui/highgui_c.h	/^    CV_CAP_STEREO   =400,   \/\/ TYZX proprietary drivers$/;"	e	enum:__anon171
CV_CAP_TYZX	highgui/highgui_c.h	/^    CV_CAP_TYZX     =400,$/;"	e	enum:__anon171
CV_CAP_UNICAP	highgui/highgui_c.h	/^    CV_CAP_UNICAP   =600,   \/\/ Unicap drivers$/;"	e	enum:__anon171
CV_CAP_V4L	highgui/highgui_c.h	/^    CV_CAP_V4L      =200,$/;"	e	enum:__anon171
CV_CAP_V4L2	highgui/highgui_c.h	/^    CV_CAP_V4L2     =200,$/;"	e	enum:__anon171
CV_CAP_VFW	highgui/highgui_c.h	/^    CV_CAP_VFW      =200,   \/\/ platform native$/;"	e	enum:__anon171
CV_CAP_XIAPI	highgui/highgui_c.h	/^    CV_CAP_XIAPI    =1100   \/\/ XIMEA Camera API$/;"	e	enum:__anon171
CV_CARRAY	core/types_c.h	165;"	d
CV_CAST_16S	core/internal.hpp	373;"	d
CV_CAST_16U	core/internal.hpp	372;"	d
CV_CAST_32F	core/internal.hpp	376;"	d
CV_CAST_32S	core/internal.hpp	374;"	d
CV_CAST_64F	core/internal.hpp	377;"	d
CV_CAST_64S	core/internal.hpp	375;"	d
CV_CAST_8S	core/internal.hpp	371;"	d
CV_CAST_8U	core/internal.hpp	370;"	d
CV_CDECL	core/types_c.h	100;"	d
CV_CDECL	core/types_c.h	103;"	d
CV_CHAIN_APPROX_NONE	imgproc/types_c.h	/^    CV_CHAIN_APPROX_NONE=1,$/;"	e	enum:__anon40
CV_CHAIN_APPROX_SIMPLE	imgproc/types_c.h	/^    CV_CHAIN_APPROX_SIMPLE=2,$/;"	e	enum:__anon40
CV_CHAIN_APPROX_TC89_KCOS	imgproc/types_c.h	/^    CV_CHAIN_APPROX_TC89_KCOS=4,$/;"	e	enum:__anon40
CV_CHAIN_APPROX_TC89_L1	imgproc/types_c.h	/^    CV_CHAIN_APPROX_TC89_L1=3,$/;"	e	enum:__anon40
CV_CHAIN_CODE	imgproc/types_c.h	/^    CV_CHAIN_CODE=0,$/;"	e	enum:__anon40
CV_CHECK	core/core_c.h	1827;"	d
CV_CHECKBOX	highgui/highgui_c.h	/^enum {CV_PUSH_BUTTON = 0, CV_CHECKBOX = 1, CV_RADIOBOX = 2};$/;"	e	enum:__anon164
CV_CHECK_NANS	core/internal.hpp	285;"	d
CV_CHECK_QUIET	core/core_c.h	642;"	d
CV_CHECK_RANGE	core/core_c.h	641;"	d
CV_CHOLESKY	core/core_c.h	740;"	d
CV_CLOCKWISE	imgproc/types_c.h	/^    CV_CLOCKWISE         =1,$/;"	e	enum:__anon43
CV_CMP	core/types_c.h	286;"	d
CV_CMP_EQ	core/core_c.h	565;"	d
CV_CMP_GE	core/core_c.h	567;"	d
CV_CMP_GT	core/core_c.h	566;"	d
CV_CMP_LE	core/core_c.h	569;"	d
CV_CMP_LT	core/core_c.h	568;"	d
CV_CMP_NE	core/core_c.h	570;"	d
CV_CN_MAX	core/types_c.h	547;"	d
CV_CN_SHIFT	core/types_c.h	548;"	d
CV_COLORCVT_MAX	imgproc/types_c.h	/^    CV_COLORCVT_MAX  =100$/;"	e	enum:__anon33
CV_COL_SAMPLE	ml/ml.hpp	61;"	d
CV_COMP_BHATTACHARYYA	imgproc/types_c.h	/^    CV_COMP_BHATTACHARYYA =3$/;"	e	enum:__anon44
CV_COMP_CHISQR	imgproc/types_c.h	/^    CV_COMP_CHISQR        =1,$/;"	e	enum:__anon44
CV_COMP_CORREL	imgproc/types_c.h	/^    CV_COMP_CORREL        =0,$/;"	e	enum:__anon44
CV_COMP_INTERSECT	imgproc/types_c.h	/^    CV_COMP_INTERSECT     =2,$/;"	e	enum:__anon44
CV_CONTOURS_MATCH_I1	imgproc/types_c.h	/^    CV_CONTOURS_MATCH_I1  =1,$/;"	e	enum:__anon42
CV_CONTOURS_MATCH_I2	imgproc/types_c.h	/^    CV_CONTOURS_MATCH_I2  =2,$/;"	e	enum:__anon42
CV_CONTOURS_MATCH_I3	imgproc/types_c.h	/^    CV_CONTOURS_MATCH_I3  =3$/;"	e	enum:__anon42
CV_CONTOUR_FIELDS	core/types_c.h	1435;"	d
CV_CONTOUR_TREES_MATCH_I1	legacy/legacy.hpp	/^enum { CV_CONTOUR_TREES_MATCH_I1 = 1 };$/;"	e	enum:__anon184
CV_COUNT	ml/ml.hpp	2026;"	d
CV_COUNTER_CLOCKWISE	imgproc/types_c.h	/^    CV_COUNTER_CLOCKWISE =2$/;"	e	enum:__anon43
CV_COUNT_OBS	legacy/legacy.hpp	174;"	d
CV_COVAR_COLS	core/core_c.h	794;"	d
CV_COVAR_NORMAL	core/core_c.h	781;"	d
CV_COVAR_ROWS	core/core_c.h	791;"	d
CV_COVAR_SCALE	core/core_c.h	788;"	d
CV_COVAR_SCRAMBLED	core/core_c.h	778;"	d
CV_COVAR_USE_AVG	core/core_c.h	785;"	d
CV_CPU_AVX	core/core_c.h	1708;"	d
CV_CPU_MMX	core/core_c.h	1700;"	d
CV_CPU_NONE	core/core_c.h	1699;"	d
CV_CPU_POPCNT	core/core_c.h	1707;"	d
CV_CPU_SSE	core/core_c.h	1701;"	d
CV_CPU_SSE2	core/core_c.h	1702;"	d
CV_CPU_SSE3	core/core_c.h	1703;"	d
CV_CPU_SSE4_1	core/core_c.h	1705;"	d
CV_CPU_SSE4_2	core/core_c.h	1706;"	d
CV_CPU_SSSE3	core/core_c.h	1704;"	d
CV_CURRENT_INT	legacy/legacy.hpp	280;"	d
CV_CURRENT_POINT	core/types_c.h	1694;"	d
CV_CUSTOM_CARRAY	core/types_c.h	166;"	d
CV_CVTIMG_FLIP	highgui/highgui_c.h	/^    CV_CVTIMG_FLIP      =1,$/;"	e	enum:__anon170
CV_CVTIMG_SWAP_RB	highgui/highgui_c.h	/^    CV_CVTIMG_SWAP_RB   =2$/;"	e	enum:__anon170
CV_DBG_BREAK	core/internal.hpp	328;"	d
CV_DECL_ALIGNED	core/internal.hpp	312;"	d
CV_DECL_ALIGNED	core/internal.hpp	314;"	d
CV_DECL_ALIGNED	core/internal.hpp	316;"	d
CV_DEFAULT	core/core_c.h	/^                               CvFreeFunc free_func CV_DEFAULT(NULL),$/;"	p	signature:(NULL)
CV_DEFAULT	core/core_c.h	/^                               void* userdata CV_DEFAULT(NULL));$/;"	p	signature:(NULL)
CV_DEFAULT	core/core_c.h	/^CVAPI(void) cvSetMemoryManager( CvAllocFunc alloc_func CV_DEFAULT(NULL),$/;"	p	signature:(NULL)
CV_DEFAULT	core/types_c.h	110;"	d
CV_DEFAULT	core/types_c.h	113;"	d
CV_DEFAULT_IMAGE_ROW_ALIGN	core/internal.hpp	252;"	d
CV_DEFAULT_MAT_ROW_ALIGN	core/internal.hpp	255;"	d
CV_DEPTH_MAX	core/types_c.h	549;"	d
CV_DESCALE	core/internal.hpp	411;"	d
CV_DIFF	core/core_c.h	844;"	d
CV_DIFF_C	core/core_c.h	847;"	d
CV_DIFF_L1	core/core_c.h	848;"	d
CV_DIFF_L2	core/core_c.h	849;"	d
CV_DIM	core/internal.hpp	387;"	d
CV_DISPARITY_BIRCHFIELD	legacy/legacy.hpp	468;"	d
CV_DIST_C	imgproc/types_c.h	/^    CV_DIST_C       =3,   \/* distance = max(|x1-x2|,|y1-y2|) *\/$/;"	e	enum:__anon46
CV_DIST_FAIR	imgproc/types_c.h	/^    CV_DIST_FAIR    =5,   \/* distance = c^2(|x|\/c-log(1+|x|\/c)), c = 1.3998 *\/$/;"	e	enum:__anon46
CV_DIST_HUBER	imgproc/types_c.h	/^    CV_DIST_HUBER   =7    \/* distance = |x|<c ? x^2\/2 : c(|x|-c\/2), c=1.345 *\/$/;"	e	enum:__anon46
CV_DIST_L1	imgproc/types_c.h	/^    CV_DIST_L1      =1,   \/* distance = |x1-x2| + |y1-y2| *\/$/;"	e	enum:__anon46
CV_DIST_L12	imgproc/types_c.h	/^    CV_DIST_L12     =4,   \/* L1-L2 metric: distance = 2(sqrt(1+x*x\/2) - 1)) *\/$/;"	e	enum:__anon46
CV_DIST_L2	imgproc/types_c.h	/^    CV_DIST_L2      =2,   \/* the simple euclidean distance *\/$/;"	e	enum:__anon46
CV_DIST_MASK_3	imgproc/types_c.h	/^    CV_DIST_MASK_3   =3,$/;"	e	enum:__anon45
CV_DIST_MASK_5	imgproc/types_c.h	/^    CV_DIST_MASK_5   =5,$/;"	e	enum:__anon45
CV_DIST_MASK_PRECISE	imgproc/types_c.h	/^    CV_DIST_MASK_PRECISE =0$/;"	e	enum:__anon45
CV_DIST_USER	imgproc/types_c.h	/^    CV_DIST_USER    =-1,  \/* User defined distance *\/$/;"	e	enum:__anon46
CV_DIST_WELSCH	imgproc/types_c.h	/^    CV_DIST_WELSCH  =6,   \/* distance = c^2\/2(1-exp(-(x\/c)^2)), c = 2.9846 *\/$/;"	e	enum:__anon46
CV_DIV_BY_ZERO_ERR	core/internal.hpp	/^    CV_DIV_BY_ZERO_ERR =  -11, \/\/ipp comp$/;"	e	enum:CvStatus
CV_DLL	core/internal.hpp	82;"	d
CV_DOMINANT_IPAN	legacy/legacy.hpp	310;"	d
CV_DTREE_CAT_DIR	ml/ml.hpp	671;"	d
CV_DXT_FORWARD	core/core_c.h	877;"	d
CV_DXT_INVERSE	core/core_c.h	878;"	d
CV_DXT_INVERSE_SCALE	core/core_c.h	881;"	d
CV_DXT_INV_SCALE	core/core_c.h	880;"	d
CV_DXT_MUL_CONJ	core/core_c.h	883;"	d
CV_DXT_ROWS	core/core_c.h	882;"	d
CV_DXT_SCALE	core/core_c.h	879;"	d
CV_DbgAssert	core/core.hpp	202;"	d
CV_DbgAssert	core/core.hpp	204;"	d
CV_EIGOBJ_BOTH_CALLBACK	legacy/legacy.hpp	74;"	d
CV_EIGOBJ_INPUT_CALLBACK	legacy/legacy.hpp	72;"	d
CV_EIGOBJ_NO_CALLBACK	legacy/legacy.hpp	71;"	d
CV_EIGOBJ_OUTPUT_CALLBACK	legacy/legacy.hpp	73;"	d
CV_ELEM_SIZE	core/types_c.h	703;"	d
CV_ELEM_SIZE1	core/types_c.h	699;"	d
CV_EMPTY	core/internal.hpp	382;"	d
CV_EQ	core/internal.hpp	361;"	d
CV_ERROR	core/core_c.h	1812;"	d
CV_ERROR_FROM_CODE	core/core_c.h	1819;"	d
CV_EVENT_FLAG_ALTKEY	highgui/highgui_c.h	/^    CV_EVENT_FLAG_ALTKEY    =32$/;"	e	enum:__anon167
CV_EVENT_FLAG_CTRLKEY	highgui/highgui_c.h	/^    CV_EVENT_FLAG_CTRLKEY   =8,$/;"	e	enum:__anon167
CV_EVENT_FLAG_LBUTTON	highgui/highgui_c.h	/^    CV_EVENT_FLAG_LBUTTON   =1,$/;"	e	enum:__anon167
CV_EVENT_FLAG_MBUTTON	highgui/highgui_c.h	/^    CV_EVENT_FLAG_MBUTTON   =4,$/;"	e	enum:__anon167
CV_EVENT_FLAG_RBUTTON	highgui/highgui_c.h	/^    CV_EVENT_FLAG_RBUTTON   =2,$/;"	e	enum:__anon167
CV_EVENT_FLAG_SHIFTKEY	highgui/highgui_c.h	/^    CV_EVENT_FLAG_SHIFTKEY  =16,$/;"	e	enum:__anon167
CV_EVENT_LBUTTONDBLCLK	highgui/highgui_c.h	/^    CV_EVENT_LBUTTONDBLCLK  =7,$/;"	e	enum:__anon166
CV_EVENT_LBUTTONDOWN	highgui/highgui_c.h	/^    CV_EVENT_LBUTTONDOWN    =1,$/;"	e	enum:__anon166
CV_EVENT_LBUTTONUP	highgui/highgui_c.h	/^    CV_EVENT_LBUTTONUP      =4,$/;"	e	enum:__anon166
CV_EVENT_MBUTTONDBLCLK	highgui/highgui_c.h	/^    CV_EVENT_MBUTTONDBLCLK  =9$/;"	e	enum:__anon166
CV_EVENT_MBUTTONDOWN	highgui/highgui_c.h	/^    CV_EVENT_MBUTTONDOWN    =3,$/;"	e	enum:__anon166
CV_EVENT_MBUTTONUP	highgui/highgui_c.h	/^    CV_EVENT_MBUTTONUP      =6,$/;"	e	enum:__anon166
CV_EVENT_MOUSEMOVE	highgui/highgui_c.h	/^    CV_EVENT_MOUSEMOVE      =0,$/;"	e	enum:__anon166
CV_EVENT_RBUTTONDBLCLK	highgui/highgui_c.h	/^    CV_EVENT_RBUTTONDBLCLK  =8,$/;"	e	enum:__anon166
CV_EVENT_RBUTTONDOWN	highgui/highgui_c.h	/^    CV_EVENT_RBUTTONDOWN    =2,$/;"	e	enum:__anon166
CV_EVENT_RBUTTONUP	highgui/highgui_c.h	/^    CV_EVENT_RBUTTONUP      =5,$/;"	e	enum:__anon166
CV_EXPORTS	core/types_c.h	136;"	d
CV_EXPORTS	core/types_c.h	138;"	d
CV_EXPORTS_AS	core/types_c.h	169;"	d
CV_EXPORTS_W	core/types_c.h	167;"	d
CV_EXPORTS_W_MAP	core/types_c.h	170;"	d
CV_EXPORTS_W_SIMPLE	core/types_c.h	168;"	d
CV_EXTERN_C	core/types_c.h	109;"	d
CV_EXTERN_C	core/types_c.h	112;"	d
CV_EXTERN_C_FUNCPTR	core/types_c.h	119;"	d
CV_EXTERN_C_FUNCPTR	core/types_c.h	121;"	d
CV_ErrModeLeaf	core/core_c.h	1730;"	d
CV_ErrModeParent	core/core_c.h	1731;"	d
CV_ErrModeSilent	core/core_c.h	1732;"	d
CV_Error	core/core.hpp	192;"	d
CV_Error	core/core.hpp	196;"	d
CV_Error_	core/core.hpp	193;"	d
CV_Error_	core/core.hpp	197;"	d
CV_FACE_ELEMENTS	legacy/legacy.hpp	/^enum CV_FACE_ELEMENTS$/;"	g
CV_FACE_LEFT_EYE	legacy/legacy.hpp	/^    CV_FACE_LEFT_EYE = 1,$/;"	e	enum:CV_FACE_ELEMENTS
CV_FACE_MOUTH	legacy/legacy.hpp	/^    CV_FACE_MOUTH = 0,$/;"	e	enum:CV_FACE_ELEMENTS
CV_FACE_RIGHT_EYE	legacy/legacy.hpp	/^    CV_FACE_RIGHT_EYE = 2$/;"	e	enum:CV_FACE_ELEMENTS
CV_FILLED	core/core_c.h	1265;"	d
CV_FIRST_VORONOIEDGE2D	legacy/legacy.hpp	992;"	d
CV_FLOODFILL_FIXED_RANGE	imgproc/types_c.h	/^    CV_FLOODFILL_FIXED_RANGE =(1 << 16),$/;"	e	enum:__anon49
CV_FLOODFILL_MASK_ONLY	imgproc/types_c.h	/^    CV_FLOODFILL_MASK_ONLY   =(1 << 17)$/;"	e	enum:__anon49
CV_FLT_TO_FIX	core/internal.hpp	412;"	d
CV_FM_7POINT	calib3d/calib3d.hpp	79;"	d
CV_FM_8POINT	calib3d/calib3d.hpp	80;"	d
CV_FM_LMEDS	calib3d/calib3d.hpp	87;"	d
CV_FM_LMEDS_ONLY	calib3d/calib3d.hpp	85;"	d
CV_FM_RANSAC	calib3d/calib3d.hpp	88;"	d
CV_FM_RANSAC_ONLY	calib3d/calib3d.hpp	86;"	d
CV_FONT_BLACK	highgui/highgui_c.h	/^        CV_FONT_BLACK           = 87 \/\/QFont::Black$/;"	e	enum:__anon162
CV_FONT_BOLD	highgui/highgui_c.h	/^        CV_FONT_BOLD            = 75,\/\/QFont::Bold,$/;"	e	enum:__anon162
CV_FONT_DEMIBOLD	highgui/highgui_c.h	/^        CV_FONT_DEMIBOLD        = 63,\/\/QFont::DemiBold,$/;"	e	enum:__anon162
CV_FONT_HERSHEY_COMPLEX	core/core_c.h	1362;"	d
CV_FONT_HERSHEY_COMPLEX_SMALL	core/core_c.h	1364;"	d
CV_FONT_HERSHEY_DUPLEX	core/core_c.h	1361;"	d
CV_FONT_HERSHEY_PLAIN	core/core_c.h	1360;"	d
CV_FONT_HERSHEY_SCRIPT_COMPLEX	core/core_c.h	1366;"	d
CV_FONT_HERSHEY_SCRIPT_SIMPLEX	core/core_c.h	1365;"	d
CV_FONT_HERSHEY_SIMPLEX	core/core_c.h	1359;"	d
CV_FONT_HERSHEY_TRIPLEX	core/core_c.h	1363;"	d
CV_FONT_ITALIC	core/core_c.h	1369;"	d
CV_FONT_LIGHT	highgui/highgui_c.h	/^enum {  CV_FONT_LIGHT           = 25,\/\/QFont::Light,$/;"	e	enum:__anon162
CV_FONT_NORMAL	highgui/highgui_c.h	/^        CV_FONT_NORMAL          = 50,\/\/QFont::Normal,$/;"	e	enum:__anon162
CV_FONT_VECTOR0	core/core_c.h	1371;"	d
CV_FOURCC	highgui/highgui_c.h	/^CV_INLINE int CV_FOURCC(char c1, char c2, char c3, char c4)$/;"	f	signature:(char c1, char c2, char c3, char c4)
CV_FOURCC_DEFAULT	highgui/highgui_c.h	451;"	d
CV_FOURCC_PROMPT	highgui/highgui_c.h	450;"	d
CV_FRONT	core/core_c.h	970;"	d
CV_FUNCNAME	core/core_c.h	1800;"	d
CV_FUNCNAME	core/core_c.h	1803;"	d
CV_GAUSSIAN	imgproc/types_c.h	/^    CV_GAUSSIAN  =2,$/;"	e	enum:__anon29
CV_GAUSSIAN_5x5	imgproc/types_c.h	/^    CV_GAUSSIAN_5x5 = 7$/;"	e	enum:__anon30
CV_GE	core/internal.hpp	364;"	d
CV_GEMM_A_T	core/core_c.h	682;"	d
CV_GEMM_B_T	core/core_c.h	683;"	d
CV_GEMM_C_T	core/core_c.h	684;"	d
CV_GET_CURRENT	legacy/compat.hpp	399;"	d
CV_GET_SEQ_ELEM	core/types_c.h	1620;"	d
CV_GLCMDESC_CLUSTERSHADE	legacy/legacy.hpp	841;"	d
CV_GLCMDESC_CLUSTERTENDENCY	legacy/legacy.hpp	840;"	d
CV_GLCMDESC_CONTRAST	legacy/legacy.hpp	839;"	d
CV_GLCMDESC_CORRELATION	legacy/legacy.hpp	842;"	d
CV_GLCMDESC_CORRELATIONINFO1	legacy/legacy.hpp	843;"	d
CV_GLCMDESC_CORRELATIONINFO2	legacy/legacy.hpp	844;"	d
CV_GLCMDESC_ENERGY	legacy/legacy.hpp	837;"	d
CV_GLCMDESC_ENTROPY	legacy/legacy.hpp	836;"	d
CV_GLCMDESC_HOMOGENITY	legacy/legacy.hpp	838;"	d
CV_GLCMDESC_MAXIMUMPROBABILITY	legacy/legacy.hpp	845;"	d
CV_GLCMDESC_OPTIMIZATION_ALLOWDOUBLENEST	legacy/legacy.hpp	832;"	d
CV_GLCMDESC_OPTIMIZATION_ALLOWTRIPLENEST	legacy/legacy.hpp	833;"	d
CV_GLCMDESC_OPTIMIZATION_HISTOGRAM	legacy/legacy.hpp	834;"	d
CV_GLCM_ALL	legacy/legacy.hpp	847;"	d
CV_GLCM_DESC	legacy/legacy.hpp	849;"	d
CV_GLCM_GLCM	legacy/legacy.hpp	848;"	d
CV_GLCM_OPTIMIZATION_HISTOGRAM	legacy/legacy.hpp	830;"	d
CV_GLCM_OPTIMIZATION_LUT	legacy/legacy.hpp	829;"	d
CV_GLCM_OPTIMIZATION_NONE	legacy/legacy.hpp	828;"	d
CV_GRAPH	core/types_c.h	1500;"	d
CV_GRAPH_ALL_ITEMS	core/core_c.h	1212;"	d
CV_GRAPH_ANY_EDGE	core/core_c.h	1207;"	d
CV_GRAPH_BACKTRACKING	core/core_c.h	1209;"	d
CV_GRAPH_BACK_EDGE	core/core_c.h	1204;"	d
CV_GRAPH_CROSS_EDGE	core/core_c.h	1206;"	d
CV_GRAPH_EDGE_FIELDS	core/types_c.h	1379;"	d
CV_GRAPH_FIELDS	core/types_c.h	1414;"	d
CV_GRAPH_FLAG_ORIENTED	core/types_c.h	1498;"	d
CV_GRAPH_FORWARD_EDGE	core/core_c.h	1205;"	d
CV_GRAPH_FORWARD_EDGE_FLAG	core/core_c.h	1221;"	d
CV_GRAPH_ITEM_VISITED_FLAG	core/core_c.h	1215;"	d
CV_GRAPH_NEW_TREE	core/core_c.h	1208;"	d
CV_GRAPH_OVER	core/core_c.h	1210;"	d
CV_GRAPH_SEARCH_TREE_NODE_FLAG	core/core_c.h	1220;"	d
CV_GRAPH_TREE_EDGE	core/core_c.h	1203;"	d
CV_GRAPH_VERTEX	core/core_c.h	1202;"	d
CV_GRAPH_VERTEX_FIELDS	core/types_c.h	1386;"	d
CV_GRAPH_WEIGHTED_EDGE_FIELDS	legacy/legacy.hpp	286;"	d
CV_GRAPH_WEIGHTED_VERTEX_FIELDS	legacy/legacy.hpp	283;"	d
CV_GRAY2BGR	imgproc/types_c.h	/^    CV_GRAY2BGR    =8,$/;"	e	enum:__anon33
CV_GRAY2BGR555	imgproc/types_c.h	/^    CV_GRAY2BGR555 =30,$/;"	e	enum:__anon33
CV_GRAY2BGR565	imgproc/types_c.h	/^    CV_GRAY2BGR565 =20,$/;"	e	enum:__anon33
CV_GRAY2BGRA	imgproc/types_c.h	/^    CV_GRAY2BGRA   =9,$/;"	e	enum:__anon33
CV_GRAY2RGB	imgproc/types_c.h	/^    CV_GRAY2RGB    =CV_GRAY2BGR,$/;"	e	enum:__anon33
CV_GRAY2RGBA	imgproc/types_c.h	/^    CV_GRAY2RGBA   =CV_GRAY2BGRA,$/;"	e	enum:__anon33
CV_GT	core/internal.hpp	363;"	d
CV_GUI_EXPANDED	highgui/highgui_c.h	/^    CV_GUI_EXPANDED         = 0x00000000,\/\/status bar and tool bar$/;"	e	enum:__anon165
CV_GUI_NORMAL	highgui/highgui_c.h	/^    CV_GUI_NORMAL           = 0x00000010,\/\/old fashious way$/;"	e	enum:__anon165
CV_GpuApiCallError	core/types_c.h	/^ CV_GpuApiCallError=           -217, $/;"	e	enum:__anon150
CV_GpuCufftCallError	core/types_c.h	/^ CV_GpuCufftCallError=         -219$/;"	e	enum:__anon150
CV_GpuNotSupported	core/types_c.h	/^ CV_GpuNotSupported=           -216,  $/;"	e	enum:__anon150
CV_GpuNppCallError	core/types_c.h	/^ CV_GpuNppCallError=           -218,$/;"	e	enum:__anon150
CV_HAAR_DO_CANNY_PRUNING	objdetect/objdetect.hpp	123;"	d
CV_HAAR_DO_ROUGH_SEARCH	objdetect/objdetect.hpp	126;"	d
CV_HAAR_FEATURE_MAX	objdetect/objdetect.hpp	64;"	d
CV_HAAR_FIND_BIGGEST_OBJECT	objdetect/objdetect.hpp	125;"	d
CV_HAAR_MAGIC_VAL	objdetect/objdetect.hpp	57;"	d
CV_HAAR_SCALE_IMAGE	objdetect/objdetect.hpp	124;"	d
CV_HARDWARE_MAX_FEATURE	core/core_c.h	1709;"	d
CV_HAVE_ALLOCA	core/internal.hpp	296;"	d
CV_HAVE_ALLOCA	core/internal.hpp	300;"	d
CV_HAVE_ALLOCA	core/internal.hpp	303;"	d
CV_HAVE_ALLOCA	core/internal.hpp	306;"	d
CV_HAVE_ALLOCA	core/internal.hpp	308;"	d
CV_HIST_ARRAY	core/types_c.h	895;"	d
CV_HIST_HAS_RANGES	core/types_c.h	924;"	d
CV_HIST_MAGIC_VAL	core/types_c.h	889;"	d
CV_HIST_RANGES_FLAG	core/types_c.h	893;"	d
CV_HIST_SPARSE	core/types_c.h	896;"	d
CV_HIST_TREE	core/types_c.h	897;"	d
CV_HIST_UNIFORM	core/types_c.h	901;"	d
CV_HIST_UNIFORM_FLAG	core/types_c.h	890;"	d
CV_HLS2BGR	imgproc/types_c.h	/^    CV_HLS2BGR     =60,$/;"	e	enum:__anon33
CV_HLS2BGR_FULL	imgproc/types_c.h	/^    CV_HLS2BGR_FULL = 72,$/;"	e	enum:__anon33
CV_HLS2RGB	imgproc/types_c.h	/^    CV_HLS2RGB     =61,$/;"	e	enum:__anon33
CV_HLS2RGB_FULL	imgproc/types_c.h	/^    CV_HLS2RGB_FULL = 73,$/;"	e	enum:__anon33
CV_HOUGH_GRADIENT	imgproc/types_c.h	/^    CV_HOUGH_GRADIENT =3$/;"	e	enum:__anon51
CV_HOUGH_MULTI_SCALE	imgproc/types_c.h	/^    CV_HOUGH_MULTI_SCALE =2,$/;"	e	enum:__anon51
CV_HOUGH_PROBABILISTIC	imgproc/types_c.h	/^    CV_HOUGH_PROBABILISTIC =1,$/;"	e	enum:__anon51
CV_HOUGH_STANDARD	imgproc/types_c.h	/^    CV_HOUGH_STANDARD =0,$/;"	e	enum:__anon51
CV_HSV2BGR	imgproc/types_c.h	/^    CV_HSV2BGR     =54,$/;"	e	enum:__anon33
CV_HSV2BGR_FULL	imgproc/types_c.h	/^    CV_HSV2BGR_FULL = 70,$/;"	e	enum:__anon33
CV_HSV2RGB	imgproc/types_c.h	/^    CV_HSV2RGB     =55,$/;"	e	enum:__anon33
CV_HSV2RGB_FULL	imgproc/types_c.h	/^    CV_HSV2RGB_FULL = 71,$/;"	e	enum:__anon33
CV_HeaderIsNull	core/types_c.h	/^ CV_HeaderIsNull=               -9,  \/* image header is NULL            *\/$/;"	e	enum:__anon150
CV_IABS	core/types_c.h	282;"	d
CV_IABS	core/types_c.h	284;"	d
CV_ICC	core/types_c.h	62;"	d
CV_ICC	core/types_c.h	64;"	d
CV_ICC	core/types_c.h	66;"	d
CV_ICC	core/types_c.h	68;"	d
CV_ICC	core/types_c.h	70;"	d
CV_IDP_BIRCHFIELD_PARAM1	legacy/legacy.hpp	461;"	d
CV_IDP_BIRCHFIELD_PARAM2	legacy/legacy.hpp	462;"	d
CV_IDP_BIRCHFIELD_PARAM3	legacy/legacy.hpp	463;"	d
CV_IDP_BIRCHFIELD_PARAM4	legacy/legacy.hpp	464;"	d
CV_IDP_BIRCHFIELD_PARAM5	legacy/legacy.hpp	465;"	d
CV_IMAGE_ELEM	core/types_c.h	540;"	d
CV_IMAX	core/types_c.h	278;"	d
CV_IMIN	core/types_c.h	276;"	d
CV_IMPL	core/internal.hpp	325;"	d
CV_IMPLEMENT_QSORT	core/internal.hpp	640;"	d
CV_IMPLEMENT_QSORT_EX	core/internal.hpp	476;"	d
CV_IMWRITE_JPEG_QUALITY	highgui/highgui_c.h	/^    CV_IMWRITE_JPEG_QUALITY =1,$/;"	e	enum:__anon169
CV_IMWRITE_PNG_COMPRESSION	highgui/highgui_c.h	/^    CV_IMWRITE_PNG_COMPRESSION =16,$/;"	e	enum:__anon169
CV_IMWRITE_PXM_BINARY	highgui/highgui_c.h	/^    CV_IMWRITE_PXM_BINARY =32$/;"	e	enum:__anon169
CV_INIT_3X3_DELTAS	imgproc/types_c.h	342;"	d
CV_INIT_FUNC_TAB	core/internal.hpp	701;"	d
CV_INIT_PIXEL_POS	legacy/compat.hpp	373;"	d
CV_INLINE	core/types_c.h	127;"	d
CV_INLINE	core/types_c.h	129;"	d
CV_INLINE	core/types_c.h	131;"	d
CV_INPAINT_NS	imgproc/types_c.h	/^    CV_INPAINT_NS      =0,$/;"	e	enum:__anon31
CV_INPAINT_TELEA	imgproc/types_c.h	/^    CV_INPAINT_TELEA   =1$/;"	e	enum:__anon31
CV_INPLACE_NOT_SUPPORTED_ERR	core/internal.hpp	/^    CV_INPLACE_NOT_SUPPORTED_ERR= -112,$/;"	e	enum:CvStatus
CV_INTER_AREA	imgproc/types_c.h	/^    CV_INTER_AREA      =3,$/;"	e	enum:__anon34
CV_INTER_CUBIC	imgproc/types_c.h	/^    CV_INTER_CUBIC     =2,$/;"	e	enum:__anon34
CV_INTER_LANCZOS4	imgproc/types_c.h	/^    CV_INTER_LANCZOS4  =4$/;"	e	enum:__anon34
CV_INTER_LINEAR	imgproc/types_c.h	/^    CV_INTER_LINEAR    =1,$/;"	e	enum:__anon34
CV_INTER_NN	imgproc/types_c.h	/^    CV_INTER_NN        =0,$/;"	e	enum:__anon34
CV_IN_OUT	core/types_c.h	171;"	d
CV_IS_CONT_MAT	core/types_c.h	618;"	d
CV_IS_GRAPH	core/types_c.h	1563;"	d
CV_IS_GRAPH_EDGE_VISITED	core/core_c.h	1218;"	d
CV_IS_GRAPH_ORIENTED	core/types_c.h	1566;"	d
CV_IS_GRAPH_VERTEX_VISITED	core/core_c.h	1216;"	d
CV_IS_HAAR_CLASSIFIER	objdetect/objdetect.hpp	60;"	d
CV_IS_HIST	core/types_c.h	913;"	d
CV_IS_IMAGE	core/types_c.h	531;"	d
CV_IS_IMAGE_HDR	core/types_c.h	528;"	d
CV_IS_MASK_ARR	core/types_c.h	679;"	d
CV_IS_MAT	core/types_c.h	676;"	d
CV_IS_MATND	core/types_c.h	827;"	d
CV_IS_MATND_HDR	core/types_c.h	824;"	d
CV_IS_MAT_CONST	core/types_c.h	694;"	d
CV_IS_MAT_CONT	core/types_c.h	617;"	d
CV_IS_MAT_HDR	core/types_c.h	666;"	d
CV_IS_MAT_HDR_Z	core/types_c.h	671;"	d
CV_IS_ROW_SAMPLE	ml/ml.hpp	66;"	d
CV_IS_SEQ	core/types_c.h	1455;"	d
CV_IS_SEQ_CHAIN	core/types_c.h	1550;"	d
CV_IS_SEQ_CHAIN_CONTOUR	core/types_c.h	1556;"	d
CV_IS_SEQ_CLOSED	core/types_c.h	1532;"	d
CV_IS_SEQ_CONTOUR	core/types_c.h	1553;"	d
CV_IS_SEQ_CONVEX	core/types_c.h	1533;"	d
CV_IS_SEQ_CURVE	core/types_c.h	1531;"	d
CV_IS_SEQ_HOLE	core/types_c.h	1534;"	d
CV_IS_SEQ_INDEX	core/types_c.h	1528;"	d
CV_IS_SEQ_POINT_SET	core/types_c.h	1538;"	d
CV_IS_SEQ_POINT_SUBSET	core/types_c.h	1541;"	d
CV_IS_SEQ_POLYGON	core/types_c.h	1547;"	d
CV_IS_SEQ_POLYGON_TREE	core/types_c.h	1559;"	d
CV_IS_SEQ_POLYLINE	core/types_c.h	1544;"	d
CV_IS_SEQ_SIMPLE	core/types_c.h	1535;"	d
CV_IS_SET	core/types_c.h	1459;"	d
CV_IS_SET_ELEM	core/types_c.h	1357;"	d
CV_IS_SET_ELEM_EXISTS	legacy/compat.hpp	271;"	d
CV_IS_SPARSE_HIST	core/types_c.h	921;"	d
CV_IS_SPARSE_MAT	core/types_c.h	860;"	d
CV_IS_SPARSE_MAT_HDR	core/types_c.h	856;"	d
CV_IS_STORAGE	core/types_c.h	1265;"	d
CV_IS_SUBDIV2D	core/types_c.h	1569;"	d
CV_IS_SUBMAT	core/types_c.h	621;"	d
CV_IS_UNIFORM_HIST	core/types_c.h	918;"	d
CV_KMEANS_USE_INITIAL_LABELS	core/core_c.h	1471;"	d
CV_L1	core/core_c.h	840;"	d
CV_L2	core/core_c.h	841;"	d
CV_LAST_VORONOIEDGE2D	legacy/legacy.hpp	993;"	d
CV_LBGR2Lab	imgproc/types_c.h	/^    CV_LBGR2Lab     = 74,$/;"	e	enum:__anon33
CV_LBGR2Luv	imgproc/types_c.h	/^    CV_LBGR2Luv     = 76,$/;"	e	enum:__anon33
CV_LE	core/internal.hpp	360;"	d
CV_LEE_AUTO	legacy/legacy.hpp	/^    CV_LEE_AUTO = -1,$/;"	e	enum:CvLeeParameters
CV_LEE_DOUBLE	legacy/legacy.hpp	/^    CV_LEE_DOUBLE = 2,$/;"	e	enum:CvLeeParameters
CV_LEE_ERODE	legacy/legacy.hpp	/^    CV_LEE_ERODE = 0,$/;"	e	enum:CvLeeParameters
CV_LEE_FLOAT	legacy/legacy.hpp	/^    CV_LEE_FLOAT = 1,$/;"	e	enum:CvLeeParameters
CV_LEE_INT	legacy/legacy.hpp	/^    CV_LEE_INT = 0,$/;"	e	enum:CvLeeParameters
CV_LEE_NON	legacy/legacy.hpp	/^    CV_LEE_NON = 2$/;"	e	enum:CvLeeParameters
CV_LEE_ZOOM	legacy/legacy.hpp	/^    CV_LEE_ZOOM = 1,$/;"	e	enum:CvLeeParameters
CV_LINK_RUNS	imgproc/types_c.h	/^    CV_LINK_RUNS=5$/;"	e	enum:__anon40
CV_LKFLOW_GET_MIN_EIGENVALS	video/tracking.hpp	81;"	d
CV_LKFLOW_INITIAL_GUESSES	video/tracking.hpp	80;"	d
CV_LKFLOW_PYR_A_READY	video/tracking.hpp	78;"	d
CV_LKFLOW_PYR_B_READY	video/tracking.hpp	79;"	d
CV_LMEDS	calib3d/calib3d.hpp	82;"	d
CV_LOAD_IMAGE_ANYCOLOR	highgui/highgui_c.h	/^    CV_LOAD_IMAGE_ANYCOLOR   =4$/;"	e	enum:__anon168
CV_LOAD_IMAGE_ANYDEPTH	highgui/highgui_c.h	/^    CV_LOAD_IMAGE_ANYDEPTH   =2,$/;"	e	enum:__anon168
CV_LOAD_IMAGE_COLOR	highgui/highgui_c.h	/^    CV_LOAD_IMAGE_COLOR      =1,$/;"	e	enum:__anon168
CV_LOAD_IMAGE_GRAYSCALE	highgui/highgui_c.h	/^    CV_LOAD_IMAGE_GRAYSCALE  =0,$/;"	e	enum:__anon168
CV_LOAD_IMAGE_UNCHANGED	highgui/highgui_c.h	/^    CV_LOAD_IMAGE_UNCHANGED  =-1,$/;"	e	enum:__anon168
CV_LOG2	core/types_c.h	263;"	d
CV_LOG2PI	ml/ml.hpp	58;"	d
CV_LRGB2Lab	imgproc/types_c.h	/^    CV_LRGB2Lab     = 75,$/;"	e	enum:__anon33
CV_LRGB2Luv	imgproc/types_c.h	/^    CV_LRGB2Luv     = 77,$/;"	e	enum:__anon33
CV_LT	core/internal.hpp	359;"	d
CV_LU	core/core_c.h	737;"	d
CV_Lab2BGR	imgproc/types_c.h	/^    CV_Lab2BGR     =56,$/;"	e	enum:__anon33
CV_Lab2LBGR	imgproc/types_c.h	/^    CV_Lab2LBGR     = 78,$/;"	e	enum:__anon33
CV_Lab2LRGB	imgproc/types_c.h	/^    CV_Lab2LRGB     = 79,$/;"	e	enum:__anon33
CV_Lab2RGB	imgproc/types_c.h	/^    CV_Lab2RGB     =57,$/;"	e	enum:__anon33
CV_Luv2BGR	imgproc/types_c.h	/^    CV_Luv2BGR     =58,$/;"	e	enum:__anon33
CV_Luv2LBGR	imgproc/types_c.h	/^    CV_Luv2LBGR     = 80,$/;"	e	enum:__anon33
CV_Luv2LRGB	imgproc/types_c.h	/^    CV_Luv2LRGB     = 81,$/;"	e	enum:__anon33
CV_Luv2RGB	imgproc/types_c.h	/^    CV_Luv2RGB     =59,$/;"	e	enum:__anon33
CV_MAGIC_MASK	core/types_c.h	623;"	d
CV_MAJOR_VERSION	core/version.hpp	50;"	d
CV_MAKETYPE	core/types_c.h	563;"	d
CV_MAKE_STR	core/internal.hpp	383;"	d
CV_MAKE_TYPE	core/types_c.h	564;"	d
CV_MALLOC_ALIGN	core/internal.hpp	262;"	d
CV_MAT32F	legacy/compat.hpp	/^    CV_MAT32F      = CV_32FC1,$/;"	e	enum:__anon178
CV_MAT3x1_32F	legacy/compat.hpp	/^    CV_MAT3x1_32F  = CV_32FC1,$/;"	e	enum:__anon178
CV_MAT3x1_64D	legacy/compat.hpp	/^    CV_MAT3x1_64D  = CV_64FC1,$/;"	e	enum:__anon178
CV_MAT3x3_32F	legacy/compat.hpp	/^    CV_MAT3x3_32F  = CV_32FC1,$/;"	e	enum:__anon178
CV_MAT3x3_64D	legacy/compat.hpp	/^    CV_MAT3x3_64D  = CV_64FC1,$/;"	e	enum:__anon178
CV_MAT4x1_32F	legacy/compat.hpp	/^    CV_MAT4x1_32F  = CV_32FC1,$/;"	e	enum:__anon178
CV_MAT4x1_64D	legacy/compat.hpp	/^    CV_MAT4x1_64D  = CV_64FC1,$/;"	e	enum:__anon178
CV_MAT4x4_32F	legacy/compat.hpp	/^    CV_MAT4x4_32F  = CV_32FC1,$/;"	e	enum:__anon178
CV_MAT4x4_64D	legacy/compat.hpp	/^    CV_MAT4x4_64D  = CV_64FC1$/;"	e	enum:__anon178
CV_MAT64D	legacy/compat.hpp	/^    CV_MAT64D      = CV_64FC1,$/;"	e	enum:__anon178
CV_MATND_MAGIC_VAL	core/types_c.h	792;"	d
CV_MAT_CN	core/types_c.h	612;"	d
CV_MAT_CN_MASK	core/types_c.h	611;"	d
CV_MAT_CONT_FLAG	core/types_c.h	616;"	d
CV_MAT_CONT_FLAG_SHIFT	core/types_c.h	615;"	d
CV_MAT_DEPTH	core/types_c.h	561;"	d
CV_MAT_DEPTH_MASK	core/types_c.h	560;"	d
CV_MAT_ELEM	core/types_c.h	741;"	d
CV_MAT_ELEM_PTR	core/types_c.h	738;"	d
CV_MAT_ELEM_PTR_FAST	core/types_c.h	733;"	d
CV_MAT_MAGIC_VAL	core/types_c.h	624;"	d
CV_MAT_TYPE	core/types_c.h	614;"	d
CV_MAT_TYPE_MASK	core/types_c.h	613;"	d
CV_MAX_ALLOC_SIZE	core/internal.hpp	259;"	d
CV_MAX_ARR	core/core_c.h	267;"	d
CV_MAX_DIM	core/types_c.h	795;"	d
CV_MAX_DIM_HEAP	core/types_c.h	796;"	d
CV_MAX_INLINE_MAT_OP_SIZE	core/internal.hpp	242;"	d
CV_MAX_LOCAL_MAT_SIZE	core/internal.hpp	245;"	d
CV_MAX_LOCAL_SIZE	core/internal.hpp	248;"	d
CV_MAX_SOBEL_KSIZE	imgproc/types_c.h	/^    CV_MAX_SOBEL_KSIZE =7$/;"	e	enum:__anon32
CV_MAX_STRLEN	core/internal.hpp	280;"	d
CV_MEDIAN	imgproc/types_c.h	/^    CV_MEDIAN =3,$/;"	e	enum:__anon29
CV_MINMAX	core/core_c.h	845;"	d
CV_MINOR_VERSION	core/version.hpp	51;"	d
CV_MOP_BLACKHAT	imgproc/types_c.h	/^    CV_MOP_BLACKHAT     =6$/;"	e	enum:__anon37
CV_MOP_CLOSE	imgproc/types_c.h	/^    CV_MOP_CLOSE        =3,$/;"	e	enum:__anon37
CV_MOP_DILATE	imgproc/types_c.h	/^    CV_MOP_DILATE       =1,$/;"	e	enum:__anon37
CV_MOP_ERODE	imgproc/types_c.h	/^    CV_MOP_ERODE        =0,$/;"	e	enum:__anon37
CV_MOP_GRADIENT	imgproc/types_c.h	/^    CV_MOP_GRADIENT     =4,$/;"	e	enum:__anon37
CV_MOP_OPEN	imgproc/types_c.h	/^    CV_MOP_OPEN         =2,$/;"	e	enum:__anon37
CV_MOP_TOPHAT	imgproc/types_c.h	/^    CV_MOP_TOPHAT       =5,$/;"	e	enum:__anon37
CV_MOVE_DOWN	legacy/compat.hpp	418;"	d
CV_MOVE_DOWN_WRAP	legacy/compat.hpp	454;"	d
CV_MOVE_LD	legacy/compat.hpp	428;"	d
CV_MOVE_LD_WRAP	legacy/compat.hpp	463;"	d
CV_MOVE_LEFT	legacy/compat.hpp	406;"	d
CV_MOVE_LEFT_WRAP	legacy/compat.hpp	441;"	d
CV_MOVE_LU	legacy/compat.hpp	422;"	d
CV_MOVE_LU_WRAP	legacy/compat.hpp	459;"	d
CV_MOVE_PARAM	legacy/compat.hpp	485;"	d
CV_MOVE_PARAM_WRAP	legacy/compat.hpp	495;"	d
CV_MOVE_RD	legacy/compat.hpp	431;"	d
CV_MOVE_RD_WRAP	legacy/compat.hpp	465;"	d
CV_MOVE_RIGHT	legacy/compat.hpp	410;"	d
CV_MOVE_RIGHT_WRAP	legacy/compat.hpp	445;"	d
CV_MOVE_RU	legacy/compat.hpp	425;"	d
CV_MOVE_RU_WRAP	legacy/compat.hpp	461;"	d
CV_MOVE_TO	legacy/compat.hpp	391;"	d
CV_MOVE_UP	legacy/compat.hpp	414;"	d
CV_MOVE_UP_WRAP	legacy/compat.hpp	449;"	d
CV_MUL	core/internal.hpp	351;"	d
CV_MaskIsTiled	core/types_c.h	/^ CV_MaskIsTiled=               -26, \/**\/$/;"	e	enum:__anon150
CV_NE	core/internal.hpp	362;"	d
CV_NEG_INF	core/internal.hpp	342;"	d
CV_NEON	core/internal.hpp	124;"	d
CV_NEON	core/internal.hpp	130;"	d
CV_NEXT_AROUND_DST	imgproc/types_c.h	/^    CV_NEXT_AROUND_DST   = 0x22,$/;"	e	enum:CvNextEdgeType
CV_NEXT_AROUND_LEFT	imgproc/types_c.h	/^    CV_NEXT_AROUND_LEFT  = 0x13,$/;"	e	enum:CvNextEdgeType
CV_NEXT_AROUND_ORG	imgproc/types_c.h	/^    CV_NEXT_AROUND_ORG   = 0x00,$/;"	e	enum:CvNextEdgeType
CV_NEXT_AROUND_RIGHT	imgproc/types_c.h	/^    CV_NEXT_AROUND_RIGHT = 0x31,$/;"	e	enum:CvNextEdgeType
CV_NEXT_GRAPH_EDGE	core/types_c.h	1711;"	d
CV_NEXT_LINE_POINT	core/core_c.h	1348;"	d
CV_NEXT_SEQ_ELEM	core/types_c.h	1647;"	d
CV_NEXT_VORONOIEDGE2D	legacy/legacy.hpp	994;"	d
CV_NEXT_VORONOISITE2D	legacy/legacy.hpp	990;"	d
CV_NODE_EMPTY	core/types_c.h	1768;"	d
CV_NODE_FLOAT	core/types_c.h	1755;"	d
CV_NODE_FLOW	core/types_c.h	1766;"	d
CV_NODE_HAS_NAME	core/types_c.h	1780;"	d
CV_NODE_IDX	core/types_c.h	881;"	d
CV_NODE_INT	core/types_c.h	1752;"	d
CV_NODE_INTEGER	core/types_c.h	1753;"	d
CV_NODE_IS_COLLECTION	core/types_c.h	1776;"	d
CV_NODE_IS_EMPTY	core/types_c.h	1778;"	d
CV_NODE_IS_FLOW	core/types_c.h	1777;"	d
CV_NODE_IS_INT	core/types_c.h	1771;"	d
CV_NODE_IS_MAP	core/types_c.h	1775;"	d
CV_NODE_IS_REAL	core/types_c.h	1772;"	d
CV_NODE_IS_SEQ	core/types_c.h	1774;"	d
CV_NODE_IS_STRING	core/types_c.h	1773;"	d
CV_NODE_IS_USER	core/types_c.h	1779;"	d
CV_NODE_MAP	core/types_c.h	1760;"	d
CV_NODE_NAMED	core/types_c.h	1769;"	d
CV_NODE_NONE	core/types_c.h	1751;"	d
CV_NODE_REAL	core/types_c.h	1754;"	d
CV_NODE_REF	core/types_c.h	1758;"	d
CV_NODE_SEQ	core/types_c.h	1759;"	d
CV_NODE_SEQ_IS_SIMPLE	core/types_c.h	1783;"	d
CV_NODE_SEQ_SIMPLE	core/types_c.h	1782;"	d
CV_NODE_STR	core/types_c.h	1756;"	d
CV_NODE_STRING	core/types_c.h	1757;"	d
CV_NODE_TYPE	core/types_c.h	1763;"	d
CV_NODE_TYPE_MASK	core/types_c.h	1761;"	d
CV_NODE_USER	core/types_c.h	1767;"	d
CV_NODE_VAL	core/types_c.h	880;"	d
CV_NOISE_GAUSSIAN	legacy/blobtrack.hpp	887;"	d
CV_NOISE_NONE	legacy/blobtrack.hpp	886;"	d
CV_NOISE_SALT_AND_PEPPER	legacy/blobtrack.hpp	890;"	d
CV_NOISE_SPECKLE	legacy/blobtrack.hpp	889;"	d
CV_NOISE_UNIFORM	legacy/blobtrack.hpp	888;"	d
CV_NONZERO	core/internal.hpp	366;"	d
CV_NONZERO_FLT	core/internal.hpp	367;"	d
CV_NOP	core/internal.hpp	348;"	d
CV_NORMAL	core/core_c.h	742;"	d
CV_NORM_MASK	core/core_c.h	842;"	d
CV_NOTDEFINED_ERR	core/internal.hpp	/^    CV_NOTDEFINED_ERR  = -48,  \/\/ipp comp$/;"	e	enum:CvStatus
CV_NOTFOUND_ERR	core/internal.hpp	/^    CV_NOTFOUND_ERR             = -110,$/;"	e	enum:CvStatus
CV_NOTHROW	core/internal.hpp	687;"	d
CV_NOT_WEIGHTED	legacy/legacy.hpp	/^    CV_NOT_WEIGHTED,$/;"	e	enum:CvGraphWeightType
CV_NO_CN_CHECK	core/core_c.h	282;"	d
CV_NO_DEPTH_CHECK	core/core_c.h	281;"	d
CV_NO_ERR	core/internal.hpp	/^    CV_NO_ERR          =   0,$/;"	e	enum:CvStatus
CV_NO_SIZE_CHECK	core/core_c.h	283;"	d
CV_NULLPTR_ERR	core/internal.hpp	/^    CV_NULLPTR_ERR     =  -2,$/;"	e	enum:CvStatus
CV_NUM_FACE_ELEMENTS	legacy/legacy.hpp	879;"	d
CV_OK	core/internal.hpp	/^    CV_OK              =   CV_NO_ERR$/;"	e	enum:CvStatus
CV_OR	core/internal.hpp	353;"	d
CV_ORIENTED_GRAPH	core/types_c.h	1501;"	d
CV_ORIGIN_BL	core/internal.hpp	338;"	d
CV_ORIGIN_TL	core/internal.hpp	337;"	d
CV_ORN	core/internal.hpp	356;"	d
CV_OUT	core/types_c.h	172;"	d
CV_OUTOFMEM_ERR	core/internal.hpp	/^    CV_OUTOFMEM_ERR    =  -3,$/;"	e	enum:CvStatus
CV_PARAM_TYPE_INT	core/types_c.h	/^enum { CV_PARAM_TYPE_INT=0, CV_PARAM_TYPE_REAL=1, CV_PARAM_TYPE_STRING=2, CV_PARAM_TYPE_MAT=3 };$/;"	e	enum:__anon158
CV_PARAM_TYPE_MAT	core/types_c.h	/^enum { CV_PARAM_TYPE_INT=0, CV_PARAM_TYPE_REAL=1, CV_PARAM_TYPE_STRING=2, CV_PARAM_TYPE_MAT=3 };$/;"	e	enum:__anon158
CV_PARAM_TYPE_REAL	core/types_c.h	/^enum { CV_PARAM_TYPE_INT=0, CV_PARAM_TYPE_REAL=1, CV_PARAM_TYPE_STRING=2, CV_PARAM_TYPE_MAT=3 };$/;"	e	enum:__anon158
CV_PARAM_TYPE_STRING	core/types_c.h	/^enum { CV_PARAM_TYPE_INT=0, CV_PARAM_TYPE_REAL=1, CV_PARAM_TYPE_STRING=2, CV_PARAM_TYPE_MAT=3 };$/;"	e	enum:__anon158
CV_PASTE	core/internal.hpp	380;"	d
CV_PASTE2	core/internal.hpp	379;"	d
CV_PCA_DATA_AS_COL	core/core_c.h	800;"	d
CV_PCA_DATA_AS_ROW	core/core_c.h	799;"	d
CV_PCA_USE_AVG	core/core_c.h	801;"	d
CV_PI	core/types_c.h	262;"	d
CV_POLY_APPROX_DP	imgproc/types_c.h	/^    CV_POLY_APPROX_DP = 0$/;"	e	enum:__anon41
CV_PORTION	ml/ml.hpp	2027;"	d
CV_POS_INF	core/internal.hpp	341;"	d
CV_PREV_AROUND_DST	imgproc/types_c.h	/^    CV_PREV_AROUND_DST   = 0x33,$/;"	e	enum:CvNextEdgeType
CV_PREV_AROUND_LEFT	imgproc/types_c.h	/^    CV_PREV_AROUND_LEFT  = 0x20,$/;"	e	enum:CvNextEdgeType
CV_PREV_AROUND_ORG	imgproc/types_c.h	/^    CV_PREV_AROUND_ORG   = 0x11,$/;"	e	enum:CvNextEdgeType
CV_PREV_AROUND_RIGHT	imgproc/types_c.h	/^    CV_PREV_AROUND_RIGHT = 0x02$/;"	e	enum:CvNextEdgeType
CV_PREV_INT	legacy/legacy.hpp	281;"	d
CV_PREV_POINT	core/types_c.h	1695;"	d
CV_PREV_SEQ_ELEM	core/types_c.h	1657;"	d
CV_PREV_VORONOIEDGE2D	legacy/legacy.hpp	995;"	d
CV_PREV_VORONOISITE2D	legacy/legacy.hpp	991;"	d
CV_PROP	core/types_c.h	173;"	d
CV_PROP_RW	core/types_c.h	174;"	d
CV_PTLOC_ERROR	imgproc/types_c.h	/^    CV_PTLOC_ERROR = -2,$/;"	e	enum:CvSubdiv2DPointLocation
CV_PTLOC_INSIDE	imgproc/types_c.h	/^    CV_PTLOC_INSIDE = 0,$/;"	e	enum:CvSubdiv2DPointLocation
CV_PTLOC_ON_EDGE	imgproc/types_c.h	/^    CV_PTLOC_ON_EDGE = 2$/;"	e	enum:CvSubdiv2DPointLocation
CV_PTLOC_OUTSIDE_RECT	imgproc/types_c.h	/^    CV_PTLOC_OUTSIDE_RECT = -1,$/;"	e	enum:CvSubdiv2DPointLocation
CV_PTLOC_VERTEX	imgproc/types_c.h	/^    CV_PTLOC_VERTEX = 1,$/;"	e	enum:CvSubdiv2DPointLocation
CV_PUSH_BUTTON	highgui/highgui_c.h	/^enum {CV_PUSH_BUTTON = 0, CV_CHECKBOX = 1, CV_RADIOBOX = 2};$/;"	e	enum:__anon164
CV_QR	core/core_c.h	741;"	d
CV_QUADEDGE2D_FIELDS	imgproc/types_c.h	355;"	d
CV_RADIOBOX	highgui/highgui_c.h	/^enum {CV_PUSH_BUTTON = 0, CV_CHECKBOX = 1, CV_RADIOBOX = 2};$/;"	e	enum:__anon164
CV_RAND_NORMAL	core/core_c.h	648;"	d
CV_RAND_UNI	core/core_c.h	647;"	d
CV_RANSAC	calib3d/calib3d.hpp	83;"	d
CV_READ_CHAIN_POINT	core/types_c.h	1682;"	d
CV_READ_EDGE	core/types_c.h	1697;"	d
CV_READ_SEQ_ELEM	core/types_c.h	1666;"	d
CV_REDUCE_AVG	core/core_c.h	866;"	d
CV_REDUCE_MAX	core/core_c.h	867;"	d
CV_REDUCE_MIN	core/core_c.h	868;"	d
CV_REDUCE_SUM	core/core_c.h	865;"	d
CV_RELATIVE	core/core_c.h	843;"	d
CV_RELATIVE_C	core/core_c.h	850;"	d
CV_RELATIVE_L1	core/core_c.h	851;"	d
CV_RELATIVE_L2	core/core_c.h	852;"	d
CV_RETR_CCOMP	imgproc/types_c.h	/^    CV_RETR_CCOMP=2,$/;"	e	enum:__anon39
CV_RETR_EXTERNAL	imgproc/types_c.h	/^    CV_RETR_EXTERNAL=0,$/;"	e	enum:__anon39
CV_RETR_LIST	imgproc/types_c.h	/^    CV_RETR_LIST=1,$/;"	e	enum:__anon39
CV_RETR_TREE	imgproc/types_c.h	/^    CV_RETR_TREE=3$/;"	e	enum:__anon39
CV_REV_READ_SEQ_ELEM	core/types_c.h	1674;"	d
CV_RGB	core/core_c.h	1264;"	d
CV_RGB2BGR	imgproc/types_c.h	/^    CV_RGB2BGR     =CV_BGR2RGB,$/;"	e	enum:__anon33
CV_RGB2BGR555	imgproc/types_c.h	/^    CV_RGB2BGR555  =23,$/;"	e	enum:__anon33
CV_RGB2BGR565	imgproc/types_c.h	/^    CV_RGB2BGR565  =13,$/;"	e	enum:__anon33
CV_RGB2BGRA	imgproc/types_c.h	/^    CV_RGB2BGRA    =CV_BGR2RGBA,$/;"	e	enum:__anon33
CV_RGB2GRAY	imgproc/types_c.h	/^    CV_RGB2GRAY    =7,$/;"	e	enum:__anon33
CV_RGB2HLS	imgproc/types_c.h	/^    CV_RGB2HLS     =53,$/;"	e	enum:__anon33
CV_RGB2HLS_FULL	imgproc/types_c.h	/^    CV_RGB2HLS_FULL = 69,$/;"	e	enum:__anon33
CV_RGB2HSV	imgproc/types_c.h	/^    CV_RGB2HSV     =41,$/;"	e	enum:__anon33
CV_RGB2HSV_FULL	imgproc/types_c.h	/^    CV_RGB2HSV_FULL = 67,$/;"	e	enum:__anon33
CV_RGB2Lab	imgproc/types_c.h	/^    CV_RGB2Lab     =45,$/;"	e	enum:__anon33
CV_RGB2Luv	imgproc/types_c.h	/^    CV_RGB2Luv     =51,$/;"	e	enum:__anon33
CV_RGB2RGBA	imgproc/types_c.h	/^    CV_RGB2RGBA    =CV_BGR2BGRA,$/;"	e	enum:__anon33
CV_RGB2XYZ	imgproc/types_c.h	/^    CV_RGB2XYZ     =33,$/;"	e	enum:__anon33
CV_RGB2YCrCb	imgproc/types_c.h	/^    CV_RGB2YCrCb   =37,$/;"	e	enum:__anon33
CV_RGB2YUV	imgproc/types_c.h	/^    CV_RGB2YUV      = 83,$/;"	e	enum:__anon33
CV_RGBA2BGR	imgproc/types_c.h	/^    CV_RGBA2BGR    =3,$/;"	e	enum:__anon33
CV_RGBA2BGR555	imgproc/types_c.h	/^    CV_RGBA2BGR555 =27,$/;"	e	enum:__anon33
CV_RGBA2BGR565	imgproc/types_c.h	/^    CV_RGBA2BGR565 =17,$/;"	e	enum:__anon33
CV_RGBA2BGRA	imgproc/types_c.h	/^    CV_RGBA2BGRA   =CV_BGRA2RGBA,$/;"	e	enum:__anon33
CV_RGBA2GRAY	imgproc/types_c.h	/^    CV_RGBA2GRAY   =11,$/;"	e	enum:__anon33
CV_RGBA2RGB	imgproc/types_c.h	/^    CV_RGBA2RGB    =CV_BGRA2BGR,$/;"	e	enum:__anon33
CV_RNG_COEFF	core/types_c.h	383;"	d
CV_RODRIGUES_M2V	legacy/compat.hpp	/^    CV_RODRIGUES_M2V = 0,$/;"	e	enum:__anon181
CV_RODRIGUES_V2M	legacy/compat.hpp	/^    CV_RODRIGUES_V2M = 1$/;"	e	enum:__anon181
CV_ROW_SAMPLE	ml/ml.hpp	64;"	d
CV_SCHARR	imgproc/types_c.h	/^    CV_SCHARR =-1,$/;"	e	enum:__anon32
CV_SEQUENCE_FIELDS	core/types_c.h	1304;"	d
CV_SEQ_CHAIN	core/types_c.h	1512;"	d
CV_SEQ_CHAIN_CONTOUR	core/types_c.h	1513;"	d
CV_SEQ_CONNECTED_COMP	core/types_c.h	1519;"	d
CV_SEQ_CONTOUR	core/types_c.h	1508;"	d
CV_SEQ_ELEM	core/types_c.h	1612;"	d
CV_SEQ_ELTYPE	core/types_c.h	1524;"	d
CV_SEQ_ELTYPE_BITS	core/types_c.h	1462;"	d
CV_SEQ_ELTYPE_CODE	core/types_c.h	1466;"	d
CV_SEQ_ELTYPE_CONNECTED_COMP	core/types_c.h	1474;"	d
CV_SEQ_ELTYPE_GENERIC	core/types_c.h	1467;"	d
CV_SEQ_ELTYPE_GRAPH_EDGE	core/types_c.h	1471;"	d
CV_SEQ_ELTYPE_GRAPH_VERTEX	core/types_c.h	1472;"	d
CV_SEQ_ELTYPE_INDEX	core/types_c.h	1470;"	d
CV_SEQ_ELTYPE_MASK	core/types_c.h	1463;"	d
CV_SEQ_ELTYPE_POINT	core/types_c.h	1465;"	d
CV_SEQ_ELTYPE_POINT3D	core/types_c.h	1475;"	d
CV_SEQ_ELTYPE_PPOINT	core/types_c.h	1469;"	d
CV_SEQ_ELTYPE_PTR	core/types_c.h	1468;"	d
CV_SEQ_ELTYPE_TRIAN_ATR	core/types_c.h	1473;"	d
CV_SEQ_FLAG_CLOSED	core/types_c.h	1492;"	d
CV_SEQ_FLAG_CONVEX	core/types_c.h	1494;"	d
CV_SEQ_FLAG_HOLE	core/types_c.h	1495;"	d
CV_SEQ_FLAG_SHIFT	core/types_c.h	1489;"	d
CV_SEQ_FLAG_SIMPLE	core/types_c.h	1493;"	d
CV_SEQ_INDEX	core/types_c.h	1522;"	d
CV_SEQ_KIND	core/types_c.h	1525;"	d
CV_SEQ_KIND_BIN_TREE	core/types_c.h	1483;"	d
CV_SEQ_KIND_BITS	core/types_c.h	1477;"	d
CV_SEQ_KIND_CURVE	core/types_c.h	1482;"	d
CV_SEQ_KIND_GENERIC	core/types_c.h	1481;"	d
CV_SEQ_KIND_GRAPH	core/types_c.h	1486;"	d
CV_SEQ_KIND_MASK	core/types_c.h	1478;"	d
CV_SEQ_KIND_SUBDIV2D	core/types_c.h	1487;"	d
CV_SEQ_MAGIC_VAL	core/types_c.h	1453;"	d
CV_SEQ_POINT3D_SET	core/types_c.h	1505;"	d
CV_SEQ_POINT_SET	core/types_c.h	1504;"	d
CV_SEQ_POLYGON	core/types_c.h	1507;"	d
CV_SEQ_POLYGON_TREE	core/types_c.h	1516;"	d
CV_SEQ_POLYLINE	core/types_c.h	1506;"	d
CV_SEQ_READER_FIELDS	core/types_c.h	1591;"	d
CV_SEQ_SIMPLE_POLYGON	core/types_c.h	1509;"	d
CV_SEQ_WRITER_FIELDS	core/types_c.h	1576;"	d
CV_SET_ELEM_FIELDS	core/types_c.h	1331;"	d
CV_SET_ELEM_FREE_FLAG	core/types_c.h	1354;"	d
CV_SET_ELEM_IDX_MASK	core/types_c.h	1353;"	d
CV_SET_FIELDS	core/types_c.h	1341;"	d
CV_SET_MAGIC_VAL	core/types_c.h	1458;"	d
CV_SHAPE_CROSS	imgproc/types_c.h	/^    CV_SHAPE_CROSS     =1,$/;"	e	enum:__anon36
CV_SHAPE_CUSTOM	imgproc/types_c.h	/^    CV_SHAPE_CUSTOM    =100$/;"	e	enum:__anon36
CV_SHAPE_ELLIPSE	imgproc/types_c.h	/^    CV_SHAPE_ELLIPSE   =2,$/;"	e	enum:__anon36
CV_SHAPE_RECT	imgproc/types_c.h	/^    CV_SHAPE_RECT      =0,$/;"	e	enum:__anon36
CV_SHIFT_DOWN	legacy/compat.hpp	/^    CV_SHIFT_DOWN = 10,$/;"	e	enum:__anon180
CV_SHIFT_LD	legacy/compat.hpp	/^    CV_SHIFT_LD = 9,$/;"	e	enum:__anon180
CV_SHIFT_LEFT	legacy/compat.hpp	/^    CV_SHIFT_LEFT = 1,$/;"	e	enum:__anon180
CV_SHIFT_LU	legacy/compat.hpp	/^    CV_SHIFT_LU = 5,$/;"	e	enum:__anon180
CV_SHIFT_NONE	legacy/compat.hpp	/^    CV_SHIFT_NONE = 2,$/;"	e	enum:__anon180
CV_SHIFT_RD	legacy/compat.hpp	/^    CV_SHIFT_RD = 11$/;"	e	enum:__anon180
CV_SHIFT_RIGHT	legacy/compat.hpp	/^    CV_SHIFT_RIGHT = 3,$/;"	e	enum:__anon180
CV_SHIFT_RU	legacy/compat.hpp	/^    CV_SHIFT_RU = 7,$/;"	e	enum:__anon180
CV_SHIFT_UP	legacy/compat.hpp	/^    CV_SHIFT_UP = 6,$/;"	e	enum:__anon180
CV_SIGN	core/types_c.h	287;"	d
CV_SIZEOF_FLOAT	core/internal.hpp	334;"	d
CV_SIZEOF_SHORT	core/internal.hpp	335;"	d
CV_SORT_ASCENDING	core/core_c.h	657;"	d
CV_SORT_DESCENDING	core/core_c.h	658;"	d
CV_SORT_EVERY_COLUMN	core/core_c.h	656;"	d
CV_SORT_EVERY_ROW	core/core_c.h	655;"	d
CV_SPARSE_HASH_RATIO	core/internal.hpp	277;"	d
CV_SPARSE_HASH_SIZE0	core/internal.hpp	274;"	d
CV_SPARSE_MAT_BLOCK	core/internal.hpp	271;"	d
CV_SPARSE_MAT_MAGIC_VAL	core/types_c.h	835;"	d
CV_SQR	core/internal.hpp	357;"	d
CV_SSE	core/internal.hpp	110;"	d
CV_SSE	core/internal.hpp	117;"	d
CV_SSE2	core/internal.hpp	111;"	d
CV_SSE2	core/internal.hpp	118;"	d
CV_SSE3	core/internal.hpp	114;"	d
CV_SSE3	core/internal.hpp	119;"	d
CV_STDCALL	core/types_c.h	101;"	d
CV_STDCALL	core/types_c.h	104;"	d
CV_STEREO_BM_BASIC	calib3d/calib3d.hpp	336;"	d
CV_STEREO_BM_FISH_EYE	calib3d/calib3d.hpp	337;"	d
CV_STEREO_BM_NARROW	calib3d/calib3d.hpp	338;"	d
CV_STEREO_BM_NORMALIZED_RESPONSE	calib3d/calib3d.hpp	298;"	d
CV_STEREO_BM_XSOBEL	calib3d/calib3d.hpp	299;"	d
CV_STEREO_GC_OCCLUDED	calib3d/calib3d.hpp	356;"	d
CV_STORAGE_APPEND	core/types_c.h	1729;"	d
CV_STORAGE_BLOCK_SIZE	core/internal.hpp	268;"	d
CV_STORAGE_MAGIC_VAL	core/types_c.h	1252;"	d
CV_STORAGE_READ	core/types_c.h	1725;"	d
CV_STORAGE_WRITE	core/types_c.h	1726;"	d
CV_STORAGE_WRITE_BINARY	core/types_c.h	1728;"	d
CV_STORAGE_WRITE_TEXT	core/types_c.h	1727;"	d
CV_STRUCT_ALIGN	core/internal.hpp	265;"	d
CV_STUB_STEP	core/internal.hpp	332;"	d
CV_STYLE_ITALIC	highgui/highgui_c.h	/^        CV_STYLE_ITALIC         = 1,\/\/QFont::StyleItalic,$/;"	e	enum:__anon163
CV_STYLE_NORMAL	highgui/highgui_c.h	/^enum {  CV_STYLE_NORMAL         = 0,\/\/QFont::StyleNormal,$/;"	e	enum:__anon163
CV_STYLE_OBLIQUE	highgui/highgui_c.h	/^        CV_STYLE_OBLIQUE        = 2 \/\/QFont::StyleOblique$/;"	e	enum:__anon163
CV_SUB	core/internal.hpp	350;"	d
CV_SUBDIV2D_FIELDS	imgproc/types_c.h	380;"	d
CV_SUBDIV2D_NEXT_EDGE	imgproc/types_c.h	419;"	d
CV_SUBDIV2D_POINT_FIELDS	imgproc/types_c.h	360;"	d
CV_SUBDIV2D_VIRTUAL_POINT_FLAG	imgproc/types_c.h	366;"	d
CV_SUBMAT_FLAG	core/types_c.h	620;"	d
CV_SUBMAT_FLAG_SHIFT	core/types_c.h	619;"	d
CV_SUBMINOR_VERSION	core/version.hpp	52;"	d
CV_SVD	core/core_c.h	738;"	d
CV_SVD_MODIFY_A	core/core_c.h	723;"	d
CV_SVD_SYM	core/core_c.h	739;"	d
CV_SVD_U_T	core/core_c.h	724;"	d
CV_SVD_V_T	core/core_c.h	725;"	d
CV_SWAP	core/types_c.h	265;"	d
CV_StsAssert	core/types_c.h	/^ CV_StsAssert=                 -215, \/* assertion failed *\/    $/;"	e	enum:__anon150
CV_StsAutoTrace	core/types_c.h	/^ CV_StsAutoTrace=               -8,  \/* tracing                         *\/$/;"	e	enum:__anon150
CV_StsBackTrace	core/types_c.h	/^ CV_StsBackTrace=               -1,  \/* pseudo error for back trace     *\/$/;"	e	enum:__anon150
CV_StsBadArg	core/types_c.h	/^ CV_StsBadArg=                  -5,  \/* function arg\/param is bad       *\/$/;"	e	enum:__anon150
CV_StsBadFlag	core/types_c.h	/^ CV_StsBadFlag=                -206, \/* flag is wrong or not supported *\/  $/;"	e	enum:__anon150
CV_StsBadFunc	core/types_c.h	/^ CV_StsBadFunc=                 -6,  \/* unsupported function            *\/$/;"	e	enum:__anon150
CV_StsBadMask	core/types_c.h	/^ CV_StsBadMask=                -208, \/* bad format of mask (neither 8uC1 nor 8sC1)*\/$/;"	e	enum:__anon150
CV_StsBadMemBlock	core/types_c.h	/^ CV_StsBadMemBlock=            -214, \/* an allocated block has been corrupted *\/$/;"	e	enum:__anon150
CV_StsBadPoint	core/types_c.h	/^ CV_StsBadPoint=               -207, \/* bad CvPoint *\/ $/;"	e	enum:__anon150
CV_StsBadSize	core/types_c.h	/^ CV_StsBadSize=                -201, \/* the input\/output structure size is incorrect  *\/$/;"	e	enum:__anon150
CV_StsDivByZero	core/types_c.h	/^ CV_StsDivByZero=              -202, \/* division by zero *\/$/;"	e	enum:__anon150
CV_StsError	core/types_c.h	/^ CV_StsError=                   -2,  \/* unknown \/unspecified error      *\/$/;"	e	enum:__anon150
CV_StsFilterOffsetErr	core/types_c.h	/^ CV_StsFilterOffsetErr=        -31, \/* incorrect filter ofset value *\/$/;"	e	enum:__anon150
CV_StsFilterStructContentErr	core/types_c.h	/^ CV_StsFilterStructContentErr= -29, \/* incorr. filter structure content *\/$/;"	e	enum:__anon150
CV_StsInplaceNotSupported	core/types_c.h	/^ CV_StsInplaceNotSupported=    -203, \/* in-place operation is not supported *\/$/;"	e	enum:__anon150
CV_StsInternal	core/types_c.h	/^ CV_StsInternal=                -3,  \/* internal error (bad state)      *\/$/;"	e	enum:__anon150
CV_StsKernelStructContentErr	core/types_c.h	/^ CV_StsKernelStructContentErr= -30, \/* incorr. transform kernel content *\/$/;"	e	enum:__anon150
CV_StsNoConv	core/types_c.h	/^ CV_StsNoConv=                  -7,  \/* iter. didn't converge           *\/$/;"	e	enum:__anon150
CV_StsNoMem	core/types_c.h	/^ CV_StsNoMem=                   -4,  \/* insufficient memory             *\/$/;"	e	enum:__anon150
CV_StsNotImplemented	core/types_c.h	/^ CV_StsNotImplemented=         -213, \/* the requested function\/feature is not implemented *\/$/;"	e	enum:__anon150
CV_StsNullPtr	core/types_c.h	/^ CV_StsNullPtr=                -27, \/* null pointer *\/$/;"	e	enum:__anon150
CV_StsObjectNotFound	core/types_c.h	/^ CV_StsObjectNotFound=         -204, \/* request can't be completed *\/$/;"	e	enum:__anon150
CV_StsOk	core/types_c.h	/^ CV_StsOk=                       0,  \/* everithing is ok                *\/$/;"	e	enum:__anon150
CV_StsOutOfRange	core/types_c.h	/^ CV_StsOutOfRange=             -211, \/* some of parameters are out of range *\/$/;"	e	enum:__anon150
CV_StsParseError	core/types_c.h	/^ CV_StsParseError=             -212, \/* invalid syntax\/structure of the parsed file *\/$/;"	e	enum:__anon150
CV_StsUnmatchedFormats	core/types_c.h	/^ CV_StsUnmatchedFormats=       -205, \/* formats of input\/output arrays differ *\/$/;"	e	enum:__anon150
CV_StsUnmatchedSizes	core/types_c.h	/^ CV_StsUnmatchedSizes=         -209, \/* sizes of input\/output structures do not match *\/$/;"	e	enum:__anon150
CV_StsUnsupportedFormat	core/types_c.h	/^ CV_StsUnsupportedFormat=      -210, \/* the data format\/type is not supported by the function*\/$/;"	e	enum:__anon150
CV_StsVecLengthErr	core/types_c.h	/^ CV_StsVecLengthErr=           -28, \/* incorrect vector length *\/$/;"	e	enum:__anon150
CV_TERMCRIT_EPS	core/types_c.h	977;"	d
CV_TERMCRIT_ITER	core/types_c.h	975;"	d
CV_TERMCRIT_NUMBER	core/types_c.h	976;"	d
CV_TEST_ERROR	ml/ml.hpp	127;"	d
CV_THRESH_BINARY	imgproc/types_c.h	/^    CV_THRESH_BINARY      =0,  \/* value = value > threshold ? max_value : 0       *\/$/;"	e	enum:__anon47
CV_THRESH_BINARY_INV	imgproc/types_c.h	/^    CV_THRESH_BINARY_INV  =1,  \/* value = value > threshold ? 0 : max_value       *\/$/;"	e	enum:__anon47
CV_THRESH_MASK	imgproc/types_c.h	/^    CV_THRESH_MASK        =7,$/;"	e	enum:__anon47
CV_THRESH_OTSU	imgproc/types_c.h	/^    CV_THRESH_OTSU        =8  \/* use Otsu algorithm to choose the optimal threshold value;$/;"	e	enum:__anon47
CV_THRESH_TOZERO	imgproc/types_c.h	/^    CV_THRESH_TOZERO      =3,  \/* value = value > threshold ? value : 0           *\/$/;"	e	enum:__anon47
CV_THRESH_TOZERO_INV	imgproc/types_c.h	/^    CV_THRESH_TOZERO_INV  =4,  \/* value = value > threshold ? 0 : value           *\/$/;"	e	enum:__anon47
CV_THRESH_TRUNC	imgproc/types_c.h	/^    CV_THRESH_TRUNC       =2,  \/* value = value > threshold ? threshold : value   *\/$/;"	e	enum:__anon47
CV_TM_CCOEFF	imgproc/types_c.h	/^    CV_TM_CCOEFF        =4,$/;"	e	enum:__anon38
CV_TM_CCOEFF_NORMED	imgproc/types_c.h	/^    CV_TM_CCOEFF_NORMED =5$/;"	e	enum:__anon38
CV_TM_CCORR	imgproc/types_c.h	/^    CV_TM_CCORR         =2,$/;"	e	enum:__anon38
CV_TM_CCORR_NORMED	imgproc/types_c.h	/^    CV_TM_CCORR_NORMED  =3,$/;"	e	enum:__anon38
CV_TM_SQDIFF	imgproc/types_c.h	/^    CV_TM_SQDIFF        =0,$/;"	e	enum:__anon38
CV_TM_SQDIFF_NORMED	imgproc/types_c.h	/^    CV_TM_SQDIFF_NORMED =1,$/;"	e	enum:__anon38
CV_TOGGLE_DBL	core/internal.hpp	345;"	d
CV_TOGGLE_FLT	core/internal.hpp	344;"	d
CV_TRAIN_ERROR	ml/ml.hpp	126;"	d
CV_TREE_NODE_FIELDS	core/types_c.h	1292;"	d
CV_TS_CONCENTRIC_SPHERES	ml/ml.hpp	2006;"	d
CV_TURN_ON_IPL_COMPATIBILITY	core/core_c.h	1517;"	d
CV_TWIN_VORONOISITE2D	legacy/legacy.hpp	998;"	d
CV_TYPE_NAME_GRAPH	core/types_c.h	1424;"	d
CV_TYPE_NAME_HAAR	objdetect/objdetect.hpp	58;"	d
CV_TYPE_NAME_IMAGE	core/types_c.h	526;"	d
CV_TYPE_NAME_MAT	core/types_c.h	625;"	d
CV_TYPE_NAME_MATND	core/types_c.h	793;"	d
CV_TYPE_NAME_ML_ANN_MLP	ml/ml.hpp	121;"	d
CV_TYPE_NAME_ML_BOOSTING	ml/ml.hpp	119;"	d
CV_TYPE_NAME_ML_CNN	ml/ml.hpp	122;"	d
CV_TYPE_NAME_ML_EM	ml/ml.hpp	118;"	d
CV_TYPE_NAME_ML_GBT	ml/ml.hpp	124;"	d
CV_TYPE_NAME_ML_KNN	ml/ml.hpp	116;"	d
CV_TYPE_NAME_ML_NBAYES	ml/ml.hpp	117;"	d
CV_TYPE_NAME_ML_RTREES	ml/ml.hpp	123;"	d
CV_TYPE_NAME_ML_SVM	ml/ml.hpp	115;"	d
CV_TYPE_NAME_ML_TREE	ml/ml.hpp	120;"	d
CV_TYPE_NAME_SEQ	core/types_c.h	1321;"	d
CV_TYPE_NAME_SEQ_TREE	core/types_c.h	1322;"	d
CV_TYPE_NAME_SPARSE_MAT	core/types_c.h	836;"	d
CV_TYZX_COLOR	highgui/highgui_c.h	/^    CV_TYZX_COLOR   =402,$/;"	e	enum:__anon171
CV_TYZX_LEFT	highgui/highgui_c.h	/^    CV_TYZX_LEFT    =400,$/;"	e	enum:__anon171
CV_TYZX_RIGHT	highgui/highgui_c.h	/^    CV_TYZX_RIGHT   =401,$/;"	e	enum:__anon171
CV_TYZX_Z	highgui/highgui_c.h	/^    CV_TYZX_Z       =403,$/;"	e	enum:__anon171
CV_UNDEF_SC_PARAM	legacy/legacy.hpp	459;"	d
CV_UNMATCHED_FORMATS_ERR	core/internal.hpp	/^    CV_UNMATCHED_FORMATS_ERR    = -104,$/;"	e	enum:CvStatus
CV_UNMATCHED_ROI_ERR	core/internal.hpp	/^    CV_UNMATCHED_ROI_ERR        = -111,$/;"	e	enum:CvStatus
CV_UNSUPPORTED_CHANNELS_ERR	core/internal.hpp	/^    CV_UNSUPPORTED_CHANNELS_ERR = -102,$/;"	e	enum:CvStatus
CV_UNSUPPORTED_COI_ERR	core/internal.hpp	/^    CV_UNSUPPORTED_COI_ERR      = -103,$/;"	e	enum:CvStatus
CV_UNSUPPORTED_DEPTH_ERR	core/internal.hpp	/^    CV_UNSUPPORTED_DEPTH_ERR    = -101,$/;"	e	enum:CvStatus
CV_UNSUPPORTED_FORMAT_ERR	core/internal.hpp	/^    CV_UNSUPPORTED_FORMAT_ERR   = -100,$/;"	e	enum:CvStatus
CV_USRTYPE1	core/types_c.h	558;"	d
CV_VALUE	legacy/legacy.hpp	814;"	d
CV_VAR_CATEGORICAL	ml/ml.hpp	113;"	d
CV_VAR_NUMERICAL	ml/ml.hpp	111;"	d
CV_VAR_ORDERED	ml/ml.hpp	112;"	d
CV_VERSION	core/version.hpp	56;"	d
CV_VORONOIDIAGRAM2D_FIELDS	legacy/legacy.hpp	1030;"	d
CV_VORONOIEDGE2D_BEGINNODE	legacy/legacy.hpp	996;"	d
CV_VORONOIEDGE2D_ENDNODE	legacy/legacy.hpp	997;"	d
CV_VORONOIEDGE2D_FIELDS	legacy/legacy.hpp	1010;"	d
CV_VORONOINODE2D_FIELDS	legacy/legacy.hpp	1020;"	d
CV_VORONOISITE2D_FIELDS	legacy/legacy.hpp	1000;"	d
CV_WARP_FILL_OUTLIERS	imgproc/types_c.h	/^    CV_WARP_FILL_OUTLIERS =8,$/;"	e	enum:__anon35
CV_WARP_INVERSE_MAP	imgproc/types_c.h	/^    CV_WARP_INVERSE_MAP  =16$/;"	e	enum:__anon35
CV_WARP_TO_CAMERA	legacy/legacy.hpp	564;"	d
CV_WEIGHTED_ALL	legacy/legacy.hpp	/^    CV_WEIGHTED_ALL$/;"	e	enum:CvGraphWeightType
CV_WEIGHTED_EDGE	legacy/legacy.hpp	/^    CV_WEIGHTED_EDGE,$/;"	e	enum:CvGraphWeightType
CV_WEIGHTED_VTX	legacy/legacy.hpp	/^    CV_WEIGHTED_VTX,$/;"	e	enum:CvGraphWeightType
CV_WHOLE_ARR	core/types_c.h	609;"	d
CV_WHOLE_SEQ	core/types_c.h	1200;"	d
CV_WHOLE_SEQ_END_INDEX	core/types_c.h	1199;"	d
CV_WINDOW_AUTOSIZE	highgui/highgui_c.h	/^    CV_WINDOW_AUTOSIZE     = 0x00000001,\/\/the user cannot resize the window, the size is constrainted by the image displayed$/;"	e	enum:__anon165
CV_WINDOW_FREERATIO	highgui/highgui_c.h	/^    CV_WINDOW_FREERATIO    = 0x00000100,\/\/the image expends as much as it can (no ratio constraint)$/;"	e	enum:__anon165
CV_WINDOW_FULLSCREEN	highgui/highgui_c.h	/^    CV_WINDOW_FULLSCREEN   = 1,\/\/change the window to fullscreen$/;"	e	enum:__anon165
CV_WINDOW_KEEPRATIO	highgui/highgui_c.h	/^    CV_WINDOW_KEEPRATIO    = 0x00000000\/\/the ration image is respected.$/;"	e	enum:__anon165
CV_WINDOW_NORMAL	highgui/highgui_c.h	/^    CV_WINDOW_NORMAL       = 0x00000000,\/\/the user can resize the window (no constraint)  \/ also use to switch a fullscreen window to a normal size$/;"	e	enum:__anon165
CV_WND_PROP_ASPECTRATIO	highgui/highgui_c.h	/^    CV_WND_PROP_ASPECTRATIO= 2,\/\/to change\/get window's aspectratio property$/;"	e	enum:__anon165
CV_WND_PROP_AUTOSIZE	highgui/highgui_c.h	/^    CV_WND_PROP_AUTOSIZE   = 1,\/\/to change\/get window's autosize property$/;"	e	enum:__anon165
CV_WND_PROP_FULLSCREEN	highgui/highgui_c.h	/^    CV_WND_PROP_FULLSCREEN = 0,\/\/to change\/get window's fullscreen property$/;"	e	enum:__anon165
CV_WRAP	core/types_c.h	175;"	d
CV_WRAP_AS	core/types_c.h	176;"	d
CV_WRAP_DEFAULT	core/types_c.h	177;"	d
CV_WRITE_SEQ_ELEM	core/types_c.h	1633;"	d
CV_WRITE_SEQ_ELEM_VAR	core/types_c.h	1623;"	d
CV_XADD	core/operations.hpp	/^  template<typename _Tp> static inline _Tp CV_XADD(_Tp* addr, _Tp delta)$/;"	f	signature:(_Tp* addr, _Tp delta)
CV_XADD	core/operations.hpp	60;"	d
CV_XADD	core/operations.hpp	63;"	d
CV_XADD	core/operations.hpp	69;"	d
CV_XADD	core/operations.hpp	71;"	d
CV_XADD	core/operations.hpp	77;"	d
CV_XOR	core/internal.hpp	354;"	d
CV_XYZ2BGR	imgproc/types_c.h	/^    CV_XYZ2BGR     =34,$/;"	e	enum:__anon33
CV_XYZ2RGB	imgproc/types_c.h	/^    CV_XYZ2RGB     =35,$/;"	e	enum:__anon33
CV_YCrCb2BGR	imgproc/types_c.h	/^    CV_YCrCb2BGR   =38,$/;"	e	enum:__anon33
CV_YCrCb2RGB	imgproc/types_c.h	/^    CV_YCrCb2RGB   =39,$/;"	e	enum:__anon33
CV_YUV2BGR	imgproc/types_c.h	/^    CV_YUV2BGR      = 84,$/;"	e	enum:__anon33
CV_YUV2RGB	imgproc/types_c.h	/^    CV_YUV2RGB      = 85,$/;"	e	enum:__anon33
CV_YUV420i2BGR	imgproc/types_c.h	/^    CV_YUV420i2BGR  = 91,$/;"	e	enum:__anon33
CV_YUV420i2RGB	imgproc/types_c.h	/^    CV_YUV420i2RGB  = 90,$/;"	e	enum:__anon33
CV_YUV420sp2BGR	imgproc/types_c.h	/^    CV_YUV420sp2BGR = 93,$/;"	e	enum:__anon33
CV_YUV420sp2RGB	imgproc/types_c.h	/^    CV_YUV420sp2RGB = 92,$/;"	e	enum:__anon33
CV_ZERO_OBJ	core/internal.hpp	385;"	d
CYCLE_O	contrib/contrib.hpp	/^        enum {CYCLE_O, CYCLE_V};$/;"	e	enum:cv::StereoVar::__anon8
CYCLE_V	contrib/contrib.hpp	/^        enum {CYCLE_O, CYCLE_V};$/;"	e	enum:cv::StereoVar::__anon8
C_SVC	ml/ml.hpp	/^    enum { C_SVC=100, NU_SVC=101, ONE_CLASS=102, EPS_SVR=103, NU_SVR=104 };$/;"	e	enum:CvSVM::__anon72
Calc	ml/ml.hpp	/^    typedef void (CvSVMKernel::*Calc)( int vec_count, int vec_size, const float** vecs,$/;"	t	struct:CvSVMKernel	access:public
CalcRho	ml/ml.hpp	/^    typedef void (CvSVMSolver::*CalcRho)( double& rho, double& r );$/;"	t	class:CvSVMSolver	access:public
CalonderDescriptorExtractor	features2d/features2d.hpp	/^    CalonderDescriptorExtractor( const string& classifierFile );$/;"	p	class:cv::CalonderDescriptorExtractor	access:public	signature:( const string& classifierFile )
CalonderDescriptorExtractor	features2d/features2d.hpp	/^CalonderDescriptorExtractor<T>::CalonderDescriptorExtractor(const std::string& classifier_file)$/;"	f	class:cv::CalonderDescriptorExtractor	signature:(const std::string& classifier_file)
CalonderDescriptorExtractor	features2d/features2d.hpp	/^class CV_EXPORTS CalonderDescriptorExtractor : public DescriptorExtractor$/;"	c	namespace:cv	inherits:DescriptorExtractor
CamShift	video/tracking.hpp	/^CV_EXPORTS_W RotatedRect CamShift( InputArray probImage, CV_OUT CV_IN_OUT Rect& window,$/;"	p	namespace:cv	signature:( InputArray probImage, CV_OUT CV_IN_OUT Rect& window, TermCriteria criteria )
Canny	gpu/gpu.hpp	/^        CV_EXPORTS void Canny(const GpuMat& dx, const GpuMat& dy, CannyBuf& buf, GpuMat& edges, double low_thresh, double high_thresh, bool L2gradient = false);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& dx, const GpuMat& dy, CannyBuf& buf, GpuMat& edges, double low_thresh, double high_thresh, bool L2gradient = false)
Canny	gpu/gpu.hpp	/^        CV_EXPORTS void Canny(const GpuMat& dx, const GpuMat& dy, GpuMat& edges, double low_thresh, double high_thresh, bool L2gradient = false);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& dx, const GpuMat& dy, GpuMat& edges, double low_thresh, double high_thresh, bool L2gradient = false)
Canny	gpu/gpu.hpp	/^        CV_EXPORTS void Canny(const GpuMat& image, CannyBuf& buf, GpuMat& edges, double low_thresh, double high_thresh, int apperture_size = 3, bool L2gradient = false);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& image, CannyBuf& buf, GpuMat& edges, double low_thresh, double high_thresh, int apperture_size = 3, bool L2gradient = false)
Canny	gpu/gpu.hpp	/^        CV_EXPORTS void Canny(const GpuMat& image, GpuMat& edges, double low_thresh, double high_thresh, int apperture_size = 3, bool L2gradient = false);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& image, GpuMat& edges, double low_thresh, double high_thresh, int apperture_size = 3, bool L2gradient = false)
Canny	imgproc/imgproc.hpp	/^CV_EXPORTS_W void Canny( InputArray image, OutputArray edges,$/;"	p	namespace:cv	signature:( InputArray image, OutputArray edges, double threshold1, double threshold2, int apertureSize=3, bool L2gradient=false )
CannyBuf	gpu/gpu.hpp	/^            CannyBuf() {}$/;"	f	struct:cv::gpu::CannyBuf	access:public	signature:()
CannyBuf	gpu/gpu.hpp	/^            CannyBuf(const GpuMat& dx_, const GpuMat& dy_);$/;"	p	struct:cv::gpu::CannyBuf	access:public	signature:(const GpuMat& dx_, const GpuMat& dy_)
CannyBuf	gpu/gpu.hpp	/^            explicit CannyBuf(const Size& image_size, int apperture_size = 3) {create(image_size, apperture_size);}$/;"	f	struct:cv::gpu::CannyBuf	access:public	signature:(const Size& image_size, int apperture_size = 3)
CannyBuf	gpu/gpu.hpp	/^        struct CV_EXPORTS CannyBuf$/;"	s	namespace:cv::gpu
CannyBuf	gpu/gpu.hpp	/^        struct CV_EXPORTS CannyBuf;$/;"	m	namespace:cv::gpu	typeref:struct:cv::gpu::CV_EXPORTS
CascadeClassifier	objdetect/objdetect.hpp	/^    CV_WRAP CascadeClassifier( const string& filename );$/;"	p	class:cv::CascadeClassifier	access:public	signature:( const string& filename )
CascadeClassifier	objdetect/objdetect.hpp	/^    CV_WRAP CascadeClassifier();$/;"	p	class:cv::CascadeClassifier	access:public	signature:()
CascadeClassifier	objdetect/objdetect.hpp	/^class CV_EXPORTS_W CascadeClassifier$/;"	c	namespace:cv
CascadeClassifier_GPU	gpu/gpu.hpp	/^            CascadeClassifier_GPU();$/;"	p	class:cv::gpu::CascadeClassifier_GPU	access:public	signature:()
CascadeClassifier_GPU	gpu/gpu.hpp	/^            CascadeClassifier_GPU(const string& filename);$/;"	p	class:cv::gpu::CascadeClassifier_GPU	access:public	signature:(const string& filename)
CascadeClassifier_GPU	gpu/gpu.hpp	/^        class CV_EXPORTS CascadeClassifier_GPU$/;"	c	namespace:cv::gpu
Center	features2d/features2d.hpp	/^  struct CV_EXPORTS Center$/;"	s	class:cv::SimpleBlobDetector	access:protected
ChannelSize	core/wimage.hpp	/^    int ChannelSize() const {return sizeof(T); }  \/\/ number of bytes per channel$/;"	f	class:cv::WImage	access:public	signature:() const
Channels	core/wimage.hpp	/^    int Channels() const {return C; }$/;"	f	class:cv::WImageC	access:public	signature:() const
Channels	core/wimage.hpp	/^    int Channels() const {return image_->nChannels; }$/;"	f	class:cv::WImage	access:public	signature:() const
ChiSquareDistance	flann/dist.h	/^struct ChiSquareDistance$/;"	s	namespace:cvflann
Cholesky	core/operations.hpp	/^CV_EXPORTS bool Cholesky(double* A, size_t astep, int m, double* b, size_t bstep, int n);    $/;"	p	namespace:cv	signature:(double* A, size_t astep, int m, double* b, size_t bstep, int n)
Cholesky	core/operations.hpp	/^CV_EXPORTS bool Cholesky(float* A, size_t astep, int m, float* b, size_t bstep, int n);$/;"	p	namespace:cv	signature:(float* A, size_t astep, int m, float* b, size_t bstep, int n)
Clear	legacy/blobtrack.hpp	/^    virtual void Clear()$/;"	f	class:CvBlobSeq	access:public	signature:()
Clear	legacy/blobtrack.hpp	/^    virtual void Clear();$/;"	p	class:CvBlobTrackSeq	access:public	signature:()
CloneFrom	core/wimage.hpp	/^    void CloneFrom(const WImage<T>& src) {$/;"	f	class:cv::WImageBuffer	access:public	signature:(const WImage<T>& src)
CloneFrom	core/wimage.hpp	/^    void CloneFrom(const WImageC<T, C>& src) {$/;"	f	class:cv::WImageBufferC	access:public	signature:(const WImageC<T, C>& src)
CommandLineParser	core/core.hpp	/^      CommandLineParser(int argc, const char* argv[], const char* key_map);$/;"	p	class:cv::CommandLineParser	access:public	signature:(int argc, const char* argv[], const char* key_map)
CommandLineParser	core/core.hpp	/^class CV_EXPORTS CommandLineParser$/;"	c	namespace:cv
CommentParam	legacy/blobtrack.hpp	/^    void CommentParam(const char* name, const char* pComment);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name, const char* pComment)
CommonParams	features2d/features2d.hpp	/^        CommonParams( int _nOctaves, int _nOctaveLayers );$/;"	p	struct:cv::SIFT::CommonParams	access:public	signature:( int _nOctaves, int _nOctaveLayers )
CommonParams	features2d/features2d.hpp	/^        CommonParams( int _nOctaves, int _nOctaveLayers, int \/*_firstOctave*\/, int \/*_angleMode*\/ );$/;"	p	struct:cv::SIFT::CommonParams	access:public	signature:( int _nOctaves, int _nOctaveLayers, int , int )
CommonParams	features2d/features2d.hpp	/^        CommonParams();$/;"	p	struct:cv::SIFT::CommonParams	access:public	signature:()
CommonParams	features2d/features2d.hpp	/^    CommonParams(float scale_factor = 1.2f, unsigned int n_levels = DEFAULT_N_LEVELS, int edge_threshold = 31,$/;"	f	struct:cv::ORB::CommonParams	access:public	signature:(float scale_factor = 1.2f, unsigned int n_levels = DEFAULT_N_LEVELS, int edge_threshold = 31, unsigned int first_level = DEFAULT_FIRST_LEVEL)
CommonParams	features2d/features2d.hpp	/^    struct CV_EXPORTS CommonParams$/;"	s	class:cv::SIFT	access:public
CommonParams	features2d/features2d.hpp	/^  struct CV_EXPORTS CommonParams$/;"	s	class:cv::ORB	access:public
CompareT	flann/heap.h	/^    struct CompareT$/;"	s	class:cvflann::Heap	access:public
Complex	core/core.hpp	/^    Complex( _Tp _re, _Tp _im=0 );$/;"	p	class:cv::Complex	access:public	signature:( _Tp _re, _Tp _im=0 )
Complex	core/core.hpp	/^    Complex( const std::complex<_Tp>& c );$/;"	p	class:cv::Complex	access:public	signature:( const std::complex<_Tp>& c )
Complex	core/core.hpp	/^    Complex();$/;"	p	class:cv::Complex	access:public	signature:()
Complex	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Complex$/;"	c	namespace:cv
Complex	core/core.hpp	74;"	d
Complex	core/operations.hpp	/^template<typename _Tp> inline Complex<_Tp>::Complex( _Tp _re, _Tp _im ) : re(_re), im(_im) {}$/;"	f	class:cv::Complex	signature:( _Tp _re, _Tp _im )
Complex	core/operations.hpp	/^template<typename _Tp> inline Complex<_Tp>::Complex() : re(0), im(0) {}$/;"	f	class:cv::Complex	signature:()
Complexd	core/core.hpp	/^typedef Complex<double> Complexd;$/;"	t	namespace:cv
Complexf	core/core.hpp	/^typedef Complex<float> Complexf;$/;"	t	namespace:cv
CompositeIndex	flann/composite_index.h	/^    CompositeIndex(const CompositeIndex&);$/;"	p	class:cvflann::CompositeIndex	access:public	signature:(const CompositeIndex&)
CompositeIndex	flann/composite_index.h	/^    CompositeIndex(const Matrix<ElementType>& inputData, const IndexParams& params = CompositeIndexParams(),$/;"	f	class:cvflann::CompositeIndex	access:public	signature:(const Matrix<ElementType>& inputData, const IndexParams& params = CompositeIndexParams(), Distance d = Distance())
CompositeIndex	flann/composite_index.h	/^class CompositeIndex : public NNIndex<Distance>$/;"	c	namespace:cvflann	inherits:NNIndex
CompositeIndexParams	flann/composite_index.h	/^    CompositeIndexParams(int trees = 4, int branching = 32, int iterations = 11,$/;"	f	struct:cvflann::CompositeIndexParams	access:public	signature:(int trees = 4, int branching = 32, int iterations = 11, flann_centers_init_t centers_init = FLANN_CENTERS_RANDOM, float cb_index = 0.2 )
CompositeIndexParams	flann/composite_index.h	/^struct CompositeIndexParams : public IndexParams$/;"	s	namespace:cvflann	inherits:IndexParams
CompositeIndexParams	flann/miniflann.hpp	/^    CompositeIndexParams(int trees = 4, int branching = 32, int iterations = 11,$/;"	p	struct:cv::flann::CompositeIndexParams	access:public	signature:(int trees = 4, int branching = 32, int iterations = 11, cvflann::flann_centers_init_t centers_init = cvflann::FLANN_CENTERS_RANDOM, float cb_index = 0.2 )
CompositeIndexParams	flann/miniflann.hpp	/^struct CV_EXPORTS CompositeIndexParams : public IndexParams$/;"	s	namespace:cv::flann	inherits:IndexParams
ConcurrentDoubleVector	core/internal.hpp	/^        typedef tbb::concurrent_vector<double> ConcurrentDoubleVector;$/;"	t	namespace:cv
ConcurrentRectVector	core/internal.hpp	/^        typedef tbb::concurrent_vector<Rect> ConcurrentRectVector;$/;"	t	namespace:cv
ConcurrentRectVector	core/internal.hpp	/^        typedef tf::ConcurrentVector<Rect> ConcurrentRectVector;$/;"	t
ConvertData	core/core.hpp	/^typedef void (*ConvertData)(const void* from, void* to, int cn);$/;"	t	namespace:cv
ConvertDescriptorsArrayToTree	features2d/features2d.hpp	/^    void ConvertDescriptorsArrayToTree(); \/\/ Converting pca_descriptors array to KD tree$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
ConvertScaleData	core/core.hpp	/^typedef void (*ConvertScaleData)(const void* from, void* to, int cn, double alpha, double beta);$/;"	t	namespace:cv
ConvolveBuf	gpu/gpu.hpp	/^            ConvolveBuf() {}$/;"	f	struct:cv::gpu::ConvolveBuf	access:public	signature:()
ConvolveBuf	gpu/gpu.hpp	/^            ConvolveBuf(Size image_size, Size templ_size) $/;"	f	struct:cv::gpu::ConvolveBuf	access:public	signature:(Size image_size, Size templ_size)
ConvolveBuf	gpu/gpu.hpp	/^        struct CV_EXPORTS ConvolveBuf$/;"	s	namespace:cv::gpu
ConvolveBuf	gpu/gpu.hpp	/^        struct CV_EXPORTS ConvolveBuf;$/;"	m	namespace:cv::gpu	typeref:struct:cv::gpu::CV_EXPORTS
CopyFrom	core/wimage.hpp	/^    void CopyFrom(const WImage<T>& src) { cvCopy(src.Ipl(), image_); }$/;"	f	class:cv::WImage	access:public	signature:(const WImage<T>& src)
CopyFrom	core/wimage.hpp	/^    void CopyFrom(const WImageC<T, C>& src) {$/;"	f	class:cv::WImageC	access:public	signature:(const WImageC<T, C>& src)
CostData	flann/autotuned_index.h	/^    struct CostData$/;"	s	class:cvflann::AutotunedIndex	access:private
CreateDescriptorsFromImage	features2d/features2d.hpp	/^    void CreateDescriptorsFromImage(IplImage* src, const std::vector<cv::KeyPoint>& features);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(IplImage* src, const std::vector<cv::KeyPoint>& features)
CreatePCADescriptors	features2d/features2d.hpp	/^    void CreatePCADescriptors();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
CreatorNotFound	flann/object_factory.h	/^class CreatorNotFound$/;"	c	namespace:cvflann
CudaMem	gpu/gpu.hpp	/^            CudaMem();$/;"	p	class:cv::gpu::CudaMem	access:public	signature:()
CudaMem	gpu/gpu.hpp	/^            CudaMem(Size size, int type, int alloc_type = ALLOC_PAGE_LOCKED);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(Size size, int type, int alloc_type = ALLOC_PAGE_LOCKED)
CudaMem	gpu/gpu.hpp	/^            CudaMem(const CudaMem& m);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(const CudaMem& m)
CudaMem	gpu/gpu.hpp	/^            CudaMem(int rows, int cols, int type, int _alloc_type = ALLOC_PAGE_LOCKED);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(int rows, int cols, int type, int _alloc_type = ALLOC_PAGE_LOCKED)
CudaMem	gpu/gpu.hpp	/^            explicit CudaMem(const Mat& m, int alloc_type = ALLOC_PAGE_LOCKED);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(const Mat& m, int alloc_type = ALLOC_PAGE_LOCKED)
CudaMem	gpu/gpu.hpp	/^        class CV_EXPORTS CudaMem$/;"	c	namespace:cv::gpu
CudaMem	gpu/matrix_operations.hpp	/^inline CudaMem::CudaMem()  : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0), alloc_type(0) {}$/;"	f	class:cv::gpu::CudaMem	signature:()
CudaMem	gpu/matrix_operations.hpp	/^inline CudaMem::CudaMem(Size _size, int _type, int _alloc_type) : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0), alloc_type(0)$/;"	f	class:cv::gpu::CudaMem	signature:(Size _size, int _type, int _alloc_type)
CudaMem	gpu/matrix_operations.hpp	/^inline CudaMem::CudaMem(const CudaMem& m) : flags(m.flags), rows(m.rows), cols(m.cols), step(m.step), data(m.data), refcount(m.refcount), datastart(m.datastart), dataend(m.dataend), alloc_type(m.alloc_type)$/;"	f	class:cv::gpu::CudaMem	signature:(const CudaMem& m)
CudaMem	gpu/matrix_operations.hpp	/^inline CudaMem::CudaMem(const Mat& m, int _alloc_type) : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0), alloc_type(0)$/;"	f	class:cv::gpu::CudaMem	signature:(const Mat& m, int _alloc_type)
CudaMem	gpu/matrix_operations.hpp	/^inline CudaMem::CudaMem(int _rows, int _cols, int _type, int _alloc_type) : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0), alloc_type(0)$/;"	f	class:cv::gpu::CudaMem	signature:(int _rows, int _cols, int _type, int _alloc_type)
Cv1DObsInfo	legacy/legacy.hpp	/^typedef CvImgObsInfo Cv1DObsInfo;$/;"	t
Cv32suf	core/types_c.h	/^Cv32suf;$/;"	t	typeref:union:Cv32suf
Cv32suf	core/types_c.h	/^typedef union Cv32suf$/;"	u
Cv32suf::f	core/types_c.h	/^    float f;$/;"	m	union:Cv32suf	access:public
Cv32suf::i	core/types_c.h	/^    int i;$/;"	m	union:Cv32suf	access:public
Cv32suf::u	core/types_c.h	/^    unsigned u;$/;"	m	union:Cv32suf	access:public
Cv3dTracker2dTrackedObject	legacy/legacy.hpp	/^} Cv3dTracker2dTrackedObject;$/;"	t	typeref:struct:__anon185
Cv3dTrackerCameraInfo	legacy/legacy.hpp	/^} Cv3dTrackerCameraInfo;$/;"	t	typeref:struct:__anon187
Cv3dTrackerCameraIntrinsics	legacy/legacy.hpp	/^} Cv3dTrackerCameraIntrinsics;$/;"	t	typeref:struct:__anon188
Cv3dTrackerTrackedObject	legacy/legacy.hpp	/^} Cv3dTrackerTrackedObject;$/;"	t	typeref:struct:__anon186
Cv64suf	core/types_c.h	/^Cv64suf;$/;"	t	typeref:union:Cv64suf
Cv64suf	core/types_c.h	/^typedef union Cv64suf$/;"	u
Cv64suf::f	core/types_c.h	/^    double f;$/;"	m	union:Cv64suf	access:public
Cv64suf::i	core/types_c.h	/^    int64 i;$/;"	m	union:Cv64suf	access:public
Cv64suf::u	core/types_c.h	/^    uint64 u;$/;"	m	union:Cv64suf	access:public
CvANN_MLP	ml/ml.hpp	/^    CV_WRAP CvANN_MLP( const cv::Mat& layerSizes,$/;"	p	class:CvANN_MLP	access:public	signature:( const cv::Mat& layerSizes, int activateFunc=CvANN_MLP::SIGMOID_SYM, double fparam1=0, double fparam2=0 )
CvANN_MLP	ml/ml.hpp	/^    CV_WRAP CvANN_MLP();$/;"	p	class:CvANN_MLP	access:public	signature:()
CvANN_MLP	ml/ml.hpp	/^    CvANN_MLP( const CvMat* layerSizes,$/;"	p	class:CvANN_MLP	access:public	signature:( const CvMat* layerSizes, int activateFunc=CvANN_MLP::SIGMOID_SYM, double fparam1=0, double fparam2=0 )
CvANN_MLP	ml/ml.hpp	/^class CV_EXPORTS_W CvANN_MLP : public CvStatModel$/;"	c	inherits:CvStatModel
CvANN_MLP::CvANN_MLP	ml/ml.hpp	/^    CV_WRAP CvANN_MLP( const cv::Mat& layerSizes,$/;"	p	class:CvANN_MLP	access:public	signature:( const cv::Mat& layerSizes, int activateFunc=CvANN_MLP::SIGMOID_SYM, double fparam1=0, double fparam2=0 )
CvANN_MLP::CvANN_MLP	ml/ml.hpp	/^    CV_WRAP CvANN_MLP();$/;"	p	class:CvANN_MLP	access:public	signature:()
CvANN_MLP::CvANN_MLP	ml/ml.hpp	/^    CvANN_MLP( const CvMat* layerSizes,$/;"	p	class:CvANN_MLP	access:public	signature:( const CvMat* layerSizes, int activateFunc=CvANN_MLP::SIGMOID_SYM, double fparam1=0, double fparam2=0 )
CvANN_MLP::GAUSSIAN	ml/ml.hpp	/^    enum { IDENTITY = 0, SIGMOID_SYM = 1, GAUSSIAN = 2 };$/;"	e	enum:CvANN_MLP::__anon83
CvANN_MLP::IDENTITY	ml/ml.hpp	/^    enum { IDENTITY = 0, SIGMOID_SYM = 1, GAUSSIAN = 2 };$/;"	e	enum:CvANN_MLP::__anon83
CvANN_MLP::NO_INPUT_SCALE	ml/ml.hpp	/^    enum { UPDATE_WEIGHTS = 1, NO_INPUT_SCALE = 2, NO_OUTPUT_SCALE = 4 };$/;"	e	enum:CvANN_MLP::__anon84
CvANN_MLP::NO_OUTPUT_SCALE	ml/ml.hpp	/^    enum { UPDATE_WEIGHTS = 1, NO_INPUT_SCALE = 2, NO_OUTPUT_SCALE = 4 };$/;"	e	enum:CvANN_MLP::__anon84
CvANN_MLP::SIGMOID_SYM	ml/ml.hpp	/^    enum { IDENTITY = 0, SIGMOID_SYM = 1, GAUSSIAN = 2 };$/;"	e	enum:CvANN_MLP::__anon83
CvANN_MLP::UPDATE_WEIGHTS	ml/ml.hpp	/^    enum { UPDATE_WEIGHTS = 1, NO_INPUT_SCALE = 2, NO_OUTPUT_SCALE = 4 };$/;"	e	enum:CvANN_MLP::__anon84
CvANN_MLP::activ_func	ml/ml.hpp	/^    int activ_func;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::calc_activ_func	ml/ml.hpp	/^    virtual void calc_activ_func( CvMat* xf, const double* bias ) const;$/;"	p	class:CvANN_MLP	access:protected	signature:( CvMat* xf, const double* bias ) const
CvANN_MLP::calc_activ_func_deriv	ml/ml.hpp	/^    virtual void calc_activ_func_deriv( CvMat* xf, CvMat* deriv, const double* bias ) const;$/;"	p	class:CvANN_MLP	access:public	signature:( CvMat* xf, CvMat* deriv, const double* bias ) const
CvANN_MLP::calc_input_scale	ml/ml.hpp	/^    virtual void calc_input_scale( const CvVectors* vecs, int flags );$/;"	p	class:CvANN_MLP	access:protected	signature:( const CvVectors* vecs, int flags )
CvANN_MLP::calc_output_scale	ml/ml.hpp	/^    virtual void calc_output_scale( const CvVectors* vecs, int flags );$/;"	p	class:CvANN_MLP	access:protected	signature:( const CvVectors* vecs, int flags )
CvANN_MLP::clear	ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvANN_MLP	access:public	signature:()
CvANN_MLP::create	ml/ml.hpp	/^    CV_WRAP virtual void create( const cv::Mat& layerSizes,$/;"	p	class:CvANN_MLP	access:public	signature:( const cv::Mat& layerSizes, int activateFunc=CvANN_MLP::SIGMOID_SYM, double fparam1=0, double fparam2=0 )
CvANN_MLP::create	ml/ml.hpp	/^    virtual void create( const CvMat* layerSizes,$/;"	p	class:CvANN_MLP	access:public	signature:( const CvMat* layerSizes, int activateFunc=CvANN_MLP::SIGMOID_SYM, double fparam1=0, double fparam2=0 )
CvANN_MLP::f_param1	ml/ml.hpp	/^    double f_param1, f_param2;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::f_param2	ml/ml.hpp	/^    double f_param1, f_param2;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::get_layer_count	ml/ml.hpp	/^    int get_layer_count() { return layer_sizes ? layer_sizes->cols : 0; }$/;"	f	class:CvANN_MLP	access:public	signature:()
CvANN_MLP::get_layer_sizes	ml/ml.hpp	/^    const CvMat* get_layer_sizes() { return layer_sizes; }$/;"	f	class:CvANN_MLP	access:public	signature:()
CvANN_MLP::get_weights	ml/ml.hpp	/^    double* get_weights(int layer)$/;"	f	class:CvANN_MLP	access:public	signature:(int layer)
CvANN_MLP::init_weights	ml/ml.hpp	/^    virtual void init_weights();$/;"	p	class:CvANN_MLP	access:protected	signature:()
CvANN_MLP::layer_sizes	ml/ml.hpp	/^    CvMat* layer_sizes;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::max_buf_sz	ml/ml.hpp	/^    int max_count, max_buf_sz;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::max_count	ml/ml.hpp	/^    int max_count, max_buf_sz;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::max_val	ml/ml.hpp	/^    double min_val, max_val, min_val1, max_val1;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::max_val1	ml/ml.hpp	/^    double min_val, max_val, min_val1, max_val1;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::min_val	ml/ml.hpp	/^    double min_val, max_val, min_val1, max_val1;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::min_val1	ml/ml.hpp	/^    double min_val, max_val, min_val1, max_val1;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::params	ml/ml.hpp	/^    CvANN_MLP_TrainParams params;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::predict	ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& inputs, cv::Mat& outputs ) const;$/;"	p	class:CvANN_MLP	access:public	signature:( const cv::Mat& inputs, cv::Mat& outputs ) const
CvANN_MLP::predict	ml/ml.hpp	/^    virtual float predict( const CvMat* inputs, CV_OUT CvMat* outputs ) const;$/;"	p	class:CvANN_MLP	access:public	signature:( const CvMat* inputs, CV_OUT CvMat* outputs ) const
CvANN_MLP::prepare_to_train	ml/ml.hpp	/^    virtual bool prepare_to_train( const CvMat* _inputs, const CvMat* _outputs,$/;"	p	class:CvANN_MLP	access:protected	signature:( const CvMat* _inputs, const CvMat* _outputs, const CvMat* _sample_weights, const CvMat* sampleIdx, CvVectors* _ivecs, CvVectors* _ovecs, double** _sw, int _flags )
CvANN_MLP::read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvANN_MLP	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
CvANN_MLP::read_params	ml/ml.hpp	/^    virtual void read_params( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvANN_MLP	access:protected	signature:( CvFileStorage* fs, CvFileNode* node )
CvANN_MLP::rng	ml/ml.hpp	/^    cv::RNG* rng;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::sample_weights	ml/ml.hpp	/^    CvMat* sample_weights;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::scale_input	ml/ml.hpp	/^    virtual void scale_input( const CvMat* _src, CvMat* _dst ) const;$/;"	p	class:CvANN_MLP	access:protected	signature:( const CvMat* _src, CvMat* _dst ) const
CvANN_MLP::scale_output	ml/ml.hpp	/^    virtual void scale_output( const CvMat* _src, CvMat* _dst ) const;$/;"	p	class:CvANN_MLP	access:protected	signature:( const CvMat* _src, CvMat* _dst ) const
CvANN_MLP::set_activ_func	ml/ml.hpp	/^    virtual void set_activ_func( int _activ_func=SIGMOID_SYM,$/;"	p	class:CvANN_MLP	access:protected	signature:( int _activ_func=SIGMOID_SYM, double _f_param1=0, double _f_param2=0 )
CvANN_MLP::train	ml/ml.hpp	/^    CV_WRAP virtual int train( const cv::Mat& inputs, const cv::Mat& outputs,$/;"	p	class:CvANN_MLP	access:public	signature:( const cv::Mat& inputs, const cv::Mat& outputs, const cv::Mat& sampleWeights, const cv::Mat& sampleIdx=cv::Mat(), CvANN_MLP_TrainParams params = CvANN_MLP_TrainParams(), int flags=0 )
CvANN_MLP::train	ml/ml.hpp	/^    virtual int train( const CvMat* inputs, const CvMat* outputs,$/;"	p	class:CvANN_MLP	access:public	signature:( const CvMat* inputs, const CvMat* outputs, const CvMat* sampleWeights, const CvMat* sampleIdx=0, CvANN_MLP_TrainParams params = CvANN_MLP_TrainParams(), int flags=0 )
CvANN_MLP::train_backprop	ml/ml.hpp	/^    virtual int train_backprop( CvVectors _ivecs, CvVectors _ovecs, const double* _sw );$/;"	p	class:CvANN_MLP	access:protected	signature:( CvVectors _ivecs, CvVectors _ovecs, const double* _sw )
CvANN_MLP::train_rprop	ml/ml.hpp	/^    virtual int train_rprop( CvVectors _ivecs, CvVectors _ovecs, const double* _sw );$/;"	p	class:CvANN_MLP	access:protected	signature:( CvVectors _ivecs, CvVectors _ovecs, const double* _sw )
CvANN_MLP::wbuf	ml/ml.hpp	/^    CvMat* wbuf;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::weights	ml/ml.hpp	/^    double** weights;$/;"	m	class:CvANN_MLP	access:protected
CvANN_MLP::write	ml/ml.hpp	/^    virtual void write( CvFileStorage* storage, const char* name ) const;$/;"	p	class:CvANN_MLP	access:public	signature:( CvFileStorage* storage, const char* name ) const
CvANN_MLP::write_params	ml/ml.hpp	/^    virtual void write_params( CvFileStorage* fs ) const;$/;"	p	class:CvANN_MLP	access:protected	signature:( CvFileStorage* fs ) const
CvANN_MLP::~CvANN_MLP	ml/ml.hpp	/^    virtual ~CvANN_MLP();$/;"	p	class:CvANN_MLP	access:public	signature:()
CvANN_MLP_TrainParams	ml/ml.hpp	/^    CvANN_MLP_TrainParams( CvTermCriteria term_crit, int train_method,$/;"	p	struct:CvANN_MLP_TrainParams	access:public	signature:( CvTermCriteria term_crit, int train_method, double param1, double param2=0 )
CvANN_MLP_TrainParams	ml/ml.hpp	/^    CvANN_MLP_TrainParams();$/;"	p	struct:CvANN_MLP_TrainParams	access:public	signature:()
CvANN_MLP_TrainParams	ml/ml.hpp	/^struct CV_EXPORTS_W_MAP CvANN_MLP_TrainParams$/;"	s
CvANN_MLP_TrainParams::BACKPROP	ml/ml.hpp	/^    enum { BACKPROP=0, RPROP=1 };$/;"	e	enum:CvANN_MLP_TrainParams::__anon82
CvANN_MLP_TrainParams::CvANN_MLP_TrainParams	ml/ml.hpp	/^    CvANN_MLP_TrainParams( CvTermCriteria term_crit, int train_method,$/;"	p	struct:CvANN_MLP_TrainParams	access:public	signature:( CvTermCriteria term_crit, int train_method, double param1, double param2=0 )
CvANN_MLP_TrainParams::CvANN_MLP_TrainParams	ml/ml.hpp	/^    CvANN_MLP_TrainParams();$/;"	p	struct:CvANN_MLP_TrainParams	access:public	signature:()
CvANN_MLP_TrainParams::RPROP	ml/ml.hpp	/^    enum { BACKPROP=0, RPROP=1 };$/;"	e	enum:CvANN_MLP_TrainParams::__anon82
CvANN_MLP_TrainParams::bp_dw_scale	ml/ml.hpp	/^    CV_PROP_RW double bp_dw_scale, bp_moment_scale;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
CvANN_MLP_TrainParams::bp_moment_scale	ml/ml.hpp	/^    CV_PROP_RW double bp_dw_scale, bp_moment_scale;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
CvANN_MLP_TrainParams::rp_dw0	ml/ml.hpp	/^    CV_PROP_RW double rp_dw0, rp_dw_plus, rp_dw_minus, rp_dw_min, rp_dw_max;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
CvANN_MLP_TrainParams::rp_dw_max	ml/ml.hpp	/^    CV_PROP_RW double rp_dw0, rp_dw_plus, rp_dw_minus, rp_dw_min, rp_dw_max;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
CvANN_MLP_TrainParams::rp_dw_min	ml/ml.hpp	/^    CV_PROP_RW double rp_dw0, rp_dw_plus, rp_dw_minus, rp_dw_min, rp_dw_max;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
CvANN_MLP_TrainParams::rp_dw_minus	ml/ml.hpp	/^    CV_PROP_RW double rp_dw0, rp_dw_plus, rp_dw_minus, rp_dw_min, rp_dw_max;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
CvANN_MLP_TrainParams::rp_dw_plus	ml/ml.hpp	/^    CV_PROP_RW double rp_dw0, rp_dw_plus, rp_dw_minus, rp_dw_min, rp_dw_max;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
CvANN_MLP_TrainParams::term_crit	ml/ml.hpp	/^    CV_PROP_RW CvTermCriteria term_crit;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
CvANN_MLP_TrainParams::train_method	ml/ml.hpp	/^    CV_PROP_RW int train_method;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
CvANN_MLP_TrainParams::~CvANN_MLP_TrainParams	ml/ml.hpp	/^    ~CvANN_MLP_TrainParams();$/;"	p	struct:CvANN_MLP_TrainParams	access:public	signature:()
CvAdaptiveSkinDetector	contrib/contrib.hpp	/^    CvAdaptiveSkinDetector(int samplingDivider = 1, int morphingMethod = MORPHING_METHOD_NONE);$/;"	p	class:CvAdaptiveSkinDetector	access:public	signature:(int samplingDivider = 1, int morphingMethod = MORPHING_METHOD_NONE)
CvAdaptiveSkinDetector	contrib/contrib.hpp	/^class CV_EXPORTS CvAdaptiveSkinDetector$/;"	c
CvAdaptiveSkinDetector::CvAdaptiveSkinDetector	contrib/contrib.hpp	/^    CvAdaptiveSkinDetector(int samplingDivider = 1, int morphingMethod = MORPHING_METHOD_NONE);$/;"	p	class:CvAdaptiveSkinDetector	access:public	signature:(int samplingDivider = 1, int morphingMethod = MORPHING_METHOD_NONE)
CvAdaptiveSkinDetector::GSD_HUE_LT	contrib/contrib.hpp	/^        GSD_HUE_LT = 3,$/;"	e	enum:CvAdaptiveSkinDetector::__anon1
CvAdaptiveSkinDetector::GSD_HUE_UT	contrib/contrib.hpp	/^        GSD_HUE_UT = 33,$/;"	e	enum:CvAdaptiveSkinDetector::__anon1
CvAdaptiveSkinDetector::GSD_INTENSITY_LT	contrib/contrib.hpp	/^        GSD_INTENSITY_LT = 15,$/;"	e	enum:CvAdaptiveSkinDetector::__anon1
CvAdaptiveSkinDetector::GSD_INTENSITY_UT	contrib/contrib.hpp	/^        GSD_INTENSITY_UT = 250$/;"	e	enum:CvAdaptiveSkinDetector::__anon1
CvAdaptiveSkinDetector::Histogram	contrib/contrib.hpp	/^    class CV_EXPORTS Histogram$/;"	c	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::Histogram::Histogram	contrib/contrib.hpp	/^        Histogram();$/;"	p	class:CvAdaptiveSkinDetector::Histogram	access:public	signature:()
CvAdaptiveSkinDetector::Histogram::HistogramSize	contrib/contrib.hpp	/^            HistogramSize = (GSD_HUE_UT - GSD_HUE_LT + 1)$/;"	e	enum:CvAdaptiveSkinDetector::Histogram::__anon2
CvAdaptiveSkinDetector::Histogram::fHistogram	contrib/contrib.hpp	/^        CvHistogram *fHistogram;$/;"	m	class:CvAdaptiveSkinDetector::Histogram	access:public
CvAdaptiveSkinDetector::Histogram::findCoverageIndex	contrib/contrib.hpp	/^        int findCoverageIndex(double surfaceToCover, int defaultValue = 0);$/;"	p	class:CvAdaptiveSkinDetector::Histogram	access:protected	signature:(double surfaceToCover, int defaultValue = 0)
CvAdaptiveSkinDetector::Histogram::findCurveThresholds	contrib/contrib.hpp	/^        void findCurveThresholds(int &x1, int &x2, double percent = 0.05);$/;"	p	class:CvAdaptiveSkinDetector::Histogram	access:public	signature:(int &x1, int &x2, double percent = 0.05)
CvAdaptiveSkinDetector::Histogram::mergeWith	contrib/contrib.hpp	/^        void mergeWith(Histogram *source, double weight);$/;"	p	class:CvAdaptiveSkinDetector::Histogram	access:public	signature:(Histogram *source, double weight)
CvAdaptiveSkinDetector::Histogram::~Histogram	contrib/contrib.hpp	/^        virtual ~Histogram();$/;"	p	class:CvAdaptiveSkinDetector::Histogram	access:public	signature:()
CvAdaptiveSkinDetector::MORPHING_METHOD_ERODE	contrib/contrib.hpp	/^        MORPHING_METHOD_ERODE = 1,$/;"	e	enum:CvAdaptiveSkinDetector::__anon3
CvAdaptiveSkinDetector::MORPHING_METHOD_ERODE_DILATE	contrib/contrib.hpp	/^        MORPHING_METHOD_ERODE_DILATE = 3$/;"	e	enum:CvAdaptiveSkinDetector::__anon3
CvAdaptiveSkinDetector::MORPHING_METHOD_ERODE_ERODE	contrib/contrib.hpp	/^        MORPHING_METHOD_ERODE_ERODE = 2,$/;"	e	enum:CvAdaptiveSkinDetector::__anon3
CvAdaptiveSkinDetector::MORPHING_METHOD_NONE	contrib/contrib.hpp	/^        MORPHING_METHOD_NONE = 0,$/;"	e	enum:CvAdaptiveSkinDetector::__anon3
CvAdaptiveSkinDetector::adaptiveFilter	contrib/contrib.hpp	/^    void adaptiveFilter();$/;"	p	class:CvAdaptiveSkinDetector	access:protected	signature:()
CvAdaptiveSkinDetector::fHistogramMergeFactor	contrib/contrib.hpp	/^    double fHistogramMergeFactor, fHuePercentCovered;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::fHuePercentCovered	contrib/contrib.hpp	/^    double fHistogramMergeFactor, fHuePercentCovered;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::histogramHueMotion	contrib/contrib.hpp	/^    Histogram histogramHueMotion, skinHueHistogram;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::imgFilteredFrame	contrib/contrib.hpp	/^    IplImage *imgHueFrame, *imgSaturationFrame, *imgLastGrayFrame, *imgMotionFrame, *imgFilteredFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::imgGrayFrame	contrib/contrib.hpp	/^    IplImage *imgShrinked, *imgTemp, *imgGrayFrame, *imgHSVFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::imgHSVFrame	contrib/contrib.hpp	/^    IplImage *imgShrinked, *imgTemp, *imgGrayFrame, *imgHSVFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::imgHueFrame	contrib/contrib.hpp	/^    IplImage *imgHueFrame, *imgSaturationFrame, *imgLastGrayFrame, *imgMotionFrame, *imgFilteredFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::imgLastGrayFrame	contrib/contrib.hpp	/^    IplImage *imgHueFrame, *imgSaturationFrame, *imgLastGrayFrame, *imgMotionFrame, *imgFilteredFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::imgMotionFrame	contrib/contrib.hpp	/^    IplImage *imgHueFrame, *imgSaturationFrame, *imgLastGrayFrame, *imgMotionFrame, *imgFilteredFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::imgSaturationFrame	contrib/contrib.hpp	/^    IplImage *imgHueFrame, *imgSaturationFrame, *imgLastGrayFrame, *imgMotionFrame, *imgFilteredFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::imgShrinked	contrib/contrib.hpp	/^    IplImage *imgShrinked, *imgTemp, *imgGrayFrame, *imgHSVFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::imgTemp	contrib/contrib.hpp	/^    IplImage *imgShrinked, *imgTemp, *imgGrayFrame, *imgHSVFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::initData	contrib/contrib.hpp	/^    void initData(IplImage *src, int widthDivider, int heightDivider);$/;"	p	class:CvAdaptiveSkinDetector	access:protected	signature:(IplImage *src, int widthDivider, int heightDivider)
CvAdaptiveSkinDetector::nFrameCount	contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::nMorphingMethod	contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::nSamplingDivider	contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::nSkinHueLowerBound	contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::nSkinHueUpperBound	contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::nStartCounter	contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::process	contrib/contrib.hpp	/^    virtual void process(IplImage *inputBGRImage, IplImage *outputHueMask);$/;"	p	class:CvAdaptiveSkinDetector	access:public	signature:(IplImage *inputBGRImage, IplImage *outputHueMask)
CvAdaptiveSkinDetector::skinHueHistogram	contrib/contrib.hpp	/^    Histogram histogramHueMotion, skinHueHistogram;$/;"	m	class:CvAdaptiveSkinDetector	access:private
CvAdaptiveSkinDetector::~CvAdaptiveSkinDetector	contrib/contrib.hpp	/^    virtual ~CvAdaptiveSkinDetector();$/;"	p	class:CvAdaptiveSkinDetector	access:public	signature:()
CvAdaptiveThreshMethod	legacy/compat.hpp	/^typedef int CvAdaptiveThreshMethod;$/;"	t
CvAffinePose	features2d/features2d.hpp	/^class CV_EXPORTS CvAffinePose$/;"	c	namespace:cv
CvAllocFunc	core/core_c.h	/^typedef void* (CV_CDECL *CvAllocFunc)(size_t size, void* userdata);$/;"	t
CvArr	core/types_c.h	/^typedef void CvArr;$/;"	t
CvAttrList	core/types_c.h	/^CvAttrList;$/;"	t	typeref:struct:CvAttrList
CvAttrList	core/types_c.h	/^typedef struct CvAttrList$/;"	s
CvAttrList::attr	core/types_c.h	/^    const char** attr;         \/* NULL-terminated array of (attribute_name,attribute_value) pairs. *\/$/;"	m	struct:CvAttrList	access:public
CvAttrList::next	core/types_c.h	/^    struct CvAttrList* next;   \/* Pointer to next chunk of the attributes list.                    *\/$/;"	m	struct:CvAttrList	typeref:struct:CvAttrList::CvAttrList	access:public
CvAvgComp	objdetect/objdetect.hpp	/^typedef struct CvAvgComp$/;"	s
CvAvgComp	objdetect/objdetect.hpp	/^} CvAvgComp;$/;"	t	typeref:struct:CvAvgComp
CvAvgComp::neighbors	objdetect/objdetect.hpp	/^    int neighbors;$/;"	m	struct:CvAvgComp	access:public
CvAvgComp::rect	objdetect/objdetect.hpp	/^    CvRect rect;$/;"	m	struct:CvAvgComp	access:public
CvBGCodeBookElem	video/background_segm.hpp	/^typedef struct CvBGCodeBookElem$/;"	s
CvBGCodeBookElem	video/background_segm.hpp	/^} CvBGCodeBookElem;$/;"	t	typeref:struct:CvBGCodeBookElem
CvBGCodeBookElem::boxMax	video/background_segm.hpp	/^    uchar boxMax[3];$/;"	m	struct:CvBGCodeBookElem	access:public
CvBGCodeBookElem::boxMin	video/background_segm.hpp	/^    uchar boxMin[3];$/;"	m	struct:CvBGCodeBookElem	access:public
CvBGCodeBookElem::learnMax	video/background_segm.hpp	/^    uchar learnMax[3];$/;"	m	struct:CvBGCodeBookElem	access:public
CvBGCodeBookElem::learnMin	video/background_segm.hpp	/^    uchar learnMin[3];$/;"	m	struct:CvBGCodeBookElem	access:public
CvBGCodeBookElem::next	video/background_segm.hpp	/^    struct CvBGCodeBookElem* next;$/;"	m	struct:CvBGCodeBookElem	typeref:struct:CvBGCodeBookElem::CvBGCodeBookElem	access:public
CvBGCodeBookElem::stale	video/background_segm.hpp	/^    int stale;$/;"	m	struct:CvBGCodeBookElem	access:public
CvBGCodeBookElem::tLastUpdate	video/background_segm.hpp	/^    int tLastUpdate;$/;"	m	struct:CvBGCodeBookElem	access:public
CvBGCodeBookModel	video/background_segm.hpp	/^typedef struct CvBGCodeBookModel$/;"	s
CvBGCodeBookModel	video/background_segm.hpp	/^} CvBGCodeBookModel;$/;"	t	typeref:struct:CvBGCodeBookModel
CvBGCodeBookModel::cbBounds	video/background_segm.hpp	/^    uchar cbBounds[3];$/;"	m	struct:CvBGCodeBookModel	access:public
CvBGCodeBookModel::cbmap	video/background_segm.hpp	/^    CvBGCodeBookElem** cbmap;$/;"	m	struct:CvBGCodeBookModel	access:public
CvBGCodeBookModel::freeList	video/background_segm.hpp	/^    CvBGCodeBookElem* freeList;$/;"	m	struct:CvBGCodeBookModel	access:public
CvBGCodeBookModel::modMax	video/background_segm.hpp	/^    uchar modMax[3];$/;"	m	struct:CvBGCodeBookModel	access:public
CvBGCodeBookModel::modMin	video/background_segm.hpp	/^    uchar modMin[3];$/;"	m	struct:CvBGCodeBookModel	access:public
CvBGCodeBookModel::size	video/background_segm.hpp	/^    CvSize size;$/;"	m	struct:CvBGCodeBookModel	access:public
CvBGCodeBookModel::storage	video/background_segm.hpp	/^    CvMemStorage* storage;$/;"	m	struct:CvBGCodeBookModel	access:public
CvBGCodeBookModel::t	video/background_segm.hpp	/^    int t;$/;"	m	struct:CvBGCodeBookModel	access:public
CvBGPixelCCStatTable	video/background_segm.hpp	/^typedef struct CvBGPixelCCStatTable$/;"	s
CvBGPixelCCStatTable	video/background_segm.hpp	/^} CvBGPixelCCStatTable;$/;"	t	typeref:struct:CvBGPixelCCStatTable
CvBGPixelCCStatTable::Pv	video/background_segm.hpp	/^    float          Pv, Pvb;$/;"	m	struct:CvBGPixelCCStatTable	access:public
CvBGPixelCCStatTable::Pvb	video/background_segm.hpp	/^    float          Pv, Pvb;$/;"	m	struct:CvBGPixelCCStatTable	access:public
CvBGPixelCCStatTable::v	video/background_segm.hpp	/^    uchar          v[6];$/;"	m	struct:CvBGPixelCCStatTable	access:public
CvBGPixelCStatTable	video/background_segm.hpp	/^typedef struct CvBGPixelCStatTable$/;"	s
CvBGPixelCStatTable	video/background_segm.hpp	/^} CvBGPixelCStatTable;$/;"	t	typeref:struct:CvBGPixelCStatTable
CvBGPixelCStatTable::Pv	video/background_segm.hpp	/^    float          Pv, Pvb;$/;"	m	struct:CvBGPixelCStatTable	access:public
CvBGPixelCStatTable::Pvb	video/background_segm.hpp	/^    float          Pv, Pvb;$/;"	m	struct:CvBGPixelCStatTable	access:public
CvBGPixelCStatTable::v	video/background_segm.hpp	/^    uchar          v[3];$/;"	m	struct:CvBGPixelCStatTable	access:public
CvBGPixelStat	video/background_segm.hpp	/^typedef struct CvBGPixelStat$/;"	s
CvBGPixelStat	video/background_segm.hpp	/^} CvBGPixelStat;$/;"	t	typeref:struct:CvBGPixelStat
CvBGPixelStat::Pbc	video/background_segm.hpp	/^    float                 Pbc;$/;"	m	struct:CvBGPixelStat	access:public
CvBGPixelStat::Pbcc	video/background_segm.hpp	/^    float                 Pbcc;$/;"	m	struct:CvBGPixelStat	access:public
CvBGPixelStat::cctable	video/background_segm.hpp	/^    CvBGPixelCCStatTable* cctable;$/;"	m	struct:CvBGPixelStat	access:public
CvBGPixelStat::ctable	video/background_segm.hpp	/^    CvBGPixelCStatTable*  ctable;$/;"	m	struct:CvBGPixelStat	access:public
CvBGPixelStat::is_trained_dyn_model	video/background_segm.hpp	/^    uchar                 is_trained_dyn_model;$/;"	m	struct:CvBGPixelStat	access:public
CvBGPixelStat::is_trained_st_model	video/background_segm.hpp	/^    uchar                 is_trained_st_model;$/;"	m	struct:CvBGPixelStat	access:public
CvBGStatModel	video/background_segm.hpp	/^typedef struct CvBGStatModel$/;"	s
CvBGStatModel	video/background_segm.hpp	/^} CvBGStatModel;$/;"	t	typeref:struct:CvBGStatModel
CvBGStatModel::CV_BG_STAT_MODEL_FIELDS	video/background_segm.hpp	/^    CV_BG_STAT_MODEL_FIELDS();$/;"	p	struct:CvBGStatModel	access:public	signature:()
CvBigFuncTable	core/internal.hpp	/^CvBigFuncTable;$/;"	t	typeref:struct:CvBigFuncTable
CvBigFuncTable	core/internal.hpp	/^typedef struct CvBigFuncTable$/;"	s
CvBigFuncTable::fn_2d	core/internal.hpp	/^    void*   fn_2d[CV_DEPTH_MAX*4];$/;"	m	struct:CvBigFuncTable	access:public
CvBlob	legacy/blobtrack.hpp	/^struct CvBlob$/;"	s
CvBlob::ID	legacy/blobtrack.hpp	/^    int     ID;  \/* blob ID         *\/$/;"	m	struct:CvBlob	access:public
CvBlob::h	legacy/blobtrack.hpp	/^    float   w,h; \/* blob sizes      *\/$/;"	m	struct:CvBlob	access:public
CvBlob::w	legacy/blobtrack.hpp	/^    float   w,h; \/* blob sizes      *\/$/;"	m	struct:CvBlob	access:public
CvBlob::x	legacy/blobtrack.hpp	/^    float   x,y; \/* blob position   *\/$/;"	m	struct:CvBlob	access:public
CvBlob::y	legacy/blobtrack.hpp	/^    float   x,y; \/* blob position   *\/$/;"	m	struct:CvBlob	access:public
CvBlobDetector	legacy/blobtrack.hpp	/^	CvBlobDetector(){SetTypeName("BlobDetector");};$/;"	f	class:CvBlobDetector	access:public	signature:()
CvBlobDetector	legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobDetector: public CvVSModule$/;"	c	inherits:CvVSModule
CvBlobDetector::CvBlobDetector	legacy/blobtrack.hpp	/^	CvBlobDetector(){SetTypeName("BlobDetector");};$/;"	f	class:CvBlobDetector	access:public	signature:()
CvBlobDetector::DetectNewBlob	legacy/blobtrack.hpp	/^    virtual int DetectNewBlob(IplImage* pImg, IplImage* pImgFG, CvBlobSeq* pNewBlobList, CvBlobSeq* pOldBlobList) = 0;$/;"	p	class:CvBlobDetector	access:public	signature:(IplImage* pImg, IplImage* pImgFG, CvBlobSeq* pNewBlobList, CvBlobSeq* pOldBlobList)
CvBlobDetector::Release	legacy/blobtrack.hpp	/^    virtual void Release()=0;$/;"	p	class:CvBlobDetector	access:public	signature:()
CvBlobSeq	legacy/blobtrack.hpp	/^    CvBlobSeq(int BlobSize = sizeof(CvBlob))$/;"	f	class:CvBlobSeq	access:public	signature:(int BlobSize = sizeof(CvBlob))
CvBlobSeq	legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobSeq$/;"	c
CvBlobSeq::AddBlob	legacy/blobtrack.hpp	/^    virtual void AddBlob(CvBlob* pB)$/;"	f	class:CvBlobSeq	access:public	signature:(CvBlob* pB)
CvBlobSeq::AddFormat	legacy/blobtrack.hpp	/^    void AddFormat(const char* str){strcat(m_pElemFormat,str);}$/;"	f	class:CvBlobSeq	access:public	signature:(const char* str)
CvBlobSeq::Clear	legacy/blobtrack.hpp	/^    virtual void Clear()$/;"	f	class:CvBlobSeq	access:public	signature:()
CvBlobSeq::CvBlobSeq	legacy/blobtrack.hpp	/^    CvBlobSeq(int BlobSize = sizeof(CvBlob))$/;"	f	class:CvBlobSeq	access:public	signature:(int BlobSize = sizeof(CvBlob))
CvBlobSeq::DelBlob	legacy/blobtrack.hpp	/^    virtual void DelBlob(int BlobIndex)$/;"	f	class:CvBlobSeq	access:public	signature:(int BlobIndex)
CvBlobSeq::DelBlobByID	legacy/blobtrack.hpp	/^    virtual void DelBlobByID(int BlobID)$/;"	f	class:CvBlobSeq	access:public	signature:(int BlobID)
CvBlobSeq::GetBlob	legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlob(int BlobIndex)$/;"	f	class:CvBlobSeq	access:public	signature:(int BlobIndex)
CvBlobSeq::GetBlobByID	legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlobByID(int BlobID)$/;"	f	class:CvBlobSeq	access:public	signature:(int BlobID)
CvBlobSeq::GetBlobNum	legacy/blobtrack.hpp	/^    virtual int GetBlobNum()$/;"	f	class:CvBlobSeq	access:public	signature:()
CvBlobSeq::Load	legacy/blobtrack.hpp	/^    virtual void Load(CvFileStorage* fs, CvFileNode* node)$/;"	f	class:CvBlobSeq	access:public	signature:(CvFileStorage* fs, CvFileNode* node)
CvBlobSeq::Write	legacy/blobtrack.hpp	/^    virtual void Write(CvFileStorage* fs, const char* name)$/;"	f	class:CvBlobSeq	access:public	signature:(CvFileStorage* fs, const char* name)
CvBlobSeq::m_pElemFormat	legacy/blobtrack.hpp	/^    char            m_pElemFormat[1024];$/;"	m	class:CvBlobSeq	access:protected
CvBlobSeq::m_pMem	legacy/blobtrack.hpp	/^    CvMemStorage*   m_pMem;$/;"	m	class:CvBlobSeq	access:protected
CvBlobSeq::m_pSeq	legacy/blobtrack.hpp	/^    CvSeq*          m_pSeq;$/;"	m	class:CvBlobSeq	access:protected
CvBlobSeq::~CvBlobSeq	legacy/blobtrack.hpp	/^    virtual ~CvBlobSeq()$/;"	f	class:CvBlobSeq	access:public	signature:()
CvBlobTrack	legacy/blobtrack.hpp	/^struct CvBlobTrack$/;"	s
CvBlobTrack::StartFrame	legacy/blobtrack.hpp	/^    int         StartFrame;$/;"	m	struct:CvBlobTrack	access:public
CvBlobTrack::TrackID	legacy/blobtrack.hpp	/^    int         TrackID;$/;"	m	struct:CvBlobTrack	access:public
CvBlobTrack::pBlobSeq	legacy/blobtrack.hpp	/^    CvBlobSeq*  pBlobSeq;$/;"	m	struct:CvBlobTrack	access:public
CvBlobTrackAnalysis	legacy/blobtrack.hpp	/^	CvBlobTrackAnalysis(){SetTypeName("BlobTrackAnalysis");};$/;"	f	class:CvBlobTrackAnalysis	access:public	signature:()
CvBlobTrackAnalysis	legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobTrackAnalysis: public CvVSModule$/;"	c	inherits:CvVSModule
CvBlobTrackAnalysis::AddBlob	legacy/blobtrack.hpp	/^    virtual void    AddBlob(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackAnalysis	access:public	signature:(CvBlob* pBlob)
CvBlobTrackAnalysis::CvBlobTrackAnalysis	legacy/blobtrack.hpp	/^	CvBlobTrackAnalysis(){SetTypeName("BlobTrackAnalysis");};$/;"	f	class:CvBlobTrackAnalysis	access:public	signature:()
CvBlobTrackAnalysis::GetState	legacy/blobtrack.hpp	/^    virtual float   GetState(int BlobID) = 0;$/;"	p	class:CvBlobTrackAnalysis	access:public	signature:(int BlobID)
CvBlobTrackAnalysis::GetStateDesc	legacy/blobtrack.hpp	/^    virtual const char*   GetStateDesc(int \/*BlobID*\/){return NULL;};$/;"	f	class:CvBlobTrackAnalysis	access:public	signature:(int )
CvBlobTrackAnalysis::Process	legacy/blobtrack.hpp	/^    virtual void    Process(IplImage* pImg, IplImage* pFG) = 0;$/;"	p	class:CvBlobTrackAnalysis	access:public	signature:(IplImage* pImg, IplImage* pFG)
CvBlobTrackAnalysis::Release	legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackAnalysis	access:public	signature:()
CvBlobTrackAnalysis::SetFileName	legacy/blobtrack.hpp	/^    virtual void    SetFileName(char* \/*DataBaseName*\/){};$/;"	f	class:CvBlobTrackAnalysis	access:public	signature:(char* )
CvBlobTrackAnalysisHeight	legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobTrackAnalysisHeight: public CvBlobTrackAnalysis$/;"	c	inherits:CvBlobTrackAnalysis
CvBlobTrackAnalysisHeight::GetHeight	legacy/blobtrack.hpp	/^    virtual double  GetHeight(CvBlob* pB) = 0;$/;"	p	class:CvBlobTrackAnalysisHeight	access:public	signature:(CvBlob* pB)
CvBlobTrackAnalysisOne	legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobTrackAnalysisOne$/;"	c
CvBlobTrackAnalysisOne::Process	legacy/blobtrack.hpp	/^    virtual int     Process(CvBlob* pBlob, IplImage* pImg, IplImage* pFG) = 0;$/;"	p	class:CvBlobTrackAnalysisOne	access:public	signature:(CvBlob* pBlob, IplImage* pImg, IplImage* pFG)
CvBlobTrackAnalysisOne::Release	legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackAnalysisOne	access:public	signature:()
CvBlobTrackAnalysisOne::~CvBlobTrackAnalysisOne	legacy/blobtrack.hpp	/^    virtual ~CvBlobTrackAnalysisOne() {};$/;"	f	class:CvBlobTrackAnalysisOne	access:public	signature:()
CvBlobTrackFVGen	legacy/blobtrack.hpp	/^	CvBlobTrackFVGen(){SetTypeName("BlobTrackFVGen");};$/;"	f	class:CvBlobTrackFVGen	access:public	signature:()
CvBlobTrackFVGen	legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobTrackFVGen : public CvVSModule$/;"	c	inherits:CvVSModule
CvBlobTrackFVGen::AddBlob	legacy/blobtrack.hpp	/^    virtual void    AddBlob(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackFVGen	access:public	signature:(CvBlob* pBlob)
CvBlobTrackFVGen::CvBlobTrackFVGen	legacy/blobtrack.hpp	/^	CvBlobTrackFVGen(){SetTypeName("BlobTrackFVGen");};$/;"	f	class:CvBlobTrackFVGen	access:public	signature:()
CvBlobTrackFVGen::GetFV	legacy/blobtrack.hpp	/^    virtual float*  GetFV(int index, int* pFVID) = 0; \/* Returns pointer to FV, if return 0 then FV not created *\/$/;"	p	class:CvBlobTrackFVGen	access:public	signature:(int index, int* pFVID)
CvBlobTrackFVGen::GetFVMax	legacy/blobtrack.hpp	/^    virtual float*  GetFVMax() = 0; \/* Returns pointer to array of maximal values of FV, if returns 0 then FVrange does not exist *\/$/;"	p	class:CvBlobTrackFVGen	access:public	signature:()
CvBlobTrackFVGen::GetFVMin	legacy/blobtrack.hpp	/^    virtual float*  GetFVMin() = 0; \/* Returns pointer to array of minimal values of FV, if returns 0 then FVrange does not exist *\/$/;"	p	class:CvBlobTrackFVGen	access:public	signature:()
CvBlobTrackFVGen::GetFVNum	legacy/blobtrack.hpp	/^    virtual int     GetFVNum() = 0;$/;"	p	class:CvBlobTrackFVGen	access:public	signature:()
CvBlobTrackFVGen::GetFVSize	legacy/blobtrack.hpp	/^    virtual int     GetFVSize() = 0;$/;"	p	class:CvBlobTrackFVGen	access:public	signature:()
CvBlobTrackFVGen::GetFVVar	legacy/blobtrack.hpp	/^    virtual float*  GetFVVar(){return NULL;}; \/* Returns pointer to array of variation of values of FV, if returns 0 then FVVar does not exist. *\/$/;"	f	class:CvBlobTrackFVGen	access:public	signature:()
CvBlobTrackFVGen::Process	legacy/blobtrack.hpp	/^    virtual void    Process(IplImage* pImg, IplImage* pFG) = 0;$/;"	p	class:CvBlobTrackFVGen	access:public	signature:(IplImage* pImg, IplImage* pFG)
CvBlobTrackFVGen::Release	legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackFVGen	access:public	signature:()
CvBlobTrackGen	legacy/blobtrack.hpp	/^	CvBlobTrackGen(){SetTypeName("BlobTrackGen");};$/;"	f	class:CvBlobTrackGen	access:public	signature:()
CvBlobTrackGen	legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobTrackGen: public CvVSModule$/;"	c	inherits:CvVSModule
CvBlobTrackGen::AddBlob	legacy/blobtrack.hpp	/^    virtual void    AddBlob(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackGen	access:public	signature:(CvBlob* pBlob)
CvBlobTrackGen::CvBlobTrackGen	legacy/blobtrack.hpp	/^	CvBlobTrackGen(){SetTypeName("BlobTrackGen");};$/;"	f	class:CvBlobTrackGen	access:public	signature:()
CvBlobTrackGen::Process	legacy/blobtrack.hpp	/^    virtual void    Process(IplImage* pImg = NULL, IplImage* pFG = NULL) = 0;$/;"	p	class:CvBlobTrackGen	access:public	signature:(IplImage* pImg = NULL, IplImage* pFG = NULL)
CvBlobTrackGen::Release	legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackGen	access:public	signature:()
CvBlobTrackGen::SetFileName	legacy/blobtrack.hpp	/^    virtual void    SetFileName(char* pFileName) = 0;$/;"	p	class:CvBlobTrackGen	access:public	signature:(char* pFileName)
CvBlobTrackPostProc	legacy/blobtrack.hpp	/^	CvBlobTrackPostProc(){SetTypeName("BlobTrackPostProc");};$/;"	f	class:CvBlobTrackPostProc	access:public	signature:()
CvBlobTrackPostProc	legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobTrackPostProc: public CvVSModule$/;"	c	inherits:CvVSModule
CvBlobTrackPostProc::AddBlob	legacy/blobtrack.hpp	/^    virtual void    AddBlob(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackPostProc	access:public	signature:(CvBlob* pBlob)
CvBlobTrackPostProc::CvBlobTrackPostProc	legacy/blobtrack.hpp	/^	CvBlobTrackPostProc(){SetTypeName("BlobTrackPostProc");};$/;"	f	class:CvBlobTrackPostProc	access:public	signature:()
CvBlobTrackPostProc::GetBlob	legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlob(int index) = 0;$/;"	p	class:CvBlobTrackPostProc	access:public	signature:(int index)
CvBlobTrackPostProc::GetBlobByID	legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlobByID(int BlobID)$/;"	f	class:CvBlobTrackPostProc	access:public	signature:(int BlobID)
CvBlobTrackPostProc::GetBlobNum	legacy/blobtrack.hpp	/^    virtual int     GetBlobNum() = 0;$/;"	p	class:CvBlobTrackPostProc	access:public	signature:()
CvBlobTrackPostProc::Process	legacy/blobtrack.hpp	/^    virtual void    Process() = 0;$/;"	p	class:CvBlobTrackPostProc	access:public	signature:()
CvBlobTrackPostProc::Release	legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackPostProc	access:public	signature:()
CvBlobTrackPostProcOne	legacy/blobtrack.hpp	/^	CvBlobTrackPostProcOne(){SetTypeName("BlobTrackPostOne");};$/;"	f	class:CvBlobTrackPostProcOne	access:public	signature:()
CvBlobTrackPostProcOne	legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobTrackPostProcOne: public CvVSModule$/;"	c	inherits:CvVSModule
CvBlobTrackPostProcOne::CvBlobTrackPostProcOne	legacy/blobtrack.hpp	/^	CvBlobTrackPostProcOne(){SetTypeName("BlobTrackPostOne");};$/;"	f	class:CvBlobTrackPostProcOne	access:public	signature:()
CvBlobTrackPostProcOne::Process	legacy/blobtrack.hpp	/^    virtual CvBlob* Process(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackPostProcOne	access:public	signature:(CvBlob* pBlob)
CvBlobTrackPostProcOne::Release	legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackPostProcOne	access:public	signature:()
CvBlobTrackPredictor	legacy/blobtrack.hpp	/^	CvBlobTrackPredictor(){SetTypeName("BlobTrackPredictor");};$/;"	f	class:CvBlobTrackPredictor	access:public	signature:()
CvBlobTrackPredictor	legacy/blobtrack.hpp	/^class CvBlobTrackPredictor: public CvVSModule$/;"	c	inherits:CvVSModule
CvBlobTrackPredictor::CvBlobTrackPredictor	legacy/blobtrack.hpp	/^	CvBlobTrackPredictor(){SetTypeName("BlobTrackPredictor");};$/;"	f	class:CvBlobTrackPredictor	access:public	signature:()
CvBlobTrackPredictor::Predict	legacy/blobtrack.hpp	/^    virtual CvBlob* Predict() = 0;$/;"	p	class:CvBlobTrackPredictor	access:public	signature:()
CvBlobTrackPredictor::Release	legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackPredictor	access:public	signature:()
CvBlobTrackPredictor::Update	legacy/blobtrack.hpp	/^    virtual void    Update(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackPredictor	access:public	signature:(CvBlob* pBlob)
CvBlobTrackSeq	legacy/blobtrack.hpp	/^    CvBlobTrackSeq(int TrackSize = sizeof(CvBlobTrack));$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackSize = sizeof(CvBlobTrack))
CvBlobTrackSeq	legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobTrackSeq$/;"	c
CvBlobTrackSeq::AddBlobTrack	legacy/blobtrack.hpp	/^    virtual void AddBlobTrack(int TrackID, int StartFrame = 0);$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackID, int StartFrame = 0)
CvBlobTrackSeq::Clear	legacy/blobtrack.hpp	/^    virtual void Clear();$/;"	p	class:CvBlobTrackSeq	access:public	signature:()
CvBlobTrackSeq::CvBlobTrackSeq	legacy/blobtrack.hpp	/^    CvBlobTrackSeq(int TrackSize = sizeof(CvBlobTrack));$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackSize = sizeof(CvBlobTrack))
CvBlobTrackSeq::DelBlobTrack	legacy/blobtrack.hpp	/^    virtual void DelBlobTrack(int TrackIndex);$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackIndex)
CvBlobTrackSeq::DelBlobTrackByID	legacy/blobtrack.hpp	/^    virtual void DelBlobTrackByID(int TrackID);$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackID)
CvBlobTrackSeq::GetBlobTrack	legacy/blobtrack.hpp	/^    virtual CvBlobTrack* GetBlobTrack(int TrackIndex);$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackIndex)
CvBlobTrackSeq::GetBlobTrackByID	legacy/blobtrack.hpp	/^    virtual CvBlobTrack* GetBlobTrackByID(int TrackID);$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackID)
CvBlobTrackSeq::GetBlobTrackNum	legacy/blobtrack.hpp	/^    virtual int GetBlobTrackNum();$/;"	p	class:CvBlobTrackSeq	access:public	signature:()
CvBlobTrackSeq::m_pMem	legacy/blobtrack.hpp	/^    CvMemStorage*   m_pMem;$/;"	m	class:CvBlobTrackSeq	access:protected
CvBlobTrackSeq::m_pSeq	legacy/blobtrack.hpp	/^    CvSeq*          m_pSeq;$/;"	m	class:CvBlobTrackSeq	access:protected
CvBlobTrackSeq::~CvBlobTrackSeq	legacy/blobtrack.hpp	/^    virtual ~CvBlobTrackSeq();$/;"	p	class:CvBlobTrackSeq	access:public	signature:()
CvBlobTracker	legacy/blobtrack.hpp	/^    CvBlobTracker();$/;"	p	class:CvBlobTracker	access:public	signature:()
CvBlobTracker	legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobTracker: public CvVSModule$/;"	c	inherits:CvVSModule
CvBlobTracker::AddBlob	legacy/blobtrack.hpp	/^    virtual CvBlob* AddBlob(CvBlob* pBlob, IplImage* pImg, IplImage* pImgFG = NULL ) = 0;$/;"	p	class:CvBlobTracker	access:public	signature:(CvBlob* pBlob, IplImage* pImg, IplImage* pImgFG = NULL )
CvBlobTracker::CvBlobTracker	legacy/blobtrack.hpp	/^    CvBlobTracker();$/;"	p	class:CvBlobTracker	access:public	signature:()
CvBlobTracker::DelBlob	legacy/blobtrack.hpp	/^    virtual void    DelBlob(int BlobIndex) = 0;$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobIndex)
CvBlobTracker::DelBlobByID	legacy/blobtrack.hpp	/^    virtual void    DelBlobByID(int BlobID);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobID)
CvBlobTracker::GetBlob	legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlob(int BlobIndex) = 0;$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobIndex)
CvBlobTracker::GetBlobByID	legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlobByID(int BlobID);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobID)
CvBlobTracker::GetBlobHyp	legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlobHyp(int BlobIndex, int \/*hypothesis*\/);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobIndex, int )
CvBlobTracker::GetBlobHypNum	legacy/blobtrack.hpp	/^    virtual int     GetBlobHypNum(int \/*BlobIdx*\/);$/;"	p	class:CvBlobTracker	access:public	signature:(int )
CvBlobTracker::GetBlobIndexByID	legacy/blobtrack.hpp	/^    virtual int     GetBlobIndexByID(int BlobID);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobID)
CvBlobTracker::GetBlobNum	legacy/blobtrack.hpp	/^    virtual int     GetBlobNum() = 0;$/;"	p	class:CvBlobTracker	access:public	signature:()
CvBlobTracker::GetConfidence	legacy/blobtrack.hpp	/^    virtual double  GetConfidence(int \/*BlobIndex*\/, CvBlob* \/*pBlob*\/, IplImage* \/*pImg*\/, IplImage* \/*pImgFG*\/ = NULL);$/;"	p	class:CvBlobTracker	access:public	signature:(int , CvBlob* , IplImage* , IplImage* = NULL)
CvBlobTracker::GetConfidenceList	legacy/blobtrack.hpp	/^    virtual double GetConfidenceList(CvBlobSeq* pBlobList, IplImage* pImg, IplImage* pImgFG = NULL);$/;"	p	class:CvBlobTracker	access:public	signature:(CvBlobSeq* pBlobList, IplImage* pImg, IplImage* pImgFG = NULL)
CvBlobTracker::Process	legacy/blobtrack.hpp	/^    virtual void    Process(IplImage* pImg, IplImage* pImgFG = NULL) = 0;$/;"	p	class:CvBlobTracker	access:public	signature:(IplImage* pImg, IplImage* pImgFG = NULL)
CvBlobTracker::ProcessBlob	legacy/blobtrack.hpp	/^    virtual void ProcessBlob(int BlobIndex, CvBlob* pBlob, IplImage* \/*pImg*\/, IplImage* \/*pImgFG*\/ = NULL);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobIndex, CvBlob* pBlob, IplImage* , IplImage* = NULL)
CvBlobTracker::Release	legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTracker	access:public	signature:()
CvBlobTracker::SetBlob	legacy/blobtrack.hpp	/^    virtual void    SetBlob(int \/*BlobIndex*\/, CvBlob* \/*pBlob*\/);$/;"	p	class:CvBlobTracker	access:public	signature:(int , CvBlob* )
CvBlobTracker::SetBlobByID	legacy/blobtrack.hpp	/^    virtual void    SetBlobByID(int BlobID, CvBlob* pBlob);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobID, CvBlob* pBlob)
CvBlobTracker::SetBlobHyp	legacy/blobtrack.hpp	/^    virtual void    SetBlobHyp(int \/*BlobIndex*\/, CvBlob* \/*pBlob*\/);$/;"	p	class:CvBlobTracker	access:public	signature:(int , CvBlob* )
CvBlobTracker::Update	legacy/blobtrack.hpp	/^    virtual void Update(IplImage* pImg, IplImage* pImgFG = NULL);$/;"	p	class:CvBlobTracker	access:public	signature:(IplImage* pImg, IplImage* pImgFG = NULL)
CvBlobTracker::UpdateBlob	legacy/blobtrack.hpp	/^    virtual void UpdateBlob(int \/*BlobIndex*\/, CvBlob* \/*pBlob*\/, IplImage* \/*pImg*\/, IplImage* \/*pImgFG*\/ = NULL);$/;"	p	class:CvBlobTracker	access:public	signature:(int , CvBlob* , IplImage* , IplImage* = NULL)
CvBlobTrackerAuto	legacy/blobtrack.hpp	/^	CvBlobTrackerAuto(){SetTypeName("BlobTrackerAuto");};$/;"	f	class:CvBlobTrackerAuto	access:public	signature:()
CvBlobTrackerAuto	legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobTrackerAuto: public CvVSModule$/;"	c	inherits:CvVSModule
CvBlobTrackerAuto::CvBlobTrackerAuto	legacy/blobtrack.hpp	/^	CvBlobTrackerAuto(){SetTypeName("BlobTrackerAuto");};$/;"	f	class:CvBlobTrackerAuto	access:public	signature:()
CvBlobTrackerAuto::GetBlob	legacy/blobtrack.hpp	/^    virtual CvBlob*     GetBlob(int index) = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:(int index)
CvBlobTrackerAuto::GetBlobByID	legacy/blobtrack.hpp	/^    virtual CvBlob*     GetBlobByID(int ID) = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:(int ID)
CvBlobTrackerAuto::GetBlobNum	legacy/blobtrack.hpp	/^    virtual int         GetBlobNum() = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:()
CvBlobTrackerAuto::GetFGMask	legacy/blobtrack.hpp	/^    virtual IplImage*   GetFGMask(){return NULL;};$/;"	f	class:CvBlobTrackerAuto	access:public	signature:()
CvBlobTrackerAuto::GetState	legacy/blobtrack.hpp	/^    virtual float       GetState(int BlobID) = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:(int BlobID)
CvBlobTrackerAuto::GetStateDesc	legacy/blobtrack.hpp	/^    virtual const char*       GetStateDesc(int BlobID) = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:(int BlobID)
CvBlobTrackerAuto::Process	legacy/blobtrack.hpp	/^    virtual void        Process(IplImage* pImg, IplImage* pMask = NULL) = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:(IplImage* pImg, IplImage* pMask = NULL)
CvBlobTrackerAuto::Release	legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:()
CvBlobTrackerAutoParam1	legacy/blobtrack.hpp	/^struct CvBlobTrackerAutoParam1$/;"	s
CvBlobTrackerAutoParam1::FGTrainFrames	legacy/blobtrack.hpp	/^    int                     FGTrainFrames; \/* Number of frames needed for FG (foreground) detector to train.        *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
CvBlobTrackerAutoParam1::UsePPData	legacy/blobtrack.hpp	/^    int                     UsePPData;$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
CvBlobTrackerAutoParam1::pBD	legacy/blobtrack.hpp	/^    CvBlobDetector*         pBD;           \/* Selected blob detector module. 					    *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
CvBlobTrackerAutoParam1::pBT	legacy/blobtrack.hpp	/^    CvBlobTracker*          pBT;           \/* Selected blob tracking module.					    *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
CvBlobTrackerAutoParam1::pBTA	legacy/blobtrack.hpp	/^    CvBlobTrackAnalysis*    pBTA;          \/* Selected blob trajectory analysis module.                             *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
CvBlobTrackerAutoParam1::pBTGen	legacy/blobtrack.hpp	/^    CvBlobTrackGen*         pBTGen;        \/* Selected blob trajectory generator.				    *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
CvBlobTrackerAutoParam1::pBTPP	legacy/blobtrack.hpp	/^    CvBlobTrackPostProc*    pBTPP;         \/* Selected blob trajectory postprocessing module.			    *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
CvBlobTrackerAutoParam1::pFG	legacy/blobtrack.hpp	/^    CvFGDetector*           pFG;           \/* FGDetector module. If this field is NULL the Process FG mask is used. *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
CvBlobTrackerOne	legacy/blobtrack.hpp	/^class CV_EXPORTS CvBlobTrackerOne : public CvVSModule$/;"	c	inherits:CvVSModule
CvBlobTrackerOne::GetConfidence	legacy/blobtrack.hpp	/^    virtual double GetConfidence(CvBlob* \/*pBlob*\/, IplImage* \/*pImg*\/,$/;"	f	class:CvBlobTrackerOne	access:public	signature:(CvBlob* , IplImage* , IplImage* = NULL, IplImage* = NULL)
CvBlobTrackerOne::Init	legacy/blobtrack.hpp	/^    virtual void Init(CvBlob* pBlobInit, IplImage* pImg, IplImage* pImgFG = NULL) = 0;$/;"	p	class:CvBlobTrackerOne	access:public	signature:(CvBlob* pBlobInit, IplImage* pImg, IplImage* pImgFG = NULL)
CvBlobTrackerOne::Process	legacy/blobtrack.hpp	/^    virtual CvBlob* Process(CvBlob* pBlobPrev, IplImage* pImg, IplImage* pImgFG = NULL) = 0;$/;"	p	class:CvBlobTrackerOne	access:public	signature:(CvBlob* pBlobPrev, IplImage* pImg, IplImage* pImgFG = NULL)
CvBlobTrackerOne::Release	legacy/blobtrack.hpp	/^    virtual void Release() =  0;$/;"	p	class:CvBlobTrackerOne	access:public	signature:()
CvBlobTrackerOne::SetCollision	legacy/blobtrack.hpp	/^    virtual void SetCollision(int \/*CollisionFlag*\/){}; \/* call in case of blob collision situation*\/$/;"	f	class:CvBlobTrackerOne	access:public	signature:(int )
CvBlobTrackerOne::SkipProcess	legacy/blobtrack.hpp	/^    virtual void SkipProcess(CvBlob* \/*pBlobPrev*\/, IplImage* \/*pImg*\/, IplImage* \/*pImgFG*\/ = NULL){};$/;"	f	class:CvBlobTrackerOne	access:public	signature:(CvBlob* , IplImage* , IplImage* = NULL)
CvBlobTrackerOne::Update	legacy/blobtrack.hpp	/^    virtual void Update(CvBlob* \/*pBlob*\/, IplImage* \/*pImg*\/, IplImage* \/*pImgFG*\/ = NULL){};$/;"	f	class:CvBlobTrackerOne	access:public	signature:(CvBlob* , IplImage* , IplImage* = NULL)
CvBlobTrackerParamLH	legacy/blobtrack.hpp	/^struct CvBlobTrackerParamLH$/;"	s
CvBlobTrackerParamLH::HistType	legacy/blobtrack.hpp	/^    int     HistType; \/* see Prob.h *\/$/;"	m	struct:CvBlobTrackerParamLH	access:public
CvBlobTrackerParamLH::ScaleAfter	legacy/blobtrack.hpp	/^    int     ScaleAfter;$/;"	m	struct:CvBlobTrackerParamLH	access:public
CvBlobTrackerParamMS	legacy/blobtrack.hpp	/^struct CvBlobTrackerParamMS$/;"	s
CvBlobTrackerParamMS::appearance_profile	legacy/blobtrack.hpp	/^    int     appearance_profile;$/;"	m	struct:CvBlobTrackerParamMS	access:public
CvBlobTrackerParamMS::meanshift_profile	legacy/blobtrack.hpp	/^    int     meanshift_profile;$/;"	m	struct:CvBlobTrackerParamMS	access:public
CvBlobTrackerParamMS::noOfSigBits	legacy/blobtrack.hpp	/^    int     noOfSigBits;$/;"	m	struct:CvBlobTrackerParamMS	access:public
CvBlobTrackerParamMS::sigma	legacy/blobtrack.hpp	/^    float   sigma;$/;"	m	struct:CvBlobTrackerParamMS	access:public
CvBool	legacy/legacy.hpp	/^typedef unsigned char CvBool;$/;"	t
CvBoost	ml/ml.hpp	/^    CV_WRAP CvBoost( const cv::Mat& trainData, int tflag,$/;"	p	class:CvBoost	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvBoostParams params=CvBoostParams() )
CvBoost	ml/ml.hpp	/^    CV_WRAP CvBoost();$/;"	p	class:CvBoost	access:public	signature:()
CvBoost	ml/ml.hpp	/^    CvBoost( const CvMat* trainData, int tflag,$/;"	p	class:CvBoost	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvBoostParams params=CvBoostParams() )
CvBoost	ml/ml.hpp	/^class CV_EXPORTS_W CvBoost : public CvStatModel$/;"	c	inherits:CvStatModel
CvBoost::CvBoost	ml/ml.hpp	/^    CV_WRAP CvBoost( const cv::Mat& trainData, int tflag,$/;"	p	class:CvBoost	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvBoostParams params=CvBoostParams() )
CvBoost::CvBoost	ml/ml.hpp	/^    CV_WRAP CvBoost();$/;"	p	class:CvBoost	access:public	signature:()
CvBoost::CvBoost	ml/ml.hpp	/^    CvBoost( const CvMat* trainData, int tflag,$/;"	p	class:CvBoost	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvBoostParams params=CvBoostParams() )
CvBoost::DEFAULT	ml/ml.hpp	/^    enum { DEFAULT=0, GINI=1, MISCLASS=3, SQERR=4 };$/;"	e	enum:CvBoost::__anon80
CvBoost::DISCRETE	ml/ml.hpp	/^    enum { DISCRETE=0, REAL=1, LOGIT=2, GENTLE=3 };$/;"	e	enum:CvBoost::__anon79
CvBoost::GENTLE	ml/ml.hpp	/^    enum { DISCRETE=0, REAL=1, LOGIT=2, GENTLE=3 };$/;"	e	enum:CvBoost::__anon79
CvBoost::GINI	ml/ml.hpp	/^    enum { DEFAULT=0, GINI=1, MISCLASS=3, SQERR=4 };$/;"	e	enum:CvBoost::__anon80
CvBoost::LOGIT	ml/ml.hpp	/^    enum { DISCRETE=0, REAL=1, LOGIT=2, GENTLE=3 };$/;"	e	enum:CvBoost::__anon79
CvBoost::MISCLASS	ml/ml.hpp	/^    enum { DEFAULT=0, GINI=1, MISCLASS=3, SQERR=4 };$/;"	e	enum:CvBoost::__anon80
CvBoost::REAL	ml/ml.hpp	/^    enum { DISCRETE=0, REAL=1, LOGIT=2, GENTLE=3 };$/;"	e	enum:CvBoost::__anon79
CvBoost::SQERR	ml/ml.hpp	/^    enum { DEFAULT=0, GINI=1, MISCLASS=3, SQERR=4 };$/;"	e	enum:CvBoost::__anon80
CvBoost::active_vars	ml/ml.hpp	/^    CvMat* active_vars;$/;"	m	class:CvBoost	access:protected
CvBoost::active_vars_abs	ml/ml.hpp	/^    CvMat* active_vars_abs;$/;"	m	class:CvBoost	access:protected
CvBoost::calc_error	ml/ml.hpp	/^    virtual float calc_error( CvMLData* _data, int type , std::vector<float> *resp = 0 ); \/\/ type in {CV_TRAIN_ERROR, CV_TEST_ERROR}$/;"	p	class:CvBoost	access:public	signature:( CvMLData* _data, int type , std::vector<float> *resp = 0 )
CvBoost::clear	ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvBoost	access:public	signature:()
CvBoost::data	ml/ml.hpp	/^    CvDTreeTrainData* data;$/;"	m	class:CvBoost	access:protected
CvBoost::get_active_vars	ml/ml.hpp	/^    virtual const CvMat* get_active_vars(bool absolute_idx=true);$/;"	p	class:CvBoost	access:public	signature:(bool absolute_idx=true)
CvBoost::get_data	ml/ml.hpp	/^    const CvDTreeTrainData* get_data() const;$/;"	p	class:CvBoost	access:public	signature:() const
CvBoost::get_params	ml/ml.hpp	/^    const CvBoostParams& get_params() const;$/;"	p	class:CvBoost	access:public	signature:() const
CvBoost::get_subtree_weights	ml/ml.hpp	/^    CvMat* get_subtree_weights();$/;"	p	class:CvBoost	access:public	signature:()
CvBoost::get_weak_predictors	ml/ml.hpp	/^    CvSeq* get_weak_predictors();$/;"	p	class:CvBoost	access:public	signature:()
CvBoost::get_weak_response	ml/ml.hpp	/^    CvMat* get_weak_response();$/;"	p	class:CvBoost	access:public	signature:()
CvBoost::get_weights	ml/ml.hpp	/^    CvMat* get_weights();$/;"	p	class:CvBoost	access:public	signature:()
CvBoost::have_active_cat_vars	ml/ml.hpp	/^    bool have_active_cat_vars;$/;"	m	class:CvBoost	access:protected
CvBoost::have_subsample	ml/ml.hpp	/^    bool have_subsample;$/;"	m	class:CvBoost	access:protected
CvBoost::orig_response	ml/ml.hpp	/^    CvMat* orig_response;$/;"	m	class:CvBoost	access:protected
CvBoost::params	ml/ml.hpp	/^    CvBoostParams params;$/;"	m	class:CvBoost	access:protected
CvBoost::predict	ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& sample, const cv::Mat& missing=cv::Mat(),$/;"	p	class:CvBoost	access:public	signature:( const cv::Mat& sample, const cv::Mat& missing=cv::Mat(), const cv::Range& slice=cv::Range::all(), bool rawMode=false, bool returnSum=false ) const
CvBoost::predict	ml/ml.hpp	/^    virtual float predict( const CvMat* sample, const CvMat* missing=0,$/;"	p	class:CvBoost	access:public	signature:( const CvMat* sample, const CvMat* missing=0, CvMat* weak_responses=0, CvSlice slice=CV_WHOLE_SEQ, bool raw_mode=false, bool return_sum=false ) const
CvBoost::prune	ml/ml.hpp	/^    CV_WRAP virtual void prune( CvSlice slice );$/;"	p	class:CvBoost	access:public	signature:( CvSlice slice )
CvBoost::read	ml/ml.hpp	/^    virtual void read( CvFileStorage* storage, CvFileNode* node );$/;"	p	class:CvBoost	access:public	signature:( CvFileStorage* storage, CvFileNode* node )
CvBoost::read_params	ml/ml.hpp	/^    virtual void read_params( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvBoost	access:protected	signature:( CvFileStorage* fs, CvFileNode* node )
CvBoost::set_params	ml/ml.hpp	/^    virtual bool set_params( const CvBoostParams& params );$/;"	p	class:CvBoost	access:protected	signature:( const CvBoostParams& params )
CvBoost::subsample_mask	ml/ml.hpp	/^    CvMat* subsample_mask;$/;"	m	class:CvBoost	access:protected
CvBoost::subtree_weights	ml/ml.hpp	/^    CvMat* subtree_weights;$/;"	m	class:CvBoost	access:protected
CvBoost::sum_response	ml/ml.hpp	/^    CvMat* sum_response;$/;"	m	class:CvBoost	access:protected
CvBoost::train	ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, int tflag,$/;"	p	class:CvBoost	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvBoostParams params=CvBoostParams(), bool update=false )
CvBoost::train	ml/ml.hpp	/^    virtual bool train( CvMLData* data,$/;"	p	class:CvBoost	access:public	signature:( CvMLData* data, CvBoostParams params=CvBoostParams(), bool update=false )
CvBoost::train	ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvBoost	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvBoostParams params=CvBoostParams(), bool update=false )
CvBoost::trim_weights	ml/ml.hpp	/^    virtual void trim_weights();$/;"	p	class:CvBoost	access:protected	signature:()
CvBoost::update_weights	ml/ml.hpp	/^    virtual void update_weights( CvBoostTree* tree );$/;"	p	class:CvBoost	access:protected	signature:( CvBoostTree* tree )
CvBoost::weak	ml/ml.hpp	/^    CvSeq* weak;$/;"	m	class:CvBoost	access:protected
CvBoost::weak_eval	ml/ml.hpp	/^    CvMat* weak_eval;$/;"	m	class:CvBoost	access:protected
CvBoost::weights	ml/ml.hpp	/^    CvMat* weights;$/;"	m	class:CvBoost	access:protected
CvBoost::write	ml/ml.hpp	/^    virtual void write( CvFileStorage* storage, const char* name ) const;$/;"	p	class:CvBoost	access:public	signature:( CvFileStorage* storage, const char* name ) const
CvBoost::write_params	ml/ml.hpp	/^    virtual void write_params( CvFileStorage* fs ) const;$/;"	p	class:CvBoost	access:protected	signature:( CvFileStorage* fs ) const
CvBoost::~CvBoost	ml/ml.hpp	/^    virtual ~CvBoost();$/;"	p	class:CvBoost	access:public	signature:()
CvBoostParams	ml/ml.hpp	/^    CvBoostParams( int boost_type, int weak_count, double weight_trim_rate,$/;"	p	struct:CvBoostParams	access:public	signature:( int boost_type, int weak_count, double weight_trim_rate, int max_depth, bool use_surrogates, const float* priors )
CvBoostParams	ml/ml.hpp	/^    CvBoostParams();$/;"	p	struct:CvBoostParams	access:public	signature:()
CvBoostParams	ml/ml.hpp	/^struct CV_EXPORTS_W_MAP CvBoostParams : public CvDTreeParams$/;"	s	inherits:CvDTreeParams
CvBoostParams::CvBoostParams	ml/ml.hpp	/^    CvBoostParams( int boost_type, int weak_count, double weight_trim_rate,$/;"	p	struct:CvBoostParams	access:public	signature:( int boost_type, int weak_count, double weight_trim_rate, int max_depth, bool use_surrogates, const float* priors )
CvBoostParams::CvBoostParams	ml/ml.hpp	/^    CvBoostParams();$/;"	p	struct:CvBoostParams	access:public	signature:()
CvBoostParams::boost_type	ml/ml.hpp	/^    CV_PROP_RW int boost_type;$/;"	m	struct:CvBoostParams	access:public
CvBoostParams::split_criteria	ml/ml.hpp	/^    CV_PROP_RW int split_criteria;$/;"	m	struct:CvBoostParams	access:public
CvBoostParams::weak_count	ml/ml.hpp	/^    CV_PROP_RW int weak_count;$/;"	m	struct:CvBoostParams	access:public
CvBoostParams::weight_trim_rate	ml/ml.hpp	/^    CV_PROP_RW double weight_trim_rate;$/;"	m	struct:CvBoostParams	access:public
CvBoostTree	ml/ml.hpp	/^    CvBoostTree();$/;"	p	class:CvBoostTree	access:public	signature:()
CvBoostTree	ml/ml.hpp	/^class CV_EXPORTS CvBoostTree: public CvDTree$/;"	c	inherits:CvDTree
CvBoostTree::CvBoostTree	ml/ml.hpp	/^    CvBoostTree();$/;"	p	class:CvBoostTree	access:public	signature:()
CvBoostTree::calc_node_dir	ml/ml.hpp	/^    virtual double calc_node_dir( CvDTreeNode* n );$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n )
CvBoostTree::calc_node_value	ml/ml.hpp	/^    virtual void calc_node_value( CvDTreeNode* n );$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n )
CvBoostTree::clear	ml/ml.hpp	/^    virtual void clear();$/;"	p	class:CvBoostTree	access:public	signature:()
CvBoostTree::ensemble	ml/ml.hpp	/^    CvBoost* ensemble;$/;"	m	class:CvBoostTree	access:protected
CvBoostTree::find_split_cat_class	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_class( CvDTreeNode* n, int vi,$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvBoostTree::find_split_cat_reg	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvBoostTree::find_split_ord_class	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_class( CvDTreeNode* n, int vi, $/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvBoostTree::find_split_ord_reg	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvBoostTree::find_surrogate_split_cat	ml/ml.hpp	/^    virtual CvDTreeSplit* find_surrogate_split_cat( CvDTreeNode* n, int vi, uchar* ext_buf = 0 );$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, uchar* ext_buf = 0 )
CvBoostTree::find_surrogate_split_ord	ml/ml.hpp	/^    virtual CvDTreeSplit* find_surrogate_split_ord( CvDTreeNode* n, int vi, uchar* ext_buf = 0 );$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, uchar* ext_buf = 0 )
CvBoostTree::read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvBoostTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
CvBoostTree::read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node,$/;"	p	class:CvBoostTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node, CvBoost* ensemble, CvDTreeTrainData* _data )
CvBoostTree::read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node,$/;"	p	class:CvBoostTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node, CvDTreeTrainData* data )
CvBoostTree::scale	ml/ml.hpp	/^    virtual void scale( double s );$/;"	p	class:CvBoostTree	access:public	signature:( double s )
CvBoostTree::train	ml/ml.hpp	/^    virtual bool train( CvDTreeTrainData* trainData, const CvMat* _subsample_idx );$/;"	p	class:CvBoostTree	access:public	signature:( CvDTreeTrainData* trainData, const CvMat* _subsample_idx )
CvBoostTree::train	ml/ml.hpp	/^    virtual bool train( CvDTreeTrainData* trainData,$/;"	p	class:CvBoostTree	access:public	signature:( CvDTreeTrainData* trainData, const CvMat* subsample_idx, CvBoost* ensemble )
CvBoostTree::train	ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvBoostTree	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvDTreeParams params=CvDTreeParams() )
CvBoostTree::try_split_node	ml/ml.hpp	/^    virtual void try_split_node( CvDTreeNode* n );$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n )
CvBoostTree::~CvBoostTree	ml/ml.hpp	/^    virtual ~CvBoostTree();$/;"	p	class:CvBoostTree	access:public	signature:()
CvBox2D	core/types_c.h	/^CvBox2D;$/;"	t	typeref:struct:CvBox2D
CvBox2D	core/types_c.h	/^typedef struct CvBox2D$/;"	s
CvBox2D32f	legacy/compat.hpp	/^typedef CvBox2D  CvBox2D32f;$/;"	t
CvBox2D::angle	core/types_c.h	/^    float angle;          \/* Angle between the horizontal axis           *\/$/;"	m	struct:CvBox2D	access:public
CvBox2D::center	core/types_c.h	/^    CvPoint2D32f center;  \/* Center of the box.                          *\/$/;"	m	struct:CvBox2D	access:public
CvBox2D::size	core/types_c.h	/^    CvSize2D32f  size;    \/* Box width and length.                       *\/$/;"	m	struct:CvBox2D	access:public
CvButtonCallback	highgui/highgui_c.h	/^typedef void (CV_CDECL *CvButtonCallback)(int state, void* userdata);$/;"	t
CvCalibEtalonType	legacy/legacy.hpp	/^CvCalibEtalonType;$/;"	t	typeref:enum:CvCalibEtalonType
CvCalibEtalonType	legacy/legacy.hpp	/^typedef enum CvCalibEtalonType$/;"	g
CvCalibFilter	legacy/legacy.hpp	/^    CvCalibFilter();$/;"	p	class:CvCalibFilter	access:public	signature:()
CvCalibFilter	legacy/legacy.hpp	/^class CV_EXPORTS CvCalibFilter$/;"	c
CvCalibFilter::CvCalibFilter	legacy/legacy.hpp	/^    CvCalibFilter();$/;"	p	class:CvCalibFilter	access:public	signature:()
CvCalibFilter::DrawPoints	legacy/legacy.hpp	/^    virtual void DrawPoints( CvMat** dst );$/;"	p	class:CvCalibFilter	access:public	signature:( CvMat** dst )
CvCalibFilter::DrawPoints	legacy/legacy.hpp	/^    virtual void DrawPoints( IplImage** dst );$/;"	p	class:CvCalibFilter	access:public	signature:( IplImage** dst )
CvCalibFilter::FindEtalon	legacy/legacy.hpp	/^    virtual bool FindEtalon( CvMat** imgs );$/;"	p	class:CvCalibFilter	access:public	signature:( CvMat** imgs )
CvCalibFilter::FindEtalon	legacy/legacy.hpp	/^    virtual bool FindEtalon( IplImage** imgs );$/;"	p	class:CvCalibFilter	access:public	signature:( IplImage** imgs )
CvCalibFilter::GetCameraCount	legacy/legacy.hpp	/^    int GetCameraCount() const { return cameraCount; }$/;"	f	class:CvCalibFilter	access:public	signature:() const
CvCalibFilter::GetCameraParams	legacy/legacy.hpp	/^    virtual const CvCamera* GetCameraParams( int idx = 0 ) const;$/;"	p	class:CvCalibFilter	access:public	signature:( int idx = 0 ) const
CvCalibFilter::GetEtalon	legacy/legacy.hpp	/^        GetEtalon( int* paramCount = 0, const double** etalonParams = 0,$/;"	p	class:CvCalibFilter	access:public	signature:( int* paramCount = 0, const double** etalonParams = 0, int* pointCount = 0, const CvPoint2D32f** etalonPoints = 0 ) const
CvCalibFilter::GetFrameCount	legacy/legacy.hpp	/^    virtual int GetFrameCount( int* framesTotal = 0 ) const;$/;"	p	class:CvCalibFilter	access:public	signature:( int* framesTotal = 0 ) const
CvCalibFilter::GetLatestPoints	legacy/legacy.hpp	/^    virtual bool GetLatestPoints( int idx, CvPoint2D32f** pts,$/;"	p	class:CvCalibFilter	access:public	signature:( int idx, CvPoint2D32f** pts, int* count, bool* found )
CvCalibFilter::GetStereoParams	legacy/legacy.hpp	/^    virtual const CvStereoCamera* GetStereoParams() const;$/;"	p	class:CvCalibFilter	access:public	signature:() const
CvCalibFilter::IsCalibrated	legacy/legacy.hpp	/^    bool IsCalibrated() const { return isCalibrated; }$/;"	f	class:CvCalibFilter	access:public	signature:() const
CvCalibFilter::LoadCameraParams	legacy/legacy.hpp	/^    virtual bool LoadCameraParams( const char* filename );$/;"	p	class:CvCalibFilter	access:public	signature:( const char* filename )
CvCalibFilter::MAX_CAMERAS	legacy/legacy.hpp	/^    enum { MAX_CAMERAS = 3 };$/;"	e	enum:CvCalibFilter::__anon189
CvCalibFilter::Push	legacy/legacy.hpp	/^    virtual bool Push( const CvPoint2D32f** points = 0 );$/;"	p	class:CvCalibFilter	access:public	signature:( const CvPoint2D32f** points = 0 )
CvCalibFilter::Rectify	legacy/legacy.hpp	/^    virtual bool Rectify( CvMat** srcarr, CvMat** dstarr );$/;"	p	class:CvCalibFilter	access:public	signature:( CvMat** srcarr, CvMat** dstarr )
CvCalibFilter::Rectify	legacy/legacy.hpp	/^    virtual bool Rectify( IplImage** srcarr, IplImage** dstarr );$/;"	p	class:CvCalibFilter	access:public	signature:( IplImage** srcarr, IplImage** dstarr )
CvCalibFilter::SaveCameraParams	legacy/legacy.hpp	/^    virtual bool SaveCameraParams( const char* filename );$/;"	p	class:CvCalibFilter	access:public	signature:( const char* filename )
CvCalibFilter::SetCameraCount	legacy/legacy.hpp	/^    virtual void SetCameraCount( int cameraCount );$/;"	p	class:CvCalibFilter	access:public	signature:( int cameraCount )
CvCalibFilter::SetCameraParams	legacy/legacy.hpp	/^    virtual bool SetCameraParams( CvCamera* params );$/;"	p	class:CvCalibFilter	access:public	signature:( CvCamera* params )
CvCalibFilter::SetEtalon	legacy/legacy.hpp	/^        SetEtalon( CvCalibEtalonType etalonType, double* etalonParams,$/;"	p	class:CvCalibFilter	access:public	signature:( CvCalibEtalonType etalonType, double* etalonParams, int pointCount = 0, CvPoint2D32f* points = 0 )
CvCalibFilter::SetFrames	legacy/legacy.hpp	/^    virtual bool SetFrames( int totalFrames );$/;"	p	class:CvCalibFilter	access:public	signature:( int totalFrames )
CvCalibFilter::Stop	legacy/legacy.hpp	/^    virtual void Stop( bool calibrate = false );$/;"	p	class:CvCalibFilter	access:public	signature:( bool calibrate = false )
CvCalibFilter::Undistort	legacy/legacy.hpp	/^    virtual bool Undistort( CvMat** src, CvMat** dst );$/;"	p	class:CvCalibFilter	access:public	signature:( CvMat** src, CvMat** dst )
CvCalibFilter::Undistort	legacy/legacy.hpp	/^    virtual bool Undistort( IplImage** src, IplImage** dst );$/;"	p	class:CvCalibFilter	access:public	signature:( IplImage** src, IplImage** dst )
CvCalibFilter::cameraCount	legacy/legacy.hpp	/^    int     cameraCount;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::cameraParams	legacy/legacy.hpp	/^    CvCamera cameraParams[MAX_CAMERAS];$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::etalonParamCount	legacy/legacy.hpp	/^    int     etalonParamCount;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::etalonParams	legacy/legacy.hpp	/^    double* etalonParams;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::etalonPointCount	legacy/legacy.hpp	/^    int     etalonPointCount;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::etalonPoints	legacy/legacy.hpp	/^    CvPoint2D32f* etalonPoints;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::etalonType	legacy/legacy.hpp	/^    CvCalibEtalonType  etalonType;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::framesAccepted	legacy/legacy.hpp	/^    int     framesAccepted;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::framesTotal	legacy/legacy.hpp	/^    int     framesTotal;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::grayImg	legacy/legacy.hpp	/^    CvMat*  grayImg;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::imgSize	legacy/legacy.hpp	/^    CvSize  imgSize;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::isCalibrated	legacy/legacy.hpp	/^    bool    isCalibrated;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::latestCounts	legacy/legacy.hpp	/^    int     latestCounts[MAX_CAMERAS];$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::latestPoints	legacy/legacy.hpp	/^    CvPoint2D32f* latestPoints[MAX_CAMERAS];$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::maxPoints	legacy/legacy.hpp	/^    int     maxPoints;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::points	legacy/legacy.hpp	/^    CvPoint2D32f* points[MAX_CAMERAS];$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::rectMap	legacy/legacy.hpp	/^    CvMat*  rectMap[MAX_CAMERAS][2];$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::stereo	legacy/legacy.hpp	/^    CvStereoCamera stereo;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::storage	legacy/legacy.hpp	/^    CvMemStorage* storage;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::tempImg	legacy/legacy.hpp	/^    CvMat*  tempImg;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::undistImg	legacy/legacy.hpp	/^    CvMat*  undistImg;$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::undistMap	legacy/legacy.hpp	/^    CvMat*  undistMap[MAX_CAMERAS][2];$/;"	m	class:CvCalibFilter	access:protected
CvCalibFilter::~CvCalibFilter	legacy/legacy.hpp	/^    virtual ~CvCalibFilter();$/;"	p	class:CvCalibFilter	access:public	signature:()
CvCallback	legacy/legacy.hpp	/^typedef int (CV_CDECL * CvCallback)(int index, void* buffer, void* user_data);$/;"	t
CvCamShiftTracker	legacy/legacy.hpp	/^    CvCamShiftTracker();$/;"	p	class:CvCamShiftTracker	access:public	signature:()
CvCamShiftTracker	legacy/legacy.hpp	/^class CV_EXPORTS CvCamShiftTracker$/;"	c
CvCamShiftTracker::CvCamShiftTracker	legacy/legacy.hpp	/^    CvCamShiftTracker();$/;"	p	class:CvCamShiftTracker	access:public	signature:()
CvCamShiftTracker::color_transform	legacy/legacy.hpp	/^    virtual void color_transform( const IplImage* img );$/;"	p	class:CvCamShiftTracker	access:protected	signature:( const IplImage* img )
CvCamShiftTracker::get_back_project	legacy/legacy.hpp	/^    virtual IplImage* get_back_project()$/;"	f	class:CvCamShiftTracker	access:public	signature:()
CvCamShiftTracker::get_center	legacy/legacy.hpp	/^    CvPoint2D32f get_center() const \/\/ center of the object$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
CvCamShiftTracker::get_hist_dims	legacy/legacy.hpp	/^    int     get_hist_dims( int* dims = 0 ) const \/\/ returns number of histogram dimensions and sets$/;"	f	class:CvCamShiftTracker	access:public	signature:( int* dims = 0 ) const
CvCamShiftTracker::get_length	legacy/legacy.hpp	/^    float   get_length() const \/\/ the larger linear size of the object$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
CvCamShiftTracker::get_max_ch_val	legacy/legacy.hpp	/^    int     get_max_ch_val( int channel ) const \/\/ get the maximum allowed value of the specified channel$/;"	f	class:CvCamShiftTracker	access:public	signature:( int channel ) const
CvCamShiftTracker::get_min_ch_val	legacy/legacy.hpp	/^    int     get_min_ch_val( int channel ) const \/\/ get the minimum allowed value of the specified channel$/;"	f	class:CvCamShiftTracker	access:public	signature:( int channel ) const
CvCamShiftTracker::get_orientation	legacy/legacy.hpp	/^    float   get_orientation() const \/\/ orientation of the object in degrees$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
CvCamShiftTracker::get_threshold	legacy/legacy.hpp	/^    int     get_threshold() const \/\/ thresholding value that applied to back project$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
CvCamShiftTracker::get_width	legacy/legacy.hpp	/^    float   get_width() const \/\/ the smaller linear size of the object$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
CvCamShiftTracker::get_window	legacy/legacy.hpp	/^    CvRect get_window() const \/\/ bounding rectangle for the object$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
CvCamShiftTracker::m_back_project	legacy/legacy.hpp	/^    IplImage*  m_back_project;$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::m_box	legacy/legacy.hpp	/^    CvBox2D    m_box;$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::m_color_planes	legacy/legacy.hpp	/^    IplImage*  m_color_planes[CV_MAX_DIM];$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::m_comp	legacy/legacy.hpp	/^    CvConnectedComp m_comp;$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::m_hist	legacy/legacy.hpp	/^    CvHistogram* m_hist;$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::m_hist_ranges	legacy/legacy.hpp	/^    float*     m_hist_ranges[CV_MAX_DIM];$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::m_hist_ranges_data	legacy/legacy.hpp	/^    float      m_hist_ranges_data[CV_MAX_DIM][2];$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::m_mask	legacy/legacy.hpp	/^    IplImage*  m_mask;$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::m_max_ch_val	legacy/legacy.hpp	/^    int        m_max_ch_val[CV_MAX_DIM];$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::m_min_ch_val	legacy/legacy.hpp	/^    int        m_min_ch_val[CV_MAX_DIM];$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::m_temp	legacy/legacy.hpp	/^    IplImage*  m_temp;$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::m_threshold	legacy/legacy.hpp	/^    int        m_threshold;$/;"	m	class:CvCamShiftTracker	access:protected
CvCamShiftTracker::query	legacy/legacy.hpp	/^    float query( int* bin ) const$/;"	f	class:CvCamShiftTracker	access:public	signature:( int* bin ) const
CvCamShiftTracker::reset_histogram	legacy/legacy.hpp	/^    virtual void  reset_histogram();$/;"	p	class:CvCamShiftTracker	access:public	signature:()
CvCamShiftTracker::set_hist_bin_range	legacy/legacy.hpp	/^    bool    set_hist_bin_range( int dim, int min_val, int max_val );$/;"	p	class:CvCamShiftTracker	access:public	signature:( int dim, int min_val, int max_val )
CvCamShiftTracker::set_hist_dims	legacy/legacy.hpp	/^    bool    set_hist_dims( int c_dims, int* dims );\/\/ set the histogram parameters$/;"	p	class:CvCamShiftTracker	access:public	signature:( int c_dims, int* dims )
CvCamShiftTracker::set_max_ch_val	legacy/legacy.hpp	/^    bool    set_max_ch_val( int channel, int val ) \/\/ set the maximum allowed value of the specified channel$/;"	f	class:CvCamShiftTracker	access:public	signature:( int channel, int val )
CvCamShiftTracker::set_min_ch_val	legacy/legacy.hpp	/^    bool    set_min_ch_val( int channel, int val ) \/\/ set the minimum allowed value of the specified channel$/;"	f	class:CvCamShiftTracker	access:public	signature:( int channel, int val )
CvCamShiftTracker::set_threshold	legacy/legacy.hpp	/^    bool    set_threshold( int threshold ) \/\/ threshold applied to the histogram bins$/;"	f	class:CvCamShiftTracker	access:public	signature:( int threshold )
CvCamShiftTracker::set_window	legacy/legacy.hpp	/^    bool    set_window( CvRect window)$/;"	f	class:CvCamShiftTracker	access:public	signature:( CvRect window)
CvCamShiftTracker::track_object	legacy/legacy.hpp	/^    virtual bool  track_object( const IplImage* cur_frame );$/;"	p	class:CvCamShiftTracker	access:public	signature:( const IplImage* cur_frame )
CvCamShiftTracker::update_histogram	legacy/legacy.hpp	/^    virtual bool  update_histogram( const IplImage* cur_frame );$/;"	p	class:CvCamShiftTracker	access:public	signature:( const IplImage* cur_frame )
CvCamShiftTracker::~CvCamShiftTracker	legacy/legacy.hpp	/^    virtual ~CvCamShiftTracker();$/;"	p	class:CvCamShiftTracker	access:public	signature:()
CvCamera	legacy/legacy.hpp	/^typedef struct CvCamera$/;"	s
CvCamera	legacy/legacy.hpp	/^} CvCamera;$/;"	t	typeref:struct:CvCamera
CvCamera::distortion	legacy/legacy.hpp	/^    float   distortion[4]; \/* distortion coefficients - two coefficients for radial distortion$/;"	m	struct:CvCamera	access:public
CvCamera::imgSize	legacy/legacy.hpp	/^    float   imgSize[2]; \/* size of the camera view, used during calibration *\/$/;"	m	struct:CvCamera	access:public
CvCamera::matrix	legacy/legacy.hpp	/^    float   matrix[9]; \/* intinsic camera parameters:  [ fx 0 cx; 0 fy cy; 0 0 1 ] *\/$/;"	m	struct:CvCamera	access:public
CvCamera::rotMatr	legacy/legacy.hpp	/^    float   rotMatr[9];$/;"	m	struct:CvCamera	access:public
CvCamera::transVect	legacy/legacy.hpp	/^    float   transVect[3]; \/* rotation matrix and transition vector relatively$/;"	m	struct:CvCamera	access:public
CvCapture	highgui/highgui_c.h	/^typedef struct CvCapture CvCapture;$/;"	t	typeref:struct:CvCapture
CvChain	core/types_c.h	/^CvChain;$/;"	t	typeref:struct:CvChain
CvChain	core/types_c.h	/^typedef struct CvChain$/;"	s
CvChain::origin	core/types_c.h	/^    CvPoint  origin;$/;"	m	struct:CvChain	access:public
CvChainApproxMethod	legacy/compat.hpp	/^typedef int CvChainApproxMethod;$/;"	t
CvChainPtReader	imgproc/types_c.h	/^CvChainPtReader;$/;"	t	typeref:struct:CvChainPtReader
CvChainPtReader	imgproc/types_c.h	/^typedef struct CvChainPtReader$/;"	s
CvChainPtReader::code	imgproc/types_c.h	/^    char      code;$/;"	m	struct:CvChainPtReader	access:public
CvChainPtReader::deltas	imgproc/types_c.h	/^    schar     deltas[8][2];$/;"	m	struct:CvChainPtReader	access:public
CvChainPtReader::pt	imgproc/types_c.h	/^    CvPoint   pt;$/;"	m	struct:CvChainPtReader	access:public
CvCliqueFinder	legacy/legacy.hpp	/^typedef struct CvCliqueFinder$/;"	s
CvCliqueFinder	legacy/legacy.hpp	/^} CvCliqueFinder;$/;"	t	typeref:struct:CvCliqueFinder
CvCliqueFinder::All	legacy/legacy.hpp	/^    int** All;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::N	legacy/legacy.hpp	/^    int N; \/\/graph size$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::adj_matr	legacy/legacy.hpp	/^    int**    adj_matr;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::best_score	legacy/legacy.hpp	/^    int best_score;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::best_weight	legacy/legacy.hpp	/^    float best_weight;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::cand_weight	legacy/legacy.hpp	/^    float* cand_weight;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::ce	legacy/legacy.hpp	/^    int* ce;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::cur_weight	legacy/legacy.hpp	/^    float* cur_weight;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::current_comp	legacy/legacy.hpp	/^    int* current_comp;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::edge_weights	legacy/legacy.hpp	/^    float* edge_weights;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::fixp	legacy/legacy.hpp	/^    int* fixp; \/\/node with minimal disconnections$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::graph	legacy/legacy.hpp	/^    CvGraph* graph;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::k	legacy/legacy.hpp	/^    int k; \/\/stack size$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::ne	legacy/legacy.hpp	/^    int* ne;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::nod	legacy/legacy.hpp	/^    int* nod;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::s	legacy/legacy.hpp	/^    int* s; \/\/for selected candidate$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::status	legacy/legacy.hpp	/^    int status;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::vertex_weights	legacy/legacy.hpp	/^    float* vertex_weights;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::weighted	legacy/legacy.hpp	/^    int weighted;$/;"	m	struct:CvCliqueFinder	access:public
CvCliqueFinder::weighted_edges	legacy/legacy.hpp	/^    int weighted_edges;    $/;"	m	struct:CvCliqueFinder	access:public
CvCloneFunc	core/types_c.h	/^typedef void* (CV_CDECL *CvCloneFunc)( const void* struct_ptr );$/;"	t
CvCmpFunc	core/core_c.h	/^typedef int (CV_CDECL* CvCmpFunc)(const void* a, const void* b, void* userdata );$/;"	t
CvCoeffType	legacy/compat.hpp	/^typedef int CvCoeffType;$/;"	t
CvCompareMethod	legacy/compat.hpp	/^typedef int CvCompareMethod;$/;"	t
CvConDensation	legacy/legacy.hpp	/^typedef struct CvConDensation$/;"	s
CvConDensation	legacy/legacy.hpp	/^} CvConDensation;$/;"	t	typeref:struct:CvConDensation
CvConDensation::DP	legacy/legacy.hpp	/^    int DP;$/;"	m	struct:CvConDensation	access:public
CvConDensation::DynamMatr	legacy/legacy.hpp	/^    float* DynamMatr;       \/* Matrix of the linear Dynamics system  *\/$/;"	m	struct:CvConDensation	access:public
CvConDensation::MP	legacy/legacy.hpp	/^    int MP;$/;"	m	struct:CvConDensation	access:public
CvConDensation::RandS	legacy/legacy.hpp	/^    struct CvRandState* RandS; \/* Array of structures to generate random vectors *\/$/;"	m	struct:CvConDensation	typeref:struct:CvConDensation::CvRandState	access:public
CvConDensation::RandomSample	legacy/legacy.hpp	/^    float* RandomSample;    \/* RandomVector to update sample set     *\/$/;"	m	struct:CvConDensation	access:public
CvConDensation::SamplesNum	legacy/legacy.hpp	/^    int SamplesNum;         \/* Number of the Samples                 *\/$/;"	m	struct:CvConDensation	access:public
CvConDensation::State	legacy/legacy.hpp	/^    float* State;           \/* Vector of State                       *\/$/;"	m	struct:CvConDensation	access:public
CvConDensation::Temp	legacy/legacy.hpp	/^    float* Temp;            \/* Temporary vector                      *\/$/;"	m	struct:CvConDensation	access:public
CvConDensation::flConfidence	legacy/legacy.hpp	/^    float* flConfidence;    \/* Confidence for each Sample            *\/$/;"	m	struct:CvConDensation	access:public
CvConDensation::flCumulative	legacy/legacy.hpp	/^    float* flCumulative;    \/* Cumulative confidence                 *\/$/;"	m	struct:CvConDensation	access:public
CvConDensation::flNewSamples	legacy/legacy.hpp	/^    float** flNewSamples;   \/* temporary array of the Sample Vectors *\/$/;"	m	struct:CvConDensation	access:public
CvConDensation::flSamples	legacy/legacy.hpp	/^    float** flSamples;      \/* arr of the Sample Vectors             *\/$/;"	m	struct:CvConDensation	access:public
CvConnectedComp	imgproc/types_c.h	/^CvConnectedComp;$/;"	t	typeref:struct:CvConnectedComp
CvConnectedComp	imgproc/types_c.h	/^typedef struct CvConnectedComp$/;"	s
CvConnectedComp::area	imgproc/types_c.h	/^    double area;    \/* area of the connected component  *\/$/;"	m	struct:CvConnectedComp	access:public
CvConnectedComp::contour	imgproc/types_c.h	/^    CvSeq* contour; \/* optional component boundary$/;"	m	struct:CvConnectedComp	access:public
CvConnectedComp::rect	imgproc/types_c.h	/^    CvRect rect;    \/* ROI of the component  *\/$/;"	m	struct:CvConnectedComp	access:public
CvConnectedComp::value	imgproc/types_c.h	/^    CvScalar value; \/* average color of the connected component *\/$/;"	m	struct:CvConnectedComp	access:public
CvContour	core/types_c.h	/^CvContour;$/;"	t	typeref:struct:CvContour
CvContour	core/types_c.h	/^typedef struct CvContour$/;"	s
CvContourOrientation	legacy/legacy.hpp	/^typedef struct CvContourOrientation$/;"	s
CvContourOrientation	legacy/legacy.hpp	/^} CvContourOrientation;$/;"	t	typeref:struct:CvContourOrientation
CvContourOrientation::egvals	legacy/legacy.hpp	/^    float egvals[2];$/;"	m	struct:CvContourOrientation	access:public
CvContourOrientation::egvects	legacy/legacy.hpp	/^    float egvects[4];$/;"	m	struct:CvContourOrientation	access:public
CvContourOrientation::imax	legacy/legacy.hpp	/^    int imax, imin;$/;"	m	struct:CvContourOrientation	access:public
CvContourOrientation::imin	legacy/legacy.hpp	/^    int imax, imin;$/;"	m	struct:CvContourOrientation	access:public
CvContourOrientation::max	legacy/legacy.hpp	/^    float max, min; \/\/ minimum and maximum projections$/;"	m	struct:CvContourOrientation	access:public
CvContourOrientation::min	legacy/legacy.hpp	/^    float max, min; \/\/ minimum and maximum projections$/;"	m	struct:CvContourOrientation	access:public
CvContourRetrievalMode	legacy/compat.hpp	/^typedef int CvContourRetrievalMode;$/;"	t
CvContourScanner	imgproc/types_c.h	/^typedef struct _CvContourScanner* CvContourScanner;$/;"	t	typeref:struct:_CvContourScanner
CvContourTree	legacy/legacy.hpp	/^typedef struct CvContourTree$/;"	s
CvContourTree	legacy/legacy.hpp	/^} CvContourTree;$/;"	t	typeref:struct:CvContourTree
CvContourTree::p1	legacy/legacy.hpp	/^    CvPoint p1;            \/* the first point of the binary tree root segment *\/$/;"	m	struct:CvContourTree	access:public
CvContourTree::p2	legacy/legacy.hpp	/^    CvPoint p2;            \/* the last point of the binary tree root segment *\/$/;"	m	struct:CvContourTree	access:public
CvContourTreesMatchMethod	legacy/compat.hpp	/^typedef int CvContourTreesMatchMethod;$/;"	t
CvContoursMatchMethod	legacy/compat.hpp	/^typedef int CvContoursMatchMethod;$/;"	t
CvConvexityDefect	imgproc/types_c.h	/^typedef struct CvConvexityDefect$/;"	s
CvConvexityDefect	imgproc/types_c.h	/^} CvConvexityDefect;$/;"	t	typeref:struct:CvConvexityDefect
CvConvexityDefect::depth	imgproc/types_c.h	/^    float depth; \/* distance between the farthest point and the convex hull *\/$/;"	m	struct:CvConvexityDefect	access:public
CvConvexityDefect::depth_point	imgproc/types_c.h	/^    CvPoint* depth_point; \/* the farthest from the convex hull point within the defect *\/$/;"	m	struct:CvConvexityDefect	access:public
CvConvexityDefect::end	imgproc/types_c.h	/^    CvPoint* end; \/* point of the contour where the defect ends *\/$/;"	m	struct:CvConvexityDefect	access:public
CvConvexityDefect::start	imgproc/types_c.h	/^    CvPoint* start; \/* point of the contour where the defect begins *\/$/;"	m	struct:CvConvexityDefect	access:public
CvDTree	ml/ml.hpp	/^    CV_WRAP CvDTree();$/;"	p	class:CvDTree	access:public	signature:()
CvDTree	ml/ml.hpp	/^class CV_EXPORTS_W CvDTree : public CvStatModel$/;"	c	inherits:CvStatModel
CvDTree::CvDTree	ml/ml.hpp	/^    CV_WRAP CvDTree();$/;"	p	class:CvDTree	access:public	signature:()
CvDTree::calc_error	ml/ml.hpp	/^    virtual float calc_error( CvMLData* trainData, int type, std::vector<float> *resp = 0 );$/;"	p	class:CvDTree	access:public	signature:( CvMLData* trainData, int type, std::vector<float> *resp = 0 )
CvDTree::calc_node_dir	ml/ml.hpp	/^    virtual double calc_node_dir( CvDTreeNode* node );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* node )
CvDTree::calc_node_value	ml/ml.hpp	/^    virtual void calc_node_value( CvDTreeNode* node );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* node )
CvDTree::clear	ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvDTree	access:public	signature:()
CvDTree::cluster_categories	ml/ml.hpp	/^    virtual void cluster_categories( const int* vectors, int vector_count,$/;"	p	class:CvDTree	access:protected	signature:( const int* vectors, int vector_count, int var_count, int* sums, int k, int* cluster_labels )
CvDTree::complete_node_dir	ml/ml.hpp	/^    virtual void complete_node_dir( CvDTreeNode* node );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* node )
CvDTree::cut_tree	ml/ml.hpp	/^    virtual int cut_tree( int T, int fold, double min_alpha );$/;"	p	class:CvDTree	access:protected	signature:( int T, int fold, double min_alpha )
CvDTree::data	ml/ml.hpp	/^    CvDTreeTrainData* data;$/;"	m	class:CvDTree	access:protected
CvDTree::do_train	ml/ml.hpp	/^    virtual bool do_train( const CvMat* _subsample_idx );$/;"	p	class:CvDTree	access:protected	signature:( const CvMat* _subsample_idx )
CvDTree::find_best_split	ml/ml.hpp	/^    virtual CvDTreeSplit* find_best_split( CvDTreeNode* n );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n )
CvDTree::find_split_cat_class	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_class( CvDTreeNode* n, int vi,$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvDTree::find_split_cat_reg	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvDTree::find_split_ord_class	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_class( CvDTreeNode* n, int vi, $/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvDTree::find_split_ord_reg	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvDTree::find_surrogate_split_cat	ml/ml.hpp	/^    virtual CvDTreeSplit* find_surrogate_split_cat( CvDTreeNode* n, int vi, uchar* ext_buf = 0 );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, uchar* ext_buf = 0 )
CvDTree::find_surrogate_split_ord	ml/ml.hpp	/^    virtual CvDTreeSplit* find_surrogate_split_ord( CvDTreeNode* n, int vi, uchar* ext_buf = 0 );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, uchar* ext_buf = 0 )
CvDTree::free_prune_data	ml/ml.hpp	/^    virtual void free_prune_data(bool cut_tree);$/;"	p	class:CvDTree	access:protected	signature:(bool cut_tree)
CvDTree::free_tree	ml/ml.hpp	/^    virtual void free_tree();$/;"	p	class:CvDTree	access:protected	signature:()
CvDTree::getVarImportance	ml/ml.hpp	/^    CV_WRAP virtual cv::Mat getVarImportance();$/;"	p	class:CvDTree	access:public	signature:()
CvDTree::get_data	ml/ml.hpp	/^    CvDTreeTrainData* get_data();$/;"	p	class:CvDTree	access:public	signature:()
CvDTree::get_pruned_tree_idx	ml/ml.hpp	/^    int get_pruned_tree_idx() const;$/;"	p	class:CvDTree	access:public	signature:() const
CvDTree::get_root	ml/ml.hpp	/^    const CvDTreeNode* get_root() const;$/;"	p	class:CvDTree	access:public	signature:() const
CvDTree::get_var_importance	ml/ml.hpp	/^    virtual const CvMat* get_var_importance();$/;"	p	class:CvDTree	access:public	signature:()
CvDTree::predict	ml/ml.hpp	/^    CV_WRAP virtual CvDTreeNode* predict( const cv::Mat& sample, const cv::Mat& missingDataMask=cv::Mat(),$/;"	p	class:CvDTree	access:public	signature:( const cv::Mat& sample, const cv::Mat& missingDataMask=cv::Mat(), bool preprocessedInput=false ) const
CvDTree::predict	ml/ml.hpp	/^    virtual CvDTreeNode* predict( const CvMat* sample, const CvMat* missingDataMask=0,$/;"	p	class:CvDTree	access:public	signature:( const CvMat* sample, const CvMat* missingDataMask=0, bool preprocessedInput=false ) const
CvDTree::prune_cv	ml/ml.hpp	/^    virtual void prune_cv();$/;"	p	class:CvDTree	access:protected	signature:()
CvDTree::pruned_tree_idx	ml/ml.hpp	/^    int pruned_tree_idx;$/;"	m	class:CvDTree	access:public
CvDTree::read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvDTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
CvDTree::read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node,$/;"	p	class:CvDTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node, CvDTreeTrainData* data )
CvDTree::read_node	ml/ml.hpp	/^    virtual CvDTreeNode* read_node( CvFileStorage* fs, CvFileNode* node, CvDTreeNode* parent );$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs, CvFileNode* node, CvDTreeNode* parent )
CvDTree::read_split	ml/ml.hpp	/^    virtual CvDTreeSplit* read_split( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs, CvFileNode* node )
CvDTree::read_tree_nodes	ml/ml.hpp	/^    virtual void read_tree_nodes( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs, CvFileNode* node )
CvDTree::root	ml/ml.hpp	/^    CvDTreeNode* root;$/;"	m	class:CvDTree	access:protected
CvDTree::split_node_data	ml/ml.hpp	/^    virtual void split_node_data( CvDTreeNode* n );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n )
CvDTree::train	ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, int tflag,$/;"	p	class:CvDTree	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvDTreeParams params=CvDTreeParams() )
CvDTree::train	ml/ml.hpp	/^    virtual bool train( CvDTreeTrainData* trainData, const CvMat* subsampleIdx );$/;"	p	class:CvDTree	access:public	signature:( CvDTreeTrainData* trainData, const CvMat* subsampleIdx )
CvDTree::train	ml/ml.hpp	/^    virtual bool train( CvMLData* trainData, CvDTreeParams params=CvDTreeParams() );$/;"	p	class:CvDTree	access:public	signature:( CvMLData* trainData, CvDTreeParams params=CvDTreeParams() )
CvDTree::train	ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvDTree	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvDTreeParams params=CvDTreeParams() )
CvDTree::try_split_node	ml/ml.hpp	/^    virtual void try_split_node( CvDTreeNode* n );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n )
CvDTree::update_tree_rnc	ml/ml.hpp	/^    virtual double update_tree_rnc( int T, int fold );$/;"	p	class:CvDTree	access:protected	signature:( int T, int fold )
CvDTree::var_importance	ml/ml.hpp	/^    CvMat* var_importance;$/;"	m	class:CvDTree	access:protected
CvDTree::write	ml/ml.hpp	/^    virtual void write( CvFileStorage* fs ) const;$/;"	p	class:CvDTree	access:public	signature:( CvFileStorage* fs ) const
CvDTree::write	ml/ml.hpp	/^    virtual void write( CvFileStorage* fs, const char* name ) const;$/;"	p	class:CvDTree	access:public	signature:( CvFileStorage* fs, const char* name ) const
CvDTree::write_node	ml/ml.hpp	/^    virtual void write_node( CvFileStorage* fs, CvDTreeNode* node ) const;$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs, CvDTreeNode* node ) const
CvDTree::write_split	ml/ml.hpp	/^    virtual void write_split( CvFileStorage* fs, CvDTreeSplit* split ) const;$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs, CvDTreeSplit* split ) const
CvDTree::write_tree_nodes	ml/ml.hpp	/^    virtual void write_tree_nodes( CvFileStorage* fs ) const;$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs ) const
CvDTree::~CvDTree	ml/ml.hpp	/^    virtual ~CvDTree();$/;"	p	class:CvDTree	access:public	signature:()
CvDTreeNode	ml/ml.hpp	/^struct CvDTreeNode$/;"	s
CvDTreeNode::Tn	ml/ml.hpp	/^    int Tn;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::alpha	ml/ml.hpp	/^    double alpha;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::buf_idx	ml/ml.hpp	/^    int buf_idx;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::class_idx	ml/ml.hpp	/^    int class_idx;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::complexity	ml/ml.hpp	/^    int complexity;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::cv_Tn	ml/ml.hpp	/^    int* cv_Tn;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::cv_node_error	ml/ml.hpp	/^    double* cv_node_error;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::cv_node_risk	ml/ml.hpp	/^    double* cv_node_risk;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::depth	ml/ml.hpp	/^    int depth;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::get_num_valid	ml/ml.hpp	/^    int get_num_valid(int vi) { return num_valid ? num_valid[vi] : sample_count; }$/;"	f	struct:CvDTreeNode	access:public	signature:(int vi)
CvDTreeNode::left	ml/ml.hpp	/^    CvDTreeNode* left;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::maxlr	ml/ml.hpp	/^    double maxlr;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::node_risk	ml/ml.hpp	/^    double node_risk, tree_risk, tree_error;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::num_valid	ml/ml.hpp	/^    int* num_valid;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::offset	ml/ml.hpp	/^    int offset;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::parent	ml/ml.hpp	/^    CvDTreeNode* parent;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::right	ml/ml.hpp	/^    CvDTreeNode* right;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::sample_count	ml/ml.hpp	/^    int sample_count;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::set_num_valid	ml/ml.hpp	/^    void set_num_valid(int vi, int n) { if( num_valid ) num_valid[vi] = n; }$/;"	f	struct:CvDTreeNode	access:public	signature:(int vi, int n)
CvDTreeNode::split	ml/ml.hpp	/^    CvDTreeSplit* split;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::tree_error	ml/ml.hpp	/^    double node_risk, tree_risk, tree_error;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::tree_risk	ml/ml.hpp	/^    double node_risk, tree_risk, tree_error;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeNode::value	ml/ml.hpp	/^    double value;$/;"	m	struct:CvDTreeNode	access:public
CvDTreeParams	ml/ml.hpp	/^    CvDTreeParams( int max_depth, int min_sample_count,$/;"	p	struct:CvDTreeParams	access:public	signature:( int max_depth, int min_sample_count, float regression_accuracy, bool use_surrogates, int max_categories, int cv_folds, bool use_1se_rule, bool truncate_pruned_tree, const float* priors )
CvDTreeParams	ml/ml.hpp	/^    CvDTreeParams();$/;"	p	struct:CvDTreeParams	access:public	signature:()
CvDTreeParams	ml/ml.hpp	/^struct CV_EXPORTS_W_MAP CvDTreeParams$/;"	s
CvDTreeParams::CvDTreeParams	ml/ml.hpp	/^    CvDTreeParams( int max_depth, int min_sample_count,$/;"	p	struct:CvDTreeParams	access:public	signature:( int max_depth, int min_sample_count, float regression_accuracy, bool use_surrogates, int max_categories, int cv_folds, bool use_1se_rule, bool truncate_pruned_tree, const float* priors )
CvDTreeParams::CvDTreeParams	ml/ml.hpp	/^    CvDTreeParams();$/;"	p	struct:CvDTreeParams	access:public	signature:()
CvDTreeParams::cv_folds	ml/ml.hpp	/^    CV_PROP_RW int   cv_folds;$/;"	m	struct:CvDTreeParams	access:public
CvDTreeParams::max_categories	ml/ml.hpp	/^    CV_PROP_RW int   max_categories;$/;"	m	struct:CvDTreeParams	access:public
CvDTreeParams::max_depth	ml/ml.hpp	/^    CV_PROP_RW int   max_depth;$/;"	m	struct:CvDTreeParams	access:public
CvDTreeParams::min_sample_count	ml/ml.hpp	/^    CV_PROP_RW int   min_sample_count;$/;"	m	struct:CvDTreeParams	access:public
CvDTreeParams::priors	ml/ml.hpp	/^    const float* priors;$/;"	m	struct:CvDTreeParams	access:public
CvDTreeParams::regression_accuracy	ml/ml.hpp	/^    CV_PROP_RW float regression_accuracy;$/;"	m	struct:CvDTreeParams	access:public
CvDTreeParams::truncate_pruned_tree	ml/ml.hpp	/^    CV_PROP_RW bool  truncate_pruned_tree;$/;"	m	struct:CvDTreeParams	access:public
CvDTreeParams::use_1se_rule	ml/ml.hpp	/^    CV_PROP_RW bool  use_1se_rule;$/;"	m	struct:CvDTreeParams	access:public
CvDTreeParams::use_surrogates	ml/ml.hpp	/^    CV_PROP_RW bool  use_surrogates;$/;"	m	struct:CvDTreeParams	access:public
CvDTreeSplit	ml/ml.hpp	/^struct CvDTreeSplit$/;"	s
CvDTreeSplit::__anon77::__anon78::c	ml/ml.hpp	/^            float c;$/;"	m	struct:CvDTreeSplit::__anon77::__anon78	access:public
CvDTreeSplit::__anon77::__anon78::split_point	ml/ml.hpp	/^            int split_point;$/;"	m	struct:CvDTreeSplit::__anon77::__anon78	access:public
CvDTreeSplit::__anon77::ord	ml/ml.hpp	/^        ord;$/;"	m	union:CvDTreeSplit::__anon77	typeref:struct:CvDTreeSplit::__anon77::__anon78	access:public
CvDTreeSplit::__anon77::subset	ml/ml.hpp	/^        int subset[2];$/;"	m	union:CvDTreeSplit::__anon77	access:public
CvDTreeSplit::condensed_idx	ml/ml.hpp	/^    int condensed_idx;$/;"	m	struct:CvDTreeSplit	access:public
CvDTreeSplit::inversed	ml/ml.hpp	/^    int inversed;$/;"	m	struct:CvDTreeSplit	access:public
CvDTreeSplit::next	ml/ml.hpp	/^    CvDTreeSplit* next;$/;"	m	struct:CvDTreeSplit	access:public
CvDTreeSplit::quality	ml/ml.hpp	/^    float quality;$/;"	m	struct:CvDTreeSplit	access:public
CvDTreeSplit::var_idx	ml/ml.hpp	/^    int var_idx;$/;"	m	struct:CvDTreeSplit	access:public
CvDTreeTrainData	ml/ml.hpp	/^    CvDTreeTrainData( const CvMat* trainData, int tflag,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, const CvDTreeParams& params=CvDTreeParams(), bool _shared=false, bool _add_labels=false )
CvDTreeTrainData	ml/ml.hpp	/^    CvDTreeTrainData();$/;"	p	struct:CvDTreeTrainData	access:public	signature:()
CvDTreeTrainData	ml/ml.hpp	/^struct CV_EXPORTS CvDTreeTrainData$/;"	s
CvDTreeTrainData::CvDTreeTrainData	ml/ml.hpp	/^    CvDTreeTrainData( const CvMat* trainData, int tflag,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, const CvDTreeParams& params=CvDTreeParams(), bool _shared=false, bool _add_labels=false )
CvDTreeTrainData::CvDTreeTrainData	ml/ml.hpp	/^    CvDTreeTrainData();$/;"	p	struct:CvDTreeTrainData	access:public	signature:()
CvDTreeTrainData::buf	ml/ml.hpp	/^    CvMat* buf;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::buf_count	ml/ml.hpp	/^    int buf_count, buf_size;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::buf_size	ml/ml.hpp	/^    int buf_count, buf_size;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::cat_count	ml/ml.hpp	/^    CvMat* cat_count;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::cat_map	ml/ml.hpp	/^    CvMat* cat_map;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::cat_ofs	ml/ml.hpp	/^    CvMat* cat_ofs;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::cat_var_count	ml/ml.hpp	/^    int ord_var_count, cat_var_count, work_var_count;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::clear	ml/ml.hpp	/^    virtual void clear();$/;"	p	struct:CvDTreeTrainData	access:public	signature:()
CvDTreeTrainData::counts	ml/ml.hpp	/^    CvMat* counts;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::cv_heap	ml/ml.hpp	/^    CvSet* cv_heap;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::data_root	ml/ml.hpp	/^    CvDTreeNode* data_root;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::direction	ml/ml.hpp	/^    CvMat* direction;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::do_responses_copy	ml/ml.hpp	/^    virtual void do_responses_copy();$/;"	p	struct:CvDTreeTrainData	access:public	signature:()
CvDTreeTrainData::free_node	ml/ml.hpp	/^    virtual void free_node( CvDTreeNode* node );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* node )
CvDTreeTrainData::free_node_data	ml/ml.hpp	/^    virtual void free_node_data( CvDTreeNode* node );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* node )
CvDTreeTrainData::free_train_data	ml/ml.hpp	/^    virtual void free_train_data();$/;"	p	struct:CvDTreeTrainData	access:public	signature:()
CvDTreeTrainData::get_cat_var_data	ml/ml.hpp	/^    virtual const int* get_cat_var_data( CvDTreeNode* n, int vi, int* cat_values_buf );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, int vi, int* cat_values_buf )
CvDTreeTrainData::get_child_buf_idx	ml/ml.hpp	/^    virtual int get_child_buf_idx( CvDTreeNode* n );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n )
CvDTreeTrainData::get_class_labels	ml/ml.hpp	/^    virtual const int* get_class_labels( CvDTreeNode* n, int* labels_buf );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, int* labels_buf )
CvDTreeTrainData::get_cv_labels	ml/ml.hpp	/^    virtual const int* get_cv_labels( CvDTreeNode* n, int* labels_buf );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, int* labels_buf )
CvDTreeTrainData::get_num_classes	ml/ml.hpp	/^    int get_num_classes() const;$/;"	p	struct:CvDTreeTrainData	access:public	signature:() const
CvDTreeTrainData::get_ord_responses	ml/ml.hpp	/^    virtual const float* get_ord_responses( CvDTreeNode* n, float* values_buf, int* sample_indices_buf );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, float* values_buf, int* sample_indices_buf )
CvDTreeTrainData::get_ord_var_data	ml/ml.hpp	/^    virtual void get_ord_var_data( CvDTreeNode* n, int vi, float* ord_values_buf, int* sorted_indices_buf,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, int vi, float* ord_values_buf, int* sorted_indices_buf, const float** ord_values, const int** sorted_indices, int* sample_indices_buf )
CvDTreeTrainData::get_sample_indices	ml/ml.hpp	/^    virtual const int* get_sample_indices( CvDTreeNode* n, int* indices_buf );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, int* indices_buf )
CvDTreeTrainData::get_var_type	ml/ml.hpp	/^    int get_var_type(int vi) const;$/;"	p	struct:CvDTreeTrainData	access:public	signature:(int vi) const
CvDTreeTrainData::get_vectors	ml/ml.hpp	/^    virtual void get_vectors( const CvMat* _subsample_idx,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( const CvMat* _subsample_idx, float* values, uchar* missing, float* responses, bool get_class_idx=false )
CvDTreeTrainData::get_work_var_count	ml/ml.hpp	/^    int get_work_var_count() const {return work_var_count;}$/;"	f	struct:CvDTreeTrainData	access:public	signature:() const
CvDTreeTrainData::have_labels	ml/ml.hpp	/^    bool have_labels, have_priors;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::have_priors	ml/ml.hpp	/^    bool have_labels, have_priors;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::is_buf_16u	ml/ml.hpp	/^    int is_buf_16u;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::is_classifier	ml/ml.hpp	/^    bool is_classifier;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::max_c_count	ml/ml.hpp	/^    int sample_count, var_all, var_count, max_c_count;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::new_node	ml/ml.hpp	/^    virtual CvDTreeNode* new_node( CvDTreeNode* parent, int count,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* parent, int count, int storage_idx, int offset )
CvDTreeTrainData::new_split_cat	ml/ml.hpp	/^    virtual CvDTreeSplit* new_split_cat( int vi, float quality );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( int vi, float quality )
CvDTreeTrainData::new_split_ord	ml/ml.hpp	/^    virtual CvDTreeSplit* new_split_ord( int vi, float cmp_val,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( int vi, float cmp_val, int split_point, int inversed, float quality )
CvDTreeTrainData::node_heap	ml/ml.hpp	/^    CvSet* node_heap;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::nv_heap	ml/ml.hpp	/^    CvSet* nv_heap;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::ord_var_count	ml/ml.hpp	/^    int ord_var_count, cat_var_count, work_var_count;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::params	ml/ml.hpp	/^    CvDTreeParams params;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::priors	ml/ml.hpp	/^    CvMat* priors;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::priors_mult	ml/ml.hpp	/^    CvMat* priors_mult;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::read_params	ml/ml.hpp	/^    virtual void read_params( CvFileStorage* fs, CvFileNode* node );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
CvDTreeTrainData::responses	ml/ml.hpp	/^    const CvMat* responses;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::responses_copy	ml/ml.hpp	/^    CvMat* responses_copy; \/\/ used in Boosting$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::rng	ml/ml.hpp	/^    cv::RNG* rng;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::sample_count	ml/ml.hpp	/^    int sample_count, var_all, var_count, max_c_count;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::set_data	ml/ml.hpp	/^    virtual void set_data( const CvMat* trainData, int tflag,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, const CvDTreeParams& params=CvDTreeParams(), bool _shared=false, bool _add_labels=false, bool _update_data=false )
CvDTreeTrainData::set_params	ml/ml.hpp	/^    virtual bool set_params( const CvDTreeParams& params );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( const CvDTreeParams& params )
CvDTreeTrainData::shared	ml/ml.hpp	/^    bool shared;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::split_buf	ml/ml.hpp	/^    CvMat* split_buf;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::split_heap	ml/ml.hpp	/^    CvSet* split_heap;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::subsample_data	ml/ml.hpp	/^    virtual CvDTreeNode* subsample_data( const CvMat* _subsample_idx );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( const CvMat* _subsample_idx )
CvDTreeTrainData::temp_storage	ml/ml.hpp	/^    CvMemStorage* temp_storage;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::tflag	ml/ml.hpp	/^    int tflag;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::train_data	ml/ml.hpp	/^    const CvMat* train_data;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::tree_storage	ml/ml.hpp	/^    CvMemStorage* tree_storage;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::var_all	ml/ml.hpp	/^    int sample_count, var_all, var_count, max_c_count;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::var_count	ml/ml.hpp	/^    int sample_count, var_all, var_count, max_c_count;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::var_idx	ml/ml.hpp	/^    CvMat* var_idx;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::var_type	ml/ml.hpp	/^    CvMat* var_type; \/\/ i-th element =$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::work_var_count	ml/ml.hpp	/^    int ord_var_count, cat_var_count, work_var_count;$/;"	m	struct:CvDTreeTrainData	access:public
CvDTreeTrainData::write_params	ml/ml.hpp	/^    virtual void write_params( CvFileStorage* fs ) const;$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvFileStorage* fs ) const
CvDTreeTrainData::~CvDTreeTrainData	ml/ml.hpp	/^    virtual ~CvDTreeTrainData();$/;"	p	struct:CvDTreeTrainData	access:public	signature:()
CvDataMatrixCode	objdetect/objdetect.hpp	/^struct CV_EXPORTS CvDataMatrixCode {$/;"	s
CvDataMatrixCode::corners	objdetect/objdetect.hpp	/^  CvMat *corners;$/;"	m	struct:CvDataMatrixCode	access:public
CvDataMatrixCode::msg	objdetect/objdetect.hpp	/^  char msg[4];$/;"	m	struct:CvDataMatrixCode	access:public
CvDataMatrixCode::original	objdetect/objdetect.hpp	/^  CvMat *original;$/;"	m	struct:CvDataMatrixCode	access:public
CvDefParam	legacy/blobtrack.hpp	/^struct CvDefParam$/;"	s
CvDefParam::Double	legacy/blobtrack.hpp	/^    double              Double;$/;"	m	struct:CvDefParam	access:public
CvDefParam::Float	legacy/blobtrack.hpp	/^    float               Float;$/;"	m	struct:CvDefParam	access:public
CvDefParam::Int	legacy/blobtrack.hpp	/^    int                 Int;$/;"	m	struct:CvDefParam	access:public
CvDefParam::Str	legacy/blobtrack.hpp	/^    char*               Str;$/;"	m	struct:CvDefParam	access:public
CvDefParam::next	legacy/blobtrack.hpp	/^    struct CvDefParam*    next;$/;"	m	struct:CvDefParam	typeref:struct:CvDefParam::CvDefParam	access:public
CvDefParam::pComment	legacy/blobtrack.hpp	/^    char*               pComment;$/;"	m	struct:CvDefParam	access:public
CvDefParam::pDouble	legacy/blobtrack.hpp	/^    double*             pDouble;$/;"	m	struct:CvDefParam	access:public
CvDefParam::pFloat	legacy/blobtrack.hpp	/^    float*              pFloat;$/;"	m	struct:CvDefParam	access:public
CvDefParam::pInt	legacy/blobtrack.hpp	/^    int*                pInt;$/;"	m	struct:CvDefParam	access:public
CvDefParam::pName	legacy/blobtrack.hpp	/^    char*               pName;$/;"	m	struct:CvDefParam	access:public
CvDefParam::pStr	legacy/blobtrack.hpp	/^    char**              pStr;$/;"	m	struct:CvDefParam	access:public
CvDetectedBlob	legacy/blobtrack.hpp	/^struct CV_EXPORTS CvDetectedBlob : public CvBlob$/;"	s	inherits:CvBlob
CvDetectedBlob::response	legacy/blobtrack.hpp	/^    float response;$/;"	m	struct:CvDetectedBlob	access:public
CvDisMaskType	legacy/compat.hpp	/^typedef int CvDisMaskType;$/;"	t
CvDisType	legacy/compat.hpp	/^typedef int CvDisType;$/;"	t
CvDistanceFunction	imgproc/types_c.h	/^typedef float (CV_CDECL * CvDistanceFunction)( const float* a, const float* b, void* user_param );$/;"	t
CvDrawShape	legacy/blobtrack.hpp	/^struct CvDrawShape$/;"	s
CvDrawShape::ELLIPSE	legacy/blobtrack.hpp	/^    enum {RECT, ELLIPSE} shape;$/;"	e	enum:CvDrawShape::__anon177
CvDrawShape::RECT	legacy/blobtrack.hpp	/^    enum {RECT, ELLIPSE} shape;$/;"	e	enum:CvDrawShape::__anon177
CvDrawShape::color	legacy/blobtrack.hpp	/^    CvScalar color;$/;"	m	struct:CvDrawShape	access:public
CvDrawShape::shape	legacy/blobtrack.hpp	/^    enum {RECT, ELLIPSE} shape;$/;"	m	struct:CvDrawShape	typeref:enum:CvDrawShape::__anon177	access:public
CvEHMM	legacy/legacy.hpp	/^typedef struct CvEHMM$/;"	s
CvEHMM	legacy/legacy.hpp	/^} CvEHMM;$/;"	t	typeref:struct:CvEHMM
CvEHMM::__anon183::ehmm	legacy/legacy.hpp	/^        struct CvEHMM* ehmm; \/* pointer to an embedded model or NULL, if it is a leaf *\/$/;"	m	union:CvEHMM::__anon183	typeref:struct:CvEHMM::__anon183::CvEHMM	access:public
CvEHMM::__anon183::state	legacy/legacy.hpp	/^        CvEHMMState* state; \/* if level == 0 points to real states array,$/;"	m	union:CvEHMM::__anon183	access:public
CvEHMM::level	legacy/legacy.hpp	/^    int level; \/* 0 - lowest(i.e its states are real states), ..... *\/$/;"	m	struct:CvEHMM	access:public
CvEHMM::num_states	legacy/legacy.hpp	/^    int num_states; \/* number of HMM states *\/$/;"	m	struct:CvEHMM	access:public
CvEHMM::obsProb	legacy/legacy.hpp	/^    float** obsProb; \/* if level == 0 - array of brob matrices corresponding to hmm$/;"	m	struct:CvEHMM	access:public
CvEHMM::transP	legacy/legacy.hpp	/^    float*  transP;\/*transition probab. matrices for states *\/$/;"	m	struct:CvEHMM	access:public
CvEHMM::u	legacy/legacy.hpp	/^    } u;$/;"	m	struct:CvEHMM	typeref:union:CvEHMM::__anon183	access:public
CvEHMMState	legacy/legacy.hpp	/^typedef struct CvEHMMState$/;"	s
CvEHMMState	legacy/legacy.hpp	/^} CvEHMMState;$/;"	t	typeref:struct:CvEHMMState
CvEHMMState::inv_var	legacy/legacy.hpp	/^    float* inv_var;     \/* square root of inversed variances corresp. to each mixture*\/$/;"	m	struct:CvEHMMState	access:public
CvEHMMState::log_var_val	legacy/legacy.hpp	/^    float* log_var_val; \/* sum of 0.5 (LN2PI + ln(variance[i]) ) for i=1,n *\/$/;"	m	struct:CvEHMMState	access:public
CvEHMMState::mu	legacy/legacy.hpp	/^    float* mu;          \/*mean vectors corresponding to each mixture*\/$/;"	m	struct:CvEHMMState	access:public
CvEHMMState::num_mix	legacy/legacy.hpp	/^    int num_mix;        \/*number of mixtures in this state*\/$/;"	m	struct:CvEHMMState	access:public
CvEHMMState::weight	legacy/legacy.hpp	/^    float* weight;      \/*array of mixture weights. Summ of all weights in state is 1. *\/$/;"	m	struct:CvEHMMState	access:public
CvEM	ml/ml.hpp	/^    CV_WRAP CvEM( const cv::Mat& samples, const cv::Mat& sampleIdx=cv::Mat(),$/;"	p	class:CvEM	access:public	signature:( const cv::Mat& samples, const cv::Mat& sampleIdx=cv::Mat(), CvEMParams params=CvEMParams() )
CvEM	ml/ml.hpp	/^    CV_WRAP CvEM();$/;"	p	class:CvEM	access:public	signature:()
CvEM	ml/ml.hpp	/^    CvEM( const CvMat* samples, const CvMat* sampleIdx=0,$/;"	p	class:CvEM	access:public	signature:( const CvMat* samples, const CvMat* sampleIdx=0, CvEMParams params=CvEMParams(), CvMat* labels=0 )
CvEM	ml/ml.hpp	/^class CV_EXPORTS_W CvEM : public CvStatModel$/;"	c	inherits:CvStatModel
CvEM::COV_MAT_DIAGONAL	ml/ml.hpp	/^    enum { COV_MAT_SPHERICAL=0, COV_MAT_DIAGONAL=1, COV_MAT_GENERIC=2 };$/;"	e	enum:CvEM::__anon75
CvEM::COV_MAT_GENERIC	ml/ml.hpp	/^    enum { COV_MAT_SPHERICAL=0, COV_MAT_DIAGONAL=1, COV_MAT_GENERIC=2 };$/;"	e	enum:CvEM::__anon75
CvEM::COV_MAT_SPHERICAL	ml/ml.hpp	/^    enum { COV_MAT_SPHERICAL=0, COV_MAT_DIAGONAL=1, COV_MAT_GENERIC=2 };$/;"	e	enum:CvEM::__anon75
CvEM::CvEM	ml/ml.hpp	/^    CV_WRAP CvEM( const cv::Mat& samples, const cv::Mat& sampleIdx=cv::Mat(),$/;"	p	class:CvEM	access:public	signature:( const cv::Mat& samples, const cv::Mat& sampleIdx=cv::Mat(), CvEMParams params=CvEMParams() )
CvEM::CvEM	ml/ml.hpp	/^    CV_WRAP CvEM();$/;"	p	class:CvEM	access:public	signature:()
CvEM::CvEM	ml/ml.hpp	/^    CvEM( const CvMat* samples, const CvMat* sampleIdx=0,$/;"	p	class:CvEM	access:public	signature:( const CvMat* samples, const CvMat* sampleIdx=0, CvEMParams params=CvEMParams(), CvMat* labels=0 )
CvEM::START_AUTO_STEP	ml/ml.hpp	/^    enum { START_E_STEP=1, START_M_STEP=2, START_AUTO_STEP=0 };$/;"	e	enum:CvEM::__anon76
CvEM::START_E_STEP	ml/ml.hpp	/^    enum { START_E_STEP=1, START_M_STEP=2, START_AUTO_STEP=0 };$/;"	e	enum:CvEM::__anon76
CvEM::START_M_STEP	ml/ml.hpp	/^    enum { START_E_STEP=1, START_M_STEP=2, START_AUTO_STEP=0 };$/;"	e	enum:CvEM::__anon76
CvEM::calcLikelihood	ml/ml.hpp	/^    CV_WRAP virtual double calcLikelihood( const cv::Mat &sample ) const;$/;"	p	class:CvEM	access:public	signature:( const cv::Mat &sample ) const
CvEM::clear	ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvEM	access:public	signature:()
CvEM::cov_rotate_mats	ml/ml.hpp	/^    CvMat** cov_rotate_mats;$/;"	m	class:CvEM	access:protected
CvEM::covs	ml/ml.hpp	/^    CvMat** covs;$/;"	m	class:CvEM	access:protected
CvEM::getCovs	ml/ml.hpp	/^    CV_WRAP void getCovs(CV_OUT std::vector<cv::Mat>& covs)      const;$/;"	p	class:CvEM	access:public	signature:(CV_OUT std::vector<cv::Mat>& covs) const
CvEM::getLikelihood	ml/ml.hpp	/^    CV_WRAP inline double getLikelihood() const { return log_likelihood; }$/;"	f	class:CvEM	access:public	signature:() const
CvEM::getLikelihoodDelta	ml/ml.hpp	/^    CV_WRAP inline double getLikelihoodDelta() const { return log_likelihood_delta; }$/;"	f	class:CvEM	access:public	signature:() const
CvEM::getMeans	ml/ml.hpp	/^    CV_WRAP cv::Mat  getMeans()     const;$/;"	p	class:CvEM	access:public	signature:() const
CvEM::getNClusters	ml/ml.hpp	/^    CV_WRAP int  getNClusters() const;$/;"	p	class:CvEM	access:public	signature:() const
CvEM::getProbs	ml/ml.hpp	/^    CV_WRAP cv::Mat  getProbs()     const;$/;"	p	class:CvEM	access:public	signature:() const
CvEM::getWeights	ml/ml.hpp	/^    CV_WRAP cv::Mat  getWeights()   const;$/;"	p	class:CvEM	access:public	signature:() const
CvEM::get_covs	ml/ml.hpp	/^    const CvMat** get_covs()      const;$/;"	p	class:CvEM	access:public	signature:() const
CvEM::get_log_likelihood	ml/ml.hpp	/^    inline double get_log_likelihood() const { return log_likelihood; }$/;"	f	class:CvEM	access:public	signature:() const
CvEM::get_log_likelihood_delta	ml/ml.hpp	/^    inline double get_log_likelihood_delta() const { return log_likelihood_delta; }$/;"	f	class:CvEM	access:public	signature:() const
CvEM::get_means	ml/ml.hpp	/^    const CvMat*  get_means()     const;$/;"	p	class:CvEM	access:public	signature:() const
CvEM::get_nclusters	ml/ml.hpp	/^    int           get_nclusters() const;$/;"	p	class:CvEM	access:public	signature:() const
CvEM::get_probs	ml/ml.hpp	/^    const CvMat*  get_probs()     const;$/;"	p	class:CvEM	access:public	signature:() const
CvEM::get_weights	ml/ml.hpp	/^    const CvMat*  get_weights()   const;$/;"	p	class:CvEM	access:public	signature:() const
CvEM::init_auto	ml/ml.hpp	/^    virtual void init_auto( const CvVectors& samples );$/;"	p	class:CvEM	access:protected	signature:( const CvVectors& samples )
CvEM::init_em	ml/ml.hpp	/^    virtual void init_em( const CvVectors& train_data );$/;"	p	class:CvEM	access:protected	signature:( const CvVectors& train_data )
CvEM::inv_eigen_values	ml/ml.hpp	/^    CvMat* inv_eigen_values;$/;"	m	class:CvEM	access:protected
CvEM::kmeans	ml/ml.hpp	/^    virtual void kmeans( const CvVectors& train_data, int nclusters,$/;"	p	class:CvEM	access:protected	signature:( const CvVectors& train_data, int nclusters, CvMat* labels, CvTermCriteria criteria, const CvMat* means )
CvEM::log_likelihood	ml/ml.hpp	/^    double log_likelihood;$/;"	m	class:CvEM	access:protected
CvEM::log_likelihood_delta	ml/ml.hpp	/^    double log_likelihood_delta;$/;"	m	class:CvEM	access:protected
CvEM::log_weight_div_det	ml/ml.hpp	/^    CvMat* log_weight_div_det;$/;"	m	class:CvEM	access:protected
CvEM::means	ml/ml.hpp	/^    CvMat* means;$/;"	m	class:CvEM	access:protected
CvEM::params	ml/ml.hpp	/^    CvEMParams params;$/;"	m	class:CvEM	access:protected
CvEM::predict	ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& sample, CV_OUT cv::Mat* probs=0 ) const;$/;"	p	class:CvEM	access:public	signature:( const cv::Mat& sample, CV_OUT cv::Mat* probs=0 ) const
CvEM::predict	ml/ml.hpp	/^    virtual float predict( const CvMat* sample, CV_OUT CvMat* probs ) const;$/;"	p	class:CvEM	access:public	signature:( const CvMat* sample, CV_OUT CvMat* probs ) const
CvEM::probs	ml/ml.hpp	/^    CvMat* probs;$/;"	m	class:CvEM	access:protected
CvEM::read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvEM	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
CvEM::read_params	ml/ml.hpp	/^    virtual void read_params( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvEM	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
CvEM::run_em	ml/ml.hpp	/^    virtual double run_em( const CvVectors& train_data );$/;"	p	class:CvEM	access:protected	signature:( const CvVectors& train_data )
CvEM::set_params	ml/ml.hpp	/^    virtual void set_params( const CvEMParams& params,$/;"	p	class:CvEM	access:protected	signature:( const CvEMParams& params, const CvVectors& train_data )
CvEM::train	ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& samples,$/;"	p	class:CvEM	access:public	signature:( const cv::Mat& samples, const cv::Mat& sampleIdx=cv::Mat(), CvEMParams params=CvEMParams(), CV_OUT cv::Mat* labels=0 )
CvEM::train	ml/ml.hpp	/^    virtual bool train( const CvMat* samples, const CvMat* sampleIdx=0,$/;"	p	class:CvEM	access:public	signature:( const CvMat* samples, const CvMat* sampleIdx=0, CvEMParams params=CvEMParams(), CvMat* labels=0 )
CvEM::weights	ml/ml.hpp	/^    CvMat* weights;$/;"	m	class:CvEM	access:protected
CvEM::write	ml/ml.hpp	/^    virtual void write( CvFileStorage* fs, const char* name ) const;$/;"	p	class:CvEM	access:public	signature:( CvFileStorage* fs, const char* name ) const
CvEM::write_params	ml/ml.hpp	/^    virtual void write_params( CvFileStorage* fs ) const;$/;"	p	class:CvEM	access:public	signature:( CvFileStorage* fs ) const
CvEM::~CvEM	ml/ml.hpp	/^    virtual ~CvEM();$/;"	p	class:CvEM	access:public	signature:()
CvEMParams	ml/ml.hpp	/^    CvEMParams( int nclusters, int cov_mat_type=1\/*CvEM::COV_MAT_DIAGONAL*\/,$/;"	p	struct:CvEMParams	access:public	signature:( int nclusters, int cov_mat_type=1 , int start_step=0 , CvTermCriteria term_crit=cvTermCriteria(CV_TERMCRIT_ITER+CV_TERMCRIT_EPS, 100, FLT_EPSILON), const CvMat* probs=0, const CvMat* weights=0, const CvMat* means=0, const CvMat** covs=0 )
CvEMParams	ml/ml.hpp	/^    CvEMParams();$/;"	p	struct:CvEMParams	access:public	signature:()
CvEMParams	ml/ml.hpp	/^struct CV_EXPORTS_W_MAP CvEMParams$/;"	s
CvEMParams::CvEMParams	ml/ml.hpp	/^    CvEMParams( int nclusters, int cov_mat_type=1\/*CvEM::COV_MAT_DIAGONAL*\/,$/;"	p	struct:CvEMParams	access:public	signature:( int nclusters, int cov_mat_type=1 , int start_step=0 , CvTermCriteria term_crit=cvTermCriteria(CV_TERMCRIT_ITER+CV_TERMCRIT_EPS, 100, FLT_EPSILON), const CvMat* probs=0, const CvMat* weights=0, const CvMat* means=0, const CvMat** covs=0 )
CvEMParams::CvEMParams	ml/ml.hpp	/^    CvEMParams();$/;"	p	struct:CvEMParams	access:public	signature:()
CvEMParams::cov_mat_type	ml/ml.hpp	/^    CV_PROP_RW int cov_mat_type;$/;"	m	struct:CvEMParams	access:public
CvEMParams::covs	ml/ml.hpp	/^    const CvMat** covs;$/;"	m	struct:CvEMParams	access:public
CvEMParams::means	ml/ml.hpp	/^    const CvMat* means;$/;"	m	struct:CvEMParams	access:public
CvEMParams::nclusters	ml/ml.hpp	/^    CV_PROP_RW int nclusters;$/;"	m	struct:CvEMParams	access:public
CvEMParams::probs	ml/ml.hpp	/^    const CvMat* probs;$/;"	m	struct:CvEMParams	access:public
CvEMParams::start_step	ml/ml.hpp	/^    CV_PROP_RW int start_step;$/;"	m	struct:CvEMParams	access:public
CvEMParams::term_crit	ml/ml.hpp	/^    CV_PROP_RW CvTermCriteria term_crit;$/;"	m	struct:CvEMParams	access:public
CvEMParams::weights	ml/ml.hpp	/^    const CvMat* weights;$/;"	m	struct:CvEMParams	access:public
CvERTreeTrainData	ml/ml.hpp	/^struct CV_EXPORTS CvERTreeTrainData : public CvDTreeTrainData$/;"	s	inherits:CvDTreeTrainData
CvERTreeTrainData::get_cat_var_data	ml/ml.hpp	/^    virtual const int* get_cat_var_data( CvDTreeNode* n, int vi, int* cat_values_buf );$/;"	p	struct:CvERTreeTrainData	access:public	signature:( CvDTreeNode* n, int vi, int* cat_values_buf )
CvERTreeTrainData::get_cv_labels	ml/ml.hpp	/^    virtual const int* get_cv_labels( CvDTreeNode* n, int* labels_buf );$/;"	p	struct:CvERTreeTrainData	access:public	signature:( CvDTreeNode* n, int* labels_buf )
CvERTreeTrainData::get_ord_var_data	ml/ml.hpp	/^    virtual void get_ord_var_data( CvDTreeNode* n, int vi, float* ord_values_buf, int* missing_buf,$/;"	p	struct:CvERTreeTrainData	access:public	signature:( CvDTreeNode* n, int vi, float* ord_values_buf, int* missing_buf, const float** ord_values, const int** missing, int* sample_buf = 0 )
CvERTreeTrainData::get_sample_indices	ml/ml.hpp	/^    virtual const int* get_sample_indices( CvDTreeNode* n, int* indices_buf );$/;"	p	struct:CvERTreeTrainData	access:public	signature:( CvDTreeNode* n, int* indices_buf )
CvERTreeTrainData::get_vectors	ml/ml.hpp	/^    virtual void get_vectors( const CvMat* _subsample_idx, float* values, uchar* missing,$/;"	p	struct:CvERTreeTrainData	access:public	signature:( const CvMat* _subsample_idx, float* values, uchar* missing, float* responses, bool get_class_idx=false )
CvERTreeTrainData::missing_mask	ml/ml.hpp	/^    const CvMat* missing_mask;$/;"	m	struct:CvERTreeTrainData	access:public
CvERTreeTrainData::set_data	ml/ml.hpp	/^    virtual void set_data( const CvMat* trainData, int tflag,$/;"	p	struct:CvERTreeTrainData	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, const CvDTreeParams& params=CvDTreeParams(), bool _shared=false, bool _add_labels=false, bool _update_data=false )
CvERTreeTrainData::subsample_data	ml/ml.hpp	/^    virtual CvDTreeNode* subsample_data( const CvMat* _subsample_idx );$/;"	p	struct:CvERTreeTrainData	access:public	signature:( const CvMat* _subsample_idx )
CvERTrees	ml/ml.hpp	/^    CV_WRAP CvERTrees();$/;"	p	class:CvERTrees	access:public	signature:()
CvERTrees	ml/ml.hpp	/^class CV_EXPORTS_W CvERTrees : public CvRTrees$/;"	c	inherits:CvRTrees
CvERTrees::CvERTrees	ml/ml.hpp	/^    CV_WRAP CvERTrees();$/;"	p	class:CvERTrees	access:public	signature:()
CvERTrees::grow_forest	ml/ml.hpp	/^    virtual bool grow_forest( const CvTermCriteria term_crit );$/;"	p	class:CvERTrees	access:protected	signature:( const CvTermCriteria term_crit )
CvERTrees::train	ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, int tflag,$/;"	p	class:CvERTrees	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvRTParams params=CvRTParams())
CvERTrees::train	ml/ml.hpp	/^    virtual bool train( CvMLData* data, CvRTParams params=CvRTParams() );$/;"	p	class:CvERTrees	access:public	signature:( CvMLData* data, CvRTParams params=CvRTParams() )
CvERTrees::train	ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvERTrees	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvRTParams params=CvRTParams())
CvERTrees::~CvERTrees	ml/ml.hpp	/^    virtual ~CvERTrees();$/;"	p	class:CvERTrees	access:public	signature:()
CvElementShape	legacy/compat.hpp	/^typedef int CvElementShape;$/;"	t
CvErrorCallback	core/core_c.h	/^typedef int (CV_CDECL *CvErrorCallback)( int status, const char* func_name,$/;"	t
CvFGDStatModel	video/background_segm.hpp	/^typedef struct CvFGDStatModel$/;"	s
CvFGDStatModel	video/background_segm.hpp	/^} CvFGDStatModel;$/;"	t	typeref:struct:CvFGDStatModel
CvFGDStatModel::CV_BG_STAT_MODEL_FIELDS	video/background_segm.hpp	/^    CV_BG_STAT_MODEL_FIELDS();$/;"	p	struct:CvFGDStatModel	access:public	signature:()
CvFGDStatModel::Fbd	video/background_segm.hpp	/^    IplImage*              Fbd;$/;"	m	struct:CvFGDStatModel	access:public
CvFGDStatModel::Ftd	video/background_segm.hpp	/^    IplImage*              Ftd;$/;"	m	struct:CvFGDStatModel	access:public
CvFGDStatModel::params	video/background_segm.hpp	/^    CvFGDStatModelParams   params;$/;"	m	struct:CvFGDStatModel	access:public
CvFGDStatModel::pixel_stat	video/background_segm.hpp	/^    CvBGPixelStat*         pixel_stat;$/;"	m	struct:CvFGDStatModel	access:public
CvFGDStatModel::prev_frame	video/background_segm.hpp	/^    IplImage*              prev_frame;$/;"	m	struct:CvFGDStatModel	access:public
CvFGDStatModelParams	video/background_segm.hpp	/^typedef struct CvFGDStatModelParams$/;"	s
CvFGDStatModelParams	video/background_segm.hpp	/^} CvFGDStatModelParams;$/;"	t	typeref:struct:CvFGDStatModelParams
CvFGDStatModelParams::Lc	video/background_segm.hpp	/^    int    Lc;			\/* Quantized levels per 'color' component. Power of two, typically 32, 64 or 128.				*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::Lcc	video/background_segm.hpp	/^    int    Lcc;			\/* Quantized levels per 'color co-occurrence' component.  Power of two, typically 16, 32 or 64.			*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::N1c	video/background_segm.hpp	/^    int    N1c;			\/* Number of color vectors used to model normal background color variation at a given pixel.			*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::N1cc	video/background_segm.hpp	/^    int    N1cc;		\/* Number of color co-occurrence vectors used to model normal background color variation at a given pixel.	*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::N2c	video/background_segm.hpp	/^    int    N2c;			\/* Number of color vectors retained at given pixel.  Must be > N1c, typically ~ 5\/3 of N1c.			*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::N2cc	video/background_segm.hpp	/^    int    N2cc;		\/* Number of color co-occurrence vectors retained at given pixel.  Must be > N1cc, typically ~ 5\/3 of N1cc.	*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::T	video/background_segm.hpp	/^    float  T;			\/* "A percentage value which determines when new features can be recognized as new background." (Typically 0.9).*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::alpha1	video/background_segm.hpp	/^    float  alpha1;		\/* How quickly we forget old background pixel values seen.  Typically set to 0.1  				*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::alpha2	video/background_segm.hpp	/^    float  alpha2;		\/* "Controls speed of feature learning". Depends on T. Typical value circa 0.005. 				*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::alpha3	video/background_segm.hpp	/^    float  alpha3;		\/* Alternate to alpha2, used (e.g.) for quicker initial convergence. Typical value 0.1.				*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::delta	video/background_segm.hpp	/^    float  delta;		\/* Affects color and color co-occurrence quantization, typically set to 2.					*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::is_obj_without_holes	video/background_segm.hpp	/^    int    is_obj_without_holes;\/* If TRUE we ignore holes within foreground blobs. Defaults to TRUE.						*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::minArea	video/background_segm.hpp	/^    float  minArea;		\/* Discard foreground blobs whose bounding box is smaller than this threshold.					*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDStatModelParams::perform_morphing	video/background_segm.hpp	/^    int    perform_morphing;	\/* Number of erode-dilate-erode foreground-blob cleanup iterations.						*\/$/;"	m	struct:CvFGDStatModelParams	access:public
CvFGDetector	legacy/blobtrack.hpp	/^    CvFGDetector();$/;"	p	class:CvFGDetector	access:public	signature:()
CvFGDetector	legacy/blobtrack.hpp	/^class CV_EXPORTS CvFGDetector : public CvVSModule$/;"	c	inherits:CvVSModule
CvFGDetector::CvFGDetector	legacy/blobtrack.hpp	/^    CvFGDetector();$/;"	p	class:CvFGDetector	access:public	signature:()
CvFGDetector::GetMask	legacy/blobtrack.hpp	/^    virtual IplImage* GetMask() = 0;$/;"	p	class:CvFGDetector	access:public	signature:()
CvFGDetector::Process	legacy/blobtrack.hpp	/^    virtual void    Process(IplImage* pImg) = 0;$/;"	p	class:CvFGDetector	access:public	signature:(IplImage* pImg)
CvFGDetector::Release	legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvFGDetector	access:public	signature:()
CvFace	legacy/legacy.hpp	/^typedef struct CvFace$/;"	s
CvFace::LeftEyeRect	legacy/legacy.hpp	/^    CvRect LeftEyeRect;$/;"	m	struct:CvFace	access:public
CvFace::MouthRect	legacy/legacy.hpp	/^    CvRect MouthRect;$/;"	m	struct:CvFace	access:public
CvFace::RightEyeRect	legacy/legacy.hpp	/^    CvRect RightEyeRect;$/;"	m	struct:CvFace	access:public
CvFaceData	legacy/legacy.hpp	/^} CvFaceData;$/;"	t	typeref:struct:CvFace
CvFaceTracker	legacy/legacy.hpp	/^typedef struct CvFaceTracker CvFaceTracker;$/;"	t	typeref:struct:CvFaceTracker
CvFileNode	core/types_c.h	/^CvFileNode;$/;"	t	typeref:struct:CvFileNode
CvFileNode	core/types_c.h	/^typedef struct CvFileNode$/;"	s
CvFileNode::__anon157::f	core/types_c.h	/^        double f; \/* scalar floating-point number *\/$/;"	m	union:CvFileNode::__anon157	access:public
CvFileNode::__anon157::i	core/types_c.h	/^        int i;    \/* scalar integer number *\/$/;"	m	union:CvFileNode::__anon157	access:public
CvFileNode::__anon157::map	core/types_c.h	/^        CvFileNodeHash* map; \/* map (collection of named file nodes) *\/$/;"	m	union:CvFileNode::__anon157	access:public
CvFileNode::__anon157::seq	core/types_c.h	/^        CvSeq* seq; \/* sequence (ordered collection of file nodes) *\/$/;"	m	union:CvFileNode::__anon157	access:public
CvFileNode::__anon157::str	core/types_c.h	/^        CvString str; \/* text string *\/$/;"	m	union:CvFileNode::__anon157	access:public
CvFileNode::data	core/types_c.h	/^    } data;$/;"	m	struct:CvFileNode	typeref:union:CvFileNode::__anon157	access:public
CvFileNode::info	core/types_c.h	/^    struct CvTypeInfo* info; \/* type information$/;"	m	struct:CvFileNode	typeref:struct:CvFileNode::CvTypeInfo	access:public
CvFileNode::tag	core/types_c.h	/^    int tag;$/;"	m	struct:CvFileNode	access:public
CvFileNodeHash	core/types_c.h	/^typedef struct CvGenericHash CvFileNodeHash;$/;"	t	typeref:struct:CvGenericHash
CvFileStorage	core/types_c.h	/^typedef struct CvFileStorage CvFileStorage;$/;"	t	typeref:struct:CvFileStorage
CvFont	core/core_c.h	/^CvFont;$/;"	t	typeref:struct:CvFont
CvFont	core/core_c.h	/^typedef struct CvFont$/;"	s
CvFont::ascii	core/core_c.h	/^    const int*  ascii; 			\/* font data and metrics *\/$/;"	m	struct:CvFont	access:public
CvFont::color	core/core_c.h	/^	CvScalar color;				\/\/Qt:ColorFont -> cvScalar(blue_component, green_component, red\\_component[, alpha_component])$/;"	m	struct:CvFont	access:public
CvFont::cyrillic	core/core_c.h	/^    const int*  cyrillic;$/;"	m	struct:CvFont	access:public
CvFont::dx	core/core_c.h	/^    float       dx; 			\/* horizontal interval between letters *\/$/;"	m	struct:CvFont	access:public
CvFont::font_face	core/core_c.h	/^    int         font_face; 		\/\/Qt: bool italic         \/* =CV_FONT_* *\/$/;"	m	struct:CvFont	access:public
CvFont::greek	core/core_c.h	/^    const int*  greek;$/;"	m	struct:CvFont	access:public
CvFont::hscale	core/core_c.h	/^    float       hscale, vscale;$/;"	m	struct:CvFont	access:public
CvFont::line_type	core/core_c.h	/^    int         line_type;		\/\/Qt: PointSize$/;"	m	struct:CvFont	access:public
CvFont::nameFont	core/core_c.h	/^	const char* nameFont;		\/\/Qt:nameFont$/;"	m	struct:CvFont	access:public
CvFont::shear	core/core_c.h	/^    float       shear; 			\/* slope coefficient: 0 - normal, >0 - italic *\/$/;"	m	struct:CvFont	access:public
CvFont::thickness	core/core_c.h	/^    int         thickness; 		\/\/Qt: weight               \/* letters thickness *\/$/;"	m	struct:CvFont	access:public
CvFont::vscale	core/core_c.h	/^    float       hscale, vscale;$/;"	m	struct:CvFont	access:public
CvFontFace	legacy/compat.hpp	/^typedef int CvFontFace;$/;"	t
CvForestERTree	ml/ml.hpp	/^class CV_EXPORTS CvForestERTree : public CvForestTree$/;"	c	inherits:CvForestTree
CvForestERTree::calc_node_dir	ml/ml.hpp	/^    virtual double calc_node_dir( CvDTreeNode* node );$/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* node )
CvForestERTree::find_split_cat_class	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_class( CvDTreeNode* n, int vi,$/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvForestERTree::find_split_cat_reg	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvForestERTree::find_split_ord_class	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_class( CvDTreeNode* n, int vi, $/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvForestERTree::find_split_ord_reg	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
CvForestERTree::split_node_data	ml/ml.hpp	/^    virtual void split_node_data( CvDTreeNode* n );$/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* n )
CvForestTree	ml/ml.hpp	/^    CvForestTree();$/;"	p	class:CvForestTree	access:public	signature:()
CvForestTree	ml/ml.hpp	/^class CV_EXPORTS CvForestTree: public CvDTree$/;"	c	inherits:CvDTree
CvForestTree::CvForestTree	ml/ml.hpp	/^    CvForestTree();$/;"	p	class:CvForestTree	access:public	signature:()
CvForestTree::find_best_split	ml/ml.hpp	/^    virtual CvDTreeSplit* find_best_split( CvDTreeNode* n );$/;"	p	class:CvForestTree	access:protected	signature:( CvDTreeNode* n )
CvForestTree::forest	ml/ml.hpp	/^    CvRTrees* forest;$/;"	m	class:CvForestTree	access:protected
CvForestTree::get_var_count	ml/ml.hpp	/^    virtual int get_var_count() const {return data ? data->var_count : 0;}$/;"	f	class:CvForestTree	access:public	signature:() const
CvForestTree::read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvForestTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
CvForestTree::read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node, CvRTrees* forest, CvDTreeTrainData* _data );$/;"	p	class:CvForestTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node, CvRTrees* forest, CvDTreeTrainData* _data )
CvForestTree::read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node,$/;"	p	class:CvForestTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node, CvDTreeTrainData* data )
CvForestTree::train	ml/ml.hpp	/^    virtual bool train( CvDTreeTrainData* trainData, const CvMat* _subsample_idx );$/;"	p	class:CvForestTree	access:public	signature:( CvDTreeTrainData* trainData, const CvMat* _subsample_idx )
CvForestTree::train	ml/ml.hpp	/^    virtual bool train( CvDTreeTrainData* trainData, const CvMat* _subsample_idx, CvRTrees* forest );$/;"	p	class:CvForestTree	access:public	signature:( CvDTreeTrainData* trainData, const CvMat* _subsample_idx, CvRTrees* forest )
CvForestTree::train	ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvForestTree	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvDTreeParams params=CvDTreeParams() )
CvForestTree::~CvForestTree	ml/ml.hpp	/^    virtual ~CvForestTree();$/;"	p	class:CvForestTree	access:public	signature:()
CvFreeFunc	core/core_c.h	/^typedef int (CV_CDECL *CvFreeFunc)(void* pptr, void* userdata);$/;"	t
CvFuncTable	core/internal.hpp	/^CvFuncTable;$/;"	t	typeref:struct:CvFuncTable
CvFuncTable	core/internal.hpp	/^typedef struct CvFuncTable$/;"	s
CvFuncTable::fn_2d	core/internal.hpp	/^    void*   fn_2d[CV_DEPTH_MAX];$/;"	m	struct:CvFuncTable	access:public
CvFuzzyController	contrib/contrib.hpp	/^    CvFuzzyController();$/;"	p	class:CvFuzzyController	access:public	signature:()
CvFuzzyController	contrib/contrib.hpp	/^class CV_EXPORTS CvFuzzyController {$/;"	c
CvFuzzyController::CvFuzzyController	contrib/contrib.hpp	/^    CvFuzzyController();$/;"	p	class:CvFuzzyController	access:public	signature:()
CvFuzzyController::addRule	contrib/contrib.hpp	/^    void addRule(CvFuzzyCurve *c1, CvFuzzyCurve *c2, CvFuzzyCurve *o1);$/;"	p	class:CvFuzzyController	access:public	signature:(CvFuzzyCurve *c1, CvFuzzyCurve *c2, CvFuzzyCurve *o1)
CvFuzzyController::calcOutput	contrib/contrib.hpp	/^    double calcOutput(double param1, double param2);$/;"	p	class:CvFuzzyController	access:public	signature:(double param1, double param2)
CvFuzzyController::rules	contrib/contrib.hpp	/^    std::vector<CvFuzzyRule*> rules;$/;"	m	class:CvFuzzyController	access:private
CvFuzzyController::~CvFuzzyController	contrib/contrib.hpp	/^    ~CvFuzzyController();$/;"	p	class:CvFuzzyController	access:public	signature:()
CvFuzzyCurve	contrib/contrib.hpp	/^    CvFuzzyCurve();$/;"	p	class:CvFuzzyCurve	access:public	signature:()
CvFuzzyCurve	contrib/contrib.hpp	/^class CV_EXPORTS CvFuzzyCurve {$/;"	c
CvFuzzyCurve::CvFuzzyCurve	contrib/contrib.hpp	/^    CvFuzzyCurve();$/;"	p	class:CvFuzzyCurve	access:public	signature:()
CvFuzzyCurve::addPoint	contrib/contrib.hpp	/^    void addPoint(double x, double y);$/;"	p	class:CvFuzzyCurve	access:public	signature:(double x, double y)
CvFuzzyCurve::between	contrib/contrib.hpp	/^    bool between(double x, double x1, double x2);$/;"	p	class:CvFuzzyCurve	access:private	signature:(double x, double x1, double x2)
CvFuzzyCurve::calcValue	contrib/contrib.hpp	/^    double calcValue(double param);$/;"	p	class:CvFuzzyCurve	access:public	signature:(double param)
CvFuzzyCurve::centre	contrib/contrib.hpp	/^    double value, centre;$/;"	m	class:CvFuzzyCurve	access:private
CvFuzzyCurve::clear	contrib/contrib.hpp	/^    void clear();$/;"	p	class:CvFuzzyCurve	access:public	signature:()
CvFuzzyCurve::getCentre	contrib/contrib.hpp	/^    double getCentre();$/;"	p	class:CvFuzzyCurve	access:public	signature:()
CvFuzzyCurve::getValue	contrib/contrib.hpp	/^    double getValue();$/;"	p	class:CvFuzzyCurve	access:public	signature:()
CvFuzzyCurve::points	contrib/contrib.hpp	/^    std::vector<CvFuzzyPoint> points;$/;"	m	class:CvFuzzyCurve	access:private
CvFuzzyCurve::setCentre	contrib/contrib.hpp	/^    void setCentre(double _centre);$/;"	p	class:CvFuzzyCurve	access:public	signature:(double _centre)
CvFuzzyCurve::setValue	contrib/contrib.hpp	/^    void setValue(double _value);$/;"	p	class:CvFuzzyCurve	access:public	signature:(double _value)
CvFuzzyCurve::value	contrib/contrib.hpp	/^    double value, centre;$/;"	m	class:CvFuzzyCurve	access:private
CvFuzzyCurve::~CvFuzzyCurve	contrib/contrib.hpp	/^    ~CvFuzzyCurve();$/;"	p	class:CvFuzzyCurve	access:public	signature:()
CvFuzzyFunction	contrib/contrib.hpp	/^    CvFuzzyFunction();$/;"	p	class:CvFuzzyFunction	access:public	signature:()
CvFuzzyFunction	contrib/contrib.hpp	/^class CV_EXPORTS CvFuzzyFunction {$/;"	c
CvFuzzyFunction::CvFuzzyFunction	contrib/contrib.hpp	/^    CvFuzzyFunction();$/;"	p	class:CvFuzzyFunction	access:public	signature:()
CvFuzzyFunction::addCurve	contrib/contrib.hpp	/^    void addCurve(CvFuzzyCurve *curve, double value = 0);$/;"	p	class:CvFuzzyFunction	access:public	signature:(CvFuzzyCurve *curve, double value = 0)
CvFuzzyFunction::calcValue	contrib/contrib.hpp	/^    double calcValue();$/;"	p	class:CvFuzzyFunction	access:public	signature:()
CvFuzzyFunction::curves	contrib/contrib.hpp	/^    std::vector<CvFuzzyCurve> curves;$/;"	m	class:CvFuzzyFunction	access:public
CvFuzzyFunction::newCurve	contrib/contrib.hpp	/^    CvFuzzyCurve *newCurve();$/;"	p	class:CvFuzzyFunction	access:public	signature:()
CvFuzzyFunction::resetValues	contrib/contrib.hpp	/^    void resetValues();$/;"	p	class:CvFuzzyFunction	access:public	signature:()
CvFuzzyFunction::~CvFuzzyFunction	contrib/contrib.hpp	/^    ~CvFuzzyFunction();$/;"	p	class:CvFuzzyFunction	access:public	signature:()
CvFuzzyMeanShiftTracker	contrib/contrib.hpp	/^    CvFuzzyMeanShiftTracker();$/;"	p	class:CvFuzzyMeanShiftTracker	access:public	signature:()
CvFuzzyMeanShiftTracker	contrib/contrib.hpp	/^class CV_EXPORTS CvFuzzyMeanShiftTracker$/;"	c
CvFuzzyMeanShiftTracker::CvFuzzyMeanShiftTracker	contrib/contrib.hpp	/^    CvFuzzyMeanShiftTracker();$/;"	p	class:CvFuzzyMeanShiftTracker	access:public	signature:()
CvFuzzyMeanShiftTracker::FuzzyResizer	contrib/contrib.hpp	/^    class FuzzyResizer$/;"	c	class:CvFuzzyMeanShiftTracker	access:private
CvFuzzyMeanShiftTracker::FuzzyResizer::FuzzyResizer	contrib/contrib.hpp	/^        FuzzyResizer();$/;"	p	class:CvFuzzyMeanShiftTracker::FuzzyResizer	access:public	signature:()
CvFuzzyMeanShiftTracker::FuzzyResizer::calcOutput	contrib/contrib.hpp	/^        int calcOutput(double edgeDensity, double density);$/;"	p	class:CvFuzzyMeanShiftTracker::FuzzyResizer	access:public	signature:(double edgeDensity, double density)
CvFuzzyMeanShiftTracker::FuzzyResizer::fuzzyController	contrib/contrib.hpp	/^        CvFuzzyController fuzzyController;$/;"	m	class:CvFuzzyMeanShiftTracker::FuzzyResizer	access:private
CvFuzzyMeanShiftTracker::FuzzyResizer::iInput	contrib/contrib.hpp	/^        CvFuzzyFunction iInput, iOutput;$/;"	m	class:CvFuzzyMeanShiftTracker::FuzzyResizer	access:private
CvFuzzyMeanShiftTracker::FuzzyResizer::iOutput	contrib/contrib.hpp	/^        CvFuzzyFunction iInput, iOutput;$/;"	m	class:CvFuzzyMeanShiftTracker::FuzzyResizer	access:private
CvFuzzyMeanShiftTracker::MaxMeanShiftIteration	contrib/contrib.hpp	/^        MaxMeanShiftIteration   = 5,$/;"	e	enum:CvFuzzyMeanShiftTracker::__anon5
CvFuzzyMeanShiftTracker::MaxSetSizeIteration	contrib/contrib.hpp	/^        MaxSetSizeIteration     = 5$/;"	e	enum:CvFuzzyMeanShiftTracker::__anon5
CvFuzzyMeanShiftTracker::MinKernelMass	contrib/contrib.hpp	/^        MinKernelMass           = 1000$/;"	e	enum:CvFuzzyMeanShiftTracker::__anon4
CvFuzzyMeanShiftTracker::ResizeMethod	contrib/contrib.hpp	/^    enum ResizeMethod {$/;"	g	class:CvFuzzyMeanShiftTracker	access:public
CvFuzzyMeanShiftTracker::SearchWindow	contrib/contrib.hpp	/^    class SearchWindow$/;"	c	class:CvFuzzyMeanShiftTracker	access:private
CvFuzzyMeanShiftTracker::SearchWindow::SearchWindow	contrib/contrib.hpp	/^        SearchWindow();$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:()
CvFuzzyMeanShiftTracker::SearchWindow::density	contrib/contrib.hpp	/^        double density;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::depthHigh	contrib/contrib.hpp	/^        unsigned int depthLow, depthHigh;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::depthLow	contrib/contrib.hpp	/^        unsigned int depthLow, depthHigh;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::ellipseAngle	contrib/contrib.hpp	/^        double ellipseAngle;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::ellipseHeight	contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::ellipseWidth	contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::extractInfo	contrib/contrib.hpp	/^        void extractInfo(IplImage *maskImage, IplImage *depthMap, bool initDepth);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(IplImage *maskImage, IplImage *depthMap, bool initDepth)
CvFuzzyMeanShiftTracker::SearchWindow::fuzzyResizer	contrib/contrib.hpp	/^        FuzzyResizer *fuzzyResizer;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::getResizeAttribsEdgeDensityFuzzy	contrib/contrib.hpp	/^        void getResizeAttribsEdgeDensityFuzzy(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh)
CvFuzzyMeanShiftTracker::SearchWindow::getResizeAttribsEdgeDensityLinear	contrib/contrib.hpp	/^        void getResizeAttribsEdgeDensityLinear(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh)
CvFuzzyMeanShiftTracker::SearchWindow::getResizeAttribsInnerDensity	contrib/contrib.hpp	/^        void getResizeAttribsInnerDensity(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh)
CvFuzzyMeanShiftTracker::SearchWindow::height	contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::horizontalEdgeBottom	contrib/contrib.hpp	/^        int verticalEdgeLeft, verticalEdgeRight, horizontalEdgeTop, horizontalEdgeBottom;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::horizontalEdgeTop	contrib/contrib.hpp	/^        int verticalEdgeLeft, verticalEdgeRight, horizontalEdgeTop, horizontalEdgeBottom;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::initDepthValues	contrib/contrib.hpp	/^        void initDepthValues(IplImage *maskImage, IplImage *depthMap);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(IplImage *maskImage, IplImage *depthMap)
CvFuzzyMeanShiftTracker::SearchWindow::ldh	contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::ldw	contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::ldx	contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::ldy	contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::m00	contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::m01	contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::m02	contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::m10	contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::m11	contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::m20	contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::maxHeight	contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::maxWidth	contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::meanShift	contrib/contrib.hpp	/^        bool meanShift(IplImage *maskImage, IplImage *depthMap, int maxIteration, bool initDepth);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(IplImage *maskImage, IplImage *depthMap, int maxIteration, bool initDepth)
CvFuzzyMeanShiftTracker::SearchWindow::numIters	contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::numShifts	contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::setSize	contrib/contrib.hpp	/^        void setSize(int _x, int _y, int _width, int _height);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(int _x, int _y, int _width, int _height)
CvFuzzyMeanShiftTracker::SearchWindow::shift	contrib/contrib.hpp	/^        bool shift();$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:()
CvFuzzyMeanShiftTracker::SearchWindow::verticalEdgeLeft	contrib/contrib.hpp	/^        int verticalEdgeLeft, verticalEdgeRight, horizontalEdgeTop, horizontalEdgeBottom;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::verticalEdgeRight	contrib/contrib.hpp	/^        int verticalEdgeLeft, verticalEdgeRight, horizontalEdgeTop, horizontalEdgeBottom;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::width	contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::x	contrib/contrib.hpp	/^        int x, y;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::xGc	contrib/contrib.hpp	/^        int xGc, yGc;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::y	contrib/contrib.hpp	/^        int x, y;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::yGc	contrib/contrib.hpp	/^        int xGc, yGc;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
CvFuzzyMeanShiftTracker::SearchWindow::~SearchWindow	contrib/contrib.hpp	/^        ~SearchWindow();$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:()
CvFuzzyMeanShiftTracker::TrackingState	contrib/contrib.hpp	/^    enum TrackingState$/;"	g	class:CvFuzzyMeanShiftTracker	access:public
CvFuzzyMeanShiftTracker::findOptimumSearchWindow	contrib/contrib.hpp	/^    void findOptimumSearchWindow(SearchWindow &searchWindow, IplImage *maskImage, IplImage *depthMap, int maxIteration, int resizeMethod, bool initDepth);$/;"	p	class:CvFuzzyMeanShiftTracker	access:private	signature:(SearchWindow &searchWindow, IplImage *maskImage, IplImage *depthMap, int maxIteration, int resizeMethod, bool initDepth)
CvFuzzyMeanShiftTracker::kernel	contrib/contrib.hpp	/^    SearchWindow kernel;$/;"	m	class:CvFuzzyMeanShiftTracker	access:public
CvFuzzyMeanShiftTracker::rmEdgeDensityFuzzy	contrib/contrib.hpp	/^        rmEdgeDensityFuzzy      = 1,$/;"	e	enum:CvFuzzyMeanShiftTracker::ResizeMethod
CvFuzzyMeanShiftTracker::rmEdgeDensityLinear	contrib/contrib.hpp	/^        rmEdgeDensityLinear     = 0,$/;"	e	enum:CvFuzzyMeanShiftTracker::ResizeMethod
CvFuzzyMeanShiftTracker::rmInnerDensity	contrib/contrib.hpp	/^        rmInnerDensity          = 2$/;"	e	enum:CvFuzzyMeanShiftTracker::ResizeMethod
CvFuzzyMeanShiftTracker::searchMode	contrib/contrib.hpp	/^    int searchMode;$/;"	m	class:CvFuzzyMeanShiftTracker	access:public
CvFuzzyMeanShiftTracker::track	contrib/contrib.hpp	/^    void track(IplImage *maskImage, IplImage *depthMap, int resizeMethod, bool resetSearch, int minKernelMass = MinKernelMass);$/;"	p	class:CvFuzzyMeanShiftTracker	access:public	signature:(IplImage *maskImage, IplImage *depthMap, int resizeMethod, bool resetSearch, int minKernelMass = MinKernelMass)
CvFuzzyMeanShiftTracker::tsDisabled	contrib/contrib.hpp	/^        tsDisabled      = 10$/;"	e	enum:CvFuzzyMeanShiftTracker::TrackingState
CvFuzzyMeanShiftTracker::tsNone	contrib/contrib.hpp	/^        tsNone          = 0,$/;"	e	enum:CvFuzzyMeanShiftTracker::TrackingState
CvFuzzyMeanShiftTracker::tsSearching	contrib/contrib.hpp	/^        tsSearching     = 1,$/;"	e	enum:CvFuzzyMeanShiftTracker::TrackingState
CvFuzzyMeanShiftTracker::tsSetWindow	contrib/contrib.hpp	/^        tsSetWindow     = 3,$/;"	e	enum:CvFuzzyMeanShiftTracker::TrackingState
CvFuzzyMeanShiftTracker::tsTracking	contrib/contrib.hpp	/^        tsTracking      = 2,$/;"	e	enum:CvFuzzyMeanShiftTracker::TrackingState
CvFuzzyMeanShiftTracker::~CvFuzzyMeanShiftTracker	contrib/contrib.hpp	/^    ~CvFuzzyMeanShiftTracker();$/;"	p	class:CvFuzzyMeanShiftTracker	access:public	signature:()
CvFuzzyPoint	contrib/contrib.hpp	/^    CvFuzzyPoint(double _x, double _y);$/;"	p	class:CvFuzzyPoint	access:public	signature:(double _x, double _y)
CvFuzzyPoint	contrib/contrib.hpp	/^class CV_EXPORTS CvFuzzyPoint {$/;"	c
CvFuzzyPoint::CvFuzzyPoint	contrib/contrib.hpp	/^    CvFuzzyPoint(double _x, double _y);$/;"	p	class:CvFuzzyPoint	access:public	signature:(double _x, double _y)
CvFuzzyPoint::value	contrib/contrib.hpp	/^    double x, y, value;$/;"	m	class:CvFuzzyPoint	access:public
CvFuzzyPoint::x	contrib/contrib.hpp	/^    double x, y, value;$/;"	m	class:CvFuzzyPoint	access:public
CvFuzzyPoint::y	contrib/contrib.hpp	/^    double x, y, value;$/;"	m	class:CvFuzzyPoint	access:public
CvFuzzyRule	contrib/contrib.hpp	/^    CvFuzzyRule();$/;"	p	class:CvFuzzyRule	access:public	signature:()
CvFuzzyRule	contrib/contrib.hpp	/^class CV_EXPORTS CvFuzzyRule {$/;"	c
CvFuzzyRule::CvFuzzyRule	contrib/contrib.hpp	/^    CvFuzzyRule();$/;"	p	class:CvFuzzyRule	access:public	signature:()
CvFuzzyRule::calcValue	contrib/contrib.hpp	/^    double calcValue(double param1, double param2);$/;"	p	class:CvFuzzyRule	access:public	signature:(double param1, double param2)
CvFuzzyRule::fuzzyInput1	contrib/contrib.hpp	/^    CvFuzzyCurve *fuzzyInput1, *fuzzyInput2;$/;"	m	class:CvFuzzyRule	access:private
CvFuzzyRule::fuzzyInput2	contrib/contrib.hpp	/^    CvFuzzyCurve *fuzzyInput1, *fuzzyInput2;$/;"	m	class:CvFuzzyRule	access:private
CvFuzzyRule::fuzzyOutput	contrib/contrib.hpp	/^    CvFuzzyCurve *fuzzyOutput;$/;"	m	class:CvFuzzyRule	access:private
CvFuzzyRule::getOutputCurve	contrib/contrib.hpp	/^    CvFuzzyCurve *getOutputCurve();$/;"	p	class:CvFuzzyRule	access:public	signature:()
CvFuzzyRule::setRule	contrib/contrib.hpp	/^    void setRule(CvFuzzyCurve *c1, CvFuzzyCurve *c2, CvFuzzyCurve *o1);$/;"	p	class:CvFuzzyRule	access:public	signature:(CvFuzzyCurve *c1, CvFuzzyCurve *c2, CvFuzzyCurve *o1)
CvFuzzyRule::~CvFuzzyRule	contrib/contrib.hpp	/^    ~CvFuzzyRule();$/;"	p	class:CvFuzzyRule	access:public	signature:()
CvGBTrees	ml/ml.hpp	/^    CV_WRAP CvGBTrees( const cv::Mat& trainData, int tflag,$/;"	p	class:CvGBTrees	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvGBTreesParams params=CvGBTreesParams() )
CvGBTrees	ml/ml.hpp	/^    CV_WRAP CvGBTrees();$/;"	p	class:CvGBTrees	access:public	signature:()
CvGBTrees	ml/ml.hpp	/^    CvGBTrees( const CvMat* trainData, int tflag,$/;"	p	class:CvGBTrees	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvGBTreesParams params=CvGBTreesParams() )
CvGBTrees	ml/ml.hpp	/^class CV_EXPORTS_W CvGBTrees : public CvStatModel$/;"	c	inherits:CvStatModel
CvGBTrees::ABSOLUTE_LOSS	ml/ml.hpp	/^    enum {SQUARED_LOSS=0, ABSOLUTE_LOSS, HUBER_LOSS=3, DEVIANCE_LOSS};$/;"	e	enum:CvGBTrees::__anon81
CvGBTrees::CvGBTrees	ml/ml.hpp	/^    CV_WRAP CvGBTrees( const cv::Mat& trainData, int tflag,$/;"	p	class:CvGBTrees	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvGBTreesParams params=CvGBTreesParams() )
CvGBTrees::CvGBTrees	ml/ml.hpp	/^    CV_WRAP CvGBTrees();$/;"	p	class:CvGBTrees	access:public	signature:()
CvGBTrees::CvGBTrees	ml/ml.hpp	/^    CvGBTrees( const CvMat* trainData, int tflag,$/;"	p	class:CvGBTrees	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvGBTreesParams params=CvGBTreesParams() )
CvGBTrees::DEVIANCE_LOSS	ml/ml.hpp	/^    enum {SQUARED_LOSS=0, ABSOLUTE_LOSS, HUBER_LOSS=3, DEVIANCE_LOSS};$/;"	e	enum:CvGBTrees::__anon81
CvGBTrees::GetLeaves	ml/ml.hpp	/^    CvDTreeNode** GetLeaves( const CvDTree* dtree, int& len );$/;"	p	class:CvGBTrees	access:protected	signature:( const CvDTree* dtree, int& len )
CvGBTrees::HUBER_LOSS	ml/ml.hpp	/^    enum {SQUARED_LOSS=0, ABSOLUTE_LOSS, HUBER_LOSS=3, DEVIANCE_LOSS};$/;"	e	enum:CvGBTrees::__anon81
CvGBTrees::SQUARED_LOSS	ml/ml.hpp	/^    enum {SQUARED_LOSS=0, ABSOLUTE_LOSS, HUBER_LOSS=3, DEVIANCE_LOSS};$/;"	e	enum:CvGBTrees::__anon81
CvGBTrees::base_value	ml/ml.hpp	/^    float base_value;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::calc_error	ml/ml.hpp	/^    virtual float calc_error( CvMLData* _data, int type,$/;"	p	class:CvGBTrees	access:public	signature:( CvMLData* _data, int type, std::vector<float> *resp = 0 )
CvGBTrees::change_values	ml/ml.hpp	/^    virtual void change_values(CvDTree* tree, const int k = 0);$/;"	p	class:CvGBTrees	access:protected	signature:(CvDTree* tree, const int k = 0)
CvGBTrees::class_count	ml/ml.hpp	/^    int class_count;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::class_labels	ml/ml.hpp	/^    CvMat* class_labels;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::clear	ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvGBTrees	access:public	signature:()
CvGBTrees::data	ml/ml.hpp	/^    CvDTreeTrainData* data;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::delta	ml/ml.hpp	/^    float delta;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::do_subsample	ml/ml.hpp	/^    virtual void do_subsample();$/;"	p	class:CvGBTrees	access:protected	signature:()
CvGBTrees::find_gradient	ml/ml.hpp	/^    virtual void find_gradient( const int k = 0);$/;"	p	class:CvGBTrees	access:protected	signature:( const int k = 0)
CvGBTrees::find_optimal_value	ml/ml.hpp	/^    virtual float find_optimal_value( const CvMat* _Idx );$/;"	p	class:CvGBTrees	access:protected	signature:( const CvMat* _Idx )
CvGBTrees::get_len	ml/ml.hpp	/^	int get_len(const CvMat* mat) const;$/;"	p	class:CvGBTrees	access:protected	signature:(const CvMat* mat) const
CvGBTrees::leaves_get	ml/ml.hpp	/^    void leaves_get( CvDTreeNode** leaves, int& count, CvDTreeNode* node );$/;"	p	class:CvGBTrees	access:protected	signature:( CvDTreeNode** leaves, int& count, CvDTreeNode* node )
CvGBTrees::missing	ml/ml.hpp	/^    CvMat* missing;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::orig_response	ml/ml.hpp	/^    CvMat* orig_response;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::params	ml/ml.hpp	/^    CvGBTreesParams params;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::predict	ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& sample, const cv::Mat& missing=cv::Mat(),$/;"	p	class:CvGBTrees	access:public	signature:( const cv::Mat& sample, const cv::Mat& missing=cv::Mat(), const cv::Range& slice = cv::Range::all(), int k=-1 ) const
CvGBTrees::predict	ml/ml.hpp	/^    virtual float predict( const CvMat* sample, const CvMat* missing=0,$/;"	p	class:CvGBTrees	access:public	signature:( const CvMat* sample, const CvMat* missing=0, CvMat* weakResponses=0, CvSlice slice = CV_WHOLE_SEQ, int k=-1 ) const
CvGBTrees::predict_serial	ml/ml.hpp	/^    virtual float predict_serial( const CvMat* sample, const CvMat* missing=0,$/;"	p	class:CvGBTrees	access:public	signature:( const CvMat* sample, const CvMat* missing=0, CvMat* weakResponses=0, CvSlice slice = CV_WHOLE_SEQ, int k=-1 ) const
CvGBTrees::problem_type	ml/ml.hpp	/^    virtual bool problem_type() const;$/;"	p	class:CvGBTrees	access:protected	signature:() const
CvGBTrees::read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvGBTrees	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
CvGBTrees::read_params	ml/ml.hpp	/^    virtual void read_params( CvFileStorage* fs, CvFileNode* fnode );$/;"	p	class:CvGBTrees	access:protected	signature:( CvFileStorage* fs, CvFileNode* fnode )
CvGBTrees::rng	ml/ml.hpp	/^    cv::RNG* rng;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::sample_idx	ml/ml.hpp	/^    CvMat* sample_idx;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::subsample_test	ml/ml.hpp	/^    CvMat* subsample_test;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::subsample_train	ml/ml.hpp	/^    CvMat* subsample_train;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::sum_response	ml/ml.hpp	/^    CvMat* sum_response;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::sum_response_tmp	ml/ml.hpp	/^    CvMat* sum_response_tmp;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::train	ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, int tflag,$/;"	p	class:CvGBTrees	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvGBTreesParams params=CvGBTreesParams(), bool update=false )
CvGBTrees::train	ml/ml.hpp	/^    virtual bool train( CvMLData* data,$/;"	p	class:CvGBTrees	access:public	signature:( CvMLData* data, CvGBTreesParams params=CvGBTreesParams(), bool update=false )
CvGBTrees::train	ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvGBTrees	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvGBTreesParams params=CvGBTreesParams(), bool update=false )
CvGBTrees::weak	ml/ml.hpp	/^    CvSeq** weak;$/;"	m	class:CvGBTrees	access:protected
CvGBTrees::write	ml/ml.hpp	/^    virtual void write( CvFileStorage* fs, const char* name ) const;$/;"	p	class:CvGBTrees	access:public	signature:( CvFileStorage* fs, const char* name ) const
CvGBTrees::write_params	ml/ml.hpp	/^    virtual void write_params( CvFileStorage* fs ) const;$/;"	p	class:CvGBTrees	access:protected	signature:( CvFileStorage* fs ) const
CvGBTrees::~CvGBTrees	ml/ml.hpp	/^    virtual ~CvGBTrees();$/;"	p	class:CvGBTrees	access:public	signature:()
CvGBTreesParams	ml/ml.hpp	/^    CvGBTreesParams( int loss_function_type, int weak_count, float shrinkage,$/;"	p	struct:CvGBTreesParams	access:public	signature:( int loss_function_type, int weak_count, float shrinkage, float subsample_portion, int max_depth, bool use_surrogates )
CvGBTreesParams	ml/ml.hpp	/^    CvGBTreesParams();$/;"	p	struct:CvGBTreesParams	access:public	signature:()
CvGBTreesParams	ml/ml.hpp	/^struct CV_EXPORTS_W_MAP CvGBTreesParams : public CvDTreeParams$/;"	s	inherits:CvDTreeParams
CvGBTreesParams::CvGBTreesParams	ml/ml.hpp	/^    CvGBTreesParams( int loss_function_type, int weak_count, float shrinkage,$/;"	p	struct:CvGBTreesParams	access:public	signature:( int loss_function_type, int weak_count, float shrinkage, float subsample_portion, int max_depth, bool use_surrogates )
CvGBTreesParams::CvGBTreesParams	ml/ml.hpp	/^    CvGBTreesParams();$/;"	p	struct:CvGBTreesParams	access:public	signature:()
CvGBTreesParams::loss_function_type	ml/ml.hpp	/^    CV_PROP_RW int loss_function_type;$/;"	m	struct:CvGBTreesParams	access:public
CvGBTreesParams::shrinkage	ml/ml.hpp	/^    CV_PROP_RW float shrinkage;$/;"	m	struct:CvGBTreesParams	access:public
CvGBTreesParams::subsample_portion	ml/ml.hpp	/^    CV_PROP_RW float subsample_portion;$/;"	m	struct:CvGBTreesParams	access:public
CvGBTreesParams::weak_count	ml/ml.hpp	/^    CV_PROP_RW int weak_count;$/;"	m	struct:CvGBTreesParams	access:public
CvGLCM	legacy/legacy.hpp	/^typedef struct CvGLCM CvGLCM;$/;"	t	typeref:struct:CvGLCM
CvGaussBGModel	video/background_segm.hpp	/^typedef struct CvGaussBGModel$/;"	s
CvGaussBGModel	video/background_segm.hpp	/^} CvGaussBGModel;$/;"	t	typeref:struct:CvGaussBGModel
CvGaussBGModel::CV_BG_STAT_MODEL_FIELDS	video/background_segm.hpp	/^    CV_BG_STAT_MODEL_FIELDS();$/;"	p	struct:CvGaussBGModel	access:public	signature:()
CvGaussBGModel::countFrames	video/background_segm.hpp	/^    int                        countFrames;$/;"	m	struct:CvGaussBGModel	access:public
CvGaussBGModel::g_point	video/background_segm.hpp	/^    CvGaussBGPoint*            g_point;    $/;"	m	struct:CvGaussBGModel	access:public
CvGaussBGModel::params	video/background_segm.hpp	/^    CvGaussBGStatModelParams   params;    $/;"	m	struct:CvGaussBGModel	access:public
CvGaussBGPoint	video/background_segm.hpp	/^typedef struct CvGaussBGPoint$/;"	s
CvGaussBGPoint	video/background_segm.hpp	/^} CvGaussBGPoint;$/;"	t	typeref:struct:CvGaussBGPoint
CvGaussBGPoint::g_values	video/background_segm.hpp	/^    CvGaussBGValues* g_values;$/;"	m	struct:CvGaussBGPoint	access:public
CvGaussBGStatModelParams	video/background_segm.hpp	/^typedef struct CvGaussBGStatModelParams$/;"	s
CvGaussBGStatModelParams	video/background_segm.hpp	/^}CvGaussBGStatModelParams;$/;"	t	typeref:struct:CvGaussBGStatModelParams
CvGaussBGStatModelParams::bg_threshold	video/background_segm.hpp	/^    double  bg_threshold, std_threshold, minArea;$/;"	m	struct:CvGaussBGStatModelParams	access:public
CvGaussBGStatModelParams::minArea	video/background_segm.hpp	/^    double  bg_threshold, std_threshold, minArea;$/;"	m	struct:CvGaussBGStatModelParams	access:public
CvGaussBGStatModelParams::n_gauss	video/background_segm.hpp	/^    int     n_gauss;$/;"	m	struct:CvGaussBGStatModelParams	access:public
CvGaussBGStatModelParams::std_threshold	video/background_segm.hpp	/^    double  bg_threshold, std_threshold, minArea;$/;"	m	struct:CvGaussBGStatModelParams	access:public
CvGaussBGStatModelParams::variance_init	video/background_segm.hpp	/^    double  weight_init, variance_init;$/;"	m	struct:CvGaussBGStatModelParams	access:public
CvGaussBGStatModelParams::weight_init	video/background_segm.hpp	/^    double  weight_init, variance_init;$/;"	m	struct:CvGaussBGStatModelParams	access:public
CvGaussBGStatModelParams::win_size	video/background_segm.hpp	/^    int     win_size;               \/* = 1\/alpha *\/$/;"	m	struct:CvGaussBGStatModelParams	access:public
CvGaussBGValues	video/background_segm.hpp	/^typedef struct CvGaussBGValues$/;"	s
CvGaussBGValues	video/background_segm.hpp	/^} CvGaussBGValues;$/;"	t	typeref:struct:CvGaussBGValues
CvGaussBGValues::match_sum	video/background_segm.hpp	/^    int         match_sum;$/;"	m	struct:CvGaussBGValues	access:public
CvGaussBGValues::mean	video/background_segm.hpp	/^    double      mean[CV_BGFG_MOG_NCOLORS];$/;"	m	struct:CvGaussBGValues	access:public
CvGaussBGValues::variance	video/background_segm.hpp	/^    double      variance[CV_BGFG_MOG_NCOLORS];$/;"	m	struct:CvGaussBGValues	access:public
CvGaussBGValues::weight	video/background_segm.hpp	/^    double      weight;$/;"	m	struct:CvGaussBGValues	access:public
CvGraph	core/types_c.h	/^CvGraph;$/;"	t	typeref:struct:CvGraph
CvGraph	core/types_c.h	/^typedef struct CvGraph$/;"	s
CvGraphEdge	core/types_c.h	/^CvGraphEdge;$/;"	t	typeref:struct:CvGraphEdge
CvGraphEdge	core/types_c.h	/^typedef struct CvGraphEdge$/;"	s
CvGraphScanner	core/core_c.h	/^CvGraphScanner;$/;"	t	typeref:struct:CvGraphScanner
CvGraphScanner	core/core_c.h	/^typedef struct CvGraphScanner$/;"	s
CvGraphScanner::dst	core/core_c.h	/^    CvGraphVtx* dst;       \/* current graph edge destination vertex *\/$/;"	m	struct:CvGraphScanner	access:public
CvGraphScanner::edge	core/core_c.h	/^    CvGraphEdge* edge;     \/* current edge *\/$/;"	m	struct:CvGraphScanner	access:public
CvGraphScanner::graph	core/core_c.h	/^    CvGraph* graph;        \/* the graph *\/$/;"	m	struct:CvGraphScanner	access:public
CvGraphScanner::index	core/core_c.h	/^    int      index;        \/* the lower bound of certainly visited vertices *\/$/;"	m	struct:CvGraphScanner	access:public
CvGraphScanner::mask	core/core_c.h	/^    int      mask;         \/* event mask *\/$/;"	m	struct:CvGraphScanner	access:public
CvGraphScanner::stack	core/core_c.h	/^    CvSeq*   stack;        \/* the graph vertex stack *\/$/;"	m	struct:CvGraphScanner	access:public
CvGraphScanner::vtx	core/core_c.h	/^    CvGraphVtx* vtx;       \/* current graph vertex (or current edge origin) *\/$/;"	m	struct:CvGraphScanner	access:public
CvGraphVtx	core/types_c.h	/^CvGraphVtx;$/;"	t	typeref:struct:CvGraphVtx
CvGraphVtx	core/types_c.h	/^typedef struct CvGraphVtx$/;"	s
CvGraphVtx2D	core/types_c.h	/^CvGraphVtx2D;$/;"	t	typeref:struct:CvGraphVtx2D
CvGraphVtx2D	core/types_c.h	/^typedef struct CvGraphVtx2D$/;"	s
CvGraphVtx2D::ptr	core/types_c.h	/^    CvPoint2D32f* ptr;$/;"	m	struct:CvGraphVtx2D	access:public
CvGraphWeightType	legacy/legacy.hpp	/^typedef enum CvGraphWeightType$/;"	g
CvGraphWeightType	legacy/legacy.hpp	/^} CvGraphWeightType;$/;"	t	typeref:enum:CvGraphWeightType
CvGraphWeightedEdge	legacy/legacy.hpp	/^typedef struct CvGraphWeightedEdge$/;"	s
CvGraphWeightedEdge	legacy/legacy.hpp	/^} CvGraphWeightedEdge;$/;"	t	typeref:struct:CvGraphWeightedEdge
CvGraphWeightedVtx	legacy/legacy.hpp	/^typedef struct CvGraphWeightedVtx$/;"	s
CvGraphWeightedVtx	legacy/legacy.hpp	/^} CvGraphWeightedVtx;$/;"	t	typeref:struct:CvGraphWeightedVtx
CvHaarClassifier	objdetect/objdetect.hpp	/^typedef struct CvHaarClassifier$/;"	s
CvHaarClassifier	objdetect/objdetect.hpp	/^} CvHaarClassifier;$/;"	t	typeref:struct:CvHaarClassifier
CvHaarClassifier::alpha	objdetect/objdetect.hpp	/^    float* alpha;$/;"	m	struct:CvHaarClassifier	access:public
CvHaarClassifier::count	objdetect/objdetect.hpp	/^    int count;$/;"	m	struct:CvHaarClassifier	access:public
CvHaarClassifier::haar_feature	objdetect/objdetect.hpp	/^    CvHaarFeature* haar_feature;$/;"	m	struct:CvHaarClassifier	access:public
CvHaarClassifier::left	objdetect/objdetect.hpp	/^    int* left;$/;"	m	struct:CvHaarClassifier	access:public
CvHaarClassifier::right	objdetect/objdetect.hpp	/^    int* right;$/;"	m	struct:CvHaarClassifier	access:public
CvHaarClassifier::threshold	objdetect/objdetect.hpp	/^    float* threshold;$/;"	m	struct:CvHaarClassifier	access:public
CvHaarClassifierCascade	objdetect/objdetect.hpp	/^typedef struct CvHaarClassifierCascade$/;"	s
CvHaarClassifierCascade	objdetect/objdetect.hpp	/^} CvHaarClassifierCascade;$/;"	t	typeref:struct:CvHaarClassifierCascade
CvHaarClassifierCascade::count	objdetect/objdetect.hpp	/^    int  count;$/;"	m	struct:CvHaarClassifierCascade	access:public
CvHaarClassifierCascade::flags	objdetect/objdetect.hpp	/^    int  flags;$/;"	m	struct:CvHaarClassifierCascade	access:public
CvHaarClassifierCascade::hid_cascade	objdetect/objdetect.hpp	/^    CvHidHaarClassifierCascade* hid_cascade;$/;"	m	struct:CvHaarClassifierCascade	access:public
CvHaarClassifierCascade::orig_window_size	objdetect/objdetect.hpp	/^    CvSize orig_window_size;$/;"	m	struct:CvHaarClassifierCascade	access:public
CvHaarClassifierCascade::real_window_size	objdetect/objdetect.hpp	/^    CvSize real_window_size;$/;"	m	struct:CvHaarClassifierCascade	access:public
CvHaarClassifierCascade::scale	objdetect/objdetect.hpp	/^    double scale;$/;"	m	struct:CvHaarClassifierCascade	access:public
CvHaarClassifierCascade::stage_classifier	objdetect/objdetect.hpp	/^    CvHaarStageClassifier* stage_classifier;$/;"	m	struct:CvHaarClassifierCascade	access:public
CvHaarFeature	objdetect/objdetect.hpp	/^typedef struct CvHaarFeature$/;"	s
CvHaarFeature	objdetect/objdetect.hpp	/^} CvHaarFeature;$/;"	t	typeref:struct:CvHaarFeature
CvHaarFeature::__anon195::r	objdetect/objdetect.hpp	/^        CvRect r;$/;"	m	struct:CvHaarFeature::__anon195	access:public
CvHaarFeature::__anon195::weight	objdetect/objdetect.hpp	/^        float weight;$/;"	m	struct:CvHaarFeature::__anon195	access:public
CvHaarFeature::rect	objdetect/objdetect.hpp	/^    } rect[CV_HAAR_FEATURE_MAX];$/;"	m	struct:CvHaarFeature	typeref:struct:CvHaarFeature::__anon195	access:public
CvHaarFeature::tilted	objdetect/objdetect.hpp	/^    int tilted;$/;"	m	struct:CvHaarFeature	access:public
CvHaarStageClassifier	objdetect/objdetect.hpp	/^typedef struct CvHaarStageClassifier$/;"	s
CvHaarStageClassifier	objdetect/objdetect.hpp	/^} CvHaarStageClassifier;$/;"	t	typeref:struct:CvHaarStageClassifier
CvHaarStageClassifier::child	objdetect/objdetect.hpp	/^    int child;$/;"	m	struct:CvHaarStageClassifier	access:public
CvHaarStageClassifier::classifier	objdetect/objdetect.hpp	/^    CvHaarClassifier* classifier;$/;"	m	struct:CvHaarStageClassifier	access:public
CvHaarStageClassifier::count	objdetect/objdetect.hpp	/^    int  count;$/;"	m	struct:CvHaarStageClassifier	access:public
CvHaarStageClassifier::next	objdetect/objdetect.hpp	/^    int next;$/;"	m	struct:CvHaarStageClassifier	access:public
CvHaarStageClassifier::parent	objdetect/objdetect.hpp	/^    int parent;$/;"	m	struct:CvHaarStageClassifier	access:public
CvHaarStageClassifier::threshold	objdetect/objdetect.hpp	/^    float threshold;$/;"	m	struct:CvHaarStageClassifier	access:public
CvHidHaarClassifierCascade	objdetect/objdetect.hpp	/^typedef struct CvHidHaarClassifierCascade CvHidHaarClassifierCascade;$/;"	t	typeref:struct:CvHidHaarClassifierCascade
CvHistType	core/types_c.h	/^typedef int CvHistType;$/;"	t
CvHistogram	core/types_c.h	/^CvHistogram;$/;"	t	typeref:struct:CvHistogram
CvHistogram	core/types_c.h	/^typedef struct CvHistogram$/;"	s
CvHistogram::bins	core/types_c.h	/^    CvArr*  bins;$/;"	m	struct:CvHistogram	access:public
CvHistogram::mat	core/types_c.h	/^    CvMatND mat;                    \/* Embedded matrix header for array histograms. *\/$/;"	m	struct:CvHistogram	access:public
CvHistogram::thresh	core/types_c.h	/^    float   thresh[CV_MAX_DIM][2];  \/* For uniform histograms.                      *\/$/;"	m	struct:CvHistogram	access:public
CvHistogram::thresh2	core/types_c.h	/^    float** thresh2;                \/* For non-uniform histograms.                  *\/$/;"	m	struct:CvHistogram	access:public
CvHistogram::type	core/types_c.h	/^    int     type;$/;"	m	struct:CvHistogram	access:public
CvHuMoments	imgproc/types_c.h	/^CvHuMoments;$/;"	t	typeref:struct:CvHuMoments
CvHuMoments	imgproc/types_c.h	/^typedef struct CvHuMoments$/;"	s
CvHuMoments::hu1	imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
CvHuMoments::hu2	imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
CvHuMoments::hu3	imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
CvHuMoments::hu4	imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
CvHuMoments::hu5	imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
CvHuMoments::hu6	imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
CvHuMoments::hu7	imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
CvImage	legacy/legacy.hpp	/^    CvImage( CvFileStorage* fs, const char* mapname, const char* imgname ) : image(0), refcount(0)$/;"	f	class:CvImage	access:public	signature:( CvFileStorage* fs, const char* mapname, const char* imgname )
CvImage	legacy/legacy.hpp	/^    CvImage( CvFileStorage* fs, const char* seqname, int idx ) : image(0), refcount(0)$/;"	f	class:CvImage	access:public	signature:( CvFileStorage* fs, const char* seqname, int idx )
CvImage	legacy/legacy.hpp	/^    CvImage( CvSize size, int depth, int channels )$/;"	f	class:CvImage	access:public	signature:( CvSize size, int depth, int channels )
CvImage	legacy/legacy.hpp	/^    CvImage( IplImage* img ) : image(img)$/;"	f	class:CvImage	access:public	signature:( IplImage* img )
CvImage	legacy/legacy.hpp	/^    CvImage( const CvImage& img ) : image(img.image), refcount(img.refcount)$/;"	f	class:CvImage	access:public	signature:( const CvImage& img )
CvImage	legacy/legacy.hpp	/^    CvImage( const char* filename, const char* imgname=0, int color=-1 ) : image(0), refcount(0)$/;"	f	class:CvImage	access:public	signature:( const char* filename, const char* imgname=0, int color=-1 )
CvImage	legacy/legacy.hpp	/^    CvImage() : image(0), refcount(0) {}$/;"	f	class:CvImage	access:public	signature:()
CvImage	legacy/legacy.hpp	/^class CV_EXPORTS CvImage$/;"	c
CvImage::CvImage	legacy/legacy.hpp	/^    CvImage( CvFileStorage* fs, const char* mapname, const char* imgname ) : image(0), refcount(0)$/;"	f	class:CvImage	access:public	signature:( CvFileStorage* fs, const char* mapname, const char* imgname )
CvImage::CvImage	legacy/legacy.hpp	/^    CvImage( CvFileStorage* fs, const char* seqname, int idx ) : image(0), refcount(0)$/;"	f	class:CvImage	access:public	signature:( CvFileStorage* fs, const char* seqname, int idx )
CvImage::CvImage	legacy/legacy.hpp	/^    CvImage( CvSize size, int depth, int channels )$/;"	f	class:CvImage	access:public	signature:( CvSize size, int depth, int channels )
CvImage::CvImage	legacy/legacy.hpp	/^    CvImage( IplImage* img ) : image(img)$/;"	f	class:CvImage	access:public	signature:( IplImage* img )
CvImage::CvImage	legacy/legacy.hpp	/^    CvImage( const CvImage& img ) : image(img.image), refcount(img.refcount)$/;"	f	class:CvImage	access:public	signature:( const CvImage& img )
CvImage::CvImage	legacy/legacy.hpp	/^    CvImage( const char* filename, const char* imgname=0, int color=-1 ) : image(0), refcount(0)$/;"	f	class:CvImage	access:public	signature:( const char* filename, const char* imgname=0, int color=-1 )
CvImage::CvImage	legacy/legacy.hpp	/^    CvImage() : image(0), refcount(0) {}$/;"	f	class:CvImage	access:public	signature:()
CvImage::attach	legacy/legacy.hpp	/^    void attach( IplImage* img, bool use_refcount=true )$/;"	f	class:CvImage	access:public	signature:( IplImage* img, bool use_refcount=true )
CvImage::channels	legacy/legacy.hpp	/^    int channels() const { return image ? image->nChannels : 0; }$/;"	f	class:CvImage	access:public	signature:() const
CvImage::clear	legacy/legacy.hpp	/^    void clear() { detach(); }$/;"	f	class:CvImage	access:public	signature:()
CvImage::clone	legacy/legacy.hpp	/^    CvImage clone() { return CvImage(image ? cvCloneImage(image) : 0); }$/;"	f	class:CvImage	access:public	signature:()
CvImage::coi	legacy/legacy.hpp	/^    int coi() const { return !image || !image->roi ? 0 : image->roi->coi; }$/;"	f	class:CvImage	access:public	signature:() const
CvImage::create	legacy/legacy.hpp	/^    void create( CvSize size, int depth, int channels )$/;"	f	class:CvImage	access:public	signature:( CvSize size, int depth, int channels )
CvImage::data	legacy/legacy.hpp	/^    const uchar* data() const { return image ? (const uchar*)image->imageData : 0; }$/;"	f	class:CvImage	access:public	signature:() const
CvImage::data	legacy/legacy.hpp	/^    uchar* data() { return image ? (uchar*)image->imageData : 0; }$/;"	f	class:CvImage	access:public	signature:()
CvImage::depth	legacy/legacy.hpp	/^    int depth() const { return image ? image->depth : 0; }$/;"	f	class:CvImage	access:public	signature:() const
CvImage::detach	legacy/legacy.hpp	/^    void detach()$/;"	f	class:CvImage	access:public	signature:()
CvImage::height	legacy/legacy.hpp	/^    int height() const { return image ? image->height : 0; }$/;"	f	class:CvImage	access:public	signature:() const
CvImage::image	legacy/legacy.hpp	/^    IplImage* image;$/;"	m	class:CvImage	access:protected
CvImage::is_valid	legacy/legacy.hpp	/^    bool is_valid() { return image != 0; }$/;"	f	class:CvImage	access:public	signature:()
CvImage::load	legacy/legacy.hpp	/^    bool load( const char* filename, const char* imgname=0, int color=-1 );$/;"	p	class:CvImage	access:public	signature:( const char* filename, const char* imgname=0, int color=-1 )
CvImage::operator =	legacy/legacy.hpp	/^    CvImage& operator = (const CvImage& img)$/;"	f	class:CvImage	access:public	signature:(const CvImage& img)
CvImage::operator IplImage*	legacy/legacy.hpp	/^    operator IplImage* () { return image; }$/;"	f	class:CvImage	access:public	signature:()
CvImage::operator const IplImage*	legacy/legacy.hpp	/^    operator const IplImage* () const { return image; }$/;"	f	class:CvImage	access:public	signature:() const
CvImage::origin	legacy/legacy.hpp	/^    int origin() const { return image ? image->origin : 0; }$/;"	f	class:CvImage	access:public	signature:() const
CvImage::pix_size	legacy/legacy.hpp	/^    int pix_size() const { return image ? ((image->depth & 255)>>3)*image->nChannels : 0; }$/;"	f	class:CvImage	access:public	signature:() const
CvImage::read	legacy/legacy.hpp	/^    bool read( CvFileStorage* fs, const char* mapname, const char* imgname );$/;"	p	class:CvImage	access:public	signature:( CvFileStorage* fs, const char* mapname, const char* imgname )
CvImage::read	legacy/legacy.hpp	/^    bool read( CvFileStorage* fs, const char* seqname, int idx );$/;"	p	class:CvImage	access:public	signature:( CvFileStorage* fs, const char* seqname, int idx )
CvImage::refcount	legacy/legacy.hpp	/^    int* refcount;$/;"	m	class:CvImage	access:protected
CvImage::release	legacy/legacy.hpp	/^    void release() { detach(); }$/;"	f	class:CvImage	access:public	signature:()
CvImage::reset_roi	legacy/legacy.hpp	/^    void reset_roi() { cvResetImageROI(image); }$/;"	f	class:CvImage	access:public	signature:()
CvImage::roi	legacy/legacy.hpp	/^    CvRect roi() const$/;"	f	class:CvImage	access:public	signature:() const
CvImage::roi_row	legacy/legacy.hpp	/^    const uchar* roi_row(int y) const$/;"	f	class:CvImage	access:public	signature:(int y) const
CvImage::roi_row	legacy/legacy.hpp	/^    uchar* roi_row(int y)$/;"	f	class:CvImage	access:public	signature:(int y)
CvImage::roi_size	legacy/legacy.hpp	/^    CvSize roi_size() const$/;"	f	class:CvImage	access:public	signature:() const
CvImage::save	legacy/legacy.hpp	/^    void save( const char* filename, const char* imgname, const int* params=0 );$/;"	p	class:CvImage	access:public	signature:( const char* filename, const char* imgname, const int* params=0 )
CvImage::set_coi	legacy/legacy.hpp	/^    void set_coi(int coi) { cvSetImageCOI(image,coi); }$/;"	f	class:CvImage	access:public	signature:(int coi)
CvImage::set_roi	legacy/legacy.hpp	/^    void set_roi(CvRect roi) { cvSetImageROI(image,roi); }$/;"	f	class:CvImage	access:public	signature:(CvRect roi)
CvImage::show	legacy/legacy.hpp	/^    void show( const char* window_name );$/;"	p	class:CvImage	access:public	signature:( const char* window_name )
CvImage::size	legacy/legacy.hpp	/^    CvSize size() const { return image ? cvSize(image->width, image->height) : cvSize(0,0); }$/;"	f	class:CvImage	access:public	signature:() const
CvImage::step	legacy/legacy.hpp	/^    int step() const { return image ? image->widthStep : 0; }$/;"	f	class:CvImage	access:public	signature:() const
CvImage::width	legacy/legacy.hpp	/^    int width() const { return image ? image->width : 0; }$/;"	f	class:CvImage	access:public	signature:() const
CvImage::write	legacy/legacy.hpp	/^    void write( CvFileStorage* fs, const char* imgname );$/;"	p	class:CvImage	access:public	signature:( CvFileStorage* fs, const char* imgname )
CvImage::~CvImage	legacy/legacy.hpp	/^    ~CvImage()$/;"	f	class:CvImage	access:public	signature:()
CvImageDrawer	legacy/blobtrack.hpp	/^    CvImageDrawer() : m_image(0) {}$/;"	f	class:CvImageDrawer	access:public	signature:()
CvImageDrawer	legacy/blobtrack.hpp	/^class CV_EXPORTS CvImageDrawer$/;"	c
CvImageDrawer::CvImageDrawer	legacy/blobtrack.hpp	/^    CvImageDrawer() : m_image(0) {}$/;"	f	class:CvImageDrawer	access:public	signature:()
CvImageDrawer::Draw	legacy/blobtrack.hpp	/^    IplImage* Draw( const CvArr* src, CvBlobSeq* blob_seq = 0, const CvSeq* roi_seq = 0 );$/;"	p	class:CvImageDrawer	access:public	signature:( const CvArr* src, CvBlobSeq* blob_seq = 0, const CvSeq* roi_seq = 0 )
CvImageDrawer::GetImage	legacy/blobtrack.hpp	/^    IplImage* GetImage() { return m_image; }$/;"	f	class:CvImageDrawer	access:public	signature:()
CvImageDrawer::SetShapes	legacy/blobtrack.hpp	/^    void SetShapes( const CvDrawShape* shapes, int num );$/;"	p	class:CvImageDrawer	access:public	signature:( const CvDrawShape* shapes, int num )
CvImageDrawer::m_image	legacy/blobtrack.hpp	/^    IplImage* m_image;$/;"	m	class:CvImageDrawer	access:protected
CvImageDrawer::m_shape	legacy/blobtrack.hpp	/^    CvDrawShape m_shape[16];$/;"	m	class:CvImageDrawer	access:protected
CvImageDrawer::~CvImageDrawer	legacy/blobtrack.hpp	/^    ~CvImageDrawer() { cvReleaseImage( &m_image ); }$/;"	f	class:CvImageDrawer	access:public	signature:()
CvImgObsInfo	legacy/legacy.hpp	/^typedef struct CvImgObsInfo$/;"	s
CvImgObsInfo	legacy/legacy.hpp	/^} CvImgObsInfo;\/*struct for 1 image*\/$/;"	t	typeref:struct:CvImgObsInfo
CvImgObsInfo::mix	legacy/legacy.hpp	/^    int* mix;  \/* number of mixture to which observation belong *\/$/;"	m	struct:CvImgObsInfo	access:public
CvImgObsInfo::obs	legacy/legacy.hpp	/^    float* obs;\/\/consequtive observations$/;"	m	struct:CvImgObsInfo	access:public
CvImgObsInfo::obs_size	legacy/legacy.hpp	/^    int obs_size;$/;"	m	struct:CvImgObsInfo	access:public
CvImgObsInfo::obs_x	legacy/legacy.hpp	/^    int obs_x;$/;"	m	struct:CvImgObsInfo	access:public
CvImgObsInfo::obs_y	legacy/legacy.hpp	/^    int obs_y;$/;"	m	struct:CvImgObsInfo	access:public
CvImgObsInfo::state	legacy/legacy.hpp	/^    int* state;\/* arr of pairs superstate\/state to which observation belong *\/$/;"	m	struct:CvImgObsInfo	access:public
CvInput	legacy/legacy.hpp	/^CvInput;$/;"	t	typeref:union:__anon182
CvIsInstanceFunc	core/types_c.h	/^typedef int (CV_CDECL *CvIsInstanceFunc)( const void* struct_ptr );$/;"	t
CvKNearest	ml/ml.hpp	/^    CV_WRAP CvKNearest( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvKNearest	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& sampleIdx=cv::Mat(), bool isRegression=false, int max_k=32 )
CvKNearest	ml/ml.hpp	/^    CV_WRAP CvKNearest();$/;"	p	class:CvKNearest	access:public	signature:()
CvKNearest	ml/ml.hpp	/^    CvKNearest( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvKNearest	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* sampleIdx=0, bool isRegression=false, int max_k=32 )
CvKNearest	ml/ml.hpp	/^class CV_EXPORTS_W CvKNearest : public CvStatModel$/;"	c	inherits:CvStatModel
CvKNearest::CvKNearest	ml/ml.hpp	/^    CV_WRAP CvKNearest( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvKNearest	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& sampleIdx=cv::Mat(), bool isRegression=false, int max_k=32 )
CvKNearest::CvKNearest	ml/ml.hpp	/^    CV_WRAP CvKNearest();$/;"	p	class:CvKNearest	access:public	signature:()
CvKNearest::CvKNearest	ml/ml.hpp	/^    CvKNearest( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvKNearest	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* sampleIdx=0, bool isRegression=false, int max_k=32 )
CvKNearest::clear	ml/ml.hpp	/^    virtual void clear();$/;"	p	class:CvKNearest	access:public	signature:()
CvKNearest::find_nearest	ml/ml.hpp	/^    CV_WRAP virtual float find_nearest( const cv::Mat& samples, int k, CV_OUT cv::Mat& results,$/;"	p	class:CvKNearest	access:public	signature:( const cv::Mat& samples, int k, CV_OUT cv::Mat& results, CV_OUT cv::Mat& neighborResponses, CV_OUT cv::Mat& dists) const
CvKNearest::find_nearest	ml/ml.hpp	/^    virtual float find_nearest( const CvMat* samples, int k, CV_OUT CvMat* results=0,$/;"	p	class:CvKNearest	access:public	signature:( const CvMat* samples, int k, CV_OUT CvMat* results=0, const float** neighbors=0, CV_OUT CvMat* neighborResponses=0, CV_OUT CvMat* dist=0 ) const
CvKNearest::find_nearest	ml/ml.hpp	/^    virtual float find_nearest( const cv::Mat& samples, int k, cv::Mat* results=0,$/;"	p	class:CvKNearest	access:public	signature:( const cv::Mat& samples, int k, cv::Mat* results=0, const float** neighbors=0, cv::Mat* neighborResponses=0, cv::Mat* dist=0 ) const
CvKNearest::find_neighbors_direct	ml/ml.hpp	/^    virtual void find_neighbors_direct( const CvMat* _samples, int k, int start, int end,$/;"	p	class:CvKNearest	access:public	signature:( const CvMat* _samples, int k, int start, int end, float* neighbor_responses, const float** neighbors, float* dist ) const
CvKNearest::get_max_k	ml/ml.hpp	/^    int get_max_k() const;$/;"	p	class:CvKNearest	access:public	signature:() const
CvKNearest::get_sample_count	ml/ml.hpp	/^    int get_sample_count() const;$/;"	p	class:CvKNearest	access:public	signature:() const
CvKNearest::get_var_count	ml/ml.hpp	/^    int get_var_count() const;$/;"	p	class:CvKNearest	access:public	signature:() const
CvKNearest::is_regression	ml/ml.hpp	/^    bool is_regression() const;$/;"	p	class:CvKNearest	access:public	signature:() const
CvKNearest::max_k	ml/ml.hpp	/^    int max_k, var_count;$/;"	m	class:CvKNearest	access:protected
CvKNearest::regression	ml/ml.hpp	/^    bool regression;$/;"	m	class:CvKNearest	access:protected
CvKNearest::samples	ml/ml.hpp	/^    CvVectors* samples;$/;"	m	class:CvKNearest	access:protected
CvKNearest::total	ml/ml.hpp	/^    int total;$/;"	m	class:CvKNearest	access:protected
CvKNearest::train	ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvKNearest	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& sampleIdx=cv::Mat(), bool isRegression=false, int maxK=32, bool updateBase=false )
CvKNearest::train	ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvKNearest	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* sampleIdx=0, bool is_regression=false, int maxK=32, bool updateBase=false )
CvKNearest::var_count	ml/ml.hpp	/^    int max_k, var_count;$/;"	m	class:CvKNearest	access:protected
CvKNearest::write_results	ml/ml.hpp	/^    virtual float write_results( int k, int k1, int start, int end,$/;"	p	class:CvKNearest	access:public	signature:( int k, int k1, int start, int end, const float* neighbor_responses, const float* dist, CvMat* _results, CvMat* _neighbor_responses, CvMat* _dist, Cv32suf* sort_buf ) const
CvKNearest::~CvKNearest	ml/ml.hpp	/^    virtual ~CvKNearest();$/;"	p	class:CvKNearest	access:public	signature:()
CvKalman	video/tracking.hpp	/^typedef struct CvKalman$/;"	s
CvKalman	video/tracking.hpp	/^} CvKalman;$/;"	t	typeref:struct:CvKalman
CvKalman::CP	video/tracking.hpp	/^    int CP;                     \/* number of control vector dimensions *\/$/;"	m	struct:CvKalman	access:public
CvKalman::DP	video/tracking.hpp	/^    int DP;                     \/* number of state vector dimensions *\/$/;"	m	struct:CvKalman	access:public
CvKalman::DynamMatr	video/tracking.hpp	/^    float* DynamMatr;           \/* =transition_matrix->data.fl *\/$/;"	m	struct:CvKalman	access:public
CvKalman::KalmGainMatr	video/tracking.hpp	/^    float* KalmGainMatr;        \/* =gain->data.fl *\/$/;"	m	struct:CvKalman	access:public
CvKalman::MNCovariance	video/tracking.hpp	/^    float* MNCovariance;        \/* =measurement_noise_cov->data.fl *\/$/;"	m	struct:CvKalman	access:public
CvKalman::MP	video/tracking.hpp	/^    int MP;                     \/* number of measurement vector dimensions *\/$/;"	m	struct:CvKalman	access:public
CvKalman::MeasurementMatr	video/tracking.hpp	/^    float* MeasurementMatr;     \/* =measurement_matrix->data.fl *\/$/;"	m	struct:CvKalman	access:public
CvKalman::PNCovariance	video/tracking.hpp	/^    float* PNCovariance;        \/* =process_noise_cov->data.fl *\/$/;"	m	struct:CvKalman	access:public
CvKalman::PosterErrorCovariance	video/tracking.hpp	/^    float* PosterErrorCovariance;\/* =error_cov_post->data.fl *\/$/;"	m	struct:CvKalman	access:public
CvKalman::PosterState	video/tracking.hpp	/^    float* PosterState;         \/* =state_pre->data.fl *\/$/;"	m	struct:CvKalman	access:public
CvKalman::PriorErrorCovariance	video/tracking.hpp	/^    float* PriorErrorCovariance;\/* =error_cov_pre->data.fl *\/$/;"	m	struct:CvKalman	access:public
CvKalman::PriorState	video/tracking.hpp	/^    float* PriorState;          \/* =state_post->data.fl *\/$/;"	m	struct:CvKalman	access:public
CvKalman::Temp1	video/tracking.hpp	/^    float* Temp1;               \/* temp1->data.fl *\/$/;"	m	struct:CvKalman	access:public
CvKalman::Temp2	video/tracking.hpp	/^    float* Temp2;               \/* temp2->data.fl *\/$/;"	m	struct:CvKalman	access:public
CvKalman::control_matrix	video/tracking.hpp	/^    CvMat* control_matrix;      \/* control matrix (B)$/;"	m	struct:CvKalman	access:public
CvKalman::error_cov_post	video/tracking.hpp	/^    CvMat* error_cov_post;      \/* posteriori error estimate covariance matrix (P(k)):$/;"	m	struct:CvKalman	access:public
CvKalman::error_cov_pre	video/tracking.hpp	/^    CvMat* error_cov_pre;       \/* priori error estimate covariance matrix (P'(k)):$/;"	m	struct:CvKalman	access:public
CvKalman::gain	video/tracking.hpp	/^    CvMat* gain;                \/* Kalman gain matrix (K(k)):$/;"	m	struct:CvKalman	access:public
CvKalman::measurement_matrix	video/tracking.hpp	/^    CvMat* measurement_matrix;  \/* measurement matrix (H) *\/$/;"	m	struct:CvKalman	access:public
CvKalman::measurement_noise_cov	video/tracking.hpp	/^    CvMat* measurement_noise_cov; \/* measurement noise covariance matrix (R) *\/$/;"	m	struct:CvKalman	access:public
CvKalman::process_noise_cov	video/tracking.hpp	/^    CvMat* process_noise_cov;   \/* process noise covariance matrix (Q) *\/$/;"	m	struct:CvKalman	access:public
CvKalman::state_post	video/tracking.hpp	/^    CvMat* state_post;          \/* corrected state (x(k)):$/;"	m	struct:CvKalman	access:public
CvKalman::state_pre	video/tracking.hpp	/^    CvMat* state_pre;           \/* predicted state (x'(k)):$/;"	m	struct:CvKalman	access:public
CvKalman::temp1	video/tracking.hpp	/^    CvMat* temp1;               \/* temporary matrices *\/$/;"	m	struct:CvKalman	access:public
CvKalman::temp2	video/tracking.hpp	/^    CvMat* temp2;$/;"	m	struct:CvKalman	access:public
CvKalman::temp3	video/tracking.hpp	/^    CvMat* temp3;$/;"	m	struct:CvKalman	access:public
CvKalman::temp4	video/tracking.hpp	/^    CvMat* temp4;$/;"	m	struct:CvKalman	access:public
CvKalman::temp5	video/tracking.hpp	/^    CvMat* temp5;$/;"	m	struct:CvKalman	access:public
CvKalman::transition_matrix	video/tracking.hpp	/^    CvMat* transition_matrix;   \/* state transition matrix (A) *\/$/;"	m	struct:CvKalman	access:public
CvLCMEdge	legacy/legacy.hpp	/^typedef struct CvLCMEdge$/;"	s
CvLCMEdge	legacy/legacy.hpp	/^} CvLCMEdge;$/;"	t	typeref:struct:CvLCMEdge
CvLCMEdge::chain	legacy/legacy.hpp	/^    CvSeq* chain;$/;"	m	struct:CvLCMEdge	access:public
CvLCMEdge::index1	legacy/legacy.hpp	/^    int index1;$/;"	m	struct:CvLCMEdge	access:public
CvLCMEdge::index2	legacy/legacy.hpp	/^    int index2;$/;"	m	struct:CvLCMEdge	access:public
CvLCMEdge::width	legacy/legacy.hpp	/^    float width;$/;"	m	struct:CvLCMEdge	access:public
CvLCMNode	legacy/legacy.hpp	/^typedef struct CvLCMNode$/;"	s
CvLCMNode	legacy/legacy.hpp	/^} CvLCMNode;$/;"	t	typeref:struct:CvLCMNode
CvLCMNode::contour	legacy/legacy.hpp	/^    CvContour* contour; $/;"	m	struct:CvLCMNode	access:public
CvLSHOperations	imgproc/imgproc.hpp	/^struct CvLSHOperations$/;"	s
CvLSHOperations::hash_insert	imgproc/imgproc.hpp	/^  virtual void hash_insert(lsh_hash h, int l, int i) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(lsh_hash h, int l, int i)
CvLSHOperations::hash_lookup	imgproc/imgproc.hpp	/^  virtual int hash_lookup(lsh_hash h, int l, int* ret_i, int ret_i_max) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(lsh_hash h, int l, int* ret_i, int ret_i_max)
CvLSHOperations::hash_remove	imgproc/imgproc.hpp	/^  virtual void hash_remove(lsh_hash h, int l, int i) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(lsh_hash h, int l, int i)
CvLSHOperations::vector_add	imgproc/imgproc.hpp	/^  virtual int vector_add(const void* data) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(const void* data)
CvLSHOperations::vector_count	imgproc/imgproc.hpp	/^  virtual unsigned int vector_count() = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:()
CvLSHOperations::vector_lookup	imgproc/imgproc.hpp	/^  virtual const void* vector_lookup(int i) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(int i)
CvLSHOperations::vector_remove	imgproc/imgproc.hpp	/^  virtual void vector_remove(int i) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(int i)
CvLSHOperations::vector_reserve	imgproc/imgproc.hpp	/^  virtual void vector_reserve(int n) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(int n)
CvLSHOperations::~CvLSHOperations	imgproc/imgproc.hpp	/^  virtual ~CvLSHOperations() {}$/;"	f	struct:CvLSHOperations	access:public	signature:()
CvLSVMFilterObject	objdetect/objdetect.hpp	/^} CvLSVMFilterObject;$/;"	t	typeref:struct:__anon197
CvLSVMFilterPosition	objdetect/objdetect.hpp	/^} CvLSVMFilterPosition;$/;"	t	typeref:struct:__anon196
CvLatentSvmDetector	objdetect/objdetect.hpp	/^CvLatentSvmDetector;$/;"	t	typeref:struct:CvLatentSvmDetector
CvLatentSvmDetector	objdetect/objdetect.hpp	/^typedef struct CvLatentSvmDetector$/;"	s
CvLatentSvmDetector::b	objdetect/objdetect.hpp	/^	float* b;$/;"	m	struct:CvLatentSvmDetector	access:public
CvLatentSvmDetector::filters	objdetect/objdetect.hpp	/^	CvLSVMFilterObject** filters;$/;"	m	struct:CvLatentSvmDetector	access:public
CvLatentSvmDetector::num_components	objdetect/objdetect.hpp	/^	int num_components;$/;"	m	struct:CvLatentSvmDetector	access:public
CvLatentSvmDetector::num_filters	objdetect/objdetect.hpp	/^	int num_filters;$/;"	m	struct:CvLatentSvmDetector	access:public
CvLatentSvmDetector::num_part_filters	objdetect/objdetect.hpp	/^	int* num_part_filters;$/;"	m	struct:CvLatentSvmDetector	access:public
CvLatentSvmDetector::score_threshold	objdetect/objdetect.hpp	/^	float score_threshold;$/;"	m	struct:CvLatentSvmDetector	access:public
CvLeeParameters	legacy/legacy.hpp	/^typedef enum CvLeeParameters$/;"	g
CvLeeParameters	legacy/legacy.hpp	/^} CvLeeParameters;$/;"	t	typeref:enum:CvLeeParameters
CvLevMarq	calib3d/calib3d.hpp	/^    CvLevMarq( int nparams, int nerrs, CvTermCriteria criteria=$/;"	p	class:CvLevMarq	access:public	signature:( int nparams, int nerrs, CvTermCriteria criteria= cvTermCriteria(CV_TERMCRIT_EPS+CV_TERMCRIT_ITER,30,DBL_EPSILON), bool completeSymmFlag=false )
CvLevMarq	calib3d/calib3d.hpp	/^    CvLevMarq();$/;"	p	class:CvLevMarq	access:public	signature:()
CvLevMarq	calib3d/calib3d.hpp	/^class CV_EXPORTS CvLevMarq$/;"	c
CvLevMarq::CALC_J	calib3d/calib3d.hpp	/^    enum { DONE=0, STARTED=1, CALC_J=2, CHECK_ERR=3 };$/;"	e	enum:CvLevMarq::__anon86
CvLevMarq::CHECK_ERR	calib3d/calib3d.hpp	/^    enum { DONE=0, STARTED=1, CALC_J=2, CHECK_ERR=3 };$/;"	e	enum:CvLevMarq::__anon86
CvLevMarq::CvLevMarq	calib3d/calib3d.hpp	/^    CvLevMarq( int nparams, int nerrs, CvTermCriteria criteria=$/;"	p	class:CvLevMarq	access:public	signature:( int nparams, int nerrs, CvTermCriteria criteria= cvTermCriteria(CV_TERMCRIT_EPS+CV_TERMCRIT_ITER,30,DBL_EPSILON), bool completeSymmFlag=false )
CvLevMarq::CvLevMarq	calib3d/calib3d.hpp	/^    CvLevMarq();$/;"	p	class:CvLevMarq	access:public	signature:()
CvLevMarq::DONE	calib3d/calib3d.hpp	/^    enum { DONE=0, STARTED=1, CALC_J=2, CHECK_ERR=3 };$/;"	e	enum:CvLevMarq::__anon86
CvLevMarq::J	calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> J;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::JtErr	calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> JtErr;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::JtJ	calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> JtJ;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::JtJN	calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> JtJN;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::JtJV	calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> JtJV;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::JtJW	calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> JtJW;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::STARTED	calib3d/calib3d.hpp	/^    enum { DONE=0, STARTED=1, CALC_J=2, CHECK_ERR=3 };$/;"	e	enum:CvLevMarq::__anon86
CvLevMarq::clear	calib3d/calib3d.hpp	/^    void clear();$/;"	p	class:CvLevMarq	access:public	signature:()
CvLevMarq::completeSymmFlag	calib3d/calib3d.hpp	/^    bool completeSymmFlag;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::criteria	calib3d/calib3d.hpp	/^    CvTermCriteria criteria;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::err	calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> err;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::errNorm	calib3d/calib3d.hpp	/^    double prevErrNorm, errNorm;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::init	calib3d/calib3d.hpp	/^    void init( int nparams, int nerrs, CvTermCriteria criteria=$/;"	p	class:CvLevMarq	access:public	signature:( int nparams, int nerrs, CvTermCriteria criteria= cvTermCriteria(CV_TERMCRIT_EPS+CV_TERMCRIT_ITER,30,DBL_EPSILON), bool completeSymmFlag=false )
CvLevMarq::iters	calib3d/calib3d.hpp	/^    int iters;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::lambdaLg10	calib3d/calib3d.hpp	/^    int lambdaLg10;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::mask	calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> mask;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::param	calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> param;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::prevErrNorm	calib3d/calib3d.hpp	/^    double prevErrNorm, errNorm;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::prevParam	calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> prevParam;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::state	calib3d/calib3d.hpp	/^    int state;$/;"	m	class:CvLevMarq	access:public
CvLevMarq::step	calib3d/calib3d.hpp	/^    void step();$/;"	p	class:CvLevMarq	access:public	signature:()
CvLevMarq::update	calib3d/calib3d.hpp	/^    bool update( const CvMat*& param, CvMat*& J, CvMat*& err );$/;"	p	class:CvLevMarq	access:public	signature:( const CvMat*& param, CvMat*& J, CvMat*& err )
CvLevMarq::updateAlt	calib3d/calib3d.hpp	/^    bool updateAlt( const CvMat*& param, CvMat*& JtJ, CvMat*& JtErr, double*& errNorm );$/;"	p	class:CvLevMarq	access:public	signature:( const CvMat*& param, CvMat*& JtJ, CvMat*& JtErr, double*& errNorm )
CvLevMarq::~CvLevMarq	calib3d/calib3d.hpp	/^    ~CvLevMarq();$/;"	p	class:CvLevMarq	access:public	signature:()
CvLineIterator	core/types_c.h	/^CvLineIterator;$/;"	t	typeref:struct:CvLineIterator
CvLineIterator	core/types_c.h	/^typedef struct CvLineIterator$/;"	s
CvLineIterator::err	core/types_c.h	/^    int  err;$/;"	m	struct:CvLineIterator	access:public
CvLineIterator::minus_delta	core/types_c.h	/^    int  minus_delta;$/;"	m	struct:CvLineIterator	access:public
CvLineIterator::minus_step	core/types_c.h	/^    int  minus_step;$/;"	m	struct:CvLineIterator	access:public
CvLineIterator::plus_delta	core/types_c.h	/^    int  plus_delta;$/;"	m	struct:CvLineIterator	access:public
CvLineIterator::plus_step	core/types_c.h	/^    int  plus_step;$/;"	m	struct:CvLineIterator	access:public
CvLineIterator::ptr	core/types_c.h	/^    uchar* ptr;$/;"	m	struct:CvLineIterator	access:public
CvMLData	ml/ml.hpp	/^    CvMLData();$/;"	p	class:CvMLData	access:public	signature:()
CvMLData	ml/ml.hpp	/^class CV_EXPORTS CvMLData$/;"	c
CvMLData::CvMLData	ml/ml.hpp	/^    CvMLData();$/;"	p	class:CvMLData	access:public	signature:()
CvMLData::chahge_var_idx	ml/ml.hpp	/^    void chahge_var_idx( int vi, bool state ); \/\/ state == true to set vi-variable as predictor$/;"	p	class:CvMLData	access:public	signature:( int vi, bool state )
CvMLData::change_var_type	ml/ml.hpp	/^    void change_var_type( int var_idx, int type); \/\/ type in { CV_VAR_ORDERED, CV_VAR_CATEGORICAL }    $/;"	p	class:CvMLData	access:public	signature:( int var_idx, int type)
CvMLData::class_map	ml/ml.hpp	/^    std::map<std::string, int> class_map;$/;"	m	class:CvMLData	access:protected
CvMLData::clear	ml/ml.hpp	/^    virtual void clear();$/;"	p	class:CvMLData	access:protected	signature:()
CvMLData::delimiter	ml/ml.hpp	/^    char delimiter;$/;"	m	class:CvMLData	access:protected
CvMLData::free_train_test_idx	ml/ml.hpp	/^    void free_train_test_idx();$/;"	p	class:CvMLData	access:protected	signature:()
CvMLData::get_class_labels_map	ml/ml.hpp	/^    const std::map<std::string, int>& get_class_labels_map() const;$/;"	p	class:CvMLData	access:public	signature:() const
CvMLData::get_delimiter	ml/ml.hpp	/^    char get_delimiter() const;$/;"	p	class:CvMLData	access:public	signature:() const
CvMLData::get_miss_ch	ml/ml.hpp	/^    char get_miss_ch() const;$/;"	p	class:CvMLData	access:public	signature:() const
CvMLData::get_missing	ml/ml.hpp	/^    const CvMat* get_missing() const;$/;"	p	class:CvMLData	access:public	signature:() const
CvMLData::get_response_idx	ml/ml.hpp	/^    int get_response_idx() const;$/;"	p	class:CvMLData	access:public	signature:() const
CvMLData::get_responses	ml/ml.hpp	/^    const CvMat* get_responses();$/;"	p	class:CvMLData	access:public	signature:()
CvMLData::get_test_sample_idx	ml/ml.hpp	/^    const CvMat* get_test_sample_idx() const;$/;"	p	class:CvMLData	access:public	signature:() const
CvMLData::get_train_sample_idx	ml/ml.hpp	/^    const CvMat* get_train_sample_idx() const;$/;"	p	class:CvMLData	access:public	signature:() const
CvMLData::get_values	ml/ml.hpp	/^    const CvMat* get_values() const;$/;"	p	class:CvMLData	access:public	signature:() const
CvMLData::get_var_idx	ml/ml.hpp	/^    const CvMat* get_var_idx();$/;"	p	class:CvMLData	access:public	signature:()
CvMLData::get_var_type	ml/ml.hpp	/^    int get_var_type( int var_idx ) const;$/;"	p	class:CvMLData	access:public	signature:( int var_idx ) const
CvMLData::get_var_types	ml/ml.hpp	/^    const CvMat* get_var_types();$/;"	p	class:CvMLData	access:public	signature:()
CvMLData::miss_ch	ml/ml.hpp	/^    char miss_ch;$/;"	m	class:CvMLData	access:protected
CvMLData::missing	ml/ml.hpp	/^    CvMat* missing;$/;"	m	class:CvMLData	access:protected
CvMLData::mix	ml/ml.hpp	/^    bool mix;$/;"	m	class:CvMLData	access:protected
CvMLData::mix_train_and_test_idx	ml/ml.hpp	/^    void mix_train_and_test_idx();$/;"	p	class:CvMLData	access:public	signature:()
CvMLData::read_csv	ml/ml.hpp	/^    int read_csv( const char* filename );$/;"	p	class:CvMLData	access:public	signature:( const char* filename )
CvMLData::response_idx	ml/ml.hpp	/^    int response_idx;$/;"	m	class:CvMLData	access:protected
CvMLData::response_out	ml/ml.hpp	/^    CvMat* response_out; \/\/ header$/;"	m	class:CvMLData	access:protected
CvMLData::rng	ml/ml.hpp	/^    cv::RNG* rng;$/;"	m	class:CvMLData	access:protected
CvMLData::sample_idx	ml/ml.hpp	/^    int* sample_idx; \/\/ data of train_sample_idx and test_sample_idx$/;"	m	class:CvMLData	access:protected
CvMLData::set_delimiter	ml/ml.hpp	/^    void set_delimiter( char ch );$/;"	p	class:CvMLData	access:public	signature:( char ch )
CvMLData::set_miss_ch	ml/ml.hpp	/^    void set_miss_ch( char ch );$/;"	p	class:CvMLData	access:public	signature:( char ch )
CvMLData::set_response_idx	ml/ml.hpp	/^    void set_response_idx( int idx ); \/\/ old response become predictors, new response_idx = idx$/;"	p	class:CvMLData	access:public	signature:( int idx )
CvMLData::set_train_test_split	ml/ml.hpp	/^    void set_train_test_split( const CvTrainTestSplit * spl );$/;"	p	class:CvMLData	access:public	signature:( const CvTrainTestSplit * spl )
CvMLData::set_var_types	ml/ml.hpp	/^    void set_var_types( const char* str );  \/\/ str examples:$/;"	p	class:CvMLData	access:public	signature:( const char* str )
CvMLData::str_to_flt_elem	ml/ml.hpp	/^    void str_to_flt_elem( const char* token, float& flt_elem, int& type);$/;"	p	class:CvMLData	access:protected	signature:( const char* token, float& flt_elem, int& type)
CvMLData::test_sample_idx	ml/ml.hpp	/^    CvMat* test_sample_idx;$/;"	m	class:CvMLData	access:protected
CvMLData::total_class_count	ml/ml.hpp	/^    int total_class_count;$/;"	m	class:CvMLData	access:protected
CvMLData::train_sample_count	ml/ml.hpp	/^    int train_sample_count;$/;"	m	class:CvMLData	access:protected
CvMLData::train_sample_idx	ml/ml.hpp	/^    CvMat* train_sample_idx;$/;"	m	class:CvMLData	access:protected
CvMLData::values	ml/ml.hpp	/^    CvMat* values;$/;"	m	class:CvMLData	access:protected
CvMLData::var_idx_mask	ml/ml.hpp	/^    CvMat* var_idx_mask;$/;"	m	class:CvMLData	access:protected
CvMLData::var_idx_out	ml/ml.hpp	/^    CvMat* var_idx_out; \/\/ mat$/;"	m	class:CvMLData	access:protected
CvMLData::var_types	ml/ml.hpp	/^    CvMat* var_types;$/;"	m	class:CvMLData	access:protected
CvMLData::var_types_out	ml/ml.hpp	/^    CvMat* var_types_out; \/\/ mat$/;"	m	class:CvMLData	access:protected
CvMLData::~CvMLData	ml/ml.hpp	/^    virtual ~CvMLData();$/;"	p	class:CvMLData	access:public	signature:()
CvMSERParams	features2d/features2d.hpp	/^typedef struct CvMSERParams$/;"	s
CvMSERParams	features2d/features2d.hpp	/^} CvMSERParams;$/;"	t	typeref:struct:CvMSERParams
CvMSERParams::areaThreshold	features2d/features2d.hpp	/^    double areaThreshold;$/;"	m	struct:CvMSERParams	access:public
CvMSERParams::delta	features2d/features2d.hpp	/^    int delta;$/;"	m	struct:CvMSERParams	access:public
CvMSERParams::edgeBlurSize	features2d/features2d.hpp	/^    int edgeBlurSize;$/;"	m	struct:CvMSERParams	access:public
CvMSERParams::maxArea	features2d/features2d.hpp	/^    int maxArea;$/;"	m	struct:CvMSERParams	access:public
CvMSERParams::maxEvolution	features2d/features2d.hpp	/^    int maxEvolution;$/;"	m	struct:CvMSERParams	access:public
CvMSERParams::maxVariation	features2d/features2d.hpp	/^    float maxVariation;$/;"	m	struct:CvMSERParams	access:public
CvMSERParams::minArea	features2d/features2d.hpp	/^    int minArea;$/;"	m	struct:CvMSERParams	access:public
CvMSERParams::minDiversity	features2d/features2d.hpp	/^    float minDiversity;$/;"	m	struct:CvMSERParams	access:public
CvMSERParams::minMargin	features2d/features2d.hpp	/^    double minMargin;$/;"	m	struct:CvMSERParams	access:public
CvMat	core/types_c.h	/^CvMat;$/;"	t	typeref:struct:CvMat
CvMat	core/types_c.h	/^typedef struct CvMat$/;"	s
CvMat::__anon151::db	core/types_c.h	/^        double* db;$/;"	m	union:CvMat::__anon151	access:public
CvMat::__anon151::fl	core/types_c.h	/^        float* fl;$/;"	m	union:CvMat::__anon151	access:public
CvMat::__anon151::i	core/types_c.h	/^        int* i;$/;"	m	union:CvMat::__anon151	access:public
CvMat::__anon151::ptr	core/types_c.h	/^        uchar* ptr;$/;"	m	union:CvMat::__anon151	access:public
CvMat::__anon151::s	core/types_c.h	/^        short* s;$/;"	m	union:CvMat::__anon151	access:public
CvMat::__anon152::height	core/types_c.h	/^        int height;$/;"	m	union:CvMat::__anon152	access:public
CvMat::__anon152::rows	core/types_c.h	/^        int rows;$/;"	m	union:CvMat::__anon152	access:public
CvMat::__anon153::cols	core/types_c.h	/^        int cols;$/;"	m	union:CvMat::__anon153	access:public
CvMat::__anon153::width	core/types_c.h	/^        int width;$/;"	m	union:CvMat::__anon153	access:public
CvMat::cols	core/types_c.h	/^    int cols;$/;"	m	struct:CvMat	access:public
CvMat::data	core/types_c.h	/^    } data;$/;"	m	struct:CvMat	typeref:union:CvMat::__anon151	access:public
CvMat::hdr_refcount	core/types_c.h	/^    int hdr_refcount;$/;"	m	struct:CvMat	access:public
CvMat::refcount	core/types_c.h	/^    int* refcount;$/;"	m	struct:CvMat	access:public
CvMat::rows	core/types_c.h	/^    int rows;$/;"	m	struct:CvMat	access:public
CvMat::step	core/types_c.h	/^    int step;$/;"	m	struct:CvMat	access:public
CvMat::type	core/types_c.h	/^    int type;$/;"	m	struct:CvMat	access:public
CvMatArray	legacy/compat.hpp	/^typedef CvMat CvMatArray;$/;"	t
CvMatND	core/types_c.h	/^CvMatND;$/;"	t	typeref:struct:CvMatND
CvMatND	core/types_c.h	/^typedef struct CvMatND$/;"	s
CvMatND::__anon154::db	core/types_c.h	/^        double* db;$/;"	m	union:CvMatND::__anon154	access:public
CvMatND::__anon154::fl	core/types_c.h	/^        float* fl;$/;"	m	union:CvMatND::__anon154	access:public
CvMatND::__anon154::i	core/types_c.h	/^        int* i;$/;"	m	union:CvMatND::__anon154	access:public
CvMatND::__anon154::ptr	core/types_c.h	/^        uchar* ptr;$/;"	m	union:CvMatND::__anon154	access:public
CvMatND::__anon154::s	core/types_c.h	/^        short* s;$/;"	m	union:CvMatND::__anon154	access:public
CvMatND::__anon155::size	core/types_c.h	/^        int size;$/;"	m	struct:CvMatND::__anon155	access:public
CvMatND::__anon155::step	core/types_c.h	/^        int step;$/;"	m	struct:CvMatND::__anon155	access:public
CvMatND::data	core/types_c.h	/^    } data;$/;"	m	struct:CvMatND	typeref:union:CvMatND::__anon154	access:public
CvMatND::dim	core/types_c.h	/^    dim[CV_MAX_DIM];$/;"	m	struct:CvMatND	typeref:struct:CvMatND::__anon155	access:public
CvMatND::dims	core/types_c.h	/^    int dims;$/;"	m	struct:CvMatND	access:public
CvMatND::hdr_refcount	core/types_c.h	/^    int hdr_refcount;$/;"	m	struct:CvMatND	access:public
CvMatND::refcount	core/types_c.h	/^    int* refcount;$/;"	m	struct:CvMatND	access:public
CvMatND::type	core/types_c.h	/^    int type;$/;"	m	struct:CvMatND	access:public
CvMatType	legacy/compat.hpp	/^typedef int CvMatType;$/;"	t
CvMatr32f	legacy/compat.hpp	/^typedef float*   CvMatr32f;$/;"	t
CvMatr64d	legacy/compat.hpp	/^typedef double*  CvMatr64d;$/;"	t
CvMatrix	legacy/legacy.hpp	/^    CvMatrix( CvFileStorage* fs, const char* mapname, const char* matname ) : matrix(0)$/;"	f	class:CvMatrix	access:public	signature:( CvFileStorage* fs, const char* mapname, const char* matname )
CvMatrix	legacy/legacy.hpp	/^    CvMatrix( CvFileStorage* fs, const char* seqname, int idx ) : matrix(0)$/;"	f	class:CvMatrix	access:public	signature:( CvFileStorage* fs, const char* seqname, int idx )
CvMatrix	legacy/legacy.hpp	/^    CvMatrix( CvMat* m )$/;"	f	class:CvMatrix	access:public	signature:( CvMat* m )
CvMatrix	legacy/legacy.hpp	/^    CvMatrix( const CvMatrix& m )$/;"	f	class:CvMatrix	access:public	signature:( const CvMatrix& m )
CvMatrix	legacy/legacy.hpp	/^    CvMatrix( const char* filename, const char* matname=0, int color=-1 ) : matrix(0)$/;"	f	class:CvMatrix	access:public	signature:( const char* filename, const char* matname=0, int color=-1 )
CvMatrix	legacy/legacy.hpp	/^    CvMatrix( int rows, int cols, int type )$/;"	f	class:CvMatrix	access:public	signature:( int rows, int cols, int type )
CvMatrix	legacy/legacy.hpp	/^    CvMatrix( int rows, int cols, int type, CvMat* hdr,$/;"	f	class:CvMatrix	access:public	signature:( int rows, int cols, int type, CvMat* hdr, void* data=0, int step=CV_AUTOSTEP )
CvMatrix	legacy/legacy.hpp	/^    CvMatrix( int rows, int cols, int type, CvMemStorage* storage, bool alloc_data=true );$/;"	p	class:CvMatrix	access:public	signature:( int rows, int cols, int type, CvMemStorage* storage, bool alloc_data=true )
CvMatrix	legacy/legacy.hpp	/^    CvMatrix( int rows, int cols, int type, void* data, int step=CV_AUTOSTEP )$/;"	f	class:CvMatrix	access:public	signature:( int rows, int cols, int type, void* data, int step=CV_AUTOSTEP )
CvMatrix	legacy/legacy.hpp	/^    CvMatrix() : matrix(0) {}$/;"	f	class:CvMatrix	access:public	signature:()
CvMatrix	legacy/legacy.hpp	/^class CV_EXPORTS CvMatrix$/;"	c
CvMatrix3	legacy/legacy.hpp	/^typedef struct CvMatrix3$/;"	s
CvMatrix3	legacy/legacy.hpp	/^} CvMatrix3;    $/;"	t	typeref:struct:CvMatrix3
CvMatrix3::m	legacy/legacy.hpp	/^    float m[3][3];$/;"	m	struct:CvMatrix3	access:public
CvMatrix::CvMatrix	legacy/legacy.hpp	/^    CvMatrix( CvFileStorage* fs, const char* mapname, const char* matname ) : matrix(0)$/;"	f	class:CvMatrix	access:public	signature:( CvFileStorage* fs, const char* mapname, const char* matname )
CvMatrix::CvMatrix	legacy/legacy.hpp	/^    CvMatrix( CvFileStorage* fs, const char* seqname, int idx ) : matrix(0)$/;"	f	class:CvMatrix	access:public	signature:( CvFileStorage* fs, const char* seqname, int idx )
CvMatrix::CvMatrix	legacy/legacy.hpp	/^    CvMatrix( CvMat* m )$/;"	f	class:CvMatrix	access:public	signature:( CvMat* m )
CvMatrix::CvMatrix	legacy/legacy.hpp	/^    CvMatrix( const CvMatrix& m )$/;"	f	class:CvMatrix	access:public	signature:( const CvMatrix& m )
CvMatrix::CvMatrix	legacy/legacy.hpp	/^    CvMatrix( const char* filename, const char* matname=0, int color=-1 ) : matrix(0)$/;"	f	class:CvMatrix	access:public	signature:( const char* filename, const char* matname=0, int color=-1 )
CvMatrix::CvMatrix	legacy/legacy.hpp	/^    CvMatrix( int rows, int cols, int type )$/;"	f	class:CvMatrix	access:public	signature:( int rows, int cols, int type )
CvMatrix::CvMatrix	legacy/legacy.hpp	/^    CvMatrix( int rows, int cols, int type, CvMat* hdr,$/;"	f	class:CvMatrix	access:public	signature:( int rows, int cols, int type, CvMat* hdr, void* data=0, int step=CV_AUTOSTEP )
CvMatrix::CvMatrix	legacy/legacy.hpp	/^    CvMatrix( int rows, int cols, int type, CvMemStorage* storage, bool alloc_data=true );$/;"	p	class:CvMatrix	access:public	signature:( int rows, int cols, int type, CvMemStorage* storage, bool alloc_data=true )
CvMatrix::CvMatrix	legacy/legacy.hpp	/^    CvMatrix( int rows, int cols, int type, void* data, int step=CV_AUTOSTEP )$/;"	f	class:CvMatrix	access:public	signature:( int rows, int cols, int type, void* data, int step=CV_AUTOSTEP )
CvMatrix::CvMatrix	legacy/legacy.hpp	/^    CvMatrix() : matrix(0) {}$/;"	f	class:CvMatrix	access:public	signature:()
CvMatrix::addref	legacy/legacy.hpp	/^    void addref() const$/;"	f	class:CvMatrix	access:public	signature:() const
CvMatrix::channels	legacy/legacy.hpp	/^    int channels() const { return matrix ? CV_MAT_CN(matrix->type) : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
CvMatrix::clear	legacy/legacy.hpp	/^    void clear()$/;"	f	class:CvMatrix	access:public	signature:()
CvMatrix::clone	legacy/legacy.hpp	/^    CvMatrix clone() { return CvMatrix(matrix ? cvCloneMat(matrix) : 0); }$/;"	f	class:CvMatrix	access:public	signature:()
CvMatrix::cols	legacy/legacy.hpp	/^    int cols() const { return matrix ? matrix->cols : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
CvMatrix::create	legacy/legacy.hpp	/^    void create( int rows, int cols, int type )$/;"	f	class:CvMatrix	access:public	signature:( int rows, int cols, int type )
CvMatrix::data	legacy/legacy.hpp	/^    const uchar* data() const { return matrix ? matrix->data.ptr : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
CvMatrix::data	legacy/legacy.hpp	/^    uchar* data() { return matrix ? matrix->data.ptr : 0; }$/;"	f	class:CvMatrix	access:public	signature:()
CvMatrix::depth	legacy/legacy.hpp	/^    int depth() const { return matrix ? CV_MAT_DEPTH(matrix->type) : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
CvMatrix::is_valid	legacy/legacy.hpp	/^    bool is_valid() { return matrix != 0; }$/;"	f	class:CvMatrix	access:public	signature:()
CvMatrix::load	legacy/legacy.hpp	/^    bool load( const char* filename, const char* matname=0, int color=-1 );$/;"	p	class:CvMatrix	access:public	signature:( const char* filename, const char* matname=0, int color=-1 )
CvMatrix::matrix	legacy/legacy.hpp	/^    CvMat* matrix;$/;"	m	class:CvMatrix	access:protected
CvMatrix::operator =	legacy/legacy.hpp	/^    CvMatrix& operator = (const CvMatrix& _m)$/;"	f	class:CvMatrix	access:public	signature:(const CvMatrix& _m)
CvMatrix::operator CvMat*	legacy/legacy.hpp	/^    operator CvMat* () { return matrix; }$/;"	f	class:CvMatrix	access:public	signature:()
CvMatrix::operator const CvMat*	legacy/legacy.hpp	/^    operator const CvMat* () const { return matrix; }$/;"	f	class:CvMatrix	access:public	signature:() const
CvMatrix::pix_size	legacy/legacy.hpp	/^    int pix_size() const { return matrix ? CV_ELEM_SIZE(matrix->type) : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
CvMatrix::read	legacy/legacy.hpp	/^    bool read( CvFileStorage* fs, const char* mapname, const char* matname );$/;"	p	class:CvMatrix	access:public	signature:( CvFileStorage* fs, const char* mapname, const char* matname )
CvMatrix::read	legacy/legacy.hpp	/^    bool read( CvFileStorage* fs, const char* seqname, int idx );$/;"	p	class:CvMatrix	access:public	signature:( CvFileStorage* fs, const char* seqname, int idx )
CvMatrix::release	legacy/legacy.hpp	/^    void release()$/;"	f	class:CvMatrix	access:public	signature:()
CvMatrix::row	legacy/legacy.hpp	/^    const uchar* row(int i) const$/;"	f	class:CvMatrix	access:public	signature:(int i) const
CvMatrix::row	legacy/legacy.hpp	/^    uchar* row(int i) { return !matrix ? 0 : matrix->data.ptr + i*matrix->step; }$/;"	f	class:CvMatrix	access:public	signature:(int i)
CvMatrix::rows	legacy/legacy.hpp	/^    int rows() const { return matrix ? matrix->rows : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
CvMatrix::save	legacy/legacy.hpp	/^    void save( const char* filename, const char* matname, const int* params=0 );$/;"	p	class:CvMatrix	access:public	signature:( const char* filename, const char* matname, const int* params=0 )
CvMatrix::set	legacy/legacy.hpp	/^    void set( CvMat* m, bool add_ref )$/;"	f	class:CvMatrix	access:public	signature:( CvMat* m, bool add_ref )
CvMatrix::set_data	legacy/legacy.hpp	/^    void set_data( void* data, int step=CV_AUTOSTEP )$/;"	f	class:CvMatrix	access:public	signature:( void* data, int step=CV_AUTOSTEP )
CvMatrix::show	legacy/legacy.hpp	/^    void show( const char* window_name );$/;"	p	class:CvMatrix	access:public	signature:( const char* window_name )
CvMatrix::size	legacy/legacy.hpp	/^    CvSize size() const$/;"	f	class:CvMatrix	access:public	signature:() const
CvMatrix::step	legacy/legacy.hpp	/^    int step() const { return matrix ? matrix->step : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
CvMatrix::type	legacy/legacy.hpp	/^    int type() const { return matrix ? CV_MAT_TYPE(matrix->type) : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
CvMatrix::write	legacy/legacy.hpp	/^    void write( CvFileStorage* fs, const char* matname );$/;"	p	class:CvMatrix	access:public	signature:( CvFileStorage* fs, const char* matname )
CvMatrix::~CvMatrix	legacy/legacy.hpp	/^    ~CvMatrix()$/;"	f	class:CvMatrix	access:public	signature:()
CvMemBlock	core/types_c.h	/^CvMemBlock;$/;"	t	typeref:struct:CvMemBlock
CvMemBlock	core/types_c.h	/^typedef struct CvMemBlock$/;"	s
CvMemBlock::next	core/types_c.h	/^    struct CvMemBlock*  next;$/;"	m	struct:CvMemBlock	typeref:struct:CvMemBlock::CvMemBlock	access:public
CvMemBlock::prev	core/types_c.h	/^    struct CvMemBlock*  prev;$/;"	m	struct:CvMemBlock	typeref:struct:CvMemBlock::CvMemBlock	access:public
CvMemStorage	core/types_c.h	/^CvMemStorage;$/;"	t	typeref:struct:CvMemStorage
CvMemStorage	core/types_c.h	/^typedef struct CvMemStorage$/;"	s
CvMemStorage::block_size	core/types_c.h	/^    int block_size;               \/* Block size.                              *\/$/;"	m	struct:CvMemStorage	access:public
CvMemStorage::bottom	core/types_c.h	/^    CvMemBlock* bottom;           \/* First allocated block.                   *\/$/;"	m	struct:CvMemStorage	access:public
CvMemStorage::free_space	core/types_c.h	/^    int free_space;               \/* Remaining free space in current block.   *\/$/;"	m	struct:CvMemStorage	access:public
CvMemStorage::parent	core/types_c.h	/^    struct  CvMemStorage* parent; \/* We get new blocks from parent as needed. *\/$/;"	m	struct:CvMemStorage	typeref:struct:CvMemStorage::CvMemStorage	access:public
CvMemStorage::signature	core/types_c.h	/^    int signature;$/;"	m	struct:CvMemStorage	access:public
CvMemStorage::top	core/types_c.h	/^    CvMemBlock* top;              \/* Current memory block - top of the stack. *\/$/;"	m	struct:CvMemStorage	access:public
CvMemStoragePos	core/types_c.h	/^CvMemStoragePos;$/;"	t	typeref:struct:CvMemStoragePos
CvMemStoragePos	core/types_c.h	/^typedef struct CvMemStoragePos$/;"	s
CvMemStoragePos::free_space	core/types_c.h	/^    int free_space;$/;"	m	struct:CvMemStoragePos	access:public
CvMemStoragePos::top	core/types_c.h	/^    CvMemBlock* top;$/;"	m	struct:CvMemStoragePos	access:public
CvModule	core/core_c.h	/^    CvModule( CvModuleInfo* _info );$/;"	p	struct:CvModule	access:public	signature:( CvModuleInfo* _info )
CvModule	core/core_c.h	/^struct CV_EXPORTS CvModule$/;"	s
CvModule::CvModule	core/core_c.h	/^    CvModule( CvModuleInfo* _info );$/;"	p	struct:CvModule	access:public	signature:( CvModuleInfo* _info )
CvModule::first	core/core_c.h	/^    static CvModuleInfo* first;$/;"	m	struct:CvModule	access:public
CvModule::info	core/core_c.h	/^    CvModuleInfo* info;$/;"	m	struct:CvModule	access:public
CvModule::last	core/core_c.h	/^    static CvModuleInfo* last;$/;"	m	struct:CvModule	access:public
CvModule::~CvModule	core/core_c.h	/^    ~CvModule();$/;"	p	struct:CvModule	access:public	signature:()
CvModuleInfo	core/types_c.h	/^CvModuleInfo;$/;"	t	typeref:struct:CvModuleInfo
CvModuleInfo	core/types_c.h	/^typedef struct CvModuleInfo$/;"	s
CvModuleInfo::func_tab	core/types_c.h	/^    CvPluginFuncInfo* func_tab;$/;"	m	struct:CvModuleInfo	access:public
CvModuleInfo::name	core/types_c.h	/^    const char* name;$/;"	m	struct:CvModuleInfo	access:public
CvModuleInfo::next	core/types_c.h	/^    struct CvModuleInfo* next;$/;"	m	struct:CvModuleInfo	typeref:struct:CvModuleInfo::CvModuleInfo	access:public
CvModuleInfo::version	core/types_c.h	/^    const char* version;$/;"	m	struct:CvModuleInfo	access:public
CvMoments	imgproc/types_c.h	/^CvMoments;$/;"	t	typeref:struct:CvMoments
CvMoments	imgproc/types_c.h	/^typedef struct CvMoments$/;"	s
CvMoments::inv_sqrt_m00	imgproc/types_c.h	/^    double  inv_sqrt_m00; \/* m00 != 0 ? 1\/sqrt(m00) : 0 *\/$/;"	m	struct:CvMoments	access:public
CvMoments::m00	imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::m01	imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::m02	imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::m03	imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::m10	imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::m11	imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::m12	imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::m20	imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::m21	imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::m30	imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::mu02	imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::mu03	imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::mu11	imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::mu12	imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::mu20	imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::mu21	imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
CvMoments::mu30	imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
CvMorphOp	legacy/compat.hpp	/^typedef int CvMorphOp;$/;"	t
CvMouseCallback	highgui/highgui_c.h	/^typedef void (CV_CDECL *CvMouseCallback )(int event, int x, int y, int flags, void* param);$/;"	t
CvNArrayIterator	core/core_c.h	/^CvNArrayIterator;$/;"	t	typeref:struct:CvNArrayIterator
CvNArrayIterator	core/core_c.h	/^typedef struct CvNArrayIterator$/;"	s
CvNArrayIterator::count	core/core_c.h	/^    int count; \/* number of arrays *\/$/;"	m	struct:CvNArrayIterator	access:public
CvNArrayIterator::dims	core/core_c.h	/^    int dims; \/* number of dimensions to iterate *\/$/;"	m	struct:CvNArrayIterator	access:public
CvNArrayIterator::hdr	core/core_c.h	/^    CvMatND* hdr[CV_MAX_ARR]; \/* pointers to the headers of the$/;"	m	struct:CvNArrayIterator	access:public
CvNArrayIterator::ptr	core/core_c.h	/^    uchar* ptr[CV_MAX_ARR]; \/* pointers to the array slices *\/$/;"	m	struct:CvNArrayIterator	access:public
CvNArrayIterator::size	core/core_c.h	/^    CvSize size; \/* maximal common linear size: { width = size, height = 1 } *\/$/;"	m	struct:CvNArrayIterator	access:public
CvNArrayIterator::stack	core/core_c.h	/^    int stack[CV_MAX_DIM]; \/* for internal use *\/$/;"	m	struct:CvNArrayIterator	access:public
CvNextEdgeType	imgproc/types_c.h	/^CvNextEdgeType;$/;"	t	typeref:enum:CvNextEdgeType
CvNextEdgeType	imgproc/types_c.h	/^typedef enum CvNextEdgeType$/;"	g
CvNormalBayesClassifier	ml/ml.hpp	/^    CV_WRAP CvNormalBayesClassifier( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat() )
CvNormalBayesClassifier	ml/ml.hpp	/^    CV_WRAP CvNormalBayesClassifier();$/;"	p	class:CvNormalBayesClassifier	access:public	signature:()
CvNormalBayesClassifier	ml/ml.hpp	/^    CvNormalBayesClassifier( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0 )
CvNormalBayesClassifier	ml/ml.hpp	/^class CV_EXPORTS_W CvNormalBayesClassifier : public CvStatModel$/;"	c	inherits:CvStatModel
CvNormalBayesClassifier::CvNormalBayesClassifier	ml/ml.hpp	/^    CV_WRAP CvNormalBayesClassifier( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat() )
CvNormalBayesClassifier::CvNormalBayesClassifier	ml/ml.hpp	/^    CV_WRAP CvNormalBayesClassifier();$/;"	p	class:CvNormalBayesClassifier	access:public	signature:()
CvNormalBayesClassifier::CvNormalBayesClassifier	ml/ml.hpp	/^    CvNormalBayesClassifier( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0 )
CvNormalBayesClassifier::avg	ml/ml.hpp	/^    CvMat** avg;$/;"	m	class:CvNormalBayesClassifier	access:protected
CvNormalBayesClassifier::c	ml/ml.hpp	/^    CvMat*  c;$/;"	m	class:CvNormalBayesClassifier	access:protected
CvNormalBayesClassifier::clear	ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvNormalBayesClassifier	access:public	signature:()
CvNormalBayesClassifier::cls_labels	ml/ml.hpp	/^    CvMat*  cls_labels;$/;"	m	class:CvNormalBayesClassifier	access:protected
CvNormalBayesClassifier::count	ml/ml.hpp	/^    CvMat** count;$/;"	m	class:CvNormalBayesClassifier	access:protected
CvNormalBayesClassifier::cov_rotate_mats	ml/ml.hpp	/^    CvMat** cov_rotate_mats;$/;"	m	class:CvNormalBayesClassifier	access:protected
CvNormalBayesClassifier::inv_eigen_values	ml/ml.hpp	/^    CvMat** inv_eigen_values;$/;"	m	class:CvNormalBayesClassifier	access:protected
CvNormalBayesClassifier::predict	ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& samples, CV_OUT cv::Mat* results=0 ) const;$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const cv::Mat& samples, CV_OUT cv::Mat* results=0 ) const
CvNormalBayesClassifier::predict	ml/ml.hpp	/^    virtual float predict( const CvMat* samples, CV_OUT CvMat* results=0 ) const;$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const CvMat* samples, CV_OUT CvMat* results=0 ) const
CvNormalBayesClassifier::productsum	ml/ml.hpp	/^    CvMat** productsum;$/;"	m	class:CvNormalBayesClassifier	access:protected
CvNormalBayesClassifier::read	ml/ml.hpp	/^    virtual void read( CvFileStorage* storage, CvFileNode* node );$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( CvFileStorage* storage, CvFileNode* node )
CvNormalBayesClassifier::sum	ml/ml.hpp	/^    CvMat** sum;$/;"	m	class:CvNormalBayesClassifier	access:protected
CvNormalBayesClassifier::train	ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& varIdx = cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), bool update=false )
CvNormalBayesClassifier::train	ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* varIdx = 0, const CvMat* sampleIdx=0, bool update=false )
CvNormalBayesClassifier::var_all	ml/ml.hpp	/^    int     var_count, var_all;$/;"	m	class:CvNormalBayesClassifier	access:protected
CvNormalBayesClassifier::var_count	ml/ml.hpp	/^    int     var_count, var_all;$/;"	m	class:CvNormalBayesClassifier	access:protected
CvNormalBayesClassifier::var_idx	ml/ml.hpp	/^    CvMat*  var_idx;$/;"	m	class:CvNormalBayesClassifier	access:protected
CvNormalBayesClassifier::write	ml/ml.hpp	/^    virtual void write( CvFileStorage* storage, const char* name ) const;$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( CvFileStorage* storage, const char* name ) const
CvNormalBayesClassifier::~CvNormalBayesClassifier	ml/ml.hpp	/^    virtual ~CvNormalBayesClassifier();$/;"	p	class:CvNormalBayesClassifier	access:public	signature:()
CvObjectDetection	objdetect/objdetect.hpp	/^typedef struct CvObjectDetection$/;"	s
CvObjectDetection	objdetect/objdetect.hpp	/^} CvObjectDetection;$/;"	t	typeref:struct:CvObjectDetection
CvObjectDetection::rect	objdetect/objdetect.hpp	/^	CvRect rect;$/;"	m	struct:CvObjectDetection	access:public
CvObjectDetection::score	objdetect/objdetect.hpp	/^	float score;$/;"	m	struct:CvObjectDetection	access:public
CvObjectDetector	legacy/blobtrack.hpp	/^    CvObjectDetector( const char* \/*detector_file_name*\/ = 0 );$/;"	p	class:CvObjectDetector	access:public	signature:( const char* = 0 )
CvObjectDetector	legacy/blobtrack.hpp	/^class CV_EXPORTS CvObjectDetector$/;"	c
CvObjectDetector::CvObjectDetector	legacy/blobtrack.hpp	/^    CvObjectDetector( const char* \/*detector_file_name*\/ = 0 );$/;"	p	class:CvObjectDetector	access:public	signature:( const char* = 0 )
CvObjectDetector::Detect	legacy/blobtrack.hpp	/^    void Detect( const CvArr* \/*img*\/, \/* out *\/ CvBlobSeq* \/*detected_blob_seq*\/ = 0 );$/;"	p	class:CvObjectDetector	access:public	signature:( const CvArr* , CvBlobSeq* = 0 )
CvObjectDetector::GetMaxBorderSize	legacy/blobtrack.hpp	/^    int GetMaxBorderSize() const;$/;"	p	class:CvObjectDetector	access:public	signature:() const
CvObjectDetector::GetMinWindowSize	legacy/blobtrack.hpp	/^    CvSize GetMinWindowSize() const;$/;"	p	class:CvObjectDetector	access:public	signature:() const
CvObjectDetector::Load	legacy/blobtrack.hpp	/^    bool Load( const char* \/*detector_file_name*\/ = 0 );$/;"	p	class:CvObjectDetector	access:public	signature:( const char* = 0 )
CvObjectDetector::impl	legacy/blobtrack.hpp	/^    class CvObjectDetectorImpl* impl;$/;"	m	class:CvObjectDetector	typeref:class:CvObjectDetector::CvObjectDetectorImpl	access:protected
CvObjectDetector::~CvObjectDetector	legacy/blobtrack.hpp	/^    ~CvObjectDetector();$/;"	p	class:CvObjectDetector	access:public	signature:()
CvOpenGLCallback	highgui/highgui_c.h	/^typedef void (CV_CDECL *CvOpenGLCallback)(void* userdata);$/;"	t
CvPOSITObject	calib3d/calib3d.hpp	/^typedef struct CvPOSITObject CvPOSITObject;$/;"	t	typeref:struct:CvPOSITObject
CvPair16u32s	ml/ml.hpp	/^struct CvPair16u32s$/;"	s
CvPair16u32s::i	ml/ml.hpp	/^    int* i;$/;"	m	struct:CvPair16u32s	access:public
CvPair16u32s::u	ml/ml.hpp	/^    unsigned short* u;$/;"	m	struct:CvPair16u32s	access:public
CvParamGrid	ml/ml.hpp	/^    CvParamGrid( double _min_val, double _max_val, double log_step )$/;"	f	struct:CvParamGrid	access:public	signature:( double _min_val, double _max_val, double log_step )
CvParamGrid	ml/ml.hpp	/^    CvParamGrid()$/;"	f	struct:CvParamGrid	access:public	signature:()
CvParamGrid	ml/ml.hpp	/^struct CV_EXPORTS_W_MAP CvParamGrid$/;"	s
CvParamGrid::CvParamGrid	ml/ml.hpp	/^    CvParamGrid( double _min_val, double _max_val, double log_step )$/;"	f	struct:CvParamGrid	access:public	signature:( double _min_val, double _max_val, double log_step )
CvParamGrid::CvParamGrid	ml/ml.hpp	/^    CvParamGrid()$/;"	f	struct:CvParamGrid	access:public	signature:()
CvParamGrid::SVM_C	ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon71
CvParamGrid::SVM_COEF	ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon71
CvParamGrid::SVM_DEGREE	ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon71
CvParamGrid::SVM_GAMMA	ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon71
CvParamGrid::SVM_NU	ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon71
CvParamGrid::SVM_P	ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon71
CvParamGrid::check	ml/ml.hpp	/^    bool check() const;$/;"	p	struct:CvParamGrid	access:public	signature:() const
CvParamGrid::max_val	ml/ml.hpp	/^    CV_PROP_RW double max_val;$/;"	m	struct:CvParamGrid	access:public
CvParamGrid::min_val	ml/ml.hpp	/^    CV_PROP_RW double min_val;$/;"	m	struct:CvParamGrid	access:public
CvParamGrid::step	ml/ml.hpp	/^    CV_PROP_RW double step;$/;"	m	struct:CvParamGrid	access:public
CvPixelPosition32f	legacy/compat.hpp	/^} CvPixelPosition32f;$/;"	t	typeref:struct:_CvPixelPosition32f
CvPixelPosition8s	legacy/compat.hpp	/^} CvPixelPosition8s;$/;"	t	typeref:struct:_CvPixelPosition8s
CvPixelPosition8u	legacy/compat.hpp	/^} CvPixelPosition8u;$/;"	t	typeref:struct:_CvPixelPosition8u
CvPluginFuncInfo	core/types_c.h	/^CvPluginFuncInfo;$/;"	t	typeref:struct:CvPluginFuncInfo
CvPluginFuncInfo	core/types_c.h	/^typedef struct CvPluginFuncInfo$/;"	s
CvPluginFuncInfo::default_func_addr	core/types_c.h	/^    void* default_func_addr;$/;"	m	struct:CvPluginFuncInfo	access:public
CvPluginFuncInfo::func_addr	core/types_c.h	/^    void** func_addr;$/;"	m	struct:CvPluginFuncInfo	access:public
CvPluginFuncInfo::func_names	core/types_c.h	/^    const char* func_names;$/;"	m	struct:CvPluginFuncInfo	access:public
CvPluginFuncInfo::loaded_from	core/types_c.h	/^    int loaded_from;$/;"	m	struct:CvPluginFuncInfo	access:public
CvPluginFuncInfo::search_modules	core/types_c.h	/^    int search_modules;$/;"	m	struct:CvPluginFuncInfo	access:public
CvPoint	core/types_c.h	/^CvPoint;$/;"	t	typeref:struct:CvPoint
CvPoint	core/types_c.h	/^typedef struct CvPoint$/;"	s
CvPoint2D32f	core/types_c.h	/^CvPoint2D32f;$/;"	t	typeref:struct:CvPoint2D32f
CvPoint2D32f	core/types_c.h	/^typedef struct CvPoint2D32f$/;"	s
CvPoint2D32f::x	core/types_c.h	/^    float x;$/;"	m	struct:CvPoint2D32f	access:public
CvPoint2D32f::y	core/types_c.h	/^    float y;$/;"	m	struct:CvPoint2D32f	access:public
CvPoint2D64d	legacy/compat.hpp	/^typedef CvPoint2D64f CvPoint2D64d;$/;"	t
CvPoint2D64f	core/types_c.h	/^CvPoint2D64f;$/;"	t	typeref:struct:CvPoint2D64f
CvPoint2D64f	core/types_c.h	/^typedef struct CvPoint2D64f$/;"	s
CvPoint2D64f::x	core/types_c.h	/^    double x;$/;"	m	struct:CvPoint2D64f	access:public
CvPoint2D64f::y	core/types_c.h	/^    double y;$/;"	m	struct:CvPoint2D64f	access:public
CvPoint2DSeq	core/types_c.h	/^typedef CvContour CvPoint2DSeq;$/;"	t
CvPoint3D32f	core/types_c.h	/^CvPoint3D32f;$/;"	t	typeref:struct:CvPoint3D32f
CvPoint3D32f	core/types_c.h	/^typedef struct CvPoint3D32f$/;"	s
CvPoint3D32f::x	core/types_c.h	/^    float x;$/;"	m	struct:CvPoint3D32f	access:public
CvPoint3D32f::y	core/types_c.h	/^    float y;$/;"	m	struct:CvPoint3D32f	access:public
CvPoint3D32f::z	core/types_c.h	/^    float z;$/;"	m	struct:CvPoint3D32f	access:public
CvPoint3D64d	legacy/compat.hpp	/^typedef CvPoint3D64f CvPoint3D64d;$/;"	t
CvPoint3D64f	core/types_c.h	/^CvPoint3D64f;$/;"	t	typeref:struct:CvPoint3D64f
CvPoint3D64f	core/types_c.h	/^typedef struct CvPoint3D64f$/;"	s
CvPoint3D64f::x	core/types_c.h	/^    double x;$/;"	m	struct:CvPoint3D64f	access:public
CvPoint3D64f::y	core/types_c.h	/^    double y;$/;"	m	struct:CvPoint3D64f	access:public
CvPoint3D64f::z	core/types_c.h	/^    double z;$/;"	m	struct:CvPoint3D64f	access:public
CvPoint::x	core/types_c.h	/^    int x;$/;"	m	struct:CvPoint	access:public
CvPoint::y	core/types_c.h	/^    int y;$/;"	m	struct:CvPoint	access:public
CvPolyApproxMethod	legacy/compat.hpp	/^typedef int CvPolyApproxMethod;$/;"	t
CvProb	legacy/blobtrack.hpp	/^class CV_EXPORTS CvProb$/;"	c
CvProb::AddFeature	legacy/blobtrack.hpp	/^    virtual void AddFeature(float W, int* comps, int x =0, int y = 0) = 0;$/;"	p	class:CvProb	access:public	signature:(float W, int* comps, int x =0, int y = 0)
CvProb::Release	legacy/blobtrack.hpp	/^    virtual void Release() = 0;$/;"	p	class:CvProb	access:public	signature:()
CvProb::Scale	legacy/blobtrack.hpp	/^    virtual void Scale(float factor = 0, int x = -1, int y = -1) = 0;$/;"	p	class:CvProb	access:public	signature:(float factor = 0, int x = -1, int y = -1)
CvProb::Value	legacy/blobtrack.hpp	/^    virtual double Value(int* \/*comp*\/, int \/*x*\/ = 0, int \/*y*\/ = 0){return -1;};$/;"	f	class:CvProb	access:public	signature:(int* , int = 0, int = 0)
CvProb::~CvProb	legacy/blobtrack.hpp	/^    virtual ~CvProb() {};$/;"	f	class:CvProb	access:public	signature:()
CvQuadEdge2D	imgproc/types_c.h	/^CvQuadEdge2D;$/;"	t	typeref:struct:CvQuadEdge2D
CvQuadEdge2D	imgproc/types_c.h	/^typedef struct CvQuadEdge2D$/;"	s
CvRNG	core/types_c.h	/^typedef uint64 CvRNG;$/;"	t
CvRTParams	ml/ml.hpp	/^    CvRTParams( int max_depth, int min_sample_count,$/;"	p	struct:CvRTParams	access:public	signature:( int max_depth, int min_sample_count, float regression_accuracy, bool use_surrogates, int max_categories, const float* priors, bool calc_var_importance, int nactive_vars, int max_num_of_trees_in_the_forest, float forest_accuracy, int termcrit_type )
CvRTParams	ml/ml.hpp	/^    CvRTParams();$/;"	p	struct:CvRTParams	access:public	signature:()
CvRTParams	ml/ml.hpp	/^struct CV_EXPORTS_W_MAP CvRTParams : public CvDTreeParams$/;"	s	inherits:CvDTreeParams
CvRTParams::CvRTParams	ml/ml.hpp	/^    CvRTParams( int max_depth, int min_sample_count,$/;"	p	struct:CvRTParams	access:public	signature:( int max_depth, int min_sample_count, float regression_accuracy, bool use_surrogates, int max_categories, const float* priors, bool calc_var_importance, int nactive_vars, int max_num_of_trees_in_the_forest, float forest_accuracy, int termcrit_type )
CvRTParams::CvRTParams	ml/ml.hpp	/^    CvRTParams();$/;"	p	struct:CvRTParams	access:public	signature:()
CvRTParams::calc_var_importance	ml/ml.hpp	/^    CV_PROP_RW bool calc_var_importance; \/\/ true <=> RF processes variable importance$/;"	m	struct:CvRTParams	access:public
CvRTParams::nactive_vars	ml/ml.hpp	/^    CV_PROP_RW int nactive_vars;$/;"	m	struct:CvRTParams	access:public
CvRTParams::term_crit	ml/ml.hpp	/^    CV_PROP_RW CvTermCriteria term_crit;$/;"	m	struct:CvRTParams	access:public
CvRTrees	ml/ml.hpp	/^    CV_WRAP CvRTrees();$/;"	p	class:CvRTrees	access:public	signature:()
CvRTrees	ml/ml.hpp	/^class CV_EXPORTS_W CvRTrees : public CvStatModel$/;"	c	inherits:CvStatModel
CvRTrees::CvRTrees	ml/ml.hpp	/^    CV_WRAP CvRTrees();$/;"	p	class:CvRTrees	access:public	signature:()
CvRTrees::active_var_mask	ml/ml.hpp	/^    CvMat* active_var_mask;$/;"	m	class:CvRTrees	access:protected
CvRTrees::calc_error	ml/ml.hpp	/^    virtual float calc_error( CvMLData* _data, int type , std::vector<float> *resp = 0 ); \/\/ type in {CV_TRAIN_ERROR, CV_TEST_ERROR}$/;"	p	class:CvRTrees	access:public	signature:( CvMLData* _data, int type , std::vector<float> *resp = 0 )
CvRTrees::clear	ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvRTrees	access:public	signature:()
CvRTrees::data	ml/ml.hpp	/^    CvDTreeTrainData* data;$/;"	m	class:CvRTrees	access:protected
CvRTrees::getVarImportance	ml/ml.hpp	/^    CV_WRAP virtual cv::Mat getVarImportance();$/;"	p	class:CvRTrees	access:public	signature:()
CvRTrees::get_active_var_mask	ml/ml.hpp	/^    CvMat* get_active_var_mask();$/;"	p	class:CvRTrees	access:public	signature:()
CvRTrees::get_proximity	ml/ml.hpp	/^    virtual float get_proximity( const CvMat* sample1, const CvMat* sample2,$/;"	p	class:CvRTrees	access:public	signature:( const CvMat* sample1, const CvMat* sample2, const CvMat* missing1 = 0, const CvMat* missing2 = 0 ) const
CvRTrees::get_rng	ml/ml.hpp	/^    CvRNG* get_rng();$/;"	p	class:CvRTrees	access:public	signature:()
CvRTrees::get_train_error	ml/ml.hpp	/^    virtual float get_train_error();    $/;"	p	class:CvRTrees	access:public	signature:()
CvRTrees::get_tree	ml/ml.hpp	/^    CvForestTree* get_tree(int i) const;$/;"	p	class:CvRTrees	access:public	signature:(int i) const
CvRTrees::get_tree_count	ml/ml.hpp	/^    int get_tree_count() const;$/;"	p	class:CvRTrees	access:public	signature:() const
CvRTrees::get_var_importance	ml/ml.hpp	/^    virtual const CvMat* get_var_importance();$/;"	p	class:CvRTrees	access:public	signature:()
CvRTrees::grow_forest	ml/ml.hpp	/^    virtual bool grow_forest( const CvTermCriteria term_crit );$/;"	p	class:CvRTrees	access:protected	signature:( const CvTermCriteria term_crit )
CvRTrees::nclasses	ml/ml.hpp	/^    int nclasses;$/;"	m	class:CvRTrees	access:protected
CvRTrees::nsamples	ml/ml.hpp	/^    int nsamples;$/;"	m	class:CvRTrees	access:protected
CvRTrees::ntrees	ml/ml.hpp	/^    int ntrees;$/;"	m	class:CvRTrees	access:protected
CvRTrees::oob_error	ml/ml.hpp	/^    double oob_error;$/;"	m	class:CvRTrees	access:protected
CvRTrees::predict	ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& sample, const cv::Mat& missing = cv::Mat() ) const;$/;"	p	class:CvRTrees	access:public	signature:( const cv::Mat& sample, const cv::Mat& missing = cv::Mat() ) const
CvRTrees::predict	ml/ml.hpp	/^    virtual float predict( const CvMat* sample, const CvMat* missing = 0 ) const;$/;"	p	class:CvRTrees	access:public	signature:( const CvMat* sample, const CvMat* missing = 0 ) const
CvRTrees::predict_prob	ml/ml.hpp	/^    CV_WRAP virtual float predict_prob( const cv::Mat& sample, const cv::Mat& missing = cv::Mat() ) const;$/;"	p	class:CvRTrees	access:public	signature:( const cv::Mat& sample, const cv::Mat& missing = cv::Mat() ) const
CvRTrees::predict_prob	ml/ml.hpp	/^    virtual float predict_prob( const CvMat* sample, const CvMat* missing = 0 ) const;$/;"	p	class:CvRTrees	access:public	signature:( const CvMat* sample, const CvMat* missing = 0 ) const
CvRTrees::read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvRTrees	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
CvRTrees::rng	ml/ml.hpp	/^    cv::RNG* rng;$/;"	m	class:CvRTrees	access:protected
CvRTrees::train	ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, int tflag,$/;"	p	class:CvRTrees	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvRTParams params=CvRTParams() )
CvRTrees::train	ml/ml.hpp	/^    virtual bool train( CvMLData* data, CvRTParams params=CvRTParams() );$/;"	p	class:CvRTrees	access:public	signature:( CvMLData* data, CvRTParams params=CvRTParams() )
CvRTrees::train	ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvRTrees	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvRTParams params=CvRTParams() )
CvRTrees::trees	ml/ml.hpp	/^    CvForestTree** trees;$/;"	m	class:CvRTrees	access:protected
CvRTrees::var_importance	ml/ml.hpp	/^    CvMat* var_importance;$/;"	m	class:CvRTrees	access:protected
CvRTrees::write	ml/ml.hpp	/^    virtual void write( CvFileStorage* fs, const char* name ) const;$/;"	p	class:CvRTrees	access:public	signature:( CvFileStorage* fs, const char* name ) const
CvRTrees::~CvRTrees	ml/ml.hpp	/^    virtual ~CvRTrees();$/;"	p	class:CvRTrees	access:public	signature:()
CvRandState	legacy/compat.hpp	/^typedef struct CvRandState$/;"	s
CvRandState	legacy/compat.hpp	/^} CvRandState;$/;"	t	typeref:struct:CvRandState
CvRandState::disttype	legacy/compat.hpp	/^    int       disttype; \/* distribution type *\/$/;"	m	struct:CvRandState	access:public
CvRandState::param	legacy/compat.hpp	/^    CvScalar  param[2]; \/* parameters of RNG *\/$/;"	m	struct:CvRandState	access:public
CvRandState::state	legacy/compat.hpp	/^    CvRNG     state;    \/* RNG state (the current seed and carry)*\/$/;"	m	struct:CvRandState	access:public
CvReadFunc	core/types_c.h	/^typedef void* (CV_CDECL *CvReadFunc)( CvFileStorage* storage, CvFileNode* node );$/;"	t
CvRect	core/types_c.h	/^CvRect;$/;"	t	typeref:struct:CvRect
CvRect	core/types_c.h	/^typedef struct CvRect$/;"	s
CvRect::height	core/types_c.h	/^    int height;$/;"	m	struct:CvRect	access:public
CvRect::width	core/types_c.h	/^    int width;$/;"	m	struct:CvRect	access:public
CvRect::x	core/types_c.h	/^    int x;$/;"	m	struct:CvRect	access:public
CvRect::y	core/types_c.h	/^    int y;$/;"	m	struct:CvRect	access:public
CvReleaseBGStatModel	video/background_segm.hpp	/^typedef void (CV_CDECL * CvReleaseBGStatModel)( struct CvBGStatModel** bg_model );$/;"	t
CvReleaseFunc	core/types_c.h	/^typedef void (CV_CDECL *CvReleaseFunc)( void** struct_dblptr );$/;"	t
CvRodriguesType	legacy/compat.hpp	/^typedef int CvRodriguesType;$/;"	t
CvSURFParams	features2d/features2d.hpp	/^typedef struct CvSURFParams$/;"	s
CvSURFParams	features2d/features2d.hpp	/^} CvSURFParams;$/;"	t	typeref:struct:CvSURFParams
CvSURFParams::extended	features2d/features2d.hpp	/^    int    extended;$/;"	m	struct:CvSURFParams	access:public
CvSURFParams::hessianThreshold	features2d/features2d.hpp	/^    double hessianThreshold;$/;"	m	struct:CvSURFParams	access:public
CvSURFParams::nOctaveLayers	features2d/features2d.hpp	/^    int    nOctaveLayers;$/;"	m	struct:CvSURFParams	access:public
CvSURFParams::nOctaves	features2d/features2d.hpp	/^    int    nOctaves;$/;"	m	struct:CvSURFParams	access:public
CvSURFParams::upright	features2d/features2d.hpp	/^    int    upright;$/;"	m	struct:CvSURFParams	access:public
CvSURFPoint	features2d/features2d.hpp	/^typedef struct CvSURFPoint$/;"	s
CvSURFPoint	features2d/features2d.hpp	/^} CvSURFPoint;$/;"	t	typeref:struct:CvSURFPoint
CvSURFPoint::dir	features2d/features2d.hpp	/^    float        dir;$/;"	m	struct:CvSURFPoint	access:public
CvSURFPoint::hessian	features2d/features2d.hpp	/^    float        hessian;$/;"	m	struct:CvSURFPoint	access:public
CvSURFPoint::laplacian	features2d/features2d.hpp	/^    int          laplacian;$/;"	m	struct:CvSURFPoint	access:public
CvSURFPoint::pt	features2d/features2d.hpp	/^    CvPoint2D32f pt;$/;"	m	struct:CvSURFPoint	access:public
CvSURFPoint::size	features2d/features2d.hpp	/^    int          size;$/;"	m	struct:CvSURFPoint	access:public
CvSVM	ml/ml.hpp	/^    CV_WRAP CvSVM( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvSVM	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), CvSVMParams params=CvSVMParams() )
CvSVM	ml/ml.hpp	/^    CV_WRAP CvSVM();$/;"	p	class:CvSVM	access:public	signature:()
CvSVM	ml/ml.hpp	/^    CvSVM( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvSVM	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, CvSVMParams params=CvSVMParams() )
CvSVM	ml/ml.hpp	/^class CV_EXPORTS_W CvSVM : public CvStatModel$/;"	c	inherits:CvStatModel
CvSVM::C	ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon74
CvSVM::COEF	ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon74
CvSVM::C_SVC	ml/ml.hpp	/^    enum { C_SVC=100, NU_SVC=101, ONE_CLASS=102, EPS_SVR=103, NU_SVR=104 };$/;"	e	enum:CvSVM::__anon72
CvSVM::CvSVM	ml/ml.hpp	/^    CV_WRAP CvSVM( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvSVM	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), CvSVMParams params=CvSVMParams() )
CvSVM::CvSVM	ml/ml.hpp	/^    CV_WRAP CvSVM();$/;"	p	class:CvSVM	access:public	signature:()
CvSVM::CvSVM	ml/ml.hpp	/^    CvSVM( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvSVM	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, CvSVMParams params=CvSVMParams() )
CvSVM::DEGREE	ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon74
CvSVM::EPS_SVR	ml/ml.hpp	/^    enum { C_SVC=100, NU_SVC=101, ONE_CLASS=102, EPS_SVR=103, NU_SVR=104 };$/;"	e	enum:CvSVM::__anon72
CvSVM::GAMMA	ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon74
CvSVM::LINEAR	ml/ml.hpp	/^    enum { LINEAR=0, POLY=1, RBF=2, SIGMOID=3 };$/;"	e	enum:CvSVM::__anon73
CvSVM::NU	ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon74
CvSVM::NU_SVC	ml/ml.hpp	/^    enum { C_SVC=100, NU_SVC=101, ONE_CLASS=102, EPS_SVR=103, NU_SVR=104 };$/;"	e	enum:CvSVM::__anon72
CvSVM::NU_SVR	ml/ml.hpp	/^    enum { C_SVC=100, NU_SVC=101, ONE_CLASS=102, EPS_SVR=103, NU_SVR=104 };$/;"	e	enum:CvSVM::__anon72
CvSVM::ONE_CLASS	ml/ml.hpp	/^    enum { C_SVC=100, NU_SVC=101, ONE_CLASS=102, EPS_SVR=103, NU_SVR=104 };$/;"	e	enum:CvSVM::__anon72
CvSVM::P	ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon74
CvSVM::POLY	ml/ml.hpp	/^    enum { LINEAR=0, POLY=1, RBF=2, SIGMOID=3 };$/;"	e	enum:CvSVM::__anon73
CvSVM::RBF	ml/ml.hpp	/^    enum { LINEAR=0, POLY=1, RBF=2, SIGMOID=3 };$/;"	e	enum:CvSVM::__anon73
CvSVM::SIGMOID	ml/ml.hpp	/^    enum { LINEAR=0, POLY=1, RBF=2, SIGMOID=3 };$/;"	e	enum:CvSVM::__anon73
CvSVM::class_labels	ml/ml.hpp	/^    CvMat* class_labels;$/;"	m	class:CvSVM	access:protected
CvSVM::class_weights	ml/ml.hpp	/^    CvMat* class_weights;$/;"	m	class:CvSVM	access:protected
CvSVM::clear	ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvSVM	access:public	signature:()
CvSVM::create_kernel	ml/ml.hpp	/^    virtual void create_kernel();$/;"	p	class:CvSVM	access:protected	signature:()
CvSVM::create_solver	ml/ml.hpp	/^    virtual void create_solver();$/;"	p	class:CvSVM	access:protected	signature:()
CvSVM::decision_func	ml/ml.hpp	/^    CvSVMDecisionFunc* decision_func;$/;"	m	class:CvSVM	access:protected
CvSVM::do_train	ml/ml.hpp	/^    virtual bool do_train( int svm_type, int sample_count, int var_count, const float** samples,$/;"	p	class:CvSVM	access:protected	signature:( int svm_type, int sample_count, int var_count, const float** samples, const CvMat* responses, CvMemStorage* _storage, double* alpha )
CvSVM::get_default_grid	ml/ml.hpp	/^    static CvParamGrid get_default_grid( int param_id );$/;"	p	class:CvSVM	access:public	signature:( int param_id )
CvSVM::get_params	ml/ml.hpp	/^    virtual CvSVMParams get_params() const { return params; };$/;"	f	class:CvSVM	access:public	signature:() const
CvSVM::get_support_vector	ml/ml.hpp	/^    virtual const float* get_support_vector(int i) const;$/;"	p	class:CvSVM	access:public	signature:(int i) const
CvSVM::get_support_vector_count	ml/ml.hpp	/^    CV_WRAP virtual int get_support_vector_count() const;$/;"	p	class:CvSVM	access:public	signature:() const
CvSVM::get_var_count	ml/ml.hpp	/^    CV_WRAP int get_var_count() const { return var_idx ? var_idx->cols : var_all; }$/;"	f	class:CvSVM	access:public	signature:() const
CvSVM::kernel	ml/ml.hpp	/^    CvSVMKernel* kernel;$/;"	m	class:CvSVM	access:protected
CvSVM::params	ml/ml.hpp	/^    CvSVMParams params;$/;"	m	class:CvSVM	access:protected
CvSVM::predict	ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& sample, bool returnDFVal=false ) const;$/;"	p	class:CvSVM	access:public	signature:( const cv::Mat& sample, bool returnDFVal=false ) const
CvSVM::predict	ml/ml.hpp	/^    virtual float predict( const CvMat* sample, bool returnDFVal=false ) const;$/;"	p	class:CvSVM	access:public	signature:( const CvMat* sample, bool returnDFVal=false ) const
CvSVM::predict	ml/ml.hpp	/^    virtual float predict( const CvMat* samples, CvMat* results ) const;$/;"	p	class:CvSVM	access:public	signature:( const CvMat* samples, CvMat* results ) const
CvSVM::predict	ml/ml.hpp	/^    virtual float predict( const float* row_sample, int row_len, bool returnDFVal=false ) const;$/;"	p	class:CvSVM	access:protected	signature:( const float* row_sample, int row_len, bool returnDFVal=false ) const
CvSVM::read	ml/ml.hpp	/^    virtual void read( CvFileStorage* storage, CvFileNode* node );$/;"	p	class:CvSVM	access:public	signature:( CvFileStorage* storage, CvFileNode* node )
CvSVM::read_params	ml/ml.hpp	/^    virtual void read_params( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvSVM	access:protected	signature:( CvFileStorage* fs, CvFileNode* node )
CvSVM::set_params	ml/ml.hpp	/^    virtual bool set_params( const CvSVMParams& params );$/;"	p	class:CvSVM	access:protected	signature:( const CvSVMParams& params )
CvSVM::solver	ml/ml.hpp	/^    CvSVMSolver* solver;$/;"	m	class:CvSVM	access:protected
CvSVM::storage	ml/ml.hpp	/^    CvMemStorage* storage;$/;"	m	class:CvSVM	access:protected
CvSVM::sv	ml/ml.hpp	/^    float** sv;$/;"	m	class:CvSVM	access:protected
CvSVM::sv_total	ml/ml.hpp	/^    int sv_total;$/;"	m	class:CvSVM	access:protected
CvSVM::train	ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvSVM	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), CvSVMParams params=CvSVMParams() )
CvSVM::train	ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvSVM	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, CvSVMParams params=CvSVMParams() )
CvSVM::train1	ml/ml.hpp	/^    virtual bool train1( int sample_count, int var_count, const float** samples,$/;"	p	class:CvSVM	access:protected	signature:( int sample_count, int var_count, const float** samples, const void* responses, double Cp, double Cn, CvMemStorage* _storage, double* alpha, double& rho )
CvSVM::train_auto	ml/ml.hpp	/^    CV_WRAP virtual bool train_auto( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvSVM	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& varIdx, const cv::Mat& sampleIdx, CvSVMParams params, int k_fold = 10, CvParamGrid Cgrid = CvSVM::get_default_grid(CvSVM::C), CvParamGrid gammaGrid = CvSVM::get_default_grid(CvSVM::GAMMA), CvParamGrid pGrid = CvSVM::get_default_grid(CvSVM::P), CvParamGrid nuGrid = CvSVM::get_default_grid(CvSVM::NU), CvParamGrid coeffGrid = CvSVM::get_default_grid(CvSVM::COEF), CvParamGrid degreeGrid = CvSVM::get_default_grid(CvSVM::DEGREE), bool balanced=false)
CvSVM::train_auto	ml/ml.hpp	/^    virtual bool train_auto( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvSVM	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* varIdx, const CvMat* sampleIdx, CvSVMParams params, int kfold = 10, CvParamGrid Cgrid = get_default_grid(CvSVM::C), CvParamGrid gammaGrid = get_default_grid(CvSVM::GAMMA), CvParamGrid pGrid = get_default_grid(CvSVM::P), CvParamGrid nuGrid = get_default_grid(CvSVM::NU), CvParamGrid coeffGrid = get_default_grid(CvSVM::COEF), CvParamGrid degreeGrid = get_default_grid(CvSVM::DEGREE), bool balanced=false )
CvSVM::var_all	ml/ml.hpp	/^    int var_all;$/;"	m	class:CvSVM	access:protected
CvSVM::var_idx	ml/ml.hpp	/^    CvMat* var_idx;$/;"	m	class:CvSVM	access:protected
CvSVM::write	ml/ml.hpp	/^    virtual void write( CvFileStorage* storage, const char* name ) const;$/;"	p	class:CvSVM	access:public	signature:( CvFileStorage* storage, const char* name ) const
CvSVM::write_params	ml/ml.hpp	/^    virtual void write_params( CvFileStorage* fs ) const;$/;"	p	class:CvSVM	access:protected	signature:( CvFileStorage* fs ) const
CvSVM::~CvSVM	ml/ml.hpp	/^    virtual ~CvSVM();$/;"	p	class:CvSVM	access:public	signature:()
CvSVMDecisionFunc	ml/ml.hpp	/^struct CvSVMDecisionFunc$/;"	s
CvSVMDecisionFunc::alpha	ml/ml.hpp	/^    double* alpha;$/;"	m	struct:CvSVMDecisionFunc	access:public
CvSVMDecisionFunc::rho	ml/ml.hpp	/^    double rho;$/;"	m	struct:CvSVMDecisionFunc	access:public
CvSVMDecisionFunc::sv_count	ml/ml.hpp	/^    int sv_count;$/;"	m	struct:CvSVMDecisionFunc	access:public
CvSVMDecisionFunc::sv_index	ml/ml.hpp	/^    int* sv_index;$/;"	m	struct:CvSVMDecisionFunc	access:public
CvSVMKernel	ml/ml.hpp	/^    CvSVMKernel( const CvSVMParams* params, Calc _calc_func );$/;"	p	struct:CvSVMKernel	access:public	signature:( const CvSVMParams* params, Calc _calc_func )
CvSVMKernel	ml/ml.hpp	/^    CvSVMKernel();$/;"	p	struct:CvSVMKernel	access:public	signature:()
CvSVMKernel	ml/ml.hpp	/^struct CV_EXPORTS CvSVMKernel$/;"	s
CvSVMKernel::Calc	ml/ml.hpp	/^    typedef void (CvSVMKernel::*Calc)( int vec_count, int vec_size, const float** vecs,$/;"	t	struct:CvSVMKernel	access:public
CvSVMKernel::CvSVMKernel	ml/ml.hpp	/^    CvSVMKernel( const CvSVMParams* params, Calc _calc_func );$/;"	p	struct:CvSVMKernel	access:public	signature:( const CvSVMParams* params, Calc _calc_func )
CvSVMKernel::CvSVMKernel	ml/ml.hpp	/^    CvSVMKernel();$/;"	p	struct:CvSVMKernel	access:public	signature:()
CvSVMKernel::calc	ml/ml.hpp	/^    virtual void calc( int vcount, int n, const float** vecs, const float* another, float* results );$/;"	p	struct:CvSVMKernel	access:public	signature:( int vcount, int n, const float** vecs, const float* another, float* results )
CvSVMKernel::calc_func	ml/ml.hpp	/^    Calc calc_func;$/;"	m	struct:CvSVMKernel	access:public
CvSVMKernel::calc_linear	ml/ml.hpp	/^    virtual void calc_linear( int vec_count, int vec_size, const float** vecs,$/;"	p	struct:CvSVMKernel	access:public	signature:( int vec_count, int vec_size, const float** vecs, const float* another, float* results )
CvSVMKernel::calc_non_rbf_base	ml/ml.hpp	/^    virtual void calc_non_rbf_base( int vec_count, int vec_size, const float** vecs,$/;"	p	struct:CvSVMKernel	access:public	signature:( int vec_count, int vec_size, const float** vecs, const float* another, float* results, double alpha, double beta )
CvSVMKernel::calc_poly	ml/ml.hpp	/^    virtual void calc_poly( int vec_count, int vec_size, const float** vecs,$/;"	p	struct:CvSVMKernel	access:public	signature:( int vec_count, int vec_size, const float** vecs, const float* another, float* results )
CvSVMKernel::calc_rbf	ml/ml.hpp	/^    virtual void calc_rbf( int vec_count, int vec_size, const float** vecs,$/;"	p	struct:CvSVMKernel	access:public	signature:( int vec_count, int vec_size, const float** vecs, const float* another, float* results )
CvSVMKernel::calc_sigmoid	ml/ml.hpp	/^    virtual void calc_sigmoid( int vec_count, int vec_size, const float** vecs,$/;"	p	struct:CvSVMKernel	access:public	signature:( int vec_count, int vec_size, const float** vecs, const float* another, float* results )
CvSVMKernel::clear	ml/ml.hpp	/^    virtual void clear();$/;"	p	struct:CvSVMKernel	access:public	signature:()
CvSVMKernel::create	ml/ml.hpp	/^    virtual bool create( const CvSVMParams* params, Calc _calc_func );$/;"	p	struct:CvSVMKernel	access:public	signature:( const CvSVMParams* params, Calc _calc_func )
CvSVMKernel::params	ml/ml.hpp	/^    const CvSVMParams* params;$/;"	m	struct:CvSVMKernel	access:public
CvSVMKernel::~CvSVMKernel	ml/ml.hpp	/^    virtual ~CvSVMKernel();$/;"	p	struct:CvSVMKernel	access:public	signature:()
CvSVMKernelRow	ml/ml.hpp	/^struct CvSVMKernelRow$/;"	s
CvSVMKernelRow::data	ml/ml.hpp	/^    float* data;$/;"	m	struct:CvSVMKernelRow	access:public
CvSVMKernelRow::next	ml/ml.hpp	/^    CvSVMKernelRow* next;$/;"	m	struct:CvSVMKernelRow	access:public
CvSVMKernelRow::prev	ml/ml.hpp	/^    CvSVMKernelRow* prev;$/;"	m	struct:CvSVMKernelRow	access:public
CvSVMParams	ml/ml.hpp	/^    CvSVMParams( int _svm_type, int _kernel_type,$/;"	p	struct:CvSVMParams	access:public	signature:( int _svm_type, int _kernel_type, double _degree, double _gamma, double _coef0, double Cvalue, double _nu, double _p, CvMat* _class_weights, CvTermCriteria _term_crit )
CvSVMParams	ml/ml.hpp	/^    CvSVMParams();$/;"	p	struct:CvSVMParams	access:public	signature:()
CvSVMParams	ml/ml.hpp	/^struct CV_EXPORTS_W_MAP CvSVMParams$/;"	s
CvSVMParams::C	ml/ml.hpp	/^    CV_PROP_RW double      C;  \/\/ for CV_SVM_C_SVC, CV_SVM_EPS_SVR and CV_SVM_NU_SVR$/;"	m	struct:CvSVMParams	access:public
CvSVMParams::CvSVMParams	ml/ml.hpp	/^    CvSVMParams( int _svm_type, int _kernel_type,$/;"	p	struct:CvSVMParams	access:public	signature:( int _svm_type, int _kernel_type, double _degree, double _gamma, double _coef0, double Cvalue, double _nu, double _p, CvMat* _class_weights, CvTermCriteria _term_crit )
CvSVMParams::CvSVMParams	ml/ml.hpp	/^    CvSVMParams();$/;"	p	struct:CvSVMParams	access:public	signature:()
CvSVMParams::class_weights	ml/ml.hpp	/^    CvMat*      class_weights; \/\/ for CV_SVM_C_SVC$/;"	m	struct:CvSVMParams	access:public
CvSVMParams::coef0	ml/ml.hpp	/^    CV_PROP_RW double      coef0;  \/\/ for poly\/sigmoid$/;"	m	struct:CvSVMParams	access:public
CvSVMParams::degree	ml/ml.hpp	/^    CV_PROP_RW double      degree; \/\/ for poly$/;"	m	struct:CvSVMParams	access:public
CvSVMParams::gamma	ml/ml.hpp	/^    CV_PROP_RW double      gamma;  \/\/ for poly\/rbf\/sigmoid$/;"	m	struct:CvSVMParams	access:public
CvSVMParams::kernel_type	ml/ml.hpp	/^    CV_PROP_RW int         kernel_type;$/;"	m	struct:CvSVMParams	access:public
CvSVMParams::nu	ml/ml.hpp	/^    CV_PROP_RW double      nu; \/\/ for CV_SVM_NU_SVC, CV_SVM_ONE_CLASS, and CV_SVM_NU_SVR$/;"	m	struct:CvSVMParams	access:public
CvSVMParams::p	ml/ml.hpp	/^    CV_PROP_RW double      p; \/\/ for CV_SVM_EPS_SVR$/;"	m	struct:CvSVMParams	access:public
CvSVMParams::svm_type	ml/ml.hpp	/^    CV_PROP_RW int         svm_type;$/;"	m	struct:CvSVMParams	access:public
CvSVMParams::term_crit	ml/ml.hpp	/^    CV_PROP_RW CvTermCriteria term_crit; \/\/ termination criteria$/;"	m	struct:CvSVMParams	access:public
CvSVMSolutionInfo	ml/ml.hpp	/^struct CvSVMSolutionInfo$/;"	s
CvSVMSolutionInfo::obj	ml/ml.hpp	/^    double obj;$/;"	m	struct:CvSVMSolutionInfo	access:public
CvSVMSolutionInfo::r	ml/ml.hpp	/^    double r;   \/\/ for Solver_NU$/;"	m	struct:CvSVMSolutionInfo	access:public
CvSVMSolutionInfo::rho	ml/ml.hpp	/^    double rho;$/;"	m	struct:CvSVMSolutionInfo	access:public
CvSVMSolutionInfo::upper_bound_n	ml/ml.hpp	/^    double upper_bound_n;$/;"	m	struct:CvSVMSolutionInfo	access:public
CvSVMSolutionInfo::upper_bound_p	ml/ml.hpp	/^    double upper_bound_p;$/;"	m	struct:CvSVMSolutionInfo	access:public
CvSVMSolver	ml/ml.hpp	/^    CvSVMSolver( int count, int var_count, const float** samples, schar* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, schar* y, int alpha_count, double* alpha, double Cp, double Cn, CvMemStorage* storage, CvSVMKernel* kernel, GetRow get_row, SelectWorkingSet select_working_set, CalcRho calc_rho )
CvSVMSolver	ml/ml.hpp	/^    CvSVMSolver();$/;"	p	class:CvSVMSolver	access:public	signature:()
CvSVMSolver	ml/ml.hpp	/^class CV_EXPORTS CvSVMSolver$/;"	c
CvSVMSolver::C	ml/ml.hpp	/^    double C[2];  \/\/ C[0] == Cn, C[1] == Cp$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::CalcRho	ml/ml.hpp	/^    typedef void (CvSVMSolver::*CalcRho)( double& rho, double& r );$/;"	t	class:CvSVMSolver	access:public
CvSVMSolver::CvSVMSolver	ml/ml.hpp	/^    CvSVMSolver( int count, int var_count, const float** samples, schar* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, schar* y, int alpha_count, double* alpha, double Cp, double Cn, CvMemStorage* storage, CvSVMKernel* kernel, GetRow get_row, SelectWorkingSet select_working_set, CalcRho calc_rho )
CvSVMSolver::CvSVMSolver	ml/ml.hpp	/^    CvSVMSolver();$/;"	p	class:CvSVMSolver	access:public	signature:()
CvSVMSolver::G	ml/ml.hpp	/^    double* G;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::GetRow	ml/ml.hpp	/^    typedef float* (CvSVMSolver::*GetRow)( int i, float* row, float* dst, bool existed );$/;"	t	class:CvSVMSolver	access:public
CvSVMSolver::SelectWorkingSet	ml/ml.hpp	/^    typedef bool (CvSVMSolver::*SelectWorkingSet)( int& i, int& j );$/;"	t	class:CvSVMSolver	access:public
CvSVMSolver::alpha	ml/ml.hpp	/^    double* alpha;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::alpha_count	ml/ml.hpp	/^    int alpha_count;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::alpha_status	ml/ml.hpp	/^    schar* alpha_status;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::b	ml/ml.hpp	/^    double* b;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::buf	ml/ml.hpp	/^    float* buf[2];$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::cache_line_size	ml/ml.hpp	/^    int cache_line_size;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::cache_size	ml/ml.hpp	/^    int cache_size;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::calc_rho	ml/ml.hpp	/^    virtual void calc_rho( double& rho, double& r );$/;"	p	class:CvSVMSolver	access:public	signature:( double& rho, double& r )
CvSVMSolver::calc_rho_func	ml/ml.hpp	/^    CalcRho calc_rho_func;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::calc_rho_nu_svm	ml/ml.hpp	/^    virtual void calc_rho_nu_svm( double& rho, double& r );$/;"	p	class:CvSVMSolver	access:public	signature:( double& rho, double& r )
CvSVMSolver::clear	ml/ml.hpp	/^    virtual void clear();$/;"	p	class:CvSVMSolver	access:public	signature:()
CvSVMSolver::create	ml/ml.hpp	/^    virtual bool create( int count, int var_count, const float** samples, schar* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, schar* y, int alpha_count, double* alpha, double Cp, double Cn, CvMemStorage* storage, CvSVMKernel* kernel, GetRow get_row, SelectWorkingSet select_working_set, CalcRho calc_rho )
CvSVMSolver::eps	ml/ml.hpp	/^    double eps;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::get_row	ml/ml.hpp	/^    virtual float* get_row( int i, float* dst );$/;"	p	class:CvSVMSolver	access:public	signature:( int i, float* dst )
CvSVMSolver::get_row_base	ml/ml.hpp	/^    virtual float* get_row_base( int i, bool* _existed );$/;"	p	class:CvSVMSolver	access:public	signature:( int i, bool* _existed )
CvSVMSolver::get_row_func	ml/ml.hpp	/^    GetRow get_row_func;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::get_row_one_class	ml/ml.hpp	/^    virtual float* get_row_one_class( int i, float* row, float* dst, bool existed );$/;"	p	class:CvSVMSolver	access:public	signature:( int i, float* row, float* dst, bool existed )
CvSVMSolver::get_row_svc	ml/ml.hpp	/^    virtual float* get_row_svc( int i, float* row, float* dst, bool existed );$/;"	p	class:CvSVMSolver	access:public	signature:( int i, float* row, float* dst, bool existed )
CvSVMSolver::get_row_svr	ml/ml.hpp	/^    virtual float* get_row_svr( int i, float* row, float* dst, bool existed );$/;"	p	class:CvSVMSolver	access:public	signature:( int i, float* row, float* dst, bool existed )
CvSVMSolver::kernel	ml/ml.hpp	/^    CvSVMKernel* kernel;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::lru_list	ml/ml.hpp	/^    CvSVMKernelRow lru_list;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::max_iter	ml/ml.hpp	/^    int max_iter;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::params	ml/ml.hpp	/^    const CvSVMParams* params;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::rows	ml/ml.hpp	/^    CvSVMKernelRow* rows;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::sample_count	ml/ml.hpp	/^    int sample_count;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::samples	ml/ml.hpp	/^    const float** samples;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::select_working_set	ml/ml.hpp	/^    virtual bool select_working_set( int& i, int& j );$/;"	p	class:CvSVMSolver	access:public	signature:( int& i, int& j )
CvSVMSolver::select_working_set_func	ml/ml.hpp	/^    SelectWorkingSet select_working_set_func;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::select_working_set_nu_svm	ml/ml.hpp	/^    virtual bool select_working_set_nu_svm( int& i, int& j );$/;"	p	class:CvSVMSolver	access:public	signature:( int& i, int& j )
CvSVMSolver::solve_c_svc	ml/ml.hpp	/^    virtual bool solve_c_svc( int count, int var_count, const float** samples, schar* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, schar* y, double Cp, double Cn, CvMemStorage* storage, CvSVMKernel* kernel, double* alpha, CvSVMSolutionInfo& si )
CvSVMSolver::solve_eps_svr	ml/ml.hpp	/^    virtual bool solve_eps_svr( int count, int var_count, const float** samples, const float* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, const float* y, CvMemStorage* storage, CvSVMKernel* kernel, double* alpha, CvSVMSolutionInfo& si )
CvSVMSolver::solve_generic	ml/ml.hpp	/^    virtual bool solve_generic( CvSVMSolutionInfo& si );$/;"	p	class:CvSVMSolver	access:public	signature:( CvSVMSolutionInfo& si )
CvSVMSolver::solve_nu_svc	ml/ml.hpp	/^    virtual bool solve_nu_svc( int count, int var_count, const float** samples, schar* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, schar* y, CvMemStorage* storage, CvSVMKernel* kernel, double* alpha, CvSVMSolutionInfo& si )
CvSVMSolver::solve_nu_svr	ml/ml.hpp	/^    virtual bool solve_nu_svr( int count, int var_count, const float** samples, const float* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, const float* y, CvMemStorage* storage, CvSVMKernel* kernel, double* alpha, CvSVMSolutionInfo& si )
CvSVMSolver::solve_one_class	ml/ml.hpp	/^    virtual bool solve_one_class( int count, int var_count, const float** samples,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, CvMemStorage* storage, CvSVMKernel* kernel, double* alpha, CvSVMSolutionInfo& si )
CvSVMSolver::storage	ml/ml.hpp	/^    CvMemStorage* storage;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::var_count	ml/ml.hpp	/^    int var_count;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::y	ml/ml.hpp	/^    schar* y;$/;"	m	class:CvSVMSolver	access:public
CvSVMSolver::~CvSVMSolver	ml/ml.hpp	/^    virtual ~CvSVMSolver();$/;"	p	class:CvSVMSolver	access:public	signature:()
CvScalar	core/types_c.h	/^CvScalar;$/;"	t	typeref:struct:CvScalar
CvScalar	core/types_c.h	/^typedef struct CvScalar$/;"	s
CvScalar::val	core/types_c.h	/^    double val[4];$/;"	m	struct:CvScalar	access:public
CvSeq	core/types_c.h	/^CvSeq;$/;"	t	typeref:struct:CvSeq
CvSeq	core/types_c.h	/^typedef struct CvSeq$/;"	s
CvSeqBlock	core/types_c.h	/^CvSeqBlock;$/;"	t	typeref:struct:CvSeqBlock
CvSeqBlock	core/types_c.h	/^typedef struct CvSeqBlock$/;"	s
CvSeqBlock::count	core/types_c.h	/^    int    count;             \/* Number of elements in the block.           *\/$/;"	m	struct:CvSeqBlock	access:public
CvSeqBlock::data	core/types_c.h	/^    schar* data;              \/* Pointer to the first element of the block. *\/$/;"	m	struct:CvSeqBlock	access:public
CvSeqBlock::next	core/types_c.h	/^    struct CvSeqBlock*  next; \/* Next sequence block.                       *\/$/;"	m	struct:CvSeqBlock	typeref:struct:CvSeqBlock::CvSeqBlock	access:public
CvSeqBlock::prev	core/types_c.h	/^    struct CvSeqBlock*  prev; \/* Previous sequence block.                   *\/$/;"	m	struct:CvSeqBlock	typeref:struct:CvSeqBlock::CvSeqBlock	access:public
CvSeqBlock::start_index	core/types_c.h	/^  int    start_index;         \/* Index of the first element in the block +  *\/$/;"	m	struct:CvSeqBlock	access:public
CvSeqReader	core/types_c.h	/^CvSeqReader;$/;"	t	typeref:struct:CvSeqReader
CvSeqReader	core/types_c.h	/^typedef struct CvSeqReader$/;"	s
CvSeqWriter	core/types_c.h	/^CvSeqWriter;$/;"	t	typeref:struct:CvSeqWriter
CvSeqWriter	core/types_c.h	/^typedef struct CvSeqWriter$/;"	s
CvSet	core/types_c.h	/^CvSet;$/;"	t	typeref:struct:CvSet
CvSet	core/types_c.h	/^typedef struct CvSet$/;"	s
CvSetElem	core/types_c.h	/^CvSetElem;$/;"	t	typeref:struct:CvSetElem
CvSetElem	core/types_c.h	/^typedef struct CvSetElem$/;"	s
CvSize	core/types_c.h	/^CvSize;$/;"	t	typeref:struct:__anon156
CvSize2D32f	core/types_c.h	/^CvSize2D32f;$/;"	t	typeref:struct:CvSize2D32f
CvSize2D32f	core/types_c.h	/^typedef struct CvSize2D32f$/;"	s
CvSize2D32f::height	core/types_c.h	/^    float height;$/;"	m	struct:CvSize2D32f	access:public
CvSize2D32f::width	core/types_c.h	/^    float width;$/;"	m	struct:CvSize2D32f	access:public
CvSlice	core/types_c.h	/^CvSlice;$/;"	t	typeref:struct:CvSlice
CvSlice	core/types_c.h	/^typedef struct CvSlice$/;"	s
CvSlice::end_index	core/types_c.h	/^    int  start_index, end_index;$/;"	m	struct:CvSlice	access:public
CvSlice::start_index	core/types_c.h	/^    int  start_index, end_index;$/;"	m	struct:CvSlice	access:public
CvSparseMat	core/types_c.h	/^CvSparseMat;$/;"	t	typeref:struct:CvSparseMat
CvSparseMat	core/types_c.h	/^typedef struct CvSparseMat$/;"	s
CvSparseMat::dims	core/types_c.h	/^    int dims;$/;"	m	struct:CvSparseMat	access:public
CvSparseMat::hashsize	core/types_c.h	/^    int hashsize;$/;"	m	struct:CvSparseMat	access:public
CvSparseMat::hashtable	core/types_c.h	/^    void** hashtable;$/;"	m	struct:CvSparseMat	access:public
CvSparseMat::hdr_refcount	core/types_c.h	/^    int hdr_refcount;$/;"	m	struct:CvSparseMat	access:public
CvSparseMat::heap	core/types_c.h	/^    struct CvSet* heap;$/;"	m	struct:CvSparseMat	typeref:struct:CvSparseMat::CvSet	access:public
CvSparseMat::idxoffset	core/types_c.h	/^    int idxoffset;$/;"	m	struct:CvSparseMat	access:public
CvSparseMat::refcount	core/types_c.h	/^    int* refcount;$/;"	m	struct:CvSparseMat	access:public
CvSparseMat::size	core/types_c.h	/^    int size[CV_MAX_DIM];$/;"	m	struct:CvSparseMat	access:public
CvSparseMat::type	core/types_c.h	/^    int type;$/;"	m	struct:CvSparseMat	access:public
CvSparseMat::valoffset	core/types_c.h	/^    int valoffset;$/;"	m	struct:CvSparseMat	access:public
CvSparseMatIterator	core/types_c.h	/^CvSparseMatIterator;$/;"	t	typeref:struct:CvSparseMatIterator
CvSparseMatIterator	core/types_c.h	/^typedef struct CvSparseMatIterator$/;"	s
CvSparseMatIterator::curidx	core/types_c.h	/^    int curidx;$/;"	m	struct:CvSparseMatIterator	access:public
CvSparseMatIterator::mat	core/types_c.h	/^    CvSparseMat* mat;$/;"	m	struct:CvSparseMatIterator	access:public
CvSparseMatIterator::node	core/types_c.h	/^    CvSparseNode* node;$/;"	m	struct:CvSparseMatIterator	access:public
CvSparseNode	core/types_c.h	/^CvSparseNode;$/;"	t	typeref:struct:CvSparseNode
CvSparseNode	core/types_c.h	/^typedef struct CvSparseNode$/;"	s
CvSparseNode::hashval	core/types_c.h	/^    unsigned hashval;$/;"	m	struct:CvSparseNode	access:public
CvSparseNode::next	core/types_c.h	/^    struct CvSparseNode* next;$/;"	m	struct:CvSparseNode	typeref:struct:CvSparseNode::CvSparseNode	access:public
CvStarDetectorParams	features2d/features2d.hpp	/^typedef struct CvStarDetectorParams$/;"	s
CvStarDetectorParams	features2d/features2d.hpp	/^} CvStarDetectorParams;$/;"	t	typeref:struct:CvStarDetectorParams
CvStarDetectorParams::lineThresholdBinarized	features2d/features2d.hpp	/^    int lineThresholdBinarized;$/;"	m	struct:CvStarDetectorParams	access:public
CvStarDetectorParams::lineThresholdProjected	features2d/features2d.hpp	/^    int lineThresholdProjected;$/;"	m	struct:CvStarDetectorParams	access:public
CvStarDetectorParams::maxSize	features2d/features2d.hpp	/^    int maxSize;$/;"	m	struct:CvStarDetectorParams	access:public
CvStarDetectorParams::responseThreshold	features2d/features2d.hpp	/^    int responseThreshold;$/;"	m	struct:CvStarDetectorParams	access:public
CvStarDetectorParams::suppressNonmaxSize	features2d/features2d.hpp	/^    int suppressNonmaxSize;$/;"	m	struct:CvStarDetectorParams	access:public
CvStarKeypoint	features2d/features2d.hpp	/^typedef struct CvStarKeypoint$/;"	s
CvStarKeypoint	features2d/features2d.hpp	/^} CvStarKeypoint;$/;"	t	typeref:struct:CvStarKeypoint
CvStarKeypoint::pt	features2d/features2d.hpp	/^    CvPoint pt;$/;"	m	struct:CvStarKeypoint	access:public
CvStarKeypoint::response	features2d/features2d.hpp	/^    float response;$/;"	m	struct:CvStarKeypoint	access:public
CvStarKeypoint::size	features2d/features2d.hpp	/^    int size;$/;"	m	struct:CvStarKeypoint	access:public
CvStatModel	ml/ml.hpp	/^    CvStatModel();$/;"	p	class:CvStatModel	access:public	signature:()
CvStatModel	ml/ml.hpp	/^class CV_EXPORTS_W CvStatModel$/;"	c
CvStatModel::CvStatModel	ml/ml.hpp	/^    CvStatModel();$/;"	p	class:CvStatModel	access:public	signature:()
CvStatModel::clear	ml/ml.hpp	/^    virtual void clear();$/;"	p	class:CvStatModel	access:public	signature:()
CvStatModel::default_model_name	ml/ml.hpp	/^    const char* default_model_name;$/;"	m	class:CvStatModel	access:protected
CvStatModel::load	ml/ml.hpp	/^    CV_WRAP virtual void load( const char* filename, const char* name=0 );$/;"	p	class:CvStatModel	access:public	signature:( const char* filename, const char* name=0 )
CvStatModel::read	ml/ml.hpp	/^    virtual void read( CvFileStorage* storage, CvFileNode* node );$/;"	p	class:CvStatModel	access:public	signature:( CvFileStorage* storage, CvFileNode* node )
CvStatModel::save	ml/ml.hpp	/^    CV_WRAP virtual void save( const char* filename, const char* name=0 ) const;$/;"	p	class:CvStatModel	access:public	signature:( const char* filename, const char* name=0 ) const
CvStatModel::write	ml/ml.hpp	/^    virtual void write( CvFileStorage* storage, const char* name ) const;$/;"	p	class:CvStatModel	access:public	signature:( CvFileStorage* storage, const char* name ) const
CvStatModel::~CvStatModel	ml/ml.hpp	/^    virtual ~CvStatModel();$/;"	p	class:CvStatModel	access:public	signature:()
CvStatus	core/internal.hpp	/^CvStatus;$/;"	t	typeref:enum:CvStatus
CvStatus	core/internal.hpp	/^typedef enum CvStatus$/;"	g
CvStereoBMState	calib3d/calib3d.hpp	/^typedef struct CvStereoBMState$/;"	s
CvStereoBMState	calib3d/calib3d.hpp	/^} CvStereoBMState;$/;"	t	typeref:struct:CvStereoBMState
CvStereoBMState::SADWindowSize	calib3d/calib3d.hpp	/^    int SADWindowSize; \/\/ ~5x5..21x21$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::cost	calib3d/calib3d.hpp	/^    CvMat* cost;$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::disp	calib3d/calib3d.hpp	/^    CvMat* disp;$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::disp12MaxDiff	calib3d/calib3d.hpp	/^    int disp12MaxDiff;$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::minDisparity	calib3d/calib3d.hpp	/^    int minDisparity;  \/\/ minimum disparity (can be negative)$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::numberOfDisparities	calib3d/calib3d.hpp	/^    int numberOfDisparities; \/\/ maximum disparity - minimum disparity (> 0)$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::preFilterCap	calib3d/calib3d.hpp	/^    int preFilterCap; \/\/ the output of pre-filtering is clipped by [-preFilterCap,preFilterCap]$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::preFilterSize	calib3d/calib3d.hpp	/^    int preFilterSize; \/\/ averaging window size: ~5x5..21x21$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::preFilterType	calib3d/calib3d.hpp	/^    int preFilterType; \/\/ =CV_STEREO_BM_NORMALIZED_RESPONSE now$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::preFilteredImg0	calib3d/calib3d.hpp	/^    CvMat* preFilteredImg0;$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::preFilteredImg1	calib3d/calib3d.hpp	/^    CvMat* preFilteredImg1;$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::roi1	calib3d/calib3d.hpp	/^    CvRect roi1, roi2;$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::roi2	calib3d/calib3d.hpp	/^    CvRect roi1, roi2;$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::slidingSumBuf	calib3d/calib3d.hpp	/^    CvMat* slidingSumBuf;$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::speckleRange	calib3d/calib3d.hpp	/^    int speckleRange; \/\/ acceptable range of variation in window$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::speckleWindowSize	calib3d/calib3d.hpp	/^    int speckleWindowSize; \/\/ disparity variation window$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::textureThreshold	calib3d/calib3d.hpp	/^    int textureThreshold;  \/\/ the disparity is only computed for pixels$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::trySmallerWindows	calib3d/calib3d.hpp	/^    int trySmallerWindows; \/\/ if 1, the results may be more accurate,$/;"	m	struct:CvStereoBMState	access:public
CvStereoBMState::uniquenessRatio	calib3d/calib3d.hpp	/^    int uniquenessRatio;   \/\/ accept the computed disparity d* only if$/;"	m	struct:CvStereoBMState	access:public
CvStereoCamera	legacy/legacy.hpp	/^typedef struct CvStereoCamera$/;"	s
CvStereoCamera	legacy/legacy.hpp	/^} CvStereoCamera;$/;"	t	typeref:struct:CvStereoCamera
CvStereoCamera::border	legacy/legacy.hpp	/^    CvPoint2D32f border[2][4];$/;"	m	struct:CvStereoCamera	access:public
CvStereoCamera::camera	legacy/legacy.hpp	/^    CvCamera* camera[2]; \/* two individual camera parameters *\/$/;"	m	struct:CvStereoCamera	access:public
CvStereoCamera::coeffs	legacy/legacy.hpp	/^    double coeffs[2][3][3];\/* coefficients for transformation *\/$/;"	m	struct:CvStereoCamera	access:public
CvStereoCamera::epipole	legacy/legacy.hpp	/^    CvPoint3D32f epipole[2];$/;"	m	struct:CvStereoCamera	access:public
CvStereoCamera::fundMatr	legacy/legacy.hpp	/^    float fundMatr[9]; \/* fundamental matrix *\/$/;"	m	struct:CvStereoCamera	access:public
CvStereoCamera::lineCoeffs	legacy/legacy.hpp	/^    CvStereoLineCoeff* lineCoeffs;$/;"	m	struct:CvStereoCamera	access:public
CvStereoCamera::needSwapCameras	legacy/legacy.hpp	/^    int needSwapCameras;\/* flag set to 1 if need to swap cameras for good reconstruction *\/$/;"	m	struct:CvStereoCamera	access:public
CvStereoCamera::quad	legacy/legacy.hpp	/^    CvPoint2D32f quad[2][4]; \/* coordinates of destination quadrangle after$/;"	m	struct:CvStereoCamera	access:public
CvStereoCamera::rotMatrix	legacy/legacy.hpp	/^    float rotMatrix[9];$/;"	m	struct:CvStereoCamera	access:public
CvStereoCamera::transVector	legacy/legacy.hpp	/^    float transVector[3];$/;"	m	struct:CvStereoCamera	access:public
CvStereoCamera::warpSize	legacy/legacy.hpp	/^    CvSize warpSize;$/;"	m	struct:CvStereoCamera	access:public
CvStereoGCState	calib3d/calib3d.hpp	/^typedef struct CvStereoGCState$/;"	s
CvStereoGCState	calib3d/calib3d.hpp	/^} CvStereoGCState;$/;"	t	typeref:struct:CvStereoGCState
CvStereoGCState::Ithreshold	calib3d/calib3d.hpp	/^    int Ithreshold;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::K	calib3d/calib3d.hpp	/^    float K, lambda, lambda1, lambda2;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::dispLeft	calib3d/calib3d.hpp	/^    CvMat* dispLeft;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::dispRight	calib3d/calib3d.hpp	/^    CvMat* dispRight;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::edgeBuf	calib3d/calib3d.hpp	/^    CvMat* edgeBuf;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::interactionRadius	calib3d/calib3d.hpp	/^    int interactionRadius;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::lambda	calib3d/calib3d.hpp	/^    float K, lambda, lambda1, lambda2;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::lambda1	calib3d/calib3d.hpp	/^    float K, lambda, lambda1, lambda2;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::lambda2	calib3d/calib3d.hpp	/^    float K, lambda, lambda1, lambda2;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::left	calib3d/calib3d.hpp	/^    CvMat* left;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::maxIters	calib3d/calib3d.hpp	/^    int maxIters;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::minDisparity	calib3d/calib3d.hpp	/^    int minDisparity;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::numberOfDisparities	calib3d/calib3d.hpp	/^    int numberOfDisparities;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::occlusionCost	calib3d/calib3d.hpp	/^    int occlusionCost;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::ptrLeft	calib3d/calib3d.hpp	/^    CvMat* ptrLeft;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::ptrRight	calib3d/calib3d.hpp	/^    CvMat* ptrRight;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::right	calib3d/calib3d.hpp	/^    CvMat* right;$/;"	m	struct:CvStereoGCState	access:public
CvStereoGCState::vtxBuf	calib3d/calib3d.hpp	/^    CvMat* vtxBuf;$/;"	m	struct:CvStereoGCState	access:public
CvStereoLineCoeff	legacy/legacy.hpp	/^typedef struct CvStereoLineCoeff$/;"	s
CvStereoLineCoeff	legacy/legacy.hpp	/^}CvStereoLineCoeff;$/;"	t	typeref:struct:CvStereoLineCoeff
CvStereoLineCoeff::Xcoef	legacy/legacy.hpp	/^    double Xcoef;$/;"	m	struct:CvStereoLineCoeff	access:public
CvStereoLineCoeff::XcoefA	legacy/legacy.hpp	/^    double XcoefA;$/;"	m	struct:CvStereoLineCoeff	access:public
CvStereoLineCoeff::XcoefAB	legacy/legacy.hpp	/^    double XcoefAB;$/;"	m	struct:CvStereoLineCoeff	access:public
CvStereoLineCoeff::XcoefB	legacy/legacy.hpp	/^    double XcoefB;$/;"	m	struct:CvStereoLineCoeff	access:public
CvStereoLineCoeff::Ycoef	legacy/legacy.hpp	/^    double Ycoef;$/;"	m	struct:CvStereoLineCoeff	access:public
CvStereoLineCoeff::YcoefA	legacy/legacy.hpp	/^    double YcoefA;$/;"	m	struct:CvStereoLineCoeff	access:public
CvStereoLineCoeff::YcoefAB	legacy/legacy.hpp	/^    double YcoefAB;$/;"	m	struct:CvStereoLineCoeff	access:public
CvStereoLineCoeff::YcoefB	legacy/legacy.hpp	/^    double YcoefB;$/;"	m	struct:CvStereoLineCoeff	access:public
CvStereoLineCoeff::Zcoef	legacy/legacy.hpp	/^    double Zcoef;$/;"	m	struct:CvStereoLineCoeff	access:public
CvStereoLineCoeff::ZcoefA	legacy/legacy.hpp	/^    double ZcoefA;$/;"	m	struct:CvStereoLineCoeff	access:public
CvStereoLineCoeff::ZcoefAB	legacy/legacy.hpp	/^    double ZcoefAB;$/;"	m	struct:CvStereoLineCoeff	access:public
CvStereoLineCoeff::ZcoefB	legacy/legacy.hpp	/^    double ZcoefB;$/;"	m	struct:CvStereoLineCoeff	access:public
CvString	core/types_c.h	/^CvString;$/;"	t	typeref:struct:CvString
CvString	core/types_c.h	/^typedef struct CvString$/;"	s
CvString::len	core/types_c.h	/^    int len;$/;"	m	struct:CvString	access:public
CvString::ptr	core/types_c.h	/^    char* ptr;$/;"	m	struct:CvString	access:public
CvStringHashNode	core/types_c.h	/^CvStringHashNode;$/;"	t	typeref:struct:CvStringHashNode
CvStringHashNode	core/types_c.h	/^typedef struct CvStringHashNode$/;"	s
CvStringHashNode::hashval	core/types_c.h	/^    unsigned hashval;$/;"	m	struct:CvStringHashNode	access:public
CvStringHashNode::next	core/types_c.h	/^    struct CvStringHashNode* next;$/;"	m	struct:CvStringHashNode	typeref:struct:CvStringHashNode::CvStringHashNode	access:public
CvStringHashNode::str	core/types_c.h	/^    CvString str;$/;"	m	struct:CvStringHashNode	access:public
CvSubdiv2D	imgproc/types_c.h	/^CvSubdiv2D;$/;"	t	typeref:struct:CvSubdiv2D
CvSubdiv2D	imgproc/types_c.h	/^typedef struct CvSubdiv2D$/;"	s
CvSubdiv2DEdge	imgproc/types_c.h	/^typedef size_t CvSubdiv2DEdge;$/;"	t
CvSubdiv2DPoint	imgproc/types_c.h	/^CvSubdiv2DPoint;$/;"	t	typeref:struct:CvSubdiv2DPoint
CvSubdiv2DPoint	imgproc/types_c.h	/^typedef struct CvSubdiv2DPoint$/;"	s
CvSubdiv2DPointLocation	imgproc/types_c.h	/^CvSubdiv2DPointLocation;$/;"	t	typeref:enum:CvSubdiv2DPointLocation
CvSubdiv2DPointLocation	imgproc/types_c.h	/^typedef enum CvSubdiv2DPointLocation$/;"	g
CvTemplMatchMethod	legacy/compat.hpp	/^typedef int CvTemplMatchMethod;$/;"	t
CvTermCriteria	core/types_c.h	/^CvTermCriteria;$/;"	t	typeref:struct:CvTermCriteria
CvTermCriteria	core/types_c.h	/^typedef struct CvTermCriteria$/;"	s
CvTermCriteria::epsilon	core/types_c.h	/^    double epsilon;$/;"	m	struct:CvTermCriteria	access:public
CvTermCriteria::max_iter	core/types_c.h	/^    int    max_iter;$/;"	m	struct:CvTermCriteria	access:public
CvTermCriteria::type	core/types_c.h	/^    int    type;  \/* may be combination of$/;"	m	struct:CvTermCriteria	access:public
CvTestSeq	legacy/blobtrack.hpp	/^typedef void CvTestSeq;$/;"	t
CvThreshType	legacy/compat.hpp	/^typedef int CvThreshType;$/;"	t
CvTrackbarCallback	highgui/highgui_c.h	/^typedef void (CV_CDECL *CvTrackbarCallback)(int pos);$/;"	t
CvTrackbarCallback2	highgui/highgui_c.h	/^typedef void (CV_CDECL *CvTrackbarCallback2)(int pos, void* userdata);$/;"	t
CvTracksTimePos	legacy/blobtrack.hpp	/^struct CvTracksTimePos$/;"	s
CvTracksTimePos::beg1	legacy/blobtrack.hpp	/^    int beg1,beg2;$/;"	m	struct:CvTracksTimePos	access:public
CvTracksTimePos::beg2	legacy/blobtrack.hpp	/^    int beg1,beg2;$/;"	m	struct:CvTracksTimePos	access:public
CvTracksTimePos::comLen	legacy/blobtrack.hpp	/^    int comLen; \/\/common length for two tracks$/;"	m	struct:CvTracksTimePos	access:public
CvTracksTimePos::end1	legacy/blobtrack.hpp	/^    int end1,end2;$/;"	m	struct:CvTracksTimePos	access:public
CvTracksTimePos::end2	legacy/blobtrack.hpp	/^    int end1,end2;$/;"	m	struct:CvTracksTimePos	access:public
CvTracksTimePos::len1	legacy/blobtrack.hpp	/^    int len1,len2;$/;"	m	struct:CvTracksTimePos	access:public
CvTracksTimePos::len2	legacy/blobtrack.hpp	/^    int len1,len2;$/;"	m	struct:CvTracksTimePos	access:public
CvTracksTimePos::shift1	legacy/blobtrack.hpp	/^    int shift1,shift2;$/;"	m	struct:CvTracksTimePos	access:public
CvTracksTimePos::shift2	legacy/blobtrack.hpp	/^    int shift1,shift2;$/;"	m	struct:CvTracksTimePos	access:public
CvTrainTestSplit	ml/ml.hpp	/^    CvTrainTestSplit( float train_sample_portion, bool mix = true);$/;"	p	struct:CvTrainTestSplit	access:public	signature:( float train_sample_portion, bool mix = true)
CvTrainTestSplit	ml/ml.hpp	/^    CvTrainTestSplit( int train_sample_count, bool mix = true);$/;"	p	struct:CvTrainTestSplit	access:public	signature:( int train_sample_count, bool mix = true)
CvTrainTestSplit	ml/ml.hpp	/^    CvTrainTestSplit();$/;"	p	struct:CvTrainTestSplit	access:public	signature:()
CvTrainTestSplit	ml/ml.hpp	/^struct CV_EXPORTS CvTrainTestSplit$/;"	s
CvTrainTestSplit::CvTrainTestSplit	ml/ml.hpp	/^    CvTrainTestSplit( float train_sample_portion, bool mix = true);$/;"	p	struct:CvTrainTestSplit	access:public	signature:( float train_sample_portion, bool mix = true)
CvTrainTestSplit::CvTrainTestSplit	ml/ml.hpp	/^    CvTrainTestSplit( int train_sample_count, bool mix = true);$/;"	p	struct:CvTrainTestSplit	access:public	signature:( int train_sample_count, bool mix = true)
CvTrainTestSplit::CvTrainTestSplit	ml/ml.hpp	/^    CvTrainTestSplit();$/;"	p	struct:CvTrainTestSplit	access:public	signature:()
CvTrainTestSplit::__anon85::count	ml/ml.hpp	/^        int count;$/;"	m	union:CvTrainTestSplit::__anon85	access:public
CvTrainTestSplit::__anon85::portion	ml/ml.hpp	/^        float portion;$/;"	m	union:CvTrainTestSplit::__anon85	access:public
CvTrainTestSplit::mix	ml/ml.hpp	/^    bool mix;$/;"	m	struct:CvTrainTestSplit	access:public
CvTrainTestSplit::train_sample_part	ml/ml.hpp	/^    } train_sample_part;$/;"	m	struct:CvTrainTestSplit	typeref:union:CvTrainTestSplit::__anon85	access:public
CvTrainTestSplit::train_sample_part_mode	ml/ml.hpp	/^    int train_sample_part_mode;$/;"	m	struct:CvTrainTestSplit	access:public
CvTreeNodeIterator	core/core_c.h	/^CvTreeNodeIterator;$/;"	t	typeref:struct:CvTreeNodeIterator
CvTreeNodeIterator	core/core_c.h	/^typedef struct CvTreeNodeIterator$/;"	s
CvTreeNodeIterator::level	core/core_c.h	/^    int level;$/;"	m	struct:CvTreeNodeIterator	access:public
CvTreeNodeIterator::max_level	core/core_c.h	/^    int max_level;$/;"	m	struct:CvTreeNodeIterator	access:public
CvTreeNodeIterator::node	core/core_c.h	/^    const void* node;$/;"	m	struct:CvTreeNodeIterator	access:public
CvType	core/core_c.h	/^    CvType( const char* type_name,$/;"	p	struct:CvType	access:public	signature:( const char* type_name, CvIsInstanceFunc is_instance, CvReleaseFunc release=0, CvReadFunc read=0, CvWriteFunc write=0, CvCloneFunc clone=0 )
CvType	core/core_c.h	/^struct CV_EXPORTS CvType$/;"	s
CvType	flann/flann.hpp	/^template <> struct CvType<char> { static int type() { return CV_8S; } };$/;"	s	namespace:cv::flann
CvType	flann/flann.hpp	/^template <> struct CvType<double> { static int type() { return CV_64F; } };$/;"	s	namespace:cv::flann
CvType	flann/flann.hpp	/^template <> struct CvType<float> { static int type() { return CV_32F; } };$/;"	s	namespace:cv::flann
CvType	flann/flann.hpp	/^template <> struct CvType<int> { static int type() { return CV_32S; } };$/;"	s	namespace:cv::flann
CvType	flann/flann.hpp	/^template <> struct CvType<short> { static int type() { return CV_16S; } };$/;"	s	namespace:cv::flann
CvType	flann/flann.hpp	/^template <> struct CvType<unsigned char> { static int type() { return CV_8U; } };$/;"	s	namespace:cv::flann
CvType	flann/flann.hpp	/^template <> struct CvType<unsigned short> { static int type() { return CV_16U; } };$/;"	s	namespace:cv::flann
CvType	flann/flann.hpp	/^template <typename T> struct CvType {};$/;"	s	namespace:cv::flann
CvType::CvType	core/core_c.h	/^    CvType( const char* type_name,$/;"	p	struct:CvType	access:public	signature:( const char* type_name, CvIsInstanceFunc is_instance, CvReleaseFunc release=0, CvReadFunc read=0, CvWriteFunc write=0, CvCloneFunc clone=0 )
CvType::first	core/core_c.h	/^    static CvTypeInfo* first;$/;"	m	struct:CvType	access:public
CvType::info	core/core_c.h	/^    CvTypeInfo* info;$/;"	m	struct:CvType	access:public
CvType::last	core/core_c.h	/^    static CvTypeInfo* last;$/;"	m	struct:CvType	access:public
CvType::~CvType	core/core_c.h	/^    ~CvType();$/;"	p	struct:CvType	access:public	signature:()
CvTypeInfo	core/types_c.h	/^CvTypeInfo;$/;"	t	typeref:struct:CvTypeInfo
CvTypeInfo	core/types_c.h	/^typedef struct CvTypeInfo$/;"	s
CvTypeInfo::clone	core/types_c.h	/^    CvCloneFunc clone;$/;"	m	struct:CvTypeInfo	access:public
CvTypeInfo::flags	core/types_c.h	/^    int flags;$/;"	m	struct:CvTypeInfo	access:public
CvTypeInfo::header_size	core/types_c.h	/^    int header_size;$/;"	m	struct:CvTypeInfo	access:public
CvTypeInfo::is_instance	core/types_c.h	/^    CvIsInstanceFunc is_instance;$/;"	m	struct:CvTypeInfo	access:public
CvTypeInfo::next	core/types_c.h	/^    struct CvTypeInfo* next;$/;"	m	struct:CvTypeInfo	typeref:struct:CvTypeInfo::CvTypeInfo	access:public
CvTypeInfo::prev	core/types_c.h	/^    struct CvTypeInfo* prev;$/;"	m	struct:CvTypeInfo	typeref:struct:CvTypeInfo::CvTypeInfo	access:public
CvTypeInfo::read	core/types_c.h	/^    CvReadFunc read;$/;"	m	struct:CvTypeInfo	access:public
CvTypeInfo::release	core/types_c.h	/^    CvReleaseFunc release;$/;"	m	struct:CvTypeInfo	access:public
CvTypeInfo::type_name	core/types_c.h	/^    const char* type_name;$/;"	m	struct:CvTypeInfo	access:public
CvTypeInfo::write	core/types_c.h	/^    CvWriteFunc write;$/;"	m	struct:CvTypeInfo	access:public
CvUpdateBGStatModel	video/background_segm.hpp	/^typedef int (CV_CDECL * CvUpdateBGStatModel)( IplImage* curr_frame, struct CvBGStatModel* bg_model,$/;"	t
CvVSModule	legacy/blobtrack.hpp	/^    CvVSModule();$/;"	p	class:CvVSModule	access:public	signature:()
CvVSModule	legacy/blobtrack.hpp	/^class CV_EXPORTS CvVSModule$/;"	c
CvVSModule::AddParam	legacy/blobtrack.hpp	/^    void AddParam(const char* name);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name)
CvVSModule::AddParam	legacy/blobtrack.hpp	/^    void AddParam(const char* name, const char** pAddr);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name, const char** pAddr)
CvVSModule::AddParam	legacy/blobtrack.hpp	/^    void AddParam(const char* name, double* pAddr);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name, double* pAddr)
CvVSModule::AddParam	legacy/blobtrack.hpp	/^    void AddParam(const char* name, float* pAddr);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name, float* pAddr)
CvVSModule::AddParam	legacy/blobtrack.hpp	/^    void AddParam(const char* name, int* pAddr);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name, int* pAddr)
CvVSModule::CommentParam	legacy/blobtrack.hpp	/^    void CommentParam(const char* name, const char* pComment);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name, const char* pComment)
CvVSModule::CvVSModule	legacy/blobtrack.hpp	/^    CvVSModule();$/;"	p	class:CvVSModule	access:public	signature:()
CvVSModule::DelParam	legacy/blobtrack.hpp	/^    void DelParam(const char* name);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name)
CvVSModule::FreeParam	legacy/blobtrack.hpp	/^    void    FreeParam(CvDefParam** pp);$/;"	p	class:CvVSModule	access:private	signature:(CvDefParam** pp)
CvVSModule::GetModuleName	legacy/blobtrack.hpp	/^    char*   GetModuleName();$/;"	p	class:CvVSModule	access:public	signature:()
CvVSModule::GetNickName	legacy/blobtrack.hpp	/^    const char* GetNickName();$/;"	p	class:CvVSModule	access:public	signature:()
CvVSModule::GetParam	legacy/blobtrack.hpp	/^    double GetParam(const char* name);$/;"	p	class:CvVSModule	access:public	signature:(const char* name)
CvVSModule::GetParamComment	legacy/blobtrack.hpp	/^    const char* GetParamComment(const char* name);$/;"	p	class:CvVSModule	access:public	signature:(const char* name)
CvVSModule::GetParamName	legacy/blobtrack.hpp	/^    const char* GetParamName(int index);$/;"	p	class:CvVSModule	access:public	signature:(int index)
CvVSModule::GetParamPtr	legacy/blobtrack.hpp	/^    CvDefParam* GetParamPtr(const char* name);$/;"	p	class:CvVSModule	access:private	signature:(const char* name)
CvVSModule::GetParamPtr	legacy/blobtrack.hpp	/^    CvDefParam* GetParamPtr(int index);$/;"	p	class:CvVSModule	access:private	signature:(int index)
CvVSModule::GetParamStr	legacy/blobtrack.hpp	/^    const char* GetParamStr(const char* name);$/;"	p	class:CvVSModule	access:public	signature:(const char* name)
CvVSModule::GetTypeName	legacy/blobtrack.hpp	/^    const char*   GetTypeName();$/;"	p	class:CvVSModule	access:public	signature:()
CvVSModule::IsModuleName	legacy/blobtrack.hpp	/^    int     IsModuleName(const char* name);$/;"	p	class:CvVSModule	access:public	signature:(const char* name)
CvVSModule::IsModuleTypeName	legacy/blobtrack.hpp	/^    int     IsModuleTypeName(const char* name);$/;"	p	class:CvVSModule	access:public	signature:(const char* name)
CvVSModule::IsParam	legacy/blobtrack.hpp	/^    int  IsParam(const char* name);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name)
CvVSModule::LoadState	legacy/blobtrack.hpp	/^    virtual void LoadState(CvFileStorage*, CvFileNode*);$/;"	p	class:CvVSModule	access:public	signature:(CvFileStorage*, CvFileNode*)
CvVSModule::NewParam	legacy/blobtrack.hpp	/^    CvDefParam* NewParam(const char* name);$/;"	p	class:CvVSModule	access:private	signature:(const char* name)
CvVSModule::ParamUpdate	legacy/blobtrack.hpp	/^    virtual void ParamUpdate();$/;"	p	class:CvVSModule	access:public	signature:()
CvVSModule::Release	legacy/blobtrack.hpp	/^    virtual void Release() = 0;$/;"	p	class:CvVSModule	access:public	signature:()
CvVSModule::SaveState	legacy/blobtrack.hpp	/^    virtual void SaveState(CvFileStorage*);$/;"	p	class:CvVSModule	access:public	signature:(CvFileStorage*)
CvVSModule::SetModuleName	legacy/blobtrack.hpp	/^    void SetModuleName(const char* name);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name)
CvVSModule::SetNickName	legacy/blobtrack.hpp	/^    void SetNickName(const char* pStr);$/;"	p	class:CvVSModule	access:public	signature:(const char* pStr)
CvVSModule::SetParam	legacy/blobtrack.hpp	/^    void   SetParam(const char* name, double val);$/;"	p	class:CvVSModule	access:public	signature:(const char* name, double val)
CvVSModule::SetParamStr	legacy/blobtrack.hpp	/^    void   SetParamStr(const char* name, const char* str);$/;"	p	class:CvVSModule	access:public	signature:(const char* name, const char* str)
CvVSModule::SetTypeName	legacy/blobtrack.hpp	/^    void SetTypeName(const char* name);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name)
CvVSModule::TransferParamsFromChild	legacy/blobtrack.hpp	/^    void TransferParamsFromChild(CvVSModule* pM, const char* prefix = NULL);$/;"	p	class:CvVSModule	access:public	signature:(CvVSModule* pM, const char* prefix = NULL)
CvVSModule::TransferParamsToChild	legacy/blobtrack.hpp	/^    void TransferParamsToChild(CvVSModule* pM, char* prefix = NULL);$/;"	p	class:CvVSModule	access:public	signature:(CvVSModule* pM, char* prefix = NULL)
CvVSModule::m_Wnd	legacy/blobtrack.hpp	/^    int         m_Wnd;$/;"	m	class:CvVSModule	access:protected
CvVSModule::m_pModuleName	legacy/blobtrack.hpp	/^    char*       m_pModuleName;$/;"	m	class:CvVSModule	access:private
CvVSModule::m_pModuleTypeName	legacy/blobtrack.hpp	/^    char*       m_pModuleTypeName;$/;"	m	class:CvVSModule	access:private
CvVSModule::m_pNickName	legacy/blobtrack.hpp	/^    char*       m_pNickName;$/;"	m	class:CvVSModule	access:private
CvVSModule::m_pParamList	legacy/blobtrack.hpp	/^    CvDefParam*   m_pParamList;$/;"	m	class:CvVSModule	access:private
CvVSModule::~CvVSModule	legacy/blobtrack.hpp	/^    virtual ~CvVSModule();$/;"	p	class:CvVSModule	access:public	signature:()
CvVect32f	legacy/compat.hpp	/^typedef float*   CvVect32f;$/;"	t
CvVect64d	legacy/compat.hpp	/^typedef double*  CvVect64d;$/;"	t
CvVectors	ml/ml.hpp	/^struct CvVectors$/;"	s
CvVectors::__anon70::db	ml/ml.hpp	/^        double** db;$/;"	m	union:CvVectors::__anon70	access:public
CvVectors::__anon70::fl	ml/ml.hpp	/^        float** fl;$/;"	m	union:CvVectors::__anon70	access:public
CvVectors::__anon70::ptr	ml/ml.hpp	/^        uchar** ptr;$/;"	m	union:CvVectors::__anon70	access:public
CvVectors::count	ml/ml.hpp	/^    int dims, count;$/;"	m	struct:CvVectors	access:public
CvVectors::data	ml/ml.hpp	/^    } data;$/;"	m	struct:CvVectors	typeref:union:CvVectors::__anon70	access:public
CvVectors::dims	ml/ml.hpp	/^    int dims, count;$/;"	m	struct:CvVectors	access:public
CvVectors::next	ml/ml.hpp	/^    CvVectors* next;$/;"	m	struct:CvVectors	access:public
CvVectors::type	ml/ml.hpp	/^    int type;$/;"	m	struct:CvVectors	access:public
CvVideoWriter	highgui/highgui_c.h	/^typedef struct CvVideoWriter CvVideoWriter;$/;"	t	typeref:struct:CvVideoWriter
CvVoronoiDiagram2D	legacy/legacy.hpp	/^typedef struct CvVoronoiDiagram2D$/;"	s
CvVoronoiDiagram2D	legacy/legacy.hpp	/^} CvVoronoiDiagram2D;$/;"	t	typeref:struct:CvVoronoiDiagram2D
CvVoronoiEdge2D	legacy/legacy.hpp	/^typedef struct CvVoronoiEdge2D$/;"	s
CvVoronoiEdge2D	legacy/legacy.hpp	/^} CvVoronoiEdge2D;$/;"	t	typeref:struct:CvVoronoiEdge2D
CvVoronoiNode2D	legacy/legacy.hpp	/^typedef struct CvVoronoiNode2D$/;"	s
CvVoronoiNode2D	legacy/legacy.hpp	/^} CvVoronoiNode2D;$/;"	t	typeref:struct:CvVoronoiNode2D
CvVoronoiSite2D	legacy/legacy.hpp	/^typedef struct CvVoronoiSite2D$/;"	s
CvVoronoiSite2D	legacy/legacy.hpp	/^} CvVoronoiSite2D;$/;"	t	typeref:struct:CvVoronoiSite2D
CvVoronoiSite2D::next	legacy/legacy.hpp	/^    struct CvVoronoiSite2D *next[2];$/;"	m	struct:CvVoronoiSite2D	typeref:struct:CvVoronoiSite2D::CvVoronoiSite2D	access:public
CvWriteFunc	core/types_c.h	/^typedef void (CV_CDECL *CvWriteFunc)( CvFileStorage* storage, const char* name,$/;"	t
Cv_iplAllocateImageData	core/core_c.h	/^typedef void (CV_STDCALL* Cv_iplAllocateImageData)(IplImage*,int,int);$/;"	t
Cv_iplCloneImage	core/core_c.h	/^typedef IplImage* (CV_STDCALL* Cv_iplCloneImage)(const IplImage*);$/;"	t
Cv_iplCreateImageHeader	core/core_c.h	/^typedef IplImage* (CV_STDCALL* Cv_iplCreateImageHeader)$/;"	t
Cv_iplCreateROI	core/core_c.h	/^typedef IplROI* (CV_STDCALL* Cv_iplCreateROI)(int,int,int,int,int);$/;"	t
Cv_iplDeallocate	core/core_c.h	/^typedef void (CV_STDCALL* Cv_iplDeallocate)(IplImage*,int);$/;"	t
DCT_INVERSE	core/core.hpp	/^    DCT_INVERSE = DFT_INVERSE, DCT_ROWS=DFT_ROWS };$/;"	e	enum:cv::__anon101
DCT_ROWS	core/core.hpp	/^    DCT_INVERSE = DFT_INVERSE, DCT_ROWS=DFT_ROWS };$/;"	e	enum:cv::__anon101
DECOMP_CHOLESKY	core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon97
DECOMP_EIG	core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon97
DECOMP_LU	core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon97
DECOMP_NORMAL	core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon97
DECOMP_QR	core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon97
DECOMP_SVD	core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon97
DEFAULT	features2d/features2d.hpp	/^    enum{ DEFAULT = 0, \/\/ Output image matrix will be created (Mat::create),$/;"	e	enum:cv::DrawMatchesFlags::__anon194
DEFAULT	ml/ml.hpp	/^    enum { DEFAULT=0, GINI=1, MISCLASS=3, SQERR=4 };$/;"	e	enum:CvBoost::__anon80
DEFAULT_COMPRESSION_METHOD	features2d/features2d.hpp	/^        DEFAULT_COMPRESSION_METHOD = COMPRESSION_NONE$/;"	e	enum:cv::FernClassifier::__anon193
DEFAULT_DEPTH	features2d/features2d.hpp	/^  static const int DEFAULT_DEPTH = 9;$/;"	m	class:cv::RandomizedTree	access:public
DEFAULT_FIRST_LEVEL	features2d/features2d.hpp	/^    enum { DEFAULT_N_LEVELS = 3, DEFAULT_FIRST_LEVEL = 0};$/;"	e	enum:cv::ORB::CommonParams::__anon192
DEFAULT_FIRST_OCTAVE	features2d/features2d.hpp	/^        static const int DEFAULT_FIRST_OCTAVE = -1;$/;"	m	struct:cv::SIFT::CommonParams	access:public
DEFAULT_IS_NORMALIZE	features2d/features2d.hpp	/^        static const bool DEFAULT_IS_NORMALIZE = true;$/;"	m	struct:cv::SIFT::DescriptorParams	access:public
DEFAULT_ITERS	gpu/gpu.hpp	/^            enum { DEFAULT_ITERS    = 8   };$/;"	e	enum:cv::gpu::StereoConstantSpaceBP::__anon61
DEFAULT_ITERS	gpu/gpu.hpp	/^            enum { DEFAULT_ITERS  = 1 };$/;"	e	enum:cv::gpu::DisparityBilateralFilter::__anon66
DEFAULT_ITERS	gpu/gpu.hpp	/^            enum { DEFAULT_ITERS  = 5  };$/;"	e	enum:cv::gpu::StereoBeliefPropagation::__anon58
DEFAULT_LARGE_SIZE	contrib/contrib.hpp	/^        enum { DEFAULT_SMALL_SIZE = 5, DEFAULT_LARGE_SIZE = 41,$/;"	e	enum:cv::SelfSimDescriptor::__anon6
DEFAULT_LEVELS	gpu/gpu.hpp	/^            enum { DEFAULT_LEVELS   = 4   };$/;"	e	enum:cv::gpu::StereoConstantSpaceBP::__anon62
DEFAULT_LEVELS	gpu/gpu.hpp	/^            enum { DEFAULT_LEVELS = 5  };$/;"	e	enum:cv::gpu::StereoBeliefPropagation::__anon59
DEFAULT_NDISP	gpu/gpu.hpp	/^            enum { DEFAULT_NDISP    = 128 };$/;"	e	enum:cv::gpu::StereoConstantSpaceBP::__anon60
DEFAULT_NDISP	gpu/gpu.hpp	/^            enum { DEFAULT_NDISP  = 64 };$/;"	e	enum:cv::gpu::DisparityBilateralFilter::__anon64
DEFAULT_NDISP	gpu/gpu.hpp	/^            enum { DEFAULT_NDISP  = 64 };$/;"	e	enum:cv::gpu::StereoBeliefPropagation::__anon57
DEFAULT_NDISP	gpu/gpu.hpp	/^            enum { DEFAULT_NDISP = 64, DEFAULT_WINSZ = 19 };$/;"	e	enum:cv::gpu::StereoBM_GPU::__anon56
DEFAULT_NLEVELS	gpu/gpu.hpp	/^            enum { DEFAULT_NLEVELS = 64 };$/;"	e	enum:cv::gpu::HOGDescriptor::__anon68
DEFAULT_NLEVELS	objdetect/objdetect.hpp	/^    enum { DEFAULT_NLEVELS=64 };$/;"	e	enum:cv::HOGDescriptor::__anon203
DEFAULT_NOCTAVES	features2d/features2d.hpp	/^        static const int DEFAULT_NOCTAVES = 4;$/;"	m	struct:cv::SIFT::CommonParams	access:public
DEFAULT_NOCTAVE_LAYERS	features2d/features2d.hpp	/^        static const int DEFAULT_NOCTAVE_LAYERS = 3;$/;"	m	struct:cv::SIFT::CommonParams	access:public
DEFAULT_NR_PLANE	gpu/gpu.hpp	/^            enum { DEFAULT_NR_PLANE = 4   };$/;"	e	enum:cv::gpu::StereoConstantSpaceBP::__anon63
DEFAULT_NUM_ANGLES	contrib/contrib.hpp	/^            DEFAULT_NUM_ANGLES = 20, DEFAULT_START_DISTANCE_BUCKET = 3,$/;"	e	enum:cv::SelfSimDescriptor::__anon6
DEFAULT_NUM_DISTANCE_BUCKETS	contrib/contrib.hpp	/^            DEFAULT_NUM_DISTANCE_BUCKETS = 7 };$/;"	e	enum:cv::SelfSimDescriptor::__anon6
DEFAULT_NUM_QUANT_BITS	features2d/features2d.hpp	/^  static const size_t DEFAULT_NUM_QUANT_BITS = 4;$/;"	m	class:cv::RTreeClassifier	access:public
DEFAULT_N_LEVELS	features2d/features2d.hpp	/^    enum { DEFAULT_N_LEVELS = 3, DEFAULT_FIRST_LEVEL = 0};$/;"	e	enum:cv::ORB::CommonParams::__anon192
DEFAULT_RADIUS	gpu/gpu.hpp	/^            enum { DEFAULT_RADIUS = 3 };$/;"	e	enum:cv::gpu::DisparityBilateralFilter::__anon65
DEFAULT_REDUCED_NUM_DIM	features2d/features2d.hpp	/^  static const size_t DEFAULT_REDUCED_NUM_DIM = 176;$/;"	m	class:cv::RandomizedTree	access:public
DEFAULT_SIGNATURE_SIZE	features2d/features2d.hpp	/^        DEFAULT_SIGNATURE_SIZE = 176,$/;"	e	enum:cv::FernClassifier::__anon193
DEFAULT_SMALL_SIZE	contrib/contrib.hpp	/^        enum { DEFAULT_SMALL_SIZE = 5, DEFAULT_LARGE_SIZE = 41,$/;"	e	enum:cv::SelfSimDescriptor::__anon6
DEFAULT_START_DISTANCE_BUCKET	contrib/contrib.hpp	/^            DEFAULT_NUM_ANGLES = 20, DEFAULT_START_DISTANCE_BUCKET = 3,$/;"	e	enum:cv::SelfSimDescriptor::__anon6
DEFAULT_STRUCTS	features2d/features2d.hpp	/^        DEFAULT_STRUCTS = 50,$/;"	e	enum:cv::FernClassifier::__anon193
DEFAULT_STRUCT_SIZE	features2d/features2d.hpp	/^        DEFAULT_STRUCT_SIZE = 9,$/;"	e	enum:cv::FernClassifier::__anon193
DEFAULT_TREES	features2d/features2d.hpp	/^  static const int DEFAULT_TREES = 48;$/;"	m	class:cv::RTreeClassifier	access:public
DEFAULT_VIEWS	features2d/features2d.hpp	/^        DEFAULT_VIEWS = 5000,$/;"	e	enum:cv::FernClassifier::__anon193
DEFAULT_VIEWS	features2d/features2d.hpp	/^  static const int DEFAULT_VIEWS = 5000;$/;"	m	class:cv::RandomizedTree	access:public
DEFAULT_WINSZ	gpu/gpu.hpp	/^            enum { DEFAULT_NDISP = 64, DEFAULT_WINSZ = 19 };$/;"	e	enum:cv::gpu::StereoBM_GPU::__anon56
DEFAULT_WIN_SIGMA	gpu/gpu.hpp	/^            enum { DEFAULT_WIN_SIGMA = -1 };$/;"	e	enum:cv::gpu::HOGDescriptor::__anon67
DEGREE	ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon74
DEPTH_MASK	core/core.hpp	/^enum { MAGIC_MASK=0xFFFF0000, TYPE_MASK=0x00000FFF, DEPTH_MASK=7 };$/;"	e	enum:cv::__anon136
DEPTH_MASK_16S	core/core.hpp	/^    DEPTH_MASK_16S = 1 << CV_16S,$/;"	e	enum:cv::__anon135
DEPTH_MASK_16U	core/core.hpp	/^    DEPTH_MASK_16U = 1 << CV_16U,$/;"	e	enum:cv::__anon135
DEPTH_MASK_32F	core/core.hpp	/^    DEPTH_MASK_32F = 1 << CV_32F,$/;"	e	enum:cv::__anon135
DEPTH_MASK_32S	core/core.hpp	/^    DEPTH_MASK_32S = 1 << CV_32S,$/;"	e	enum:cv::__anon135
DEPTH_MASK_64F	core/core.hpp	/^    DEPTH_MASK_64F = 1 << CV_64F,$/;"	e	enum:cv::__anon135
DEPTH_MASK_8S	core/core.hpp	/^    DEPTH_MASK_8S = 1 << CV_8S,$/;"	e	enum:cv::__anon135
DEPTH_MASK_8U	core/core.hpp	/^    DEPTH_MASK_8U = 1 << CV_8U,$/;"	e	enum:cv::__anon135
DEPTH_MASK_ALL	core/core.hpp	/^    DEPTH_MASK_ALL = (DEPTH_MASK_64F<<1)-1,$/;"	e	enum:cv::__anon135
DEPTH_MASK_ALL_BUT_8S	core/core.hpp	/^    DEPTH_MASK_ALL_BUT_8S = DEPTH_MASK_ALL & ~DEPTH_MASK_8S,$/;"	e	enum:cv::__anon135
DEPTH_MASK_FLT	core/core.hpp	/^    DEPTH_MASK_FLT = DEPTH_MASK_32F + DEPTH_MASK_64F$/;"	e	enum:cv::__anon135
DESCRIPTOR_SIZE	features2d/features2d.hpp	/^        static const int DESCRIPTOR_SIZE = 128;$/;"	m	struct:cv::SIFT::DescriptorParams	access:public
DESCR_FORMAT_COL_BY_COL	gpu/gpu.hpp	/^            enum { DESCR_FORMAT_ROW_BY_ROW, DESCR_FORMAT_COL_BY_COL };$/;"	e	enum:cv::gpu::HOGDescriptor::__anon69
DESCR_FORMAT_ROW_BY_ROW	gpu/gpu.hpp	/^            enum { DESCR_FORMAT_ROW_BY_ROW, DESCR_FORMAT_COL_BY_COL };$/;"	e	enum:cv::gpu::HOGDescriptor::__anon69
DEVIANCE_LOSS	ml/ml.hpp	/^    enum {SQUARED_LOSS=0, ABSOLUTE_LOSS, HUBER_LOSS=3, DEVIANCE_LOSS};$/;"	e	enum:CvGBTrees::__anon81
DFT_COMPLEX_OUTPUT	core/core.hpp	/^enum { DFT_INVERSE=1, DFT_SCALE=2, DFT_ROWS=4, DFT_COMPLEX_OUTPUT=16, DFT_REAL_OUTPUT=32,$/;"	e	enum:cv::__anon101
DFT_INVERSE	core/core.hpp	/^enum { DFT_INVERSE=1, DFT_SCALE=2, DFT_ROWS=4, DFT_COMPLEX_OUTPUT=16, DFT_REAL_OUTPUT=32,$/;"	e	enum:cv::__anon101
DFT_REAL_OUTPUT	core/core.hpp	/^enum { DFT_INVERSE=1, DFT_SCALE=2, DFT_ROWS=4, DFT_COMPLEX_OUTPUT=16, DFT_REAL_OUTPUT=32,$/;"	e	enum:cv::__anon101
DFT_ROWS	core/core.hpp	/^enum { DFT_INVERSE=1, DFT_SCALE=2, DFT_ROWS=4, DFT_COMPLEX_OUTPUT=16, DFT_REAL_OUTPUT=32,$/;"	e	enum:cv::__anon101
DFT_SCALE	core/core.hpp	/^enum { DFT_INVERSE=1, DFT_SCALE=2, DFT_ROWS=4, DFT_COMPLEX_OUTPUT=16, DFT_REAL_OUTPUT=32,$/;"	e	enum:cv::__anon101
DISCRETE	ml/ml.hpp	/^    enum { DISCRETE=0, REAL=1, LOGIT=2, GENTLE=3 };$/;"	e	enum:CvBoost::__anon79
DISP_SCALE	calib3d/calib3d.hpp	/^    enum { DISP_SHIFT=4, DISP_SCALE = (1<<DISP_SHIFT) };$/;"	e	enum:cv::StereoSGBM::__anon93
DISP_SHIFT	calib3d/calib3d.hpp	/^    enum { DISP_SHIFT=4, DISP_SCALE = (1<<DISP_SHIFT) };$/;"	e	enum:cv::StereoSGBM::__anon93
DMatch	features2d/features2d.hpp	/^    DMatch( int _queryIdx, int _trainIdx, float _distance ) :$/;"	f	struct:cv::DMatch	access:public	signature:( int _queryIdx, int _trainIdx, float _distance )
DMatch	features2d/features2d.hpp	/^    DMatch( int _queryIdx, int _trainIdx, int _imgIdx, float _distance ) :$/;"	f	struct:cv::DMatch	access:public	signature:( int _queryIdx, int _trainIdx, int _imgIdx, float _distance )
DMatch	features2d/features2d.hpp	/^    DMatch() : queryIdx(-1), trainIdx(-1), imgIdx(-1), distance(std::numeric_limits<float>::max()) {}$/;"	f	struct:cv::DMatch	access:public	signature:()
DMatch	features2d/features2d.hpp	/^struct CV_EXPORTS DMatch$/;"	s	namespace:cv
DONE	calib3d/calib3d.hpp	/^    enum { DONE=0, STARTED=1, CALC_J=2, CHECK_ERR=3 };$/;"	e	enum:CvLevMarq::__anon86
DO_CANNY_PRUNING	objdetect/objdetect.hpp	/^    enum { DO_CANNY_PRUNING = 1, SCALE_IMAGE = 2,$/;"	e	enum:cv::CascadeClassifier::__anon201
DO_ROUGH_SEARCH	objdetect/objdetect.hpp	/^           FIND_BIGGEST_OBJECT = 4, DO_ROUGH_SEARCH = 8 };$/;"	e	enum:cv::CascadeClassifier::__anon201
DP	legacy/legacy.hpp	/^    int DP;$/;"	m	struct:CvConDensation	access:public
DP	video/tracking.hpp	/^    int DP;                     \/* number of state vector dimensions *\/$/;"	m	struct:CvKalman	access:public
DRAW_OVER_OUTIMG	features2d/features2d.hpp	/^          DRAW_OVER_OUTIMG = 1, \/\/ Output image matrix will not be created (Mat::create).$/;"	e	enum:cv::DrawMatchesFlags::__anon194
DRAW_RICH_KEYPOINTS	features2d/features2d.hpp	/^          DRAW_RICH_KEYPOINTS = 4 \/\/ For each keypoint the circle around keypoint with keypoint size and$/;"	e	enum:cv::DrawMatchesFlags::__anon194
DTree	objdetect/objdetect.hpp	/^        struct CV_EXPORTS DTree$/;"	s	class:cv::CascadeClassifier::Data	access:public
DTreeNode	objdetect/objdetect.hpp	/^        struct CV_EXPORTS DTreeNode$/;"	s	class:cv::CascadeClassifier::Data	access:public
DTreeParams	ml/ml.hpp	/^typedef CvDTreeParams DTreeParams;$/;"	t	namespace:cv
Data	objdetect/objdetect.hpp	/^    class Data$/;"	c	class:cv::CascadeClassifier	access:protected
DataDepth	core/core.hpp	/^template<> class DataDepth<bool> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	c	namespace:cv
DataDepth	core/core.hpp	/^template<> class DataDepth<char> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	c	namespace:cv
DataDepth	core/core.hpp	/^template<> class DataDepth<double> { public: enum { value = CV_64F, fmt=(int)'d' }; };$/;"	c	namespace:cv
DataDepth	core/core.hpp	/^template<> class DataDepth<float> { public: enum { value = CV_32F, fmt=(int)'f' }; };$/;"	c	namespace:cv
DataDepth	core/core.hpp	/^template<> class DataDepth<int> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	c	namespace:cv
DataDepth	core/core.hpp	/^template<> class DataDepth<schar> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	c	namespace:cv
DataDepth	core/core.hpp	/^template<> class DataDepth<short> { public: enum { value = CV_16S, fmt=(int)'s' }; };$/;"	c	namespace:cv
DataDepth	core/core.hpp	/^template<> class DataDepth<uchar> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	c	namespace:cv
DataDepth	core/core.hpp	/^template<> class DataDepth<unsigned> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	c	namespace:cv
DataDepth	core/core.hpp	/^template<> class DataDepth<ushort> { public: enum { value = CV_16U, fmt=(int)'w' }; };$/;"	c	namespace:cv
DataDepth	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS DataDepth {};$/;"	c	namespace:cv
DataDepth	core/core.hpp	/^template<typename _Tp> class DataDepth<_Tp*> { public: enum { value = CV_USRTYPE1, fmt=(int)'r' }; };$/;"	c	namespace:cv
DataMatrixCode	objdetect/objdetect.hpp	/^struct CV_EXPORTS DataMatrixCode {$/;"	s	namespace:cv
DataType	core/core.hpp	/^template<> class DataType<Range>$/;"	c	namespace:cv
DataType	core/core.hpp	/^template<> class DataType<bool>$/;"	c	namespace:cv
DataType	core/core.hpp	/^template<> class DataType<char>$/;"	c	namespace:cv
DataType	core/core.hpp	/^template<> class DataType<double>$/;"	c	namespace:cv
DataType	core/core.hpp	/^template<> class DataType<float>$/;"	c	namespace:cv
DataType	core/core.hpp	/^template<> class DataType<int>$/;"	c	namespace:cv
DataType	core/core.hpp	/^template<> class DataType<schar>$/;"	c	namespace:cv
DataType	core/core.hpp	/^template<> class DataType<short>$/;"	c	namespace:cv
DataType	core/core.hpp	/^template<> class DataType<uchar>$/;"	c	namespace:cv
DataType	core/core.hpp	/^template<> class DataType<ushort>$/;"	c	namespace:cv
DataType	core/core.hpp	/^template<typename _Tp, int cn> class DataType<Vec<_Tp, cn> >$/;"	c	namespace:cv
DataType	core/core.hpp	/^template<typename _Tp> class DataType$/;"	c	namespace:cv
DataType	core/core.hpp	/^template<typename _Tp> class DataType<Complex<_Tp> >$/;"	c	namespace:cv
DataType	core/core.hpp	/^template<typename _Tp> class DataType<Point3_<_Tp> >$/;"	c	namespace:cv
DataType	core/core.hpp	/^template<typename _Tp> class DataType<Point_<_Tp> >$/;"	c	namespace:cv
DataType	core/core.hpp	/^template<typename _Tp> class DataType<Rect_<_Tp> >$/;"	c	namespace:cv
DataType	core/core.hpp	/^template<typename _Tp> class DataType<Scalar_<_Tp> >$/;"	c	namespace:cv
DataType	core/core.hpp	/^template<typename _Tp> class DataType<Size_<_Tp> >$/;"	c	namespace:cv
DataType	core/core.hpp	/^template<typename _Tp> class DataType<std::complex<_Tp> >$/;"	c	namespace:cv
Datatype	flann/saving.h	/^struct Datatype {};$/;"	s	namespace:cvflann
Datatype	flann/saving.h	/^struct Datatype<char> { static flann_datatype_t type() { return FLANN_INT8; } };$/;"	s	namespace:cvflann
Datatype	flann/saving.h	/^struct Datatype<double> { static flann_datatype_t type() { return FLANN_FLOAT64; } };$/;"	s	namespace:cvflann
Datatype	flann/saving.h	/^struct Datatype<float> { static flann_datatype_t type() { return FLANN_FLOAT32; } };$/;"	s	namespace:cvflann
Datatype	flann/saving.h	/^struct Datatype<int> { static flann_datatype_t type() { return FLANN_INT32; } };$/;"	s	namespace:cvflann
Datatype	flann/saving.h	/^struct Datatype<short> { static flann_datatype_t type() { return FLANN_INT16; } };$/;"	s	namespace:cvflann
Datatype	flann/saving.h	/^struct Datatype<unsigned char> { static flann_datatype_t type() { return FLANN_UINT8; } };$/;"	s	namespace:cvflann
Datatype	flann/saving.h	/^struct Datatype<unsigned int> { static flann_datatype_t type() { return FLANN_UINT32; } };$/;"	s	namespace:cvflann
Datatype	flann/saving.h	/^struct Datatype<unsigned short> { static flann_datatype_t type() { return FLANN_UINT16; } };$/;"	s	namespace:cvflann
DecisionTree	ml/ml.hpp	/^typedef CvDTree DecisionTree;$/;"	t	namespace:cv
DefaultRngAuto	features2d/features2d.hpp	/^        DefaultRngAuto() : old_state(theRNG().state) { theRNG().state = (uint64)-1; }$/;"	f	struct:cv::DefaultRngAuto	access:public	signature:()
DefaultRngAuto	features2d/features2d.hpp	/^    struct CV_EXPORTS DefaultRngAuto$/;"	s	namespace:cv
DelBlob	legacy/blobtrack.hpp	/^    virtual void    DelBlob(int BlobIndex) = 0;$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobIndex)
DelBlob	legacy/blobtrack.hpp	/^    virtual void DelBlob(int BlobIndex)$/;"	f	class:CvBlobSeq	access:public	signature:(int BlobIndex)
DelBlobByID	legacy/blobtrack.hpp	/^    virtual void    DelBlobByID(int BlobID);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobID)
DelBlobByID	legacy/blobtrack.hpp	/^    virtual void DelBlobByID(int BlobID)$/;"	f	class:CvBlobSeq	access:public	signature:(int BlobID)
DelBlobTrack	legacy/blobtrack.hpp	/^    virtual void DelBlobTrack(int TrackIndex);$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackIndex)
DelBlobTrackByID	legacy/blobtrack.hpp	/^    virtual void DelBlobTrackByID(int TrackID);$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackID)
DelParam	legacy/blobtrack.hpp	/^    void DelParam(const char* name);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name)
DenseFeatureDetector	features2d/features2d.hpp	/^    DenseFeatureDetector( const DenseFeatureDetector::Params& params=DenseFeatureDetector::Params() );$/;"	p	class:cv::DenseFeatureDetector	access:public	signature:( const DenseFeatureDetector::Params& params=DenseFeatureDetector::Params() )
DenseFeatureDetector	features2d/features2d.hpp	/^class CV_EXPORTS DenseFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
Depth	core/wimage.hpp	/^    int Depth() const;$/;"	p	class:cv::WImage	access:public	signature:() const
Depth	core/wimage.hpp	/^inline int WImage<double>::Depth() const {return IPL_DEPTH_64F; }$/;"	f	class:cv::WImage	signature:() const
Depth	core/wimage.hpp	/^inline int WImage<float>::Depth() const {return IPL_DEPTH_32F; }$/;"	f	class:cv::WImage	signature:() const
Depth	core/wimage.hpp	/^inline int WImage<int>::Depth() const {return IPL_DEPTH_32S; }$/;"	f	class:cv::WImage	signature:() const
Depth	core/wimage.hpp	/^inline int WImage<short>::Depth() const {return IPL_DEPTH_16S; }$/;"	f	class:cv::WImage	signature:() const
Depth	core/wimage.hpp	/^inline int WImage<signed char>::Depth() const {return IPL_DEPTH_8S; }$/;"	f	class:cv::WImage	signature:() const
Depth	core/wimage.hpp	/^inline int WImage<uchar>::Depth() const {return IPL_DEPTH_8U; }$/;"	f	class:cv::WImage	signature:() const
Depth	core/wimage.hpp	/^inline int WImage<ushort>::Depth() const {return IPL_DEPTH_16U; }$/;"	f	class:cv::WImage	signature:() const
DescriptorCollection	features2d/features2d.hpp	/^        DescriptorCollection( const DescriptorCollection& collection );$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:( const DescriptorCollection& collection )
DescriptorCollection	features2d/features2d.hpp	/^        DescriptorCollection();$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:()
DescriptorCollection	features2d/features2d.hpp	/^    class CV_EXPORTS DescriptorCollection$/;"	c	class:cv::DescriptorMatcher	access:protected
DescriptorExtractor	features2d/features2d.hpp	/^class CV_EXPORTS DescriptorExtractor$/;"	c	namespace:cv
DescriptorMatcher	features2d/features2d.hpp	/^class CV_EXPORTS DescriptorMatcher$/;"	c	namespace:cv
DescriptorParams	features2d/features2d.hpp	/^        DescriptorParams( bool _recalculateAngles );$/;"	p	struct:cv::SIFT::DescriptorParams	access:public	signature:( bool _recalculateAngles )
DescriptorParams	features2d/features2d.hpp	/^        DescriptorParams( double _magnification, bool \/*_isNormalize*\/, bool _recalculateAngles );$/;"	p	struct:cv::SIFT::DescriptorParams	access:public	signature:( double _magnification, bool , bool _recalculateAngles )
DescriptorParams	features2d/features2d.hpp	/^        DescriptorParams();$/;"	p	struct:cv::SIFT::DescriptorParams	access:public	signature:()
DescriptorParams	features2d/features2d.hpp	/^    struct CV_EXPORTS DescriptorParams$/;"	s	class:cv::SIFT	access:public
Detect	legacy/blobtrack.hpp	/^    void Detect( const CvArr* \/*img*\/, \/* out *\/ CvBlobSeq* \/*detected_blob_seq*\/ = 0 );$/;"	p	class:CvObjectDetector	access:public	signature:( const CvArr* , CvBlobSeq* = 0 )
DetectNewBlob	legacy/blobtrack.hpp	/^    virtual int DetectNewBlob(IplImage* pImg, IplImage* pImgFG, CvBlobSeq* pNewBlobList, CvBlobSeq* pOldBlobList) = 0;$/;"	p	class:CvBlobDetector	access:public	signature:(IplImage* pImg, IplImage* pImgFG, CvBlobSeq* pNewBlobList, CvBlobSeq* pOldBlobList)
DetectorParams	features2d/features2d.hpp	/^        DetectorParams( double _threshold, double _edgeThreshold );$/;"	p	struct:cv::SIFT::DetectorParams	access:public	signature:( double _threshold, double _edgeThreshold )
DetectorParams	features2d/features2d.hpp	/^        DetectorParams();$/;"	p	struct:cv::SIFT::DetectorParams	access:public	signature:()
DetectorParams	features2d/features2d.hpp	/^    struct CV_EXPORTS DetectorParams$/;"	s	class:cv::SIFT	access:public
DevMem2D	gpu/devmem2d.hpp	/^        typedef DevMem2D_<unsigned char> DevMem2D;$/;"	t	namespace:cv::gpu
DevMem2D_	gpu/devmem2d.hpp	/^            DevMem2D_() : cols(0), rows(0), data(0), step(0) {}$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:()
DevMem2D_	gpu/devmem2d.hpp	/^            DevMem2D_(int rows_, int cols_, T *data_, size_t step_)$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:(int rows_, int cols_, T *data_, size_t step_)
DevMem2D_	gpu/devmem2d.hpp	/^            explicit DevMem2D_(const DevMem2D_<U>& d)$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:(const DevMem2D_<U>& d)
DevMem2D_	gpu/devmem2d.hpp	/^        template <typename T> struct DevMem2D_$/;"	s	namespace:cv::gpu
DevMem2Df	gpu/devmem2d.hpp	/^        typedef DevMem2D_<float> DevMem2Df;$/;"	t	namespace:cv::gpu
DevMem2Di	gpu/devmem2d.hpp	/^        typedef DevMem2D_<int> DevMem2Di;$/;"	t	namespace:cv::gpu
DeviceInfo	gpu/gpu.hpp	/^            DeviceInfo() : device_id_(getDevice()) { query(); }$/;"	f	class:cv::gpu::DeviceInfo	access:public	signature:()
DeviceInfo	gpu/gpu.hpp	/^            DeviceInfo(int device_id) : device_id_(device_id) { query(); }$/;"	f	class:cv::gpu::DeviceInfo	access:public	signature:(int device_id)
DeviceInfo	gpu/gpu.hpp	/^        class CV_EXPORTS DeviceInfo$/;"	c	namespace:cv::gpu
DisparityBilateralFilter	gpu/gpu.hpp	/^            DisparityBilateralFilter(int ndisp, int radius, int iters, float edge_threshold, float max_disc_threshold, float sigma_range);$/;"	p	class:cv::gpu::DisparityBilateralFilter	access:public	signature:(int ndisp, int radius, int iters, float edge_threshold, float max_disc_threshold, float sigma_range)
DisparityBilateralFilter	gpu/gpu.hpp	/^            explicit DisparityBilateralFilter(int ndisp = DEFAULT_NDISP, int radius = DEFAULT_RADIUS, int iters = DEFAULT_ITERS);$/;"	p	class:cv::gpu::DisparityBilateralFilter	access:public	signature:(int ndisp = DEFAULT_NDISP, int radius = DEFAULT_RADIUS, int iters = DEFAULT_ITERS)
DisparityBilateralFilter	gpu/gpu.hpp	/^        class CV_EXPORTS DisparityBilateralFilter$/;"	c	namespace:cv::gpu
DistIndex	flann/result_set.h	/^        DistIndex(DistanceType dist, unsigned int index) :$/;"	f	struct:cvflann::UniqueResultSet::DistIndex	access:public	signature:(DistanceType dist, unsigned int index)
DistIndex	flann/result_set.h	/^    struct DistIndex$/;"	s	class:cvflann::UniqueResultSet	access:public
DistIndex	flann/result_set.h	/^    typedef typename UniqueResultSet<DistanceType>::DistIndex DistIndex;$/;"	t	class:cvflann::KNNUniqueResultSet	access:protected
DistIndex	flann/result_set.h	/^    typedef typename UniqueResultSet<DistanceType>::DistIndex DistIndex;$/;"	t	class:cvflann::RadiusUniqueResultSet	access:private
DistType	gpu/gpu.hpp	/^            enum DistType {L1Dist = 0, L2Dist, HammingDist};$/;"	g	class:cv::gpu::BruteForceMatcher_GPU_base	access:public
DistanceType	flann/autotuned_index.h	/^    typedef typename Distance::ResultType DistanceType;$/;"	t	class:cvflann::AutotunedIndex	access:public
DistanceType	flann/composite_index.h	/^    typedef typename Distance::ResultType DistanceType;$/;"	t	class:cvflann::CompositeIndex	access:public
DistanceType	flann/flann.hpp	/^        typedef typename Distance::ResultType DistanceType;$/;"	t	class:cv::flann::GenericIndex	access:public
DistanceType	flann/flann.hpp	/^        typedef typename L2<T>::ResultType DistanceType;$/;"	t	class:cv::flann::Index_	access:public
DistanceType	flann/flann_base.hpp	/^    typedef typename Distance::ResultType DistanceType;$/;"	t	class:cvflann::Index	access:public
DistanceType	flann/hierarchical_clustering_index.h	/^    typedef typename Distance::ResultType DistanceType;$/;"	t	class:cvflann::HierarchicalClusteringIndex	access:public
DistanceType	flann/kdtree_index.h	/^    typedef typename Distance::ResultType DistanceType;$/;"	t	class:cvflann::KDTreeIndex	access:public
DistanceType	flann/kdtree_single_index.h	/^    typedef typename Distance::ResultType DistanceType;$/;"	t	class:cvflann::KDTreeSingleIndex	access:public
DistanceType	flann/kmeans_index.h	/^    typedef typename Distance::ResultType DistanceType;$/;"	t	class:cvflann::KMeansIndex	access:public
DistanceType	flann/linear_index.h	/^    typedef typename Distance::ResultType DistanceType;$/;"	t	class:cvflann::LinearIndex	access:public
DistanceType	flann/lsh_index.h	/^    typedef typename Distance::ResultType DistanceType;$/;"	t	class:cvflann::LshIndex	access:public
DistanceType	flann/nn_index.h	/^    typedef typename Distance::ResultType DistanceType;$/;"	t	class:cvflann::NNIndex	access:private
Double	legacy/blobtrack.hpp	/^    double              Double;$/;"	m	struct:CvDefParam	access:public
Draw	legacy/blobtrack.hpp	/^    IplImage* Draw( const CvArr* src, CvBlobSeq* blob_seq = 0, const CvSeq* roi_seq = 0 );$/;"	p	class:CvImageDrawer	access:public	signature:( const CvArr* src, CvBlobSeq* blob_seq = 0, const CvSeq* roi_seq = 0 )
DrawMatchesFlags	features2d/features2d.hpp	/^struct CV_EXPORTS DrawMatchesFlags$/;"	s	namespace:cv
DrawPoints	legacy/legacy.hpp	/^    virtual void DrawPoints( CvMat** dst );$/;"	p	class:CvCalibFilter	access:public	signature:( CvMat** dst )
DrawPoints	legacy/legacy.hpp	/^    virtual void DrawPoints( IplImage** dst );$/;"	p	class:CvCalibFilter	access:public	signature:( IplImage** dst )
DynamMatr	legacy/legacy.hpp	/^    float* DynamMatr;       \/* Matrix of the linear Dynamics system  *\/$/;"	m	struct:CvConDensation	access:public
DynamMatr	video/tracking.hpp	/^    float* DynamMatr;           \/* =transition_matrix->data.fl *\/$/;"	m	struct:CvKalman	access:public
DynamicAdaptedFeatureDetector	features2d/features2d.hpp	/^	DynamicAdaptedFeatureDetector(const DynamicAdaptedFeatureDetector&);$/;"	p	class:cv::DynamicAdaptedFeatureDetector	access:private	signature:(const DynamicAdaptedFeatureDetector&)
DynamicAdaptedFeatureDetector	features2d/features2d.hpp	/^    DynamicAdaptedFeatureDetector( const Ptr<AdjusterAdapter>& adjaster, int min_features=400, int max_features=500, int max_iters=5 );$/;"	p	class:cv::DynamicAdaptedFeatureDetector	access:public	signature:( const Ptr<AdjusterAdapter>& adjaster, int min_features=400, int max_features=500, int max_iters=5 )
DynamicAdaptedFeatureDetector	features2d/features2d.hpp	/^class CV_EXPORTS DynamicAdaptedFeatureDetector: public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
DynamicBitset	flann/dynamic_bitset.h	/^    DynamicBitset()$/;"	f	class:DynamicBitset	access:public	signature:()
DynamicBitset	flann/dynamic_bitset.h	/^    DynamicBitset(size_t size)$/;"	f	class:DynamicBitset	access:public	signature:(size_t size)
DynamicBitset	flann/dynamic_bitset.h	/^class DynamicBitset$/;"	c
DynamicBitset	flann/dynamic_bitset.h	/^typedef boost::dynamic_bitset<> DynamicBitset;$/;"	t
DynamicBitset::DynamicBitset	flann/dynamic_bitset.h	/^    DynamicBitset()$/;"	f	class:DynamicBitset	access:public	signature:()
DynamicBitset::DynamicBitset	flann/dynamic_bitset.h	/^    DynamicBitset(size_t size)$/;"	f	class:DynamicBitset	access:public	signature:(size_t size)
DynamicBitset::bitset_	flann/dynamic_bitset.h	/^    std::vector<size_t> bitset_;$/;"	m	class:DynamicBitset	access:private
DynamicBitset::cell_bit_size_	flann/dynamic_bitset.h	/^    static const unsigned int cell_bit_size_ = CHAR_BIT * sizeof(size_t);$/;"	m	class:DynamicBitset	access:private
DynamicBitset::clear	flann/dynamic_bitset.h	/^    void clear()$/;"	f	class:DynamicBitset	access:public	signature:()
DynamicBitset::empty	flann/dynamic_bitset.h	/^    bool empty() const$/;"	f	class:DynamicBitset	access:public	signature:() const
DynamicBitset::reset	flann/dynamic_bitset.h	/^    void reset()$/;"	f	class:DynamicBitset	access:public	signature:()
DynamicBitset::reset	flann/dynamic_bitset.h	/^    void reset(size_t index)$/;"	f	class:DynamicBitset	access:public	signature:(size_t index)
DynamicBitset::reset_block	flann/dynamic_bitset.h	/^    void reset_block(size_t index)$/;"	f	class:DynamicBitset	access:public	signature:(size_t index)
DynamicBitset::resize	flann/dynamic_bitset.h	/^    void resize(size_t size)$/;"	f	class:DynamicBitset	access:public	signature:(size_t size)
DynamicBitset::set	flann/dynamic_bitset.h	/^    void set(size_t index)$/;"	f	class:DynamicBitset	access:public	signature:(size_t index)
DynamicBitset::size	flann/dynamic_bitset.h	/^    size_t size() const$/;"	f	class:DynamicBitset	access:public	signature:() const
DynamicBitset::size_	flann/dynamic_bitset.h	/^    size_t size_;$/;"	m	class:DynamicBitset	access:private
DynamicBitset::test	flann/dynamic_bitset.h	/^    bool test(size_t index) const$/;"	f	class:DynamicBitset	access:public	signature:(size_t index) const
ELLIPSE	legacy/blobtrack.hpp	/^    enum {RECT, ELLIPSE} shape;$/;"	e	enum:CvDrawShape::__anon177
EMD	imgproc/imgproc.hpp	/^CV_EXPORTS float EMD( InputArray signature1, InputArray signature2,$/;"	p	namespace:cv	signature:( InputArray signature1, InputArray signature2, int distType, InputArray cost=noArray(), float* lowerBound=0, OutputArray flow=noArray() )
EMPTY	core/core.hpp	/^        EMPTY=32, \/\/!< empty structure (sequence or mapping)$/;"	e	enum:cv::FileNode::__anon149
EMParams	ml/ml.hpp	/^typedef CvEMParams EMParams;$/;"	t	namespace:cv
EPS	core/core.hpp	/^        EPS=2 \/\/!< the desired accuracy or change in parameters at which the iterative algorithm stops$/;"	e	enum:cv::TermCriteria::__anon139
EPS_SVR	ml/ml.hpp	/^    enum { C_SVC=100, NU_SVC=101, ONE_CLASS=102, EPS_SVR=103, NU_SVR=104 };$/;"	e	enum:CvSVM::__anon72
ERTree	ml/ml.hpp	/^typedef CvForestERTree ERTree;$/;"	t	namespace:cv
ERTreeTRainData	ml/ml.hpp	/^typedef CvERTreeTrainData ERTreeTRainData;$/;"	t	namespace:cv
ERTrees	ml/ml.hpp	/^typedef CvERTrees ERTrees;$/;"	t	namespace:cv
EUCLIDEAN	flann/defines.h	/^    EUCLIDEAN = 1,$/;"	e	enum:cvflann::flann_distance_t
EVENT_FLAG_ALTKEY	highgui/highgui.hpp	/^    EVENT_FLAG_ALTKEY    =32$/;"	e	enum:cv::__anon161
EVENT_FLAG_CTRLKEY	highgui/highgui.hpp	/^    EVENT_FLAG_CTRLKEY   =8,$/;"	e	enum:cv::__anon161
EVENT_FLAG_LBUTTON	highgui/highgui.hpp	/^    EVENT_FLAG_LBUTTON   =1,$/;"	e	enum:cv::__anon161
EVENT_FLAG_MBUTTON	highgui/highgui.hpp	/^    EVENT_FLAG_MBUTTON   =4,$/;"	e	enum:cv::__anon161
EVENT_FLAG_RBUTTON	highgui/highgui.hpp	/^    EVENT_FLAG_RBUTTON   =2,$/;"	e	enum:cv::__anon161
EVENT_FLAG_SHIFTKEY	highgui/highgui.hpp	/^    EVENT_FLAG_SHIFTKEY  =16,$/;"	e	enum:cv::__anon161
EVENT_LBUTTONDBLCLK	highgui/highgui.hpp	/^    EVENT_LBUTTONDBLCLK  =7,$/;"	e	enum:cv::__anon160
EVENT_LBUTTONDOWN	highgui/highgui.hpp	/^    EVENT_LBUTTONDOWN    =1,$/;"	e	enum:cv::__anon160
EVENT_LBUTTONUP	highgui/highgui.hpp	/^    EVENT_LBUTTONUP      =4,$/;"	e	enum:cv::__anon160
EVENT_MBUTTONDBLCLK	highgui/highgui.hpp	/^    EVENT_MBUTTONDBLCLK  =9$/;"	e	enum:cv::__anon160
EVENT_MBUTTONDOWN	highgui/highgui.hpp	/^    EVENT_MBUTTONDOWN    =3,$/;"	e	enum:cv::__anon160
EVENT_MBUTTONUP	highgui/highgui.hpp	/^    EVENT_MBUTTONUP      =6,$/;"	e	enum:cv::__anon160
EVENT_MOUSEMOVE	highgui/highgui.hpp	/^    EVENT_MOUSEMOVE      =0,$/;"	e	enum:cv::__anon160
EVENT_RBUTTONDBLCLK	highgui/highgui.hpp	/^    EVENT_RBUTTONDBLCLK  =8,$/;"	e	enum:cv::__anon160
EVENT_RBUTTONDOWN	highgui/highgui.hpp	/^    EVENT_RBUTTONDOWN    =2,$/;"	e	enum:cv::__anon160
EVENT_RBUTTONUP	highgui/highgui.hpp	/^    EVENT_RBUTTONUP      =5,$/;"	e	enum:cv::__anon160
EXIT	core/internal.hpp	96;"	d
EXPR	core/core.hpp	/^        STD_VECTOR_MAT=5<<KIND_SHIFT, EXPR=6<<KIND_SHIFT };$/;"	e	enum:cv::_InputArray::__anon134
ElementType	flann/autotuned_index.h	/^    typedef typename Distance::ElementType ElementType;$/;"	t	class:cvflann::AutotunedIndex	access:public
ElementType	flann/composite_index.h	/^    typedef typename Distance::ElementType ElementType;$/;"	t	class:cvflann::CompositeIndex	access:public
ElementType	flann/dist.h	/^    typedef T ElementType;$/;"	t	struct:cvflann::ChiSquareDistance	access:public
ElementType	flann/dist.h	/^    typedef T ElementType;$/;"	t	struct:cvflann::Hamming	access:public
ElementType	flann/dist.h	/^    typedef T ElementType;$/;"	t	struct:cvflann::Hamming2	access:public
ElementType	flann/dist.h	/^    typedef T ElementType;$/;"	t	struct:cvflann::HellingerDistance	access:public
ElementType	flann/dist.h	/^    typedef T ElementType;$/;"	t	struct:cvflann::HistIntersectionDistance	access:public
ElementType	flann/dist.h	/^    typedef T ElementType;$/;"	t	struct:cvflann::KL_Divergence	access:public
ElementType	flann/dist.h	/^    typedef T ElementType;$/;"	t	struct:cvflann::L1	access:public
ElementType	flann/dist.h	/^    typedef T ElementType;$/;"	t	struct:cvflann::L2	access:public
ElementType	flann/dist.h	/^    typedef T ElementType;$/;"	t	struct:cvflann::L2_Simple	access:public
ElementType	flann/dist.h	/^    typedef T ElementType;$/;"	t	struct:cvflann::MaxDistance	access:public
ElementType	flann/dist.h	/^    typedef T ElementType;$/;"	t	struct:cvflann::MinkowskiDistance	access:public
ElementType	flann/dist.h	/^    typedef unsigned char ElementType;$/;"	t	struct:cvflann::HammingLUT	access:public
ElementType	flann/flann.hpp	/^        typedef typename Distance::ElementType ElementType;$/;"	t	class:cv::flann::GenericIndex	access:public
ElementType	flann/flann.hpp	/^        typedef typename L2<T>::ElementType ElementType;$/;"	t	class:cv::flann::Index_	access:public
ElementType	flann/flann_base.hpp	/^    typedef typename Distance::ElementType ElementType;$/;"	t	class:cvflann::Index	access:public
ElementType	flann/hierarchical_clustering_index.h	/^    typedef typename Distance::ElementType ElementType;$/;"	t	class:cvflann::HierarchicalClusteringIndex	access:public
ElementType	flann/kdtree_index.h	/^    typedef typename Distance::ElementType ElementType;$/;"	t	class:cvflann::KDTreeIndex	access:public
ElementType	flann/kdtree_single_index.h	/^    typedef typename Distance::ElementType ElementType;$/;"	t	class:cvflann::KDTreeSingleIndex	access:public
ElementType	flann/kmeans_index.h	/^    typedef typename Distance::ElementType ElementType;$/;"	t	class:cvflann::KMeansIndex	access:public
ElementType	flann/linear_index.h	/^    typedef typename Distance::ElementType ElementType;$/;"	t	class:cvflann::LinearIndex	access:public
ElementType	flann/lsh_index.h	/^    typedef typename Distance::ElementType ElementType;$/;"	t	class:cvflann::LshIndex	access:public
ElementType	flann/nn_index.h	/^    typedef typename Distance::ElementType ElementType;$/;"	t	class:cvflann::NNIndex	access:private
EmptyMeshException	contrib/contrib.hpp	/^        struct EmptyMeshException {};$/;"	s	class:cv::Mesh3D	access:public
ErrorCallback	core/core.hpp	/^typedef int (CV_CDECL *ErrorCallback)( int status, const char* func_name,$/;"	t	namespace:cv
EstimatePose	features2d/features2d.hpp	/^    void EstimatePose(IplImage* patch, int& pose_idx, float& distance) const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(IplImage* patch, int& pose_idx, float& distance) const
EstimatePosePCA	features2d/features2d.hpp	/^    void EstimatePosePCA(CvArr* patch, int& pose_idx, float& distance, CvMat* avg, CvMat* eigenvalues) const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(CvArr* patch, int& pose_idx, float& distance, CvMat* avg, CvMat* eigenvalues) const
Exception	core/core.hpp	/^    Exception();$/;"	p	class:cv::Exception	access:public	signature:()
Exception	core/core.hpp	/^    Exception(int _code, const string& _err, const string& _func, const string& _file, int _line);$/;"	p	class:cv::Exception	access:public	signature:(int _code, const string& _err, const string& _func, const string& _file, int _line)
Exception	core/core.hpp	/^class CV_EXPORTS Exception : public std::exception$/;"	c	namespace:cv	inherits:std::exception
ExpectationMaximization	ml/ml.hpp	/^typedef CvEM ExpectationMaximization;$/;"	t	namespace:cv
FALSE	core/internal.hpp	88;"	d
FAST	features2d/features2d.hpp	/^CV_EXPORTS void FAST( const Mat& image, CV_OUT vector<KeyPoint>& keypoints,$/;"	p	namespace:cv	signature:( const Mat& image, CV_OUT vector<KeyPoint>& keypoints, int threshold, bool nonmaxSupression=true )
FEATURE_SET_COMPUTE_10	gpu/gpu.hpp	/^            FEATURE_SET_COMPUTE_10 = 10,$/;"	e	enum:cv::gpu::FeatureSet
FEATURE_SET_COMPUTE_11	gpu/gpu.hpp	/^            FEATURE_SET_COMPUTE_11 = 11,$/;"	e	enum:cv::gpu::FeatureSet
FEATURE_SET_COMPUTE_12	gpu/gpu.hpp	/^            FEATURE_SET_COMPUTE_12 = 12,$/;"	e	enum:cv::gpu::FeatureSet
FEATURE_SET_COMPUTE_13	gpu/gpu.hpp	/^            FEATURE_SET_COMPUTE_13 = 13,$/;"	e	enum:cv::gpu::FeatureSet
FEATURE_SET_COMPUTE_20	gpu/gpu.hpp	/^            FEATURE_SET_COMPUTE_20 = 20,$/;"	e	enum:cv::gpu::FeatureSet
FEATURE_SET_COMPUTE_21	gpu/gpu.hpp	/^            FEATURE_SET_COMPUTE_21 = 21,$/;"	e	enum:cv::gpu::FeatureSet
FGTrainFrames	legacy/blobtrack.hpp	/^    int                     FGTrainFrames; \/* Number of frames needed for FG (foreground) detector to train.        *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
FIND_BIGGEST_OBJECT	objdetect/objdetect.hpp	/^           FIND_BIGGEST_OBJECT = 4, DO_ROUGH_SEARCH = 8 };$/;"	e	enum:cv::CascadeClassifier::__anon201
FIRST_ANGLE	features2d/features2d.hpp	/^        enum { FIRST_ANGLE = 0, AVERAGE_ANGLE = 1 };$/;"	e	enum:cv::SIFT::CommonParams::__anon190
FISH_EYE_PRESET	calib3d/calib3d.hpp	/^        BASIC_PRESET=0, FISH_EYE_PRESET=1, NARROW_PRESET=2 };$/;"	e	enum:cv::StereoBM::__anon92
FLANNException	flann/general.h	/^    FLANNException(const char* message) : std::runtime_error(message) { }$/;"	f	class:cvflann::FLANNException	access:public	signature:(const char* message)
FLANNException	flann/general.h	/^    FLANNException(const std::string& message) : std::runtime_error(message) { }$/;"	f	class:cvflann::FLANNException	access:public	signature:(const std::string& message)
FLANNException	flann/general.h	/^class FLANNException : public std::runtime_error$/;"	c	namespace:cvflann	inherits:std::runtime_error
FLANN_ARRAY_LEN	flann/defines.h	75;"	d
FLANN_ARRAY_LEN	flann/defines.h	76;"	d
FLANN_BASE_HPP_	flann/flann_base.hpp	32;"	d
FLANN_CENTERS_GONZALES	flann/defines.h	/^    FLANN_CENTERS_GONZALES = 1,$/;"	e	enum:cvflann::flann_centers_init_t
FLANN_CENTERS_KMEANSPP	flann/defines.h	/^    FLANN_CENTERS_KMEANSPP = 2,$/;"	e	enum:cvflann::flann_centers_init_t
FLANN_CENTERS_RANDOM	flann/defines.h	/^    FLANN_CENTERS_RANDOM = 0,$/;"	e	enum:cvflann::flann_centers_init_t
FLANN_CHECKS_AUTOTUNED	flann/defines.h	/^    FLANN_CHECKS_AUTOTUNED = -2$/;"	e	enum:cvflann::__anon205
FLANN_CHECKS_UNLIMITED	flann/defines.h	/^    FLANN_CHECKS_UNLIMITED = -1,$/;"	e	enum:cvflann::__anon205
FLANN_DEPRECATED	flann/defines.h	54;"	d
FLANN_DEPRECATED	flann/defines.h	57;"	d
FLANN_DEPRECATED	flann/defines.h	59;"	d
FLANN_DEPRECATED	flann/defines.h	62;"	d
FLANN_DISTANCE_CHECK	flann/flann.hpp	130;"	d
FLANN_DIST_CHI_SQUARE	flann/defines.h	/^    FLANN_DIST_CHI_SQUARE = 7,$/;"	e	enum:cvflann::flann_distance_t
FLANN_DIST_CS	flann/defines.h	/^    FLANN_DIST_CS         = 7,$/;"	e	enum:cvflann::flann_distance_t
FLANN_DIST_EUCLIDEAN	flann/defines.h	/^    FLANN_DIST_EUCLIDEAN = 1,$/;"	e	enum:cvflann::flann_distance_t
FLANN_DIST_HELLINGER	flann/defines.h	/^    FLANN_DIST_HELLINGER = 6,$/;"	e	enum:cvflann::flann_distance_t
FLANN_DIST_HIST_INTERSECT	flann/defines.h	/^    FLANN_DIST_HIST_INTERSECT   = 5,$/;"	e	enum:cvflann::flann_distance_t
FLANN_DIST_KL	flann/defines.h	/^    FLANN_DIST_KL                = 8,$/;"	e	enum:cvflann::flann_distance_t
FLANN_DIST_KULLBACK_LEIBLER	flann/defines.h	/^    FLANN_DIST_KULLBACK_LEIBLER  = 8,$/;"	e	enum:cvflann::flann_distance_t
FLANN_DIST_L1	flann/defines.h	/^    FLANN_DIST_L1 = 2,$/;"	e	enum:cvflann::flann_distance_t
FLANN_DIST_L2	flann/defines.h	/^    FLANN_DIST_L2 = 1,$/;"	e	enum:cvflann::flann_distance_t
FLANN_DIST_MANHATTAN	flann/defines.h	/^    FLANN_DIST_MANHATTAN = 2,$/;"	e	enum:cvflann::flann_distance_t
FLANN_DIST_MAX	flann/defines.h	/^    FLANN_DIST_MAX   = 4,$/;"	e	enum:cvflann::flann_distance_t
FLANN_DIST_MINKOWSKI	flann/defines.h	/^    FLANN_DIST_MINKOWSKI = 3,$/;"	e	enum:cvflann::flann_distance_t
FLANN_EXPORT	flann/defines.h	36;"	d
FLANN_EXPORT	flann/defines.h	41;"	d
FLANN_EXPORT	flann/defines.h	43;"	d
FLANN_EXPORT	flann/defines.h	45;"	d
FLANN_EXPORT	flann/defines.h	49;"	d
FLANN_FLOAT32	flann/defines.h	/^    FLANN_FLOAT32 = 8,$/;"	e	enum:cvflann::flann_datatype_t
FLANN_FLOAT64	flann/defines.h	/^    FLANN_FLOAT64 = 9$/;"	e	enum:cvflann::flann_datatype_t
FLANN_INDEX_AUTOTUNED	flann/defines.h	/^    FLANN_INDEX_AUTOTUNED = 255,$/;"	e	enum:cvflann::flann_algorithm_t
FLANN_INDEX_COMPOSITE	flann/defines.h	/^    FLANN_INDEX_COMPOSITE = 3,$/;"	e	enum:cvflann::flann_algorithm_t
FLANN_INDEX_HIERARCHICAL	flann/defines.h	/^    FLANN_INDEX_HIERARCHICAL = 5,$/;"	e	enum:cvflann::flann_algorithm_t
FLANN_INDEX_KDTREE	flann/defines.h	/^    FLANN_INDEX_KDTREE = 1,$/;"	e	enum:cvflann::flann_algorithm_t
FLANN_INDEX_KDTREE_SINGLE	flann/defines.h	/^    FLANN_INDEX_KDTREE_SINGLE = 4,$/;"	e	enum:cvflann::flann_algorithm_t
FLANN_INDEX_KMEANS	flann/defines.h	/^    FLANN_INDEX_KMEANS = 2,$/;"	e	enum:cvflann::flann_algorithm_t
FLANN_INDEX_LINEAR	flann/defines.h	/^    FLANN_INDEX_LINEAR = 0,$/;"	e	enum:cvflann::flann_algorithm_t
FLANN_INDEX_LSH	flann/defines.h	/^    FLANN_INDEX_LSH = 6,$/;"	e	enum:cvflann::flann_algorithm_t
FLANN_INDEX_SAVED	flann/defines.h	/^    FLANN_INDEX_SAVED = 254,$/;"	e	enum:cvflann::flann_algorithm_t
FLANN_INT16	flann/defines.h	/^    FLANN_INT16 = 1,$/;"	e	enum:cvflann::flann_datatype_t
FLANN_INT32	flann/defines.h	/^    FLANN_INT32 = 2,$/;"	e	enum:cvflann::flann_datatype_t
FLANN_INT64	flann/defines.h	/^    FLANN_INT64 = 3,$/;"	e	enum:cvflann::flann_datatype_t
FLANN_INT8	flann/defines.h	/^    FLANN_INT8 = 0,$/;"	e	enum:cvflann::flann_datatype_t
FLANN_LOGGER_H	flann/logger.h	32;"	d
FLANN_LOG_ERROR	flann/defines.h	/^    FLANN_LOG_ERROR = 2,$/;"	e	enum:cvflann::flann_log_level_t
FLANN_LOG_FATAL	flann/defines.h	/^    FLANN_LOG_FATAL = 1,$/;"	e	enum:cvflann::flann_log_level_t
FLANN_LOG_INFO	flann/defines.h	/^    FLANN_LOG_INFO = 4,$/;"	e	enum:cvflann::flann_log_level_t
FLANN_LOG_NONE	flann/defines.h	/^    FLANN_LOG_NONE = 0,$/;"	e	enum:cvflann::flann_log_level_t
FLANN_LOG_WARN	flann/defines.h	/^    FLANN_LOG_WARN = 3,$/;"	e	enum:cvflann::flann_log_level_t
FLANN_NNINDEX_H	flann/nn_index.h	32;"	d
FLANN_PLATFORM_32_BIT	flann/defines.h	66;"	d
FLANN_PLATFORM_32_BIT	flann/defines.h	71;"	d
FLANN_PLATFORM_64_BIT	flann/defines.h	67;"	d
FLANN_PLATFORM_64_BIT	flann/defines.h	69;"	d
FLANN_RANDOM_H	flann/random.h	32;"	d
FLANN_RESULTSET_H	flann/result_set.h	32;"	d
FLANN_SIGNATURE_	flann/saving.h	39;"	d
FLANN_SIGNATURE_	flann/saving.h	41;"	d
FLANN_TIMER_H	flann/timer.h	32;"	d
FLANN_UINT16	flann/defines.h	/^    FLANN_UINT16 = 5,$/;"	e	enum:cvflann::flann_datatype_t
FLANN_UINT32	flann/defines.h	/^    FLANN_UINT32 = 6,$/;"	e	enum:cvflann::flann_datatype_t
FLANN_UINT64	flann/defines.h	/^    FLANN_UINT64 = 7,$/;"	e	enum:cvflann::flann_datatype_t
FLANN_UINT8	flann/defines.h	/^    FLANN_UINT8 = 4,$/;"	e	enum:cvflann::flann_datatype_t
FLANN_VERSION_	flann/config.h	34;"	d
FLANN_VERSION_	flann/config.h	36;"	d
FLOAT	core/core.hpp	/^        FLOAT=REAL, \/\/!< synonym or REAL$/;"	e	enum:cv::FileNode::__anon149
FLOODFILL_FIXED_RANGE	imgproc/imgproc.hpp	/^enum { FLOODFILL_FIXED_RANGE = 1 << 16, FLOODFILL_MASK_ONLY = 1 << 17 };$/;"	e	enum:cv::__anon22
FLOODFILL_MASK_ONLY	imgproc/imgproc.hpp	/^enum { FLOODFILL_FIXED_RANGE = 1 << 16, FLOODFILL_MASK_ONLY = 1 << 17 };$/;"	e	enum:cv::__anon22
FLOW	core/core.hpp	/^        FLOW=8, \/\/!< compact representation of a sequence or mapping. Used only by YAML writer$/;"	e	enum:cv::FileNode::__anon149
FMG	contrib/contrib.hpp	/^		void FMG(Mat &I1, Mat &I2, Mat &I2x, Mat &u, int level);$/;"	p	class:cv::StereoVar	access:private	signature:(Mat &I1, Mat &I2, Mat &I2x, Mat &u, int level)
FM_7POINT	calib3d/calib3d.hpp	/^    FM_7POINT = CV_FM_7POINT, \/\/!< 7-point algorithm$/;"	e	enum:cv::__anon91
FM_8POINT	calib3d/calib3d.hpp	/^    FM_8POINT = CV_FM_8POINT, \/\/!< 8-point algorithm$/;"	e	enum:cv::__anon91
FM_LMEDS	calib3d/calib3d.hpp	/^    FM_LMEDS = CV_FM_LMEDS,  \/\/!< least-median algorithm$/;"	e	enum:cv::__anon91
FM_RANSAC	calib3d/calib3d.hpp	/^    FM_RANSAC = CV_FM_RANSAC  \/\/!< RANSAC algorithm$/;"	e	enum:cv::__anon91
FONT_HERSHEY_COMPLEX	core/core.hpp	/^    FONT_HERSHEY_COMPLEX = 3,$/;"	e	enum:cv::__anon144
FONT_HERSHEY_COMPLEX_SMALL	core/core.hpp	/^    FONT_HERSHEY_COMPLEX_SMALL = 5,$/;"	e	enum:cv::__anon144
FONT_HERSHEY_DUPLEX	core/core.hpp	/^    FONT_HERSHEY_DUPLEX = 2,$/;"	e	enum:cv::__anon144
FONT_HERSHEY_PLAIN	core/core.hpp	/^    FONT_HERSHEY_PLAIN = 1,$/;"	e	enum:cv::__anon144
FONT_HERSHEY_SCRIPT_COMPLEX	core/core.hpp	/^    FONT_HERSHEY_SCRIPT_COMPLEX = 7,$/;"	e	enum:cv::__anon144
FONT_HERSHEY_SCRIPT_SIMPLEX	core/core.hpp	/^    FONT_HERSHEY_SCRIPT_SIMPLEX = 6,$/;"	e	enum:cv::__anon144
FONT_HERSHEY_SIMPLEX	core/core.hpp	/^    FONT_HERSHEY_SIMPLEX = 0,$/;"	e	enum:cv::__anon144
FONT_HERSHEY_TRIPLEX	core/core.hpp	/^    FONT_HERSHEY_TRIPLEX = 4,$/;"	e	enum:cv::__anon144
FONT_ITALIC	core/core.hpp	/^    FONT_ITALIC = 16$/;"	e	enum:cv::__anon144
FULL_UV	core/core.hpp	/^    enum { MODIFY_A=1, NO_UV=2, FULL_UV=4 };$/;"	e	enum:cv::SVD::__anon142
False	flann/dist.h	/^class False$/;"	c	namespace:cvflann
FastAdjuster	features2d/features2d.hpp	/^    FastAdjuster(int init_thresh=20, bool nonmax=true, int min_thresh=1, int max_thresh=200);$/;"	p	class:cv::FastAdjuster	access:public	signature:(int init_thresh=20, bool nonmax=true, int min_thresh=1, int max_thresh=200)
FastAdjuster	features2d/features2d.hpp	/^class CV_EXPORTS FastAdjuster: public AdjusterAdapter$/;"	c	namespace:cv	inherits:AdjusterAdapter
FastFeatureDetector	features2d/features2d.hpp	/^    FastFeatureDetector( int threshold=10, bool nonmaxSuppression=true );$/;"	p	class:cv::FastFeatureDetector	access:public	signature:( int threshold=10, bool nonmaxSuppression=true )
FastFeatureDetector	features2d/features2d.hpp	/^class CV_EXPORTS FastFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
Fbd	video/background_segm.hpp	/^    IplImage*              Fbd;$/;"	m	struct:CvFGDStatModel	access:public
Feature	features2d/features2d.hpp	/^        Feature() : x1(0), y1(0), x2(0), y2(0) {}$/;"	f	struct:cv::FernClassifier::Feature	access:public	signature:()
Feature	features2d/features2d.hpp	/^        Feature(int _x1, int _y1, int _x2, int _y2)$/;"	f	struct:cv::FernClassifier::Feature	access:public	signature:(int _x1, int _y1, int _x2, int _y2)
Feature	features2d/features2d.hpp	/^    struct Feature$/;"	s	class:cv::FernClassifier	access:public
FeatureDetector	features2d/features2d.hpp	/^class CV_EXPORTS FeatureDetector$/;"	c	namespace:cv
FeatureEvaluator	objdetect/objdetect.hpp	/^class CV_EXPORTS FeatureEvaluator$/;"	c	namespace:cv
FeatureIndex	flann/lsh_table.h	/^typedef uint32_t FeatureIndex;$/;"	t	namespace:cvflann::lsh
FeatureSet	gpu/gpu.hpp	/^        enum FeatureSet$/;"	g	namespace:cv::gpu
FernClassifier	features2d/features2d.hpp	/^    FernClassifier();$/;"	p	class:cv::FernClassifier	access:public	signature:()
FernClassifier	features2d/features2d.hpp	/^    FernClassifier(const FileNode& node);$/;"	p	class:cv::FernClassifier	access:public	signature:(const FileNode& node)
FernClassifier	features2d/features2d.hpp	/^    FernClassifier(const vector<vector<Point2f> >& points,$/;"	p	class:cv::FernClassifier	access:public	signature:(const vector<vector<Point2f> >& points, const vector<Mat>& refimgs, const vector<vector<int> >& labels=vector<vector<int> >(), int _nclasses=0, int _patchSize=PATCH_SIZE, int _signatureSize=DEFAULT_SIGNATURE_SIZE, int _nstructs=DEFAULT_STRUCTS, int _structSize=DEFAULT_STRUCT_SIZE, int _nviews=DEFAULT_VIEWS, int _compressionMethod=COMPRESSION_NONE, const PatchGenerator& patchGenerator=PatchGenerator())
FernClassifier	features2d/features2d.hpp	/^class CV_EXPORTS FernClassifier$/;"	c	namespace:cv
FernDescriptorMatch	features2d/features2d.hpp	/^typedef FernDescriptorMatcher FernDescriptorMatch;$/;"	t	namespace:cv
FernDescriptorMatcher	features2d/features2d.hpp	/^    FernDescriptorMatcher( const Params& params=Params() );$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:( const Params& params=Params() )
FernDescriptorMatcher	features2d/features2d.hpp	/^class CV_EXPORTS FernDescriptorMatcher : public GenericDescriptorMatcher$/;"	c	namespace:cv	inherits:GenericDescriptorMatcher
FileNode	core/core.hpp	/^    CV_WRAP FileNode();$/;"	p	class:cv::FileNode	access:public	signature:()
FileNode	core/core.hpp	/^    FileNode(const CvFileStorage* fs, const CvFileNode* node);$/;"	p	class:cv::FileNode	access:public	signature:(const CvFileStorage* fs, const CvFileNode* node)
FileNode	core/core.hpp	/^    FileNode(const FileNode& node);$/;"	p	class:cv::FileNode	access:public	signature:(const FileNode& node)
FileNode	core/core.hpp	/^class CV_EXPORTS FileNode;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
FileNode	core/core.hpp	/^class CV_EXPORTS_W_SIMPLE FileNode$/;"	c	namespace:cv
FileNode	core/operations.hpp	/^inline FileNode::FileNode() : fs(0), node(0) {}$/;"	f	class:cv::FileNode	signature:()
FileNode	core/operations.hpp	/^inline FileNode::FileNode(const CvFileStorage* _fs, const CvFileNode* _node)$/;"	f	class:cv::FileNode	signature:(const CvFileStorage* _fs, const CvFileNode* _node)
FileNode	core/operations.hpp	/^inline FileNode::FileNode(const FileNode& _node) : fs(_node.fs), node(_node.node) {}$/;"	f	class:cv::FileNode	signature:(const FileNode& _node)
FileNodeIterator	core/core.hpp	/^    FileNodeIterator();$/;"	p	class:cv::FileNodeIterator	access:public	signature:()
FileNodeIterator	core/core.hpp	/^    FileNodeIterator(const CvFileStorage* fs, const CvFileNode* node, size_t ofs=0);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(const CvFileStorage* fs, const CvFileNode* node, size_t ofs=0)
FileNodeIterator	core/core.hpp	/^    FileNodeIterator(const FileNodeIterator& it);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(const FileNodeIterator& it)
FileNodeIterator	core/core.hpp	/^class CV_EXPORTS FileNodeIterator$/;"	c	namespace:cv
FileNodeIterator	core/core.hpp	/^class CV_EXPORTS FileNodeIterator;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
FileStorage	core/core.hpp	/^    CV_WRAP FileStorage();$/;"	p	class:cv::FileStorage	access:public	signature:()
FileStorage	core/core.hpp	/^    CV_WRAP FileStorage(const string& filename, int flags, const string& encoding=string());$/;"	p	class:cv::FileStorage	access:public	signature:(const string& filename, int flags, const string& encoding=string())
FileStorage	core/core.hpp	/^    FileStorage(CvFileStorage* fs);$/;"	p	class:cv::FileStorage	access:public	signature:(CvFileStorage* fs)
FileStorage	core/core.hpp	/^class CV_EXPORTS_W FileStorage$/;"	c	namespace:cv
FilterEngine	imgproc/imgproc.hpp	/^    FilterEngine();$/;"	p	class:cv::FilterEngine	access:public	signature:()
FilterEngine	imgproc/imgproc.hpp	/^    FilterEngine(const Ptr<BaseFilter>& _filter2D,$/;"	p	class:cv::FilterEngine	access:public	signature:(const Ptr<BaseFilter>& _filter2D, const Ptr<BaseRowFilter>& _rowFilter, const Ptr<BaseColumnFilter>& _columnFilter, int srcType, int dstType, int bufType, int _rowBorderType=BORDER_REPLICATE, int _columnBorderType=-1, const Scalar& _borderValue=Scalar())
FilterEngine	imgproc/imgproc.hpp	/^class CV_EXPORTS FilterEngine$/;"	c	namespace:cv
FilterEngine_GPU	gpu/gpu.hpp	/^        class CV_EXPORTS FilterEngine_GPU$/;"	c	namespace:cv::gpu
FindDescriptor	features2d/features2d.hpp	/^    void FindDescriptor(IplImage* patch, int n, std::vector<int>& desc_idxs, std::vector<int>& pose_idxs,$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(IplImage* patch, int n, std::vector<int>& desc_idxs, std::vector<int>& pose_idxs, std::vector<float>& distances, std::vector<float>& _scales, float* scale_ranges = 0) const
FindDescriptor	features2d/features2d.hpp	/^    void FindDescriptor(IplImage* patch, int& desc_idx, int& pose_idx, float& distance, float* _scale = 0, float* scale_ranges = 0) const;$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(IplImage* patch, int& desc_idx, int& pose_idx, float& distance, float* _scale = 0, float* scale_ranges = 0) const
FindDescriptor	features2d/features2d.hpp	/^    void FindDescriptor(IplImage* src, cv::Point2f pt, int& desc_idx, int& pose_idx, float& distance) const;$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(IplImage* src, cv::Point2f pt, int& desc_idx, int& pose_idx, float& distance) const
FindEtalon	legacy/legacy.hpp	/^    virtual bool FindEtalon( CvMat** imgs );$/;"	p	class:CvCalibFilter	access:public	signature:( CvMat** imgs )
FindEtalon	legacy/legacy.hpp	/^    virtual bool FindEtalon( IplImage** imgs );$/;"	p	class:CvCalibFilter	access:public	signature:( IplImage** imgs )
FlannBasedMatcher	features2d/features2d.hpp	/^    FlannBasedMatcher( const Ptr<flann::IndexParams>& indexParams=new flann::KDTreeIndexParams(),$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:( const Ptr<flann::IndexParams>& indexParams=new flann::KDTreeIndexParams(), const Ptr<flann::SearchParams>& searchParams=new flann::SearchParams() )
FlannBasedMatcher	features2d/features2d.hpp	/^class CV_EXPORTS FlannBasedMatcher : public DescriptorMatcher$/;"	c	namespace:cv	inherits:DescriptorMatcher
Float	legacy/blobtrack.hpp	/^    float               Float;$/;"	m	struct:CvDefParam	access:public
ForestTree	ml/ml.hpp	/^typedef CvForestTree ForestTree;$/;"	t	namespace:cv
Formatted	core/operations.hpp	/^    Formatted(const Mat& m, const Formatter* fmt,$/;"	p	struct:cv::Formatted	access:public	signature:(const Mat& m, const Formatter* fmt, const int* params=0)
Formatted	core/operations.hpp	/^    Formatted(const Mat& m, const Formatter* fmt,$/;"	p	struct:cv::Formatted	access:public	signature:(const Mat& m, const Formatter* fmt, const vector<int>& params)
Formatted	core/operations.hpp	/^struct CV_EXPORTS Formatted$/;"	s	namespace:cv
Formatter	core/operations.hpp	/^class CV_EXPORTS Formatter$/;"	c	namespace:cv
FreeParam	legacy/blobtrack.hpp	/^    void    FreeParam(CvDefParam** pp);$/;"	p	class:CvVSModule	access:private	signature:(CvDefParam** pp)
Ftd	video/background_segm.hpp	/^    IplImage*              Ftd;$/;"	m	struct:CvFGDStatModel	access:public
FuzzyResizer	contrib/contrib.hpp	/^        FuzzyResizer();$/;"	p	class:CvFuzzyMeanShiftTracker::FuzzyResizer	access:public	signature:()
FuzzyResizer	contrib/contrib.hpp	/^    class FuzzyResizer$/;"	c	class:CvFuzzyMeanShiftTracker	access:private
G	ml/ml.hpp	/^    double* G;$/;"	m	class:CvSVMSolver	access:public
GAMMA	ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon74
GAUSSIAN	ml/ml.hpp	/^    enum { IDENTITY = 0, SIGMOID_SYM = 1, GAUSSIAN = 2 };$/;"	e	enum:CvANN_MLP::__anon83
GC_BGD	imgproc/imgproc.hpp	/^    GC_BGD    = 0,  \/\/!< background$/;"	e	enum:cv::__anon19
GC_EVAL	imgproc/imgproc.hpp	/^    GC_EVAL            = 2$/;"	e	enum:cv::__anon20
GC_FGD	imgproc/imgproc.hpp	/^    GC_FGD    = 1,  \/\/!< foreground$/;"	e	enum:cv::__anon19
GC_INIT_WITH_MASK	imgproc/imgproc.hpp	/^    GC_INIT_WITH_MASK  = 1,$/;"	e	enum:cv::__anon20
GC_INIT_WITH_RECT	imgproc/imgproc.hpp	/^    GC_INIT_WITH_RECT  = 0,$/;"	e	enum:cv::__anon20
GC_PR_BGD	imgproc/imgproc.hpp	/^    GC_PR_BGD = 2,  \/\/!< most probably background$/;"	e	enum:cv::__anon19
GC_PR_FGD	imgproc/imgproc.hpp	/^    GC_PR_FGD = 3   \/\/!< most probably foreground $/;"	e	enum:cv::__anon19
GEMM_1_T	core/core.hpp	/^enum { GEMM_1_T=1, GEMM_2_T=2, GEMM_3_T=4 };$/;"	e	enum:cv::__anon100
GEMM_2_T	core/core.hpp	/^enum { GEMM_1_T=1, GEMM_2_T=2, GEMM_3_T=4 };$/;"	e	enum:cv::__anon100
GEMM_3_T	core/core.hpp	/^enum { GEMM_1_T=1, GEMM_2_T=2, GEMM_3_T=4 };$/;"	e	enum:cv::__anon100
GENTLE	ml/ml.hpp	/^    enum { DISCRETE=0, REAL=1, LOGIT=2, GENTLE=3 };$/;"	e	enum:CvBoost::__anon79
GET_DEFAULT_EDGE_THRESHOLD	features2d/features2d.hpp	/^        static double GET_DEFAULT_EDGE_THRESHOLD() { return 10.0; }$/;"	f	struct:cv::SIFT::DetectorParams	access:public	signature:()
GET_DEFAULT_MAGNIFICATION	features2d/features2d.hpp	/^        static double GET_DEFAULT_MAGNIFICATION() { return 3.0; }$/;"	f	struct:cv::SIFT::DescriptorParams	access:public	signature:()
GET_DEFAULT_THRESHOLD	features2d/features2d.hpp	/^        static double GET_DEFAULT_THRESHOLD() { return 0.04; }$/;"	f	struct:cv::SIFT::DetectorParams	access:public	signature:()
GET_LOWER_QUANT_PERC	features2d/features2d.hpp	/^  static float GET_LOWER_QUANT_PERC() { return .03f; }$/;"	f	class:cv::RandomizedTree	access:public	signature:()
GET_MAX_SCALE	features2d/features2d.hpp	/^        static float GET_MAX_SCALE() { return 1.5f; }$/;"	f	class:cv::OneWayDescriptorMatcher::Params	access:public	signature:()
GET_MIN_SCALE	features2d/features2d.hpp	/^        static float GET_MIN_SCALE() { return 0.7f; }$/;"	f	class:cv::OneWayDescriptorMatcher::Params	access:public	signature:()
GET_STEP_SCALE	features2d/features2d.hpp	/^        static float GET_STEP_SCALE() { return 1.2f; }$/;"	f	class:cv::OneWayDescriptorMatcher::Params	access:public	signature:()
GET_UPPER_QUANT_PERC	features2d/features2d.hpp	/^  static float GET_UPPER_QUANT_PERC() { return .92f; }$/;"	f	class:cv::RandomizedTree	access:public	signature:()
GINI	ml/ml.hpp	/^    enum { DEFAULT=0, GINI=1, MISCLASS=3, SQERR=4 };$/;"	e	enum:CvBoost::__anon80
GLOBAL_ATOMICS	gpu/gpu.hpp	/^            GLOBAL_ATOMICS = FEATURE_SET_COMPUTE_11,$/;"	e	enum:cv::gpu::FeatureSet
GSD_HUE_LT	contrib/contrib.hpp	/^        GSD_HUE_LT = 3,$/;"	e	enum:CvAdaptiveSkinDetector::__anon1
GSD_HUE_UT	contrib/contrib.hpp	/^        GSD_HUE_UT = 33,$/;"	e	enum:CvAdaptiveSkinDetector::__anon1
GSD_INTENSITY_LT	contrib/contrib.hpp	/^        GSD_INTENSITY_LT = 15,$/;"	e	enum:CvAdaptiveSkinDetector::__anon1
GSD_INTENSITY_UT	contrib/contrib.hpp	/^        GSD_INTENSITY_UT = 250$/;"	e	enum:CvAdaptiveSkinDetector::__anon1
GaussianBlur	gpu/gpu.hpp	/^        CV_EXPORTS void GaussianBlur(const GpuMat& src, GpuMat& dst, Size ksize, double sigma1, double sigma2 = 0,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Size ksize, double sigma1, double sigma2 = 0, int rowBorderType = BORDER_DEFAULT, int columnBorderType = -1, Stream& stream = Stream::Null())
GaussianBlur	imgproc/imgproc.hpp	/^CV_EXPORTS_W void GaussianBlur( InputArray src,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, Size ksize, double sigma1, double sigma2=0, int borderType=BORDER_DEFAULT )
GeneratePCA	features2d/features2d.hpp	/^    void GeneratePCA(const char* img_path, const char* images_list, int pose_count=500);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(const char* img_path, const char* images_list, int pose_count=500)
GenerateSamples	features2d/features2d.hpp	/^    void GenerateSamples(int pose_count, IplImage* frontal, int norm = 0);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int pose_count, IplImage* frontal, int norm = 0)
GenerateSamplesFast	features2d/features2d.hpp	/^    void GenerateSamplesFast(IplImage* frontal, CvMat* pca_hr_avg,$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(IplImage* frontal, CvMat* pca_hr_avg, CvMat* pca_hr_eigenvectors, OneWayDescriptor* pca_descriptors)
GenericDescriptorMatch	features2d/features2d.hpp	/^typedef GenericDescriptorMatcher GenericDescriptorMatch;$/;"	t	namespace:cv
GenericDescriptorMatcher	features2d/features2d.hpp	/^    GenericDescriptorMatcher();$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:()
GenericDescriptorMatcher	features2d/features2d.hpp	/^class CV_EXPORTS GenericDescriptorMatcher$/;"	c	namespace:cv
GenericIndex	flann/flann.hpp	/^        GenericIndex(const Mat& features, const ::cvflann::IndexParams& params, Distance distance = Distance());$/;"	p	class:cv::flann::GenericIndex	access:public	signature:(const Mat& features, const ::cvflann::IndexParams& params, Distance distance = Distance())
GenericIndex	flann/flann.hpp	/^GenericIndex<Distance>::GenericIndex(const Mat& dataset, const ::cvflann::IndexParams& params, Distance distance)$/;"	f	class:cv::flann::GenericIndex	signature:(const Mat& dataset, const ::cvflann::IndexParams& params, Distance distance)
GenericIndex	flann/flann.hpp	/^class GenericIndex $/;"	c	namespace:cv::flann
GetBlob	legacy/blobtrack.hpp	/^    virtual CvBlob*     GetBlob(int index) = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:(int index)
GetBlob	legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlob(int BlobIndex) = 0;$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobIndex)
GetBlob	legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlob(int BlobIndex)$/;"	f	class:CvBlobSeq	access:public	signature:(int BlobIndex)
GetBlob	legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlob(int index) = 0;$/;"	p	class:CvBlobTrackPostProc	access:public	signature:(int index)
GetBlobByID	legacy/blobtrack.hpp	/^    virtual CvBlob*     GetBlobByID(int ID) = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:(int ID)
GetBlobByID	legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlobByID(int BlobID)$/;"	f	class:CvBlobSeq	access:public	signature:(int BlobID)
GetBlobByID	legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlobByID(int BlobID)$/;"	f	class:CvBlobTrackPostProc	access:public	signature:(int BlobID)
GetBlobByID	legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlobByID(int BlobID);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobID)
GetBlobHyp	legacy/blobtrack.hpp	/^    virtual CvBlob* GetBlobHyp(int BlobIndex, int \/*hypothesis*\/);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobIndex, int )
GetBlobHypNum	legacy/blobtrack.hpp	/^    virtual int     GetBlobHypNum(int \/*BlobIdx*\/);$/;"	p	class:CvBlobTracker	access:public	signature:(int )
GetBlobIndexByID	legacy/blobtrack.hpp	/^    virtual int     GetBlobIndexByID(int BlobID);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobID)
GetBlobNum	legacy/blobtrack.hpp	/^    virtual int         GetBlobNum() = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:()
GetBlobNum	legacy/blobtrack.hpp	/^    virtual int     GetBlobNum() = 0;$/;"	p	class:CvBlobTrackPostProc	access:public	signature:()
GetBlobNum	legacy/blobtrack.hpp	/^    virtual int     GetBlobNum() = 0;$/;"	p	class:CvBlobTracker	access:public	signature:()
GetBlobNum	legacy/blobtrack.hpp	/^    virtual int GetBlobNum()$/;"	f	class:CvBlobSeq	access:public	signature:()
GetBlobTrack	legacy/blobtrack.hpp	/^    virtual CvBlobTrack* GetBlobTrack(int TrackIndex);$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackIndex)
GetBlobTrackByID	legacy/blobtrack.hpp	/^    virtual CvBlobTrack* GetBlobTrackByID(int TrackID);$/;"	p	class:CvBlobTrackSeq	access:public	signature:(int TrackID)
GetBlobTrackNum	legacy/blobtrack.hpp	/^    virtual int GetBlobTrackNum();$/;"	p	class:CvBlobTrackSeq	access:public	signature:()
GetCameraCount	legacy/legacy.hpp	/^    int GetCameraCount() const { return cameraCount; }$/;"	f	class:CvCalibFilter	access:public	signature:() const
GetCameraParams	legacy/legacy.hpp	/^    virtual const CvCamera* GetCameraParams( int idx = 0 ) const;$/;"	p	class:CvCalibFilter	access:public	signature:( int idx = 0 ) const
GetCenter	features2d/features2d.hpp	/^    CvPoint GetCenter() const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:() const
GetConfidence	legacy/blobtrack.hpp	/^    virtual double  GetConfidence(int \/*BlobIndex*\/, CvBlob* \/*pBlob*\/, IplImage* \/*pImg*\/, IplImage* \/*pImgFG*\/ = NULL);$/;"	p	class:CvBlobTracker	access:public	signature:(int , CvBlob* , IplImage* , IplImage* = NULL)
GetConfidence	legacy/blobtrack.hpp	/^    virtual double GetConfidence(CvBlob* \/*pBlob*\/, IplImage* \/*pImg*\/,$/;"	f	class:CvBlobTrackerOne	access:public	signature:(CvBlob* , IplImage* , IplImage* = NULL, IplImage* = NULL)
GetConfidenceList	legacy/blobtrack.hpp	/^    virtual double GetConfidenceList(CvBlobSeq* pBlobList, IplImage* pImg, IplImage* pImgFG = NULL);$/;"	p	class:CvBlobTracker	access:public	signature:(CvBlobSeq* pBlobList, IplImage* pImg, IplImage* pImgFG = NULL)
GetDescriptor	features2d/features2d.hpp	/^    const OneWayDescriptor* GetDescriptor(int desc_idx) const {return &m_descriptors[desc_idx];};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:(int desc_idx) const
GetDescriptorCount	features2d/features2d.hpp	/^    int GetDescriptorCount() const {return m_train_feature_count;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
GetDescriptorPart	features2d/features2d.hpp	/^    int GetDescriptorPart(int desc_idx) const;$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(int desc_idx) const
GetEtalon	legacy/legacy.hpp	/^        GetEtalon( int* paramCount = 0, const double** etalonParams = 0,$/;"	p	class:CvCalibFilter	access:public	signature:( int* paramCount = 0, const double** etalonParams = 0, int* pointCount = 0, const CvPoint2D32f** etalonPoints = 0 ) const
GetFGMask	legacy/blobtrack.hpp	/^    virtual IplImage*   GetFGMask(){return NULL;};$/;"	f	class:CvBlobTrackerAuto	access:public	signature:()
GetFV	legacy/blobtrack.hpp	/^    virtual float*  GetFV(int index, int* pFVID) = 0; \/* Returns pointer to FV, if return 0 then FV not created *\/$/;"	p	class:CvBlobTrackFVGen	access:public	signature:(int index, int* pFVID)
GetFVMax	legacy/blobtrack.hpp	/^    virtual float*  GetFVMax() = 0; \/* Returns pointer to array of maximal values of FV, if returns 0 then FVrange does not exist *\/$/;"	p	class:CvBlobTrackFVGen	access:public	signature:()
GetFVMin	legacy/blobtrack.hpp	/^    virtual float*  GetFVMin() = 0; \/* Returns pointer to array of minimal values of FV, if returns 0 then FVrange does not exist *\/$/;"	p	class:CvBlobTrackFVGen	access:public	signature:()
GetFVNum	legacy/blobtrack.hpp	/^    virtual int     GetFVNum() = 0;$/;"	p	class:CvBlobTrackFVGen	access:public	signature:()
GetFVSize	legacy/blobtrack.hpp	/^    virtual int     GetFVSize() = 0;$/;"	p	class:CvBlobTrackFVGen	access:public	signature:()
GetFVVar	legacy/blobtrack.hpp	/^    virtual float*  GetFVVar(){return NULL;}; \/* Returns pointer to array of variation of values of FV, if returns 0 then FVVar does not exist. *\/$/;"	f	class:CvBlobTrackFVGen	access:public	signature:()
GetFeatureName	features2d/features2d.hpp	/^    const char* GetFeatureName() const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:() const
GetFrameCount	legacy/legacy.hpp	/^    virtual int GetFrameCount( int* framesTotal = 0 ) const;$/;"	p	class:CvCalibFilter	access:public	signature:( int* framesTotal = 0 ) const
GetHeight	legacy/blobtrack.hpp	/^    virtual double  GetHeight(CvBlob* pB) = 0;$/;"	p	class:CvBlobTrackAnalysisHeight	access:public	signature:(CvBlob* pB)
GetImage	legacy/blobtrack.hpp	/^    IplImage* GetImage() { return m_image; }$/;"	f	class:CvImageDrawer	access:public	signature:()
GetInputPatchSize	features2d/features2d.hpp	/^    CvSize GetInputPatchSize() const$/;"	f	class:cv::OneWayDescriptor	access:public	signature:() const
GetLabeledFeatures	features2d/features2d.hpp	/^    const vector<cv::KeyPoint>& GetLabeledFeatures() const {return m_train_features;};$/;"	f	class:cv::OneWayDescriptorObject	access:public	signature:() const
GetLabeledFeatures	features2d/features2d.hpp	/^    vector<cv::KeyPoint>& GetLabeledFeatures() {return m_train_features;};$/;"	f	class:cv::OneWayDescriptorObject	access:public	signature:()
GetLatestPoints	legacy/legacy.hpp	/^    virtual bool GetLatestPoints( int idx, CvPoint2D32f** pts,$/;"	p	class:CvCalibFilter	access:public	signature:( int idx, CvPoint2D32f** pts, int* count, bool* found )
GetLeaves	ml/ml.hpp	/^    CvDTreeNode** GetLeaves( const CvDTree* dtree, int& len );$/;"	p	class:CvGBTrees	access:protected	signature:( const CvDTree* dtree, int& len )
GetLowPCA	features2d/features2d.hpp	/^    int GetLowPCA(CvMat** avg, CvMat** eigenvectors)$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:(CvMat** avg, CvMat** eigenvectors)
GetMask	legacy/blobtrack.hpp	/^    virtual IplImage* GetMask() = 0;$/;"	p	class:CvFGDetector	access:public	signature:()
GetMaxBorderSize	legacy/blobtrack.hpp	/^    int GetMaxBorderSize() const;$/;"	p	class:CvObjectDetector	access:public	signature:() const
GetMinWindowSize	legacy/blobtrack.hpp	/^    CvSize GetMinWindowSize() const;$/;"	p	class:CvObjectDetector	access:public	signature:() const
GetModuleName	legacy/blobtrack.hpp	/^    char*   GetModuleName();$/;"	p	class:CvVSModule	access:public	signature:()
GetNickName	legacy/blobtrack.hpp	/^    const char* GetNickName();$/;"	p	class:CvVSModule	access:public	signature:()
GetObjectFeatureCount	features2d/features2d.hpp	/^    int GetObjectFeatureCount() const {return m_object_feature_count;};$/;"	f	class:cv::OneWayDescriptorObject	access:public	signature:() const
GetPCACoeffs	features2d/features2d.hpp	/^    CvMat** GetPCACoeffs() const {return m_pca_coeffs;}$/;"	f	class:cv::OneWayDescriptor	access:public	signature:() const
GetPCADimHigh	features2d/features2d.hpp	/^    int GetPCADimHigh() const {return m_pca_dim_high;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
GetPCADimHigh	features2d/features2d.hpp	/^    int GetPCADimHigh() const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:() const
GetPCADimLow	features2d/features2d.hpp	/^    int GetPCADimLow() const {return m_pca_dim_low;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
GetPCADimLow	features2d/features2d.hpp	/^    int GetPCADimLow() const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:() const
GetPCAFilename	features2d/features2d.hpp	/^    static string GetPCAFilename () { return "pca.yml"; }$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:()
GetParam	legacy/blobtrack.hpp	/^    double GetParam(const char* name);$/;"	p	class:CvVSModule	access:public	signature:(const char* name)
GetParamComment	legacy/blobtrack.hpp	/^    const char* GetParamComment(const char* name);$/;"	p	class:CvVSModule	access:public	signature:(const char* name)
GetParamName	legacy/blobtrack.hpp	/^    const char* GetParamName(int index);$/;"	p	class:CvVSModule	access:public	signature:(int index)
GetParamPtr	legacy/blobtrack.hpp	/^    CvDefParam* GetParamPtr(const char* name);$/;"	p	class:CvVSModule	access:private	signature:(const char* name)
GetParamPtr	legacy/blobtrack.hpp	/^    CvDefParam* GetParamPtr(int index);$/;"	p	class:CvVSModule	access:private	signature:(int index)
GetParamStr	legacy/blobtrack.hpp	/^    const char* GetParamStr(const char* name);$/;"	p	class:CvVSModule	access:public	signature:(const char* name)
GetPatch	features2d/features2d.hpp	/^    IplImage* GetPatch(int index);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int index)
GetPatchSize	features2d/features2d.hpp	/^    CvSize GetPatchSize() const {return m_patch_size;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
GetPatchSize	features2d/features2d.hpp	/^    CvSize GetPatchSize() const$/;"	f	class:cv::OneWayDescriptor	access:public	signature:() const
GetPose	features2d/features2d.hpp	/^    CvAffinePose GetPose(int index) const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int index) const
GetPoseCount	features2d/features2d.hpp	/^    int GetPoseCount() const {return m_pose_count;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
GetPyrLevels	features2d/features2d.hpp	/^    int GetPyrLevels() const {return m_pyr_levels;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
GetRow	ml/ml.hpp	/^    typedef float* (CvSVMSolver::*GetRow)( int i, float* row, float* dst, bool existed );$/;"	t	class:CvSVMSolver	access:public
GetState	legacy/blobtrack.hpp	/^    virtual float       GetState(int BlobID) = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:(int BlobID)
GetState	legacy/blobtrack.hpp	/^    virtual float   GetState(int BlobID) = 0;$/;"	p	class:CvBlobTrackAnalysis	access:public	signature:(int BlobID)
GetStateDesc	legacy/blobtrack.hpp	/^    virtual const char*       GetStateDesc(int BlobID) = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:(int BlobID)
GetStateDesc	legacy/blobtrack.hpp	/^    virtual const char*   GetStateDesc(int \/*BlobID*\/){return NULL;};$/;"	f	class:CvBlobTrackAnalysis	access:public	signature:(int )
GetStereoParams	legacy/legacy.hpp	/^    virtual const CvStereoCamera* GetStereoParams() const;$/;"	p	class:CvCalibFilter	access:public	signature:() const
GetTypeName	legacy/blobtrack.hpp	/^    const char*   GetTypeName();$/;"	p	class:CvVSModule	access:public	signature:()
GoodFeaturesToTrackDetector	features2d/features2d.hpp	/^    GoodFeaturesToTrackDetector( const GoodFeaturesToTrackDetector::Params& params=GoodFeaturesToTrackDetector::Params() );$/;"	p	class:cv::GoodFeaturesToTrackDetector	access:public	signature:( const GoodFeaturesToTrackDetector::Params& params=GoodFeaturesToTrackDetector::Params() )
GoodFeaturesToTrackDetector	features2d/features2d.hpp	/^    GoodFeaturesToTrackDetector( int maxCorners, double qualityLevel, double minDistance,$/;"	p	class:cv::GoodFeaturesToTrackDetector	access:public	signature:( int maxCorners, double qualityLevel, double minDistance, int blockSize=3, bool useHarrisDetector=false, double k=0.04 )
GoodFeaturesToTrackDetector	features2d/features2d.hpp	/^class CV_EXPORTS GoodFeaturesToTrackDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
GpuMat	gpu/gpumat.hpp	/^        GpuMat();$/;"	p	class:cv::gpu::GpuMat	access:public	signature:()
GpuMat	gpu/gpumat.hpp	/^        GpuMat(Size size, int type);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(Size size, int type)
GpuMat	gpu/gpumat.hpp	/^        GpuMat(Size size, int type, const Scalar& s);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(Size size, int type, const Scalar& s)
GpuMat	gpu/gpumat.hpp	/^        GpuMat(Size size, int type, void* data, size_t step = Mat::AUTO_STEP);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(Size size, int type, void* data, size_t step = Mat::AUTO_STEP)
GpuMat	gpu/gpumat.hpp	/^        GpuMat(const GpuMat& m);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const GpuMat& m)
GpuMat	gpu/gpumat.hpp	/^        GpuMat(const GpuMat& m, const Range& rowRange, const Range& colRange);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const GpuMat& m, const Range& rowRange, const Range& colRange)
GpuMat	gpu/gpumat.hpp	/^        GpuMat(const GpuMat& m, const Rect& roi);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const GpuMat& m, const Rect& roi)
GpuMat	gpu/gpumat.hpp	/^        GpuMat(int rows, int cols, int type);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int rows, int cols, int type)
GpuMat	gpu/gpumat.hpp	/^        GpuMat(int rows, int cols, int type, const Scalar& s);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int rows, int cols, int type, const Scalar& s)
GpuMat	gpu/gpumat.hpp	/^        GpuMat(int rows, int cols, int type, void* data, size_t step = Mat::AUTO_STEP);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int rows, int cols, int type, void* data, size_t step = Mat::AUTO_STEP)
GpuMat	gpu/gpumat.hpp	/^        explicit GpuMat (const Mat& m);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Mat& m)
GpuMat	gpu/gpumat.hpp	/^    class CV_EXPORTS GpuMat$/;"	c	namespace:cv::gpu
GpuMat	gpu/gpumat.hpp	/^    inline GpuMat::GpuMat() : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0) {}$/;"	f	class:cv::gpu::GpuMat	signature:()
GpuMat	gpu/gpumat.hpp	/^    inline GpuMat::GpuMat(int rows_, int cols_, int type_) : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0)$/;"	f	class:cv::gpu::GpuMat	signature:(int rows_, int cols_, int type_)
GradientBoostingTreeParams	ml/ml.hpp	/^typedef CvGBTreesParams GradientBoostingTreeParams;$/;"	t	namespace:cv
GradientBoostingTrees	ml/ml.hpp	/^typedef CvGBTrees GradientBoostingTrees;$/;"	t	namespace:cv
Graph	legacy/legacy.hpp	/^CVAPI(int) cvReleaseLinearContorModelStorage(CvGraph** Graph);$/;"	v
GreaterEq	core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS GreaterEq$/;"	c	namespace:cv
GreaterEqIdx	core/operations.hpp	/^    GreaterEqIdx( const _Tp* _arr ) : arr(_arr) {}$/;"	f	class:cv::GreaterEqIdx	access:public	signature:( const _Tp* _arr )
GreaterEqIdx	core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS GreaterEqIdx$/;"	c	namespace:cv
GridAdaptedFeatureDetector	features2d/features2d.hpp	/^    GridAdaptedFeatureDetector( const Ptr<FeatureDetector>& detector, int maxTotalKeypoints=1000,$/;"	p	class:cv::GridAdaptedFeatureDetector	access:public	signature:( const Ptr<FeatureDetector>& detector, int maxTotalKeypoints=1000, int gridRows=4, int gridCols=4 )
GridAdaptedFeatureDetector	features2d/features2d.hpp	/^class CV_EXPORTS GridAdaptedFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
H	objdetect/objdetect.hpp	/^    float *H;$/;"	m	struct:__anon197	access:public
HAAR	objdetect/objdetect.hpp	/^    enum { HAAR = 0, LBP = 1 };$/;"	e	enum:cv::FeatureEvaluator::__anon198
HASH_BIT	core/core.hpp	/^    enum { MAGIC_VAL=0x42FD0000, MAX_DIM=CV_MAX_DIM, HASH_SCALE=0x5bd1e995, HASH_BIT=0x80000000 };$/;"	e	enum:cv::SparseMat::__anon146
HASH_SCALE	core/core.hpp	/^    enum { MAGIC_VAL=0x42FD0000, MAX_DIM=CV_MAX_DIM, HASH_SCALE=0x5bd1e995, HASH_BIT=0x80000000 };$/;"	e	enum:cv::SparseMat::__anon146
HAVE_IPL	core/types_c.h	95;"	d
HAVE_TBB	core/internal.hpp	146;"	d
HELLINGER	flann/defines.h	/^    HELLINGER = 6,$/;"	e	enum:cvflann::flann_distance_t
HG_AUTOSIZE	highgui/highgui_c.h	489;"	d
HIST_INTERSECT	flann/defines.h	/^    HIST_INTERSECT   = 5,$/;"	e	enum:cvflann::flann_distance_t
HOGDescriptor	gpu/gpu.hpp	/^            HOGDescriptor(Size win_size=Size(64, 128), Size block_size=Size(16, 16),$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:(Size win_size=Size(64, 128), Size block_size=Size(16, 16), Size block_stride=Size(8, 8), Size cell_size=Size(8, 8), int nbins=9, double win_sigma=DEFAULT_WIN_SIGMA, double threshold_L2hys=0.2, bool gamma_correction=true, int nlevels=DEFAULT_NLEVELS)
HOGDescriptor	gpu/gpu.hpp	/^        struct CV_EXPORTS HOGDescriptor$/;"	s	namespace:cv::gpu
HOGDescriptor	objdetect/objdetect.hpp	/^    CV_WRAP HOGDescriptor() : winSize(64,128), blockSize(16,16), blockStride(8,8),$/;"	f	struct:cv::HOGDescriptor	access:public	signature:()
HOGDescriptor	objdetect/objdetect.hpp	/^    CV_WRAP HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride,$/;"	f	struct:cv::HOGDescriptor	access:public	signature:(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture=1, double _winSigma=-1, int _histogramNormType=HOGDescriptor::L2Hys, double _L2HysThreshold=0.2, bool _gammaCorrection=false, int _nlevels=HOGDescriptor::DEFAULT_NLEVELS)
HOGDescriptor	objdetect/objdetect.hpp	/^    CV_WRAP HOGDescriptor(const String& filename)$/;"	f	struct:cv::HOGDescriptor	access:public	signature:(const String& filename)
HOGDescriptor	objdetect/objdetect.hpp	/^    HOGDescriptor(const HOGDescriptor& d)$/;"	f	struct:cv::HOGDescriptor	access:public	signature:(const HOGDescriptor& d)
HOGDescriptor	objdetect/objdetect.hpp	/^struct CV_EXPORTS_W HOGDescriptor$/;"	s	namespace:cv
HUBER_LOSS	ml/ml.hpp	/^    enum {SQUARED_LOSS=0, ABSOLUTE_LOSS, HUBER_LOSS=3, DEVIANCE_LOSS};$/;"	e	enum:CvGBTrees::__anon81
Hamming	features2d/features2d.hpp	/^struct CV_EXPORTS Hamming$/;"	s	namespace:cv
Hamming	flann/dist.h	/^struct Hamming$/;"	s	namespace:cvflann
Hamming2	flann/dist.h	/^struct Hamming2$/;"	s	namespace:cvflann
HammingDist	gpu/gpu.hpp	/^            enum DistType {L1Dist = 0, L2Dist, HammingDist};$/;"	e	enum:cv::gpu::BruteForceMatcher_GPU_base::DistType
HammingLUT	features2d/features2d.hpp	/^struct CV_EXPORTS HammingLUT$/;"	s	namespace:cv
HammingLUT	flann/dist.h	/^struct HammingLUT$/;"	s	namespace:cvflann
Hdr	core/core.hpp	/^        Hdr(int _dims, const int* _sizes, int _type);$/;"	p	struct:cv::SparseMat::Hdr	access:public	signature:(int _dims, const int* _sizes, int _type)
Hdr	core/core.hpp	/^    struct CV_EXPORTS Hdr$/;"	s	class:cv::SparseMat	access:public
Hdr	core/operations.hpp	/^        Hdr() : data(0), datastart(0), refcount(0), size(0), capacity(0) {};$/;"	f	struct:cv::Vector::Hdr	access:public	signature:()
Hdr	core/operations.hpp	/^    struct CV_EXPORTS Hdr$/;"	s	class:cv::Vector	access:public
Heap	flann/heap.h	/^    Heap(int size)$/;"	f	class:cvflann::Heap	access:public	signature:(int size)
Heap	flann/heap.h	/^class Heap$/;"	c	namespace:cvflann
Height	core/wimage.hpp	/^    int Height() const {return image_->height; }$/;"	f	class:cv::WImage	access:public	signature:() const
HellingerDistance	flann/dist.h	/^struct HellingerDistance$/;"	s	namespace:cvflann
HierarchicalClusteringIndex	flann/hierarchical_clustering_index.h	/^    HierarchicalClusteringIndex(const HierarchicalClusteringIndex&);$/;"	p	class:cvflann::HierarchicalClusteringIndex	access:public	signature:(const HierarchicalClusteringIndex&)
HierarchicalClusteringIndex	flann/hierarchical_clustering_index.h	/^    HierarchicalClusteringIndex(const Matrix<ElementType>& inputData, const IndexParams& index_params = HierarchicalClusteringIndexParams(),$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:public	signature:(const Matrix<ElementType>& inputData, const IndexParams& index_params = HierarchicalClusteringIndexParams(), Distance d = Distance())
HierarchicalClusteringIndex	flann/hierarchical_clustering_index.h	/^class HierarchicalClusteringIndex : public NNIndex<Distance>$/;"	c	namespace:cvflann	inherits:NNIndex
HierarchicalClusteringIndexParams	flann/hierarchical_clustering_index.h	/^    HierarchicalClusteringIndexParams(int branching = 32,$/;"	f	struct:cvflann::HierarchicalClusteringIndexParams	access:public	signature:(int branching = 32, flann_centers_init_t centers_init = FLANN_CENTERS_RANDOM, int trees = 4, int leaf_size = 100)
HierarchicalClusteringIndexParams	flann/hierarchical_clustering_index.h	/^struct HierarchicalClusteringIndexParams : public IndexParams$/;"	s	namespace:cvflann	inherits:IndexParams
HistIntersectionDistance	flann/dist.h	/^struct HistIntersectionDistance$/;"	s	namespace:cvflann
HistType	legacy/blobtrack.hpp	/^    int     HistType; \/* see Prob.h *\/$/;"	m	struct:CvBlobTrackerParamLH	access:public
Histogram	contrib/contrib.hpp	/^        Histogram();$/;"	p	class:CvAdaptiveSkinDetector::Histogram	access:public	signature:()
Histogram	contrib/contrib.hpp	/^    class CV_EXPORTS Histogram$/;"	c	class:CvAdaptiveSkinDetector	access:private
HistogramSize	contrib/contrib.hpp	/^            HistogramSize = (GSD_HUE_UT - GSD_HUE_LT + 1)$/;"	e	enum:CvAdaptiveSkinDetector::Histogram::__anon2
HoughCircles	imgproc/imgproc.hpp	/^CV_EXPORTS_W void HoughCircles( InputArray image, OutputArray circles,$/;"	p	namespace:cv	signature:( InputArray image, OutputArray circles, int method, double dp, double minDist, double param1=100, double param2=100, int minRadius=0, int maxRadius=0 )
HoughLines	imgproc/imgproc.hpp	/^CV_EXPORTS_W void HoughLines( InputArray image, OutputArray lines,$/;"	p	namespace:cv	signature:( InputArray image, OutputArray lines, double rho, double theta, int threshold, double srn=0, double stn=0 )
HoughLinesP	imgproc/imgproc.hpp	/^CV_EXPORTS_W void HoughLinesP( InputArray image, OutputArray lines,$/;"	p	namespace:cv	signature:( InputArray image, OutputArray lines, double rho, double theta, int threshold, double minLineLength=0, double maxLineGap=0 )
HuMoments	imgproc/imgproc.hpp	/^CV_EXPORTS void HuMoments( const Moments& moments, double hu[7] );$/;"	p	namespace:cv	signature:( const Moments& moments, double hu[7] )
HuMoments	imgproc/imgproc.hpp	/^CV_EXPORTS_W void HuMoments( const Moments& m, CV_OUT OutputArray hu );$/;"	p	namespace:cv	signature:( const Moments& m, CV_OUT OutputArray hu )
ID	core/types_c.h	/^    int  ID;                \/* version (=0)*\/$/;"	m	struct:_IplImage	access:public
ID	legacy/blobtrack.hpp	/^    int     ID;  \/* blob ID         *\/$/;"	m	struct:CvBlob	access:public
IDENTITY	ml/ml.hpp	/^    enum { IDENTITY = 0, SIGMOID_SYM = 1, GAUSSIAN = 2 };$/;"	e	enum:CvANN_MLP::__anon83
INCVMemAllocator	gpu/NCV.hpp	/^class NCV_EXPORTS INCVMemAllocator$/;"	c
INCVMemAllocator::alignment	gpu/NCV.hpp	/^    virtual Ncv32u alignment(void) const = 0;$/;"	p	class:INCVMemAllocator	access:public	signature:(void) const
INCVMemAllocator::alloc	gpu/NCV.hpp	/^    virtual NCVStatus alloc(NCVMemSegment &seg, size_t size) = 0;$/;"	p	class:INCVMemAllocator	access:public	signature:(NCVMemSegment &seg, size_t size)
INCVMemAllocator::dealloc	gpu/NCV.hpp	/^    virtual NCVStatus dealloc(NCVMemSegment &seg) = 0;$/;"	p	class:INCVMemAllocator	access:public	signature:(NCVMemSegment &seg)
INCVMemAllocator::isCounting	gpu/NCV.hpp	/^    virtual NcvBool isCounting(void) const = 0;$/;"	p	class:INCVMemAllocator	access:public	signature:(void) const
INCVMemAllocator::isInitialized	gpu/NCV.hpp	/^    virtual NcvBool isInitialized(void) const = 0;$/;"	p	class:INCVMemAllocator	access:public	signature:(void) const
INCVMemAllocator::maxSize	gpu/NCV.hpp	/^    virtual size_t maxSize(void) const = 0;$/;"	p	class:INCVMemAllocator	access:public	signature:(void) const
INCVMemAllocator::memType	gpu/NCV.hpp	/^    virtual NCVMemoryType memType(void) const = 0;$/;"	p	class:INCVMemAllocator	access:public	signature:(void) const
INCVMemAllocator::~INCVMemAllocator	gpu/NCV.hpp	/^    virtual ~INCVMemAllocator() = 0;$/;"	p	class:INCVMemAllocator	access:public	signature:()
INCVMemAllocator::~INCVMemAllocator	gpu/NCV.hpp	/^inline INCVMemAllocator::~INCVMemAllocator() {}$/;"	f	class:INCVMemAllocator	signature:()
INPAINT_NS	imgproc/imgproc.hpp	/^    INPAINT_NS=CV_INPAINT_NS, \/\/ Navier-Stokes algorithm$/;"	e	enum:cv::__anon21
INPAINT_TELEA	imgproc/imgproc.hpp	/^    INPAINT_TELEA=CV_INPAINT_TELEA \/\/ A. Telea algorithm$/;"	e	enum:cv::__anon21
INSIDE_MAP	core/core.hpp	/^        INSIDE_MAP=4$/;"	e	enum:cv::FileStorage::__anon148
INT	core/core.hpp	/^        INT=1, \/\/!< an integer$/;"	e	enum:cv::FileNode::__anon149
INTER_AREA	imgproc/imgproc.hpp	/^    INTER_AREA=CV_INTER_AREA, \/\/!< area-based (or super) interpolation$/;"	e	enum:cv::__anon14
INTER_BITS	imgproc/imgproc.hpp	/^    INTER_BITS=5, INTER_BITS2=INTER_BITS*2,$/;"	e	enum:cv::__anon15
INTER_BITS2	imgproc/imgproc.hpp	/^    INTER_BITS=5, INTER_BITS2=INTER_BITS*2,$/;"	e	enum:cv::__anon15
INTER_CUBIC	imgproc/imgproc.hpp	/^    INTER_CUBIC=CV_INTER_CUBIC, \/\/!< bicubic interpolation$/;"	e	enum:cv::__anon14
INTER_LANCZOS4	imgproc/imgproc.hpp	/^    INTER_LANCZOS4=CV_INTER_LANCZOS4, \/\/!< Lanczos interpolation over 8x8 neighborhood$/;"	e	enum:cv::__anon14
INTER_LINEAR	imgproc/imgproc.hpp	/^    INTER_LINEAR=CV_INTER_LINEAR, \/\/!< bilinear interpolation$/;"	e	enum:cv::__anon14
INTER_MAX	imgproc/imgproc.hpp	/^    INTER_MAX=7,$/;"	e	enum:cv::__anon14
INTER_NEAREST	imgproc/imgproc.hpp	/^    INTER_NEAREST=CV_INTER_NN, \/\/!< nearest neighbor interpolation$/;"	e	enum:cv::__anon14
INTER_TAB_SIZE	imgproc/imgproc.hpp	/^    INTER_TAB_SIZE=(1<<INTER_BITS),$/;"	e	enum:cv::__anon15
INTER_TAB_SIZE2	imgproc/imgproc.hpp	/^    INTER_TAB_SIZE2=INTER_TAB_SIZE*INTER_TAB_SIZE$/;"	e	enum:cv::__anon15
IPL2CV_DEPTH	core/types_c.h	706;"	d
IPL_ALIGN_16BYTES	core/types_c.h	436;"	d
IPL_ALIGN_32BYTES	core/types_c.h	437;"	d
IPL_ALIGN_4BYTES	core/types_c.h	434;"	d
IPL_ALIGN_8BYTES	core/types_c.h	435;"	d
IPL_ALIGN_DWORD	core/types_c.h	439;"	d
IPL_ALIGN_QWORD	core/types_c.h	440;"	d
IPL_BORDER_CONSTANT	core/types_c.h	442;"	d
IPL_BORDER_REFLECT	core/types_c.h	444;"	d
IPL_BORDER_REFLECT_101	core/types_c.h	522;"	d
IPL_BORDER_REPLICATE	core/types_c.h	443;"	d
IPL_BORDER_TRANSPARENT	core/types_c.h	523;"	d
IPL_BORDER_WRAP	core/types_c.h	445;"	d
IPL_DATA_ORDER_PIXEL	core/types_c.h	428;"	d
IPL_DATA_ORDER_PLANE	core/types_c.h	429;"	d
IPL_DEPTH_16S	core/types_c.h	425;"	d
IPL_DEPTH_16U	core/types_c.h	421;"	d
IPL_DEPTH_1U	core/types_c.h	419;"	d
IPL_DEPTH_32F	core/types_c.h	422;"	d
IPL_DEPTH_32S	core/types_c.h	426;"	d
IPL_DEPTH_64F	core/types_c.h	536;"	d
IPL_DEPTH_8S	core/types_c.h	424;"	d
IPL_DEPTH_8U	core/types_c.h	420;"	d
IPL_DEPTH_SIGN	core/types_c.h	417;"	d
IPL_GAUSSIAN_5x5	legacy/compat.hpp	/^    IPL_GAUSSIAN_5x5 = 7$/;"	e	enum:__anon179
IPL_IMAGE_DATA	core/types_c.h	516;"	d
IPL_IMAGE_HEADER	core/types_c.h	515;"	d
IPL_IMAGE_MAGIC_VAL	core/types_c.h	525;"	d
IPL_IMAGE_ROI	core/types_c.h	517;"	d
IPL_ORIGIN_BL	core/types_c.h	432;"	d
IPL_ORIGIN_TL	core/types_c.h	431;"	d
IPPI_CALL	core/internal.hpp	135;"	d
ImageData	core/wimage.hpp	/^    T* ImageData() { return reinterpret_cast<T*>(image_->imageData); }$/;"	f	class:cv::WImage	access:public	signature:()
ImageData	core/wimage.hpp	/^    const T* ImageData() const {$/;"	f	class:cv::WImage	access:public	signature:() const
Index	flann/flann_base.hpp	/^    Index(const Matrix<ElementType>& features, const IndexParams& params, Distance distance = Distance() )$/;"	f	class:cvflann::Index	access:public	signature:(const Matrix<ElementType>& features, const IndexParams& params, Distance distance = Distance() )
Index	flann/flann_base.hpp	/^class Index : public NNIndex<Distance>$/;"	c	namespace:cvflann	inherits:NNIndex
Index	flann/miniflann.hpp	/^    CV_WRAP Index();$/;"	p	class:cv::flann::Index	access:public	signature:()
Index	flann/miniflann.hpp	/^    CV_WRAP Index(InputArray features, const IndexParams& params, cvflann::flann_distance_t distType=cvflann::FLANN_DIST_L2);$/;"	p	class:cv::flann::Index	access:public	signature:(InputArray features, const IndexParams& params, cvflann::flann_distance_t distType=cvflann::FLANN_DIST_L2)
Index	flann/miniflann.hpp	/^class CV_EXPORTS_W Index$/;"	c	namespace:cv::flann
IndexHeader	flann/saving.h	/^struct IndexHeader$/;"	s	namespace:cvflann
IndexParams	flann/miniflann.hpp	/^    IndexParams();$/;"	p	struct:cv::flann::IndexParams	access:public	signature:()
IndexParams	flann/miniflann.hpp	/^struct CV_EXPORTS IndexParams$/;"	s	namespace:cv::flann
IndexParams	flann/params.h	/^typedef std::map<std::string, any> IndexParams;$/;"	t	namespace:cvflann
Index_	flann/flann.hpp	/^	Index_(const Mat& features, const ::cvflann::IndexParams& params);$/;"	p	class:cv::flann::Index_	access:public	signature:(const Mat& features, const ::cvflann::IndexParams& params)
Index_	flann/flann.hpp	/^Index_<T>::Index_(const Mat& dataset, const ::cvflann::IndexParams& params)$/;"	f	class:cv::flann::Index_	signature:(const Mat& dataset, const ::cvflann::IndexParams& params)
Index_	flann/flann.hpp	/^class FLANN_DEPRECATED Index_ {$/;"	c	namespace:cv::flann
Init	legacy/blobtrack.hpp	/^    virtual void Init(CvBlob* pBlobInit, IplImage* pImg, IplImage* pImgFG = NULL) = 0;$/;"	p	class:CvBlobTrackerOne	access:public	signature:(CvBlob* pBlobInit, IplImage* pImg, IplImage* pImgFG = NULL)
Initialize	features2d/features2d.hpp	/^    void Initialize(int pose_count, IplImage* frontal, const char* feature_name = 0, int norm = 0);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int pose_count, IplImage* frontal, const char* feature_name = 0, int norm = 0)
InitializeDescriptor	features2d/features2d.hpp	/^    void InitializeDescriptor(int desc_idx, IplImage* train_image, const char* feature_label);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(int desc_idx, IplImage* train_image, const char* feature_label)
InitializeDescriptor	features2d/features2d.hpp	/^    void InitializeDescriptor(int desc_idx, IplImage* train_image, const cv::KeyPoint& keypoint, const char* feature_label);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(int desc_idx, IplImage* train_image, const cv::KeyPoint& keypoint, const char* feature_label)
InitializeDescriptors	features2d/features2d.hpp	/^    void InitializeDescriptors(IplImage* train_image, const vector<cv::KeyPoint>& features,$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(IplImage* train_image, const vector<cv::KeyPoint>& features, const char* feature_label = , int desc_start_idx = 0)
InitializeFast	features2d/features2d.hpp	/^    void InitializeFast(int pose_count, IplImage* frontal, const char* feature_name,$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int pose_count, IplImage* frontal, const char* feature_name, CvMat* pca_hr_avg, CvMat* pca_hr_eigenvectors, OneWayDescriptor* pca_descriptors)
InitializeObjectDescriptors	features2d/features2d.hpp	/^    void InitializeObjectDescriptors(IplImage* train_image, const vector<cv::KeyPoint>& features,$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(IplImage* train_image, const vector<cv::KeyPoint>& features, const char* feature_label, int desc_start_idx = 0, float scale = 1.0f, int is_background = 0)
InitializePCACoeffs	features2d/features2d.hpp	/^    void InitializePCACoeffs(CvMat* avg, CvMat* eigenvectors);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(CvMat* avg, CvMat* eigenvectors)
InitializePoseTransforms	features2d/features2d.hpp	/^    void InitializePoseTransforms();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
InitializePoses	features2d/features2d.hpp	/^    void InitializePoses();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
InitializeTransformsFromPoses	features2d/features2d.hpp	/^    void InitializeTransformsFromPoses();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
InputArray	core/core.hpp	/^typedef const _InputArray& InputArray;$/;"	t	namespace:cv
InputArrayOfArrays	core/core.hpp	/^typedef InputArray InputArrayOfArrays;$/;"	t	namespace:cv
InputOutputArray	core/core.hpp	/^typedef OutputArray InputOutputArray;$/;"	t	namespace:cv
InputOutputArrayOfArrays	core/core.hpp	/^typedef OutputArray InputOutputArrayOfArrays;$/;"	t	namespace:cv
Int	legacy/blobtrack.hpp	/^    int                 Int;$/;"	m	struct:CvDefParam	access:public
Interval	flann/kdtree_single_index.h	/^    struct Interval$/;"	s	class:cvflann::KDTreeSingleIndex	access:private
Ipl	core/wimage.hpp	/^    IplImage* Ipl() {return image_; }$/;"	f	class:cv::WImage	access:public	signature:()
Ipl	core/wimage.hpp	/^    const IplImage* Ipl() const {return image_; }$/;"	f	class:cv::WImage	access:public	signature:() const
IplConvKernel	core/types_c.h	/^IplConvKernel;$/;"	t	typeref:struct:_IplConvKernel
IplConvKernelFP	core/types_c.h	/^IplConvKernelFP;$/;"	t	typeref:struct:_IplConvKernelFP
IplImage	core/types_c.h	/^IplImage;$/;"	t	typeref:struct:_IplImage
IplROI	core/types_c.h	/^IplROI;$/;"	t	typeref:struct:_IplROI
IplTileInfo	core/types_c.h	/^typedef struct _IplTileInfo IplTileInfo;$/;"	t	typeref:struct:_IplTileInfo
IsCalibrated	legacy/legacy.hpp	/^    bool IsCalibrated() const { return isCalibrated; }$/;"	f	class:CvCalibFilter	access:public	signature:() const
IsDescriptorObject	features2d/features2d.hpp	/^    int IsDescriptorObject(int desc_idx) const;$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(int desc_idx) const
IsModuleName	legacy/blobtrack.hpp	/^    int     IsModuleName(const char* name);$/;"	p	class:CvVSModule	access:public	signature:(const char* name)
IsModuleTypeName	legacy/blobtrack.hpp	/^    int     IsModuleTypeName(const char* name);$/;"	p	class:CvVSModule	access:public	signature:(const char* name)
IsNull	core/wimage.hpp	/^    bool IsNull() const {return WImage<T>::image_ == NULL; }$/;"	f	class:cv::WImageBuffer	access:public	signature:() const
IsNull	core/wimage.hpp	/^    bool IsNull() const {return WImage<T>::image_ == NULL; }$/;"	f	class:cv::WImageBufferC	access:public	signature:() const
IsParam	legacy/blobtrack.hpp	/^    int  IsParam(const char* name);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name)
Ithreshold	calib3d/calib3d.hpp	/^    int Ithreshold;$/;"	m	struct:CvStereoGCState	access:public
J	calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> J;$/;"	m	class:CvLevMarq	access:public
JtErr	calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> JtErr;$/;"	m	class:CvLevMarq	access:public
JtJ	calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> JtJ;$/;"	m	class:CvLevMarq	access:public
JtJN	calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> JtJN;$/;"	m	class:CvLevMarq	access:public
JtJV	calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> JtJV;$/;"	m	class:CvLevMarq	access:public
JtJW	calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> JtJW;$/;"	m	class:CvLevMarq	access:public
JtJ_diag	contrib/contrib.hpp	/^        CvMat* JtJ_diag; \/\/diagonal of JtJ,  used to backup diagonal elements before augmentation$/;"	m	class:cv::LevMarqSparse	access:public
K	calib3d/calib3d.hpp	/^    float K, lambda, lambda1, lambda2;$/;"	m	struct:CvStereoGCState	access:public
KDTREE	flann/defines.h	/^    KDTREE = 1,$/;"	e	enum:cvflann::flann_algorithm_t
KDTREE_SINGLE	flann/defines.h	/^    KDTREE_SINGLE = 4,$/;"	e	enum:cvflann::flann_algorithm_t
KDTree	core/core.hpp	/^    CV_WRAP KDTree();$/;"	p	class:cv::KDTree	access:public	signature:()
KDTree	core/core.hpp	/^    CV_WRAP KDTree(InputArray points, InputArray _labels,$/;"	p	class:cv::KDTree	access:public	signature:(InputArray points, InputArray _labels, bool copyAndReorderPoints=false)
KDTree	core/core.hpp	/^    CV_WRAP KDTree(InputArray points, bool copyAndReorderPoints=false);$/;"	p	class:cv::KDTree	access:public	signature:(InputArray points, bool copyAndReorderPoints=false)
KDTree	core/core.hpp	/^class CV_EXPORTS_W KDTree$/;"	c	namespace:cv
KDTreeIndex	flann/kdtree_index.h	/^    KDTreeIndex(const KDTreeIndex&);$/;"	p	class:cvflann::KDTreeIndex	access:public	signature:(const KDTreeIndex&)
KDTreeIndex	flann/kdtree_index.h	/^    KDTreeIndex(const Matrix<ElementType>& inputData, const IndexParams& params = KDTreeIndexParams(),$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:(const Matrix<ElementType>& inputData, const IndexParams& params = KDTreeIndexParams(), Distance d = Distance() )
KDTreeIndex	flann/kdtree_index.h	/^class KDTreeIndex : public NNIndex<Distance>$/;"	c	namespace:cvflann	inherits:NNIndex
KDTreeIndexParams	flann/kdtree_index.h	/^    KDTreeIndexParams(int trees = 4)$/;"	f	struct:cvflann::KDTreeIndexParams	access:public	signature:(int trees = 4)
KDTreeIndexParams	flann/kdtree_index.h	/^struct KDTreeIndexParams : public IndexParams$/;"	s	namespace:cvflann	inherits:IndexParams
KDTreeIndexParams	flann/miniflann.hpp	/^    KDTreeIndexParams(int trees=4);$/;"	p	struct:cv::flann::KDTreeIndexParams	access:public	signature:(int trees=4)
KDTreeIndexParams	flann/miniflann.hpp	/^struct CV_EXPORTS KDTreeIndexParams : public IndexParams$/;"	s	namespace:cv::flann	inherits:IndexParams
KDTreeSingleIndex	flann/kdtree_single_index.h	/^    KDTreeSingleIndex(const KDTreeSingleIndex&);$/;"	p	class:cvflann::KDTreeSingleIndex	access:public	signature:(const KDTreeSingleIndex&)
KDTreeSingleIndex	flann/kdtree_single_index.h	/^    KDTreeSingleIndex(const Matrix<ElementType>& inputData, const IndexParams& params = KDTreeSingleIndexParams(),$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:(const Matrix<ElementType>& inputData, const IndexParams& params = KDTreeSingleIndexParams(), Distance d = Distance() )
KDTreeSingleIndex	flann/kdtree_single_index.h	/^class KDTreeSingleIndex : public NNIndex<Distance>$/;"	c	namespace:cvflann	inherits:NNIndex
KDTreeSingleIndexParams	flann/kdtree_single_index.h	/^    KDTreeSingleIndexParams(int leaf_max_size = 10, bool reorder = true, int dim = -1)$/;"	f	struct:cvflann::KDTreeSingleIndexParams	access:public	signature:(int leaf_max_size = 10, bool reorder = true, int dim = -1)
KDTreeSingleIndexParams	flann/kdtree_single_index.h	/^struct KDTreeSingleIndexParams : public IndexParams$/;"	s	namespace:cvflann	inherits:IndexParams
KERNEL_ASYMMETRICAL	imgproc/imgproc.hpp	/^enum { KERNEL_GENERAL=0, KERNEL_SYMMETRICAL=1, KERNEL_ASYMMETRICAL=2,$/;"	e	enum:cv::__anon11
KERNEL_GENERAL	imgproc/imgproc.hpp	/^enum { KERNEL_GENERAL=0, KERNEL_SYMMETRICAL=1, KERNEL_ASYMMETRICAL=2,$/;"	e	enum:cv::__anon11
KERNEL_INTEGER	imgproc/imgproc.hpp	/^       KERNEL_SMOOTH=4, KERNEL_INTEGER=8 };$/;"	e	enum:cv::__anon11
KERNEL_SIZE	features2d/features2d.hpp	/^    static const int KERNEL_SIZE = 9;$/;"	m	class:cv::BriefDescriptorExtractor	access:public
KERNEL_SMOOTH	imgproc/imgproc.hpp	/^       KERNEL_SMOOTH=4, KERNEL_INTEGER=8 };$/;"	e	enum:cv::__anon11
KERNEL_SYMMETRICAL	imgproc/imgproc.hpp	/^enum { KERNEL_GENERAL=0, KERNEL_SYMMETRICAL=1, KERNEL_ASYMMETRICAL=2,$/;"	e	enum:cv::__anon11
KIND_SHIFT	core/core.hpp	/^    enum { KIND_SHIFT=16, NONE=0<<KIND_SHIFT, MAT=1<<KIND_SHIFT,$/;"	e	enum:cv::_InputArray::__anon134
KL	flann/defines.h	/^    KL         = 8,$/;"	e	enum:cvflann::flann_distance_t
KL_Divergence	flann/dist.h	/^struct KL_Divergence$/;"	s	namespace:cvflann
KMEANS	flann/defines.h	/^    KMEANS = 2,$/;"	e	enum:cvflann::flann_algorithm_t
KMEANS_PP_CENTERS	core/core.hpp	/^    KMEANS_PP_CENTERS=2,     \/\/ Uses k-Means++ algorithm for initialization$/;"	e	enum:cv::__anon143
KMEANS_RANDOM_CENTERS	core/core.hpp	/^    KMEANS_RANDOM_CENTERS=0, \/\/ Chooses random centers for k-Means initialization$/;"	e	enum:cv::__anon143
KMEANS_USE_INITIAL_LABELS	core/core.hpp	/^    KMEANS_USE_INITIAL_LABELS=1 \/\/ Uses the user-provided labels for K-Means initialization$/;"	e	enum:cv::__anon143
KMeansIndex	flann/kmeans_index.h	/^    KMeansIndex(const KMeansIndex&);$/;"	p	class:cvflann::KMeansIndex	access:public	signature:(const KMeansIndex&)
KMeansIndex	flann/kmeans_index.h	/^    KMeansIndex(const Matrix<ElementType>& inputData, const IndexParams& params = KMeansIndexParams(),$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(const Matrix<ElementType>& inputData, const IndexParams& params = KMeansIndexParams(), Distance d = Distance())
KMeansIndex	flann/kmeans_index.h	/^class KMeansIndex : public NNIndex<Distance>$/;"	c	namespace:cvflann	inherits:NNIndex
KMeansIndexParams	flann/kmeans_index.h	/^    KMeansIndexParams(int branching = 32, int iterations = 11,$/;"	f	struct:cvflann::KMeansIndexParams	access:public	signature:(int branching = 32, int iterations = 11, flann_centers_init_t centers_init = FLANN_CENTERS_RANDOM, float cb_index = 0.2 )
KMeansIndexParams	flann/kmeans_index.h	/^struct KMeansIndexParams : public IndexParams$/;"	s	namespace:cvflann	inherits:IndexParams
KMeansIndexParams	flann/miniflann.hpp	/^    KMeansIndexParams(int branching = 32, int iterations = 11,$/;"	p	struct:cv::flann::KMeansIndexParams	access:public	signature:(int branching = 32, int iterations = 11, cvflann::flann_centers_init_t centers_init = cvflann::FLANN_CENTERS_RANDOM, float cb_index = 0.2 )
KMeansIndexParams	flann/miniflann.hpp	/^struct CV_EXPORTS KMeansIndexParams : public IndexParams$/;"	s	namespace:cv::flann	inherits:IndexParams
KMeansNode	flann/kmeans_index.h	/^    struct KMeansNode$/;"	s	class:cvflann::KMeansIndex	access:private
KMeansNodePtr	flann/kmeans_index.h	/^    typedef KMeansNode* KMeansNodePtr;$/;"	t	class:cvflann::KMeansIndex	access:private
KNNRadiusUniqueResultSet	flann/result_set.h	/^    KNNRadiusUniqueResultSet(unsigned int capacity, DistanceType radius)$/;"	f	class:cvflann::KNNRadiusUniqueResultSet	access:public	signature:(unsigned int capacity, DistanceType radius)
KNNRadiusUniqueResultSet	flann/result_set.h	/^class KNNRadiusUniqueResultSet : public KNNUniqueResultSet<DistanceType>$/;"	c	namespace:cvflann	inherits:KNNUniqueResultSet
KNNResultSet	flann/result_set.h	/^    KNNResultSet(int capacity_) : capacity(capacity_), count(0)$/;"	f	class:cvflann::KNNResultSet	access:public	signature:(int capacity_)
KNNResultSet	flann/result_set.h	/^class KNNResultSet : public ResultSet<DistanceType>$/;"	c	namespace:cvflann	inherits:ResultSet
KNNSimpleResultSet	flann/result_set.h	/^    KNNSimpleResultSet(int capacity_) : capacity(capacity_), count(0)$/;"	f	class:cvflann::KNNSimpleResultSet	access:public	signature:(int capacity_)
KNNSimpleResultSet	flann/result_set.h	/^class KNNSimpleResultSet : public ResultSet<DistanceType>$/;"	c	namespace:cvflann	inherits:ResultSet
KNNUniqueResultSet	flann/result_set.h	/^    KNNUniqueResultSet(unsigned int capacity) : capacity_(capacity)$/;"	f	class:cvflann::KNNUniqueResultSet	access:public	signature:(unsigned int capacity)
KNNUniqueResultSet	flann/result_set.h	/^class KNNUniqueResultSet : public UniqueResultSet<DistanceType>$/;"	c	namespace:cvflann	inherits:UniqueResultSet
KNearest	ml/ml.hpp	/^typedef CvKNearest KNearest;$/;"	t	namespace:cv
KULLBACK_LEIBLER	flann/defines.h	/^    KULLBACK_LEIBLER  = 8$/;"	e	enum:cvflann::flann_distance_t
K_LOG2_WARP_SIZE	gpu/NCV.hpp	/^const Ncv32u K_LOG2_WARP_SIZE = 5;$/;"	v
K_WARP_SIZE	gpu/NCV.hpp	/^const Ncv32u K_WARP_SIZE = 32;$/;"	v
KalmGainMatr	video/tracking.hpp	/^    float* KalmGainMatr;        \/* =gain->data.fl *\/$/;"	m	struct:CvKalman	access:public
KalmanFilter	video/tracking.hpp	/^    CV_WRAP KalmanFilter();$/;"	p	class:cv::KalmanFilter	access:public	signature:()
KalmanFilter	video/tracking.hpp	/^    CV_WRAP KalmanFilter(int dynamParams, int measureParams, int controlParams=0, int type=CV_32F);$/;"	p	class:cv::KalmanFilter	access:public	signature:(int dynamParams, int measureParams, int controlParams=0, int type=CV_32F)
KalmanFilter	video/tracking.hpp	/^class CV_EXPORTS_W KalmanFilter$/;"	c	namespace:cv
KeyPoint	features2d/features2d.hpp	/^    CV_WRAP KeyPoint() : pt(0,0), size(0), angle(-1), response(0), octave(0), class_id(-1) {}$/;"	f	class:cv::KeyPoint	access:public	signature:()
KeyPoint	features2d/features2d.hpp	/^    CV_WRAP KeyPoint(float x, float y, float _size, float _angle=-1,$/;"	f	class:cv::KeyPoint	access:public	signature:(float x, float y, float _size, float _angle=-1, float _response=0, int _octave=0, int _class_id=-1)
KeyPoint	features2d/features2d.hpp	/^    KeyPoint(Point2f _pt, float _size, float _angle=-1,$/;"	f	class:cv::KeyPoint	access:public	signature:(Point2f _pt, float _size, float _angle=-1, float _response=0, int _octave=0, int _class_id=-1)
KeyPoint	features2d/features2d.hpp	/^class CV_EXPORTS_W_SIMPLE KeyPoint$/;"	c	namespace:cv
KeyPointCollection	features2d/features2d.hpp	/^        KeyPointCollection( const KeyPointCollection& collection );$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( const KeyPointCollection& collection )
KeyPointCollection	features2d/features2d.hpp	/^        KeyPointCollection();$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:()
KeyPointCollection	features2d/features2d.hpp	/^    class CV_EXPORTS KeyPointCollection$/;"	c	class:cv::GenericDescriptorMatcher	access:protected
KeyPointsFilter	features2d/features2d.hpp	/^    KeyPointsFilter(){}$/;"	f	class:cv::KeyPointsFilter	access:public	signature:()
KeyPointsFilter	features2d/features2d.hpp	/^class CV_EXPORTS KeyPointsFilter$/;"	c	namespace:cv
KeypointLayout	gpu/gpu.hpp	/^            enum KeypointLayout $/;"	g	class:cv::gpu::SURF_GPU	access:public
L1	features2d/features2d.hpp	/^struct CV_EXPORTS L1$/;"	s	namespace:cv
L1	flann/dist.h	/^struct L1$/;"	s	namespace:cvflann
L1Dist	gpu/gpu.hpp	/^            enum DistType {L1Dist = 0, L2Dist, HammingDist};$/;"	e	enum:cv::gpu::BruteForceMatcher_GPU_base::DistType
L2	features2d/features2d.hpp	/^struct CV_EXPORTS L2$/;"	s	namespace:cv
L2	flann/dist.h	/^struct L2$/;"	s	namespace:cvflann
L2Dist	gpu/gpu.hpp	/^            enum DistType {L1Dist = 0, L2Dist, HammingDist};$/;"	e	enum:cv::gpu::BruteForceMatcher_GPU_base::DistType
L2Hys	objdetect/objdetect.hpp	/^    enum { L2Hys=0 };$/;"	e	enum:cv::HOGDescriptor::__anon202
L2HysThreshold	objdetect/objdetect.hpp	/^    CV_PROP double L2HysThreshold;$/;"	m	struct:cv::HOGDescriptor	access:public
L2_Simple	flann/dist.h	/^struct L2_Simple$/;"	s	namespace:cvflann
LBP	objdetect/objdetect.hpp	/^    enum { HAAR = 0, LBP = 1 };$/;"	e	enum:cv::FeatureEvaluator::__anon198
LDetector	features2d/features2d.hpp	/^    LDetector();$/;"	p	class:cv::LDetector	access:public	signature:()
LDetector	features2d/features2d.hpp	/^    LDetector(int _radius, int _threshold, int _nOctaves,$/;"	p	class:cv::LDetector	access:public	signature:(int _radius, int _threshold, int _nOctaves, int _nViews, double _baseFeatureSize, double _clusteringDistance)
LDetector	features2d/features2d.hpp	/^class CV_EXPORTS LDetector$/;"	c	namespace:cv
LINEAR	flann/defines.h	/^    LINEAR = 0,$/;"	e	enum:cvflann::flann_algorithm_t
LINEAR	ml/ml.hpp	/^    enum { LINEAR=0, POLY=1, RBF=2, SIGMOID=3 };$/;"	e	enum:CvSVM::__anon73
LMEDS	calib3d/calib3d.hpp	/^    LMEDS=CV_LMEDS, \/\/!< least-median algorithm$/;"	e	enum:cv::__anon87
LOGIT	ml/ml.hpp	/^    enum { DISCRETE=0, REAL=1, LOGIT=2, GENTLE=3 };$/;"	e	enum:CvBoost::__anon79
LOG_METHOD	flann/logger.h	108;"	d
LU	core/operations.hpp	/^CV_EXPORTS int LU(double* A, size_t astep, int m, double* b, size_t bstep, int n);$/;"	p	namespace:cv	signature:(double* A, size_t astep, int m, double* b, size_t bstep, int n)
LU	core/operations.hpp	/^CV_EXPORTS int LU(float* A, size_t astep, int m, float* b, size_t bstep, int n);$/;"	p	namespace:cv	signature:(float* A, size_t astep, int m, float* b, size_t bstep, int n)
LUT	core/core.hpp	/^CV_EXPORTS_W void LUT(InputArray src, InputArray lut, OutputArray dst,$/;"	p	namespace:cv	signature:(InputArray src, InputArray lut, OutputArray dst, int interpolation=0)
LUT	gpu/gpu.hpp	/^        CV_EXPORTS void LUT(const GpuMat& src, const Mat& lut, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, const Mat& lut, GpuMat& dst, Stream& stream = Stream::Null())
Laplacian	gpu/gpu.hpp	/^        CV_EXPORTS void Laplacian(const GpuMat& src, GpuMat& dst, int ddepth, int ksize = 1, double scale = 1, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, int ksize = 1, double scale = 1, Stream& stream = Stream::Null())
Laplacian	imgproc/imgproc.hpp	/^CV_EXPORTS_W void Laplacian( InputArray src, OutputArray dst, int ddepth,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int ddepth, int ksize=1, double scale=1, double delta=0, int borderType=BORDER_DEFAULT )
Lc	video/background_segm.hpp	/^    int    Lc;			\/* Quantized levels per 'color' component. Power of two, typically 32, 64 or 128.				*\/$/;"	m	struct:CvFGDStatModelParams	access:public
Lcc	video/background_segm.hpp	/^    int    Lcc;			\/* Quantized levels per 'color co-occurrence' component.  Power of two, typically 16, 32 or 64.			*\/$/;"	m	struct:CvFGDStatModelParams	access:public
LeftEyeRect	legacy/legacy.hpp	/^    CvRect LeftEyeRect;$/;"	m	struct:CvFace	access:public
LessThan	core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS LessThan$/;"	c	namespace:cv
LessThanIdx	core/operations.hpp	/^    LessThanIdx( const _Tp* _arr ) : arr(_arr) {}$/;"	f	class:cv::LessThanIdx	access:public	signature:( const _Tp* _arr )
LessThanIdx	core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS LessThanIdx$/;"	c	namespace:cv
LevMarqSparse	contrib/contrib.hpp	/^        LevMarqSparse();$/;"	p	class:cv::LevMarqSparse	access:public	signature:()
LevMarqSparse	contrib/contrib.hpp	/^        LevMarqSparse(int npoints, \/\/ number of points$/;"	p	class:cv::LevMarqSparse	access:public	signature:(int npoints, int ncameras, int nPointParams, int nCameraParams, int nErrParams, Mat& visibility, Mat& P0, Mat& X, TermCriteria criteria, void (CV_CDECL * fjac)(int i, int j, Mat& point_params, Mat& cam_params, Mat& A, Mat& B, void* data), void (CV_CDECL * func)(int i, int j, Mat& point_params, Mat& cam_params, Mat& estim, void* data), void* data, BundleAdjustCallback cb, void* user_data )
LevMarqSparse	contrib/contrib.hpp	/^    class LevMarqSparse {$/;"	c	namespace:cv
LineIterator	core/core.hpp	/^    LineIterator( const Mat& img, Point pt1, Point pt2,$/;"	p	class:cv::LineIterator	access:public	signature:( const Mat& img, Point pt1, Point pt2, int connectivity=8, bool leftToRight=false )
LineIterator	core/core.hpp	/^class CV_EXPORTS LineIterator$/;"	c	namespace:cv
LinearIndex	flann/linear_index.h	/^    LinearIndex(const LinearIndex&);$/;"	p	class:cvflann::LinearIndex	access:public	signature:(const LinearIndex&)
LinearIndex	flann/linear_index.h	/^    LinearIndex(const Matrix<ElementType>& inputData, const IndexParams& params = LinearIndexParams(),$/;"	f	class:cvflann::LinearIndex	access:public	signature:(const Matrix<ElementType>& inputData, const IndexParams& params = LinearIndexParams(), Distance d = Distance())
LinearIndex	flann/linear_index.h	/^class LinearIndex : public NNIndex<Distance>$/;"	c	namespace:cvflann	inherits:NNIndex
LinearIndexParams	flann/linear_index.h	/^    LinearIndexParams()$/;"	f	struct:cvflann::LinearIndexParams	access:public	signature:()
LinearIndexParams	flann/linear_index.h	/^struct LinearIndexParams : public IndexParams$/;"	s	namespace:cvflann	inherits:IndexParams
LinearIndexParams	flann/miniflann.hpp	/^    LinearIndexParams();$/;"	p	struct:cv::flann::LinearIndexParams	access:public	signature:()
LinearIndexParams	flann/miniflann.hpp	/^struct CV_EXPORTS LinearIndexParams : public IndexParams$/;"	s	namespace:cv::flann	inherits:IndexParams
Load	legacy/blobtrack.hpp	/^    bool Load( const char* \/*detector_file_name*\/ = 0 );$/;"	p	class:CvObjectDetector	access:public	signature:( const char* = 0 )
Load	legacy/blobtrack.hpp	/^    virtual void Load(CvFileStorage* fs, CvFileNode* node)$/;"	f	class:CvBlobSeq	access:public	signature:(CvFileStorage* fs, CvFileNode* node)
LoadCameraParams	legacy/legacy.hpp	/^    virtual bool LoadCameraParams( const char* filename );$/;"	p	class:CvCalibFilter	access:public	signature:( const char* filename )
LoadPCADescriptors	features2d/features2d.hpp	/^    int LoadPCADescriptors(const FileNode &fn);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(const FileNode &fn)
LoadPCADescriptors	features2d/features2d.hpp	/^    int LoadPCADescriptors(const char* filename);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(const char* filename)
LoadPCAall	features2d/features2d.hpp	/^    void LoadPCAall (const FileNode &fn);$/;"	p	class:cv::OneWayDescriptorBase	access:protected	signature:(const FileNode &fn)
LoadState	legacy/blobtrack.hpp	/^    virtual void LoadState(CvFileStorage*, CvFileNode*);$/;"	p	class:CvVSModule	access:public	signature:(CvFileStorage*, CvFileNode*)
Logger	flann/logger.h	/^    Logger() : stream(stdout), logLevel(FLANN_LOG_WARN) {}$/;"	f	class:cvflann::Logger	access:private	signature:()
Logger	flann/logger.h	/^class Logger$/;"	c	namespace:cvflann
LshIndex	flann/lsh_index.h	/^    LshIndex(const LshIndex&);$/;"	p	class:cvflann::LshIndex	access:public	signature:(const LshIndex&)
LshIndex	flann/lsh_index.h	/^    LshIndex(const Matrix<ElementType>& input_data, const IndexParams& params = LshIndexParams(),$/;"	f	class:cvflann::LshIndex	access:public	signature:(const Matrix<ElementType>& input_data, const IndexParams& params = LshIndexParams(), Distance d = Distance())
LshIndex	flann/lsh_index.h	/^class LshIndex : public NNIndex<Distance>$/;"	c	namespace:cvflann	inherits:NNIndex
LshIndexParams	flann/lsh_index.h	/^    LshIndexParams(unsigned int table_number, unsigned int key_size, unsigned int multi_probe_level)$/;"	f	struct:cvflann::LshIndexParams	access:public	signature:(unsigned int table_number, unsigned int key_size, unsigned int multi_probe_level)
LshIndexParams	flann/lsh_index.h	/^struct LshIndexParams : public IndexParams$/;"	s	namespace:cvflann	inherits:IndexParams
LshIndexParams	flann/miniflann.hpp	/^    LshIndexParams(int table_number, int key_size, int multi_probe_level);$/;"	p	struct:cv::flann::LshIndexParams	access:public	signature:(int table_number, int key_size, int multi_probe_level)
LshIndexParams	flann/miniflann.hpp	/^struct CV_EXPORTS LshIndexParams : public IndexParams$/;"	s	namespace:cv::flann	inherits:IndexParams
LshStats	flann/lsh_table.h	/^struct LshStats$/;"	s	namespace:cvflann::lsh
LshTable	flann/lsh_table.h	/^    LshTable()$/;"	f	class:cvflann::lsh::LshTable	access:public	signature:()
LshTable	flann/lsh_table.h	/^    LshTable(unsigned int \/*feature_size*\/, unsigned int \/*key_size*\/)$/;"	f	class:cvflann::lsh::LshTable	access:public	signature:(unsigned int , unsigned int )
LshTable	flann/lsh_table.h	/^class LshTable$/;"	c	namespace:cvflann::lsh
LshTable	flann/lsh_table.h	/^inline LshTable<unsigned char>::LshTable(unsigned int feature_size, unsigned int subsignature_size)$/;"	f	class:cvflann::lsh::LshTable	signature:(unsigned int feature_size, unsigned int subsignature_size)
MAGIC_MASK	core/core.hpp	/^enum { MAGIC_MASK=0xFFFF0000, TYPE_MASK=0x00000FFF, DEPTH_MASK=7 };$/;"	e	enum:cv::__anon136
MAGIC_VAL	core/core.hpp	/^    enum { MAGIC_VAL=0x42FD0000, MAX_DIM=CV_MAX_DIM, HASH_SCALE=0x5bd1e995, HASH_BIT=0x80000000 };$/;"	e	enum:cv::SparseMat::__anon146
MAGIC_VAL	core/core.hpp	/^    enum { MAGIC_VAL=0x42FF0000, AUTO_STEP=0, CONTINUOUS_FLAG=CV_MAT_CONT_FLAG, SUBMATRIX_FLAG=CV_SUBMAT_FLAG };$/;"	e	enum:cv::Mat::__anon137
MANHATTAN	flann/defines.h	/^    MANHATTAN = 2,$/;"	e	enum:cvflann::flann_distance_t
MAP	core/core.hpp	/^        MAP=6, \/\/!< mapping$/;"	e	enum:cv::FileNode::__anon149
MAT	core/core.hpp	/^    enum { KIND_SHIFT=16, NONE=0<<KIND_SHIFT, MAT=1<<KIND_SHIFT,$/;"	e	enum:cv::_InputArray::__anon134
MATX	core/core.hpp	/^        MATX=2<<KIND_SHIFT, STD_VECTOR=3<<KIND_SHIFT,$/;"	e	enum:cv::_InputArray::__anon134
MAX	core/types_c.h	272;"	d
MAX_CAMERAS	legacy/legacy.hpp	/^    enum { MAX_CAMERAS = 3 };$/;"	e	enum:CvCalibFilter::__anon189
MAX_DIM	core/core.hpp	/^    enum { MAGIC_VAL=0x42FD0000, MAX_DIM=CV_MAX_DIM, HASH_SCALE=0x5bd1e995, HASH_BIT=0x80000000 };$/;"	e	enum:cv::SparseMat::__anon146
MAX_DIST	flann/defines.h	/^    MAX_DIST   = 4,$/;"	e	enum:cvflann::flann_distance_t
MAX_ITER	core/core.hpp	/^        MAX_ITER=COUNT, \/\/!< ditto$/;"	e	enum:cv::TermCriteria::__anon139
MIN	core/types_c.h	268;"	d
MINKOWSKI	flann/defines.h	/^    MINKOWSKI = 3,$/;"	e	enum:cvflann::flann_distance_t
MISCLASS	ml/ml.hpp	/^    enum { DEFAULT=0, GINI=1, MISCLASS=3, SQERR=4 };$/;"	e	enum:CvBoost::__anon80
MNCovariance	video/tracking.hpp	/^    float* MNCovariance;        \/* =measurement_noise_cov->data.fl *\/$/;"	m	struct:CvKalman	access:public
MODIFY_A	core/core.hpp	/^    enum { MODIFY_A=1, NO_UV=2, FULL_UV=4 };$/;"	e	enum:cv::SVD::__anon142
MORPHING_METHOD_ERODE	contrib/contrib.hpp	/^        MORPHING_METHOD_ERODE = 1,$/;"	e	enum:CvAdaptiveSkinDetector::__anon3
MORPHING_METHOD_ERODE_DILATE	contrib/contrib.hpp	/^        MORPHING_METHOD_ERODE_DILATE = 3$/;"	e	enum:CvAdaptiveSkinDetector::__anon3
MORPHING_METHOD_ERODE_ERODE	contrib/contrib.hpp	/^        MORPHING_METHOD_ERODE_ERODE = 2,$/;"	e	enum:CvAdaptiveSkinDetector::__anon3
MORPHING_METHOD_NONE	contrib/contrib.hpp	/^        MORPHING_METHOD_NONE = 0,$/;"	e	enum:CvAdaptiveSkinDetector::__anon3
MORPH_BLACKHAT	imgproc/imgproc.hpp	/^       MORPH_BLACKHAT=CV_MOP_BLACKHAT };$/;"	e	enum:cv::__anon12
MORPH_CLOSE	imgproc/imgproc.hpp	/^       MORPH_OPEN=CV_MOP_OPEN, MORPH_CLOSE=CV_MOP_CLOSE,$/;"	e	enum:cv::__anon12
MORPH_CROSS	imgproc/imgproc.hpp	/^enum { MORPH_RECT=0, MORPH_CROSS=1, MORPH_ELLIPSE=2 };$/;"	e	enum:cv::__anon13
MORPH_DILATE	imgproc/imgproc.hpp	/^enum { MORPH_ERODE=CV_MOP_ERODE, MORPH_DILATE=CV_MOP_DILATE,$/;"	e	enum:cv::__anon12
MORPH_ELLIPSE	imgproc/imgproc.hpp	/^enum { MORPH_RECT=0, MORPH_CROSS=1, MORPH_ELLIPSE=2 };$/;"	e	enum:cv::__anon13
MORPH_ERODE	imgproc/imgproc.hpp	/^enum { MORPH_ERODE=CV_MOP_ERODE, MORPH_DILATE=CV_MOP_DILATE,$/;"	e	enum:cv::__anon12
MORPH_GRADIENT	imgproc/imgproc.hpp	/^       MORPH_GRADIENT=CV_MOP_GRADIENT, MORPH_TOPHAT=CV_MOP_TOPHAT,$/;"	e	enum:cv::__anon12
MORPH_OPEN	imgproc/imgproc.hpp	/^       MORPH_OPEN=CV_MOP_OPEN, MORPH_CLOSE=CV_MOP_CLOSE,$/;"	e	enum:cv::__anon12
MORPH_RECT	imgproc/imgproc.hpp	/^enum { MORPH_RECT=0, MORPH_CROSS=1, MORPH_ELLIPSE=2 };$/;"	e	enum:cv::__anon13
MORPH_TOPHAT	imgproc/imgproc.hpp	/^       MORPH_GRADIENT=CV_MOP_GRADIENT, MORPH_TOPHAT=CV_MOP_TOPHAT,$/;"	e	enum:cv::__anon12
MP	legacy/legacy.hpp	/^    int MP;$/;"	m	struct:CvConDensation	access:public
MP	video/tracking.hpp	/^    int MP;                     \/* number of measurement vector dimensions *\/$/;"	m	struct:CvKalman	access:public
MSER	features2d/features2d.hpp	/^    CV_WRAP MSER( int _delta, int _min_area, int _max_area,$/;"	p	class:cv::MSER	access:public	signature:( int _delta, int _min_area, int _max_area, double _max_variation, double _min_diversity, int _max_evolution, double _area_threshold, double _min_margin, int _edge_blur_size )
MSER	features2d/features2d.hpp	/^    CV_WRAP MSER();$/;"	p	class:cv::MSER	access:public	signature:()
MSER	features2d/features2d.hpp	/^class CV_EXPORTS_W MSER : public CvMSERParams$/;"	c	namespace:cv	inherits:CvMSERParams
MSize	core/core.hpp	/^        MSize(int* _p);$/;"	p	struct:cv::Mat::MSize	access:public	signature:(int* _p)
MSize	core/core.hpp	/^    struct CV_EXPORTS MSize$/;"	s	class:cv::Mat	access:public
MSize	core/mat.hpp	/^inline Mat::MSize::MSize(int* _p) : p(_p) {}$/;"	f	class:cv::Mat::MSize	signature:(int* _p)
MStep	core/core.hpp	/^        MStep();$/;"	p	struct:cv::Mat::MStep	access:public	signature:()
MStep	core/core.hpp	/^        MStep(size_t s);$/;"	p	struct:cv::Mat::MStep	access:public	signature:(size_t s)
MStep	core/core.hpp	/^    struct CV_EXPORTS MStep$/;"	s	class:cv::Mat	access:public
MStep	core/mat.hpp	/^inline Mat::MStep::MStep() { p = buf; p[0] = p[1] = 0; }$/;"	f	class:cv::Mat::MStep	signature:()
MStep	core/mat.hpp	/^inline Mat::MStep::MStep(size_t s) { p = buf; p[0] = s; p[1] = 0; }$/;"	f	class:cv::Mat::MStep	signature:(size_t s)
Mahalanobis	core/core.hpp	/^CV_EXPORTS_W double Mahalanobis(InputArray v1, InputArray v2, InputArray icovar);$/;"	p	namespace:cv	signature:(InputArray v1, InputArray v2, InputArray icovar)
Mahalonobis	core/core.hpp	/^CV_EXPORTS double Mahalonobis(InputArray v1, InputArray v2, InputArray icovar);$/;"	p	namespace:cv	signature:(InputArray v1, InputArray v2, InputArray icovar)
Mat	core/core.hpp	/^    Mat();$/;"	p	class:cv::Mat	access:public	signature:()
Mat	core/core.hpp	/^    Mat(Size _size, int _type);$/;"	p	class:cv::Mat	access:public	signature:(Size _size, int _type)
Mat	core/core.hpp	/^    Mat(Size _size, int _type, const Scalar& _s);$/;"	p	class:cv::Mat	access:public	signature:(Size _size, int _type, const Scalar& _s)
Mat	core/core.hpp	/^    Mat(Size _size, int _type, void* _data, size_t _step=AUTO_STEP);$/;"	p	class:cv::Mat	access:public	signature:(Size _size, int _type, void* _data, size_t _step=AUTO_STEP)
Mat	core/core.hpp	/^    Mat(const CvMat* m, bool copyData=false);$/;"	p	class:cv::Mat	access:public	signature:(const CvMat* m, bool copyData=false)
Mat	core/core.hpp	/^    Mat(const CvMatND* m, bool copyData=false);$/;"	p	class:cv::Mat	access:public	signature:(const CvMatND* m, bool copyData=false)
Mat	core/core.hpp	/^    Mat(const IplImage* img, bool copyData=false);$/;"	p	class:cv::Mat	access:public	signature:(const IplImage* img, bool copyData=false)
Mat	core/core.hpp	/^    Mat(const Mat& m);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m)
Mat	core/core.hpp	/^    Mat(const Mat& m, const Range& rowRange, const Range& colRange=Range::all());$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m, const Range& rowRange, const Range& colRange=Range::all())
Mat	core/core.hpp	/^    Mat(const Mat& m, const Range* ranges);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m, const Range* ranges)
Mat	core/core.hpp	/^    Mat(const Mat& m, const Rect& roi);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m, const Rect& roi)
Mat	core/core.hpp	/^    Mat(int _ndims, const int* _sizes, int _type);$/;"	p	class:cv::Mat	access:public	signature:(int _ndims, const int* _sizes, int _type)
Mat	core/core.hpp	/^    Mat(int _ndims, const int* _sizes, int _type, const Scalar& _s);$/;"	p	class:cv::Mat	access:public	signature:(int _ndims, const int* _sizes, int _type, const Scalar& _s)
Mat	core/core.hpp	/^    Mat(int _ndims, const int* _sizes, int _type, void* _data, const size_t* _steps=0);$/;"	p	class:cv::Mat	access:public	signature:(int _ndims, const int* _sizes, int _type, void* _data, const size_t* _steps=0)
Mat	core/core.hpp	/^    Mat(int _rows, int _cols, int _type);$/;"	p	class:cv::Mat	access:public	signature:(int _rows, int _cols, int _type)
Mat	core/core.hpp	/^    Mat(int _rows, int _cols, int _type, const Scalar& _s);$/;"	p	class:cv::Mat	access:public	signature:(int _rows, int _cols, int _type, const Scalar& _s)
Mat	core/core.hpp	/^    Mat(int _rows, int _cols, int _type, void* _data, size_t _step=AUTO_STEP);$/;"	p	class:cv::Mat	access:public	signature:(int _rows, int _cols, int _type, void* _data, size_t _step=AUTO_STEP)
Mat	core/core.hpp	/^    template<typename _Tp, int m, int n> explicit Mat(const Matx<_Tp, m, n>& mtx,$/;"	p	class:cv::Mat	access:public	signature:(const Matx<_Tp, m, n>& mtx, bool copyData=true)
Mat	core/core.hpp	/^    template<typename _Tp, int n> explicit Mat(const Vec<_Tp, n>& vec,$/;"	p	class:cv::Mat	access:public	signature:(const Vec<_Tp, n>& vec, bool copyData=true)
Mat	core/core.hpp	/^    template<typename _Tp> explicit Mat(const MatCommaInitializer_<_Tp>& commaInitializer);$/;"	p	class:cv::Mat	access:public	signature:(const MatCommaInitializer_<_Tp>& commaInitializer)
Mat	core/core.hpp	/^    template<typename _Tp> explicit Mat(const Point3_<_Tp>& pt, bool copyData=true);$/;"	p	class:cv::Mat	access:public	signature:(const Point3_<_Tp>& pt, bool copyData=true)
Mat	core/core.hpp	/^    template<typename _Tp> explicit Mat(const Point_<_Tp>& pt, bool copyData=true);$/;"	p	class:cv::Mat	access:public	signature:(const Point_<_Tp>& pt, bool copyData=true)
Mat	core/core.hpp	/^    template<typename _Tp> explicit Mat(const vector<_Tp>& vec, bool copyData=false);$/;"	p	class:cv::Mat	access:public	signature:(const vector<_Tp>& vec, bool copyData=false)
Mat	core/core.hpp	/^class CV_EXPORTS Mat$/;"	c	namespace:cv
Mat	core/mat.hpp	/^inline Mat::Mat()$/;"	f	class:cv::Mat	signature:()
Mat	core/mat.hpp	/^inline Mat::Mat(Size _sz, int _type)$/;"	f	class:cv::Mat	signature:(Size _sz, int _type)
Mat	core/mat.hpp	/^inline Mat::Mat(Size _sz, int _type, const Scalar& _s)$/;"	f	class:cv::Mat	signature:(Size _sz, int _type, const Scalar& _s)
Mat	core/mat.hpp	/^inline Mat::Mat(Size _sz, int _type, void* _data, size_t _step)$/;"	f	class:cv::Mat	signature:(Size _sz, int _type, void* _data, size_t _step)
Mat	core/mat.hpp	/^inline Mat::Mat(const CvMat* m, bool copyData)$/;"	f	class:cv::Mat	signature:(const CvMat* m, bool copyData)
Mat	core/mat.hpp	/^inline Mat::Mat(const Mat& m)$/;"	f	class:cv::Mat	signature:(const Mat& m)
Mat	core/mat.hpp	/^inline Mat::Mat(int _dims, const int* _sz, int _type)$/;"	f	class:cv::Mat	signature:(int _dims, const int* _sz, int _type)
Mat	core/mat.hpp	/^inline Mat::Mat(int _dims, const int* _sz, int _type, const Scalar& _s)$/;"	f	class:cv::Mat	signature:(int _dims, const int* _sz, int _type, const Scalar& _s)
Mat	core/mat.hpp	/^inline Mat::Mat(int _rows, int _cols, int _type)$/;"	f	class:cv::Mat	signature:(int _rows, int _cols, int _type)
Mat	core/mat.hpp	/^inline Mat::Mat(int _rows, int _cols, int _type, const Scalar& _s)$/;"	f	class:cv::Mat	signature:(int _rows, int _cols, int _type, const Scalar& _s)
Mat	core/mat.hpp	/^inline Mat::Mat(int _rows, int _cols, int _type, void* _data, size_t _step)$/;"	f	class:cv::Mat	signature:(int _rows, int _cols, int _type, void* _data, size_t _step)
Mat	core/mat.hpp	/^template<typename _Tp, int m, int n> inline Mat::Mat(const Matx<_Tp,m,n>& M, bool copyData)$/;"	f	class:cv::Mat	signature:(const Matx<_Tp,m,n>& M, bool copyData)
Mat	core/mat.hpp	/^template<typename _Tp, int n> inline Mat::Mat(const Vec<_Tp, n>& vec, bool copyData)$/;"	f	class:cv::Mat	signature:(const Vec<_Tp, n>& vec, bool copyData)
Mat	core/mat.hpp	/^template<typename _Tp> inline Mat::Mat(const MatCommaInitializer_<_Tp>& commaInitializer)$/;"	f	class:cv::Mat	signature:(const MatCommaInitializer_<_Tp>& commaInitializer)
Mat	core/mat.hpp	/^template<typename _Tp> inline Mat::Mat(const Point3_<_Tp>& pt, bool copyData)$/;"	f	class:cv::Mat	signature:(const Point3_<_Tp>& pt, bool copyData)
Mat	core/mat.hpp	/^template<typename _Tp> inline Mat::Mat(const Point_<_Tp>& pt, bool copyData)$/;"	f	class:cv::Mat	signature:(const Point_<_Tp>& pt, bool copyData)
Mat	core/mat.hpp	/^template<typename _Tp> inline Mat::Mat(const vector<_Tp>& vec, bool copyData)$/;"	f	class:cv::Mat	signature:(const vector<_Tp>& vec, bool copyData)
Mat1b	core/core.hpp	/^typedef Mat_<uchar> Mat1b;$/;"	t	namespace:cv
Mat1d	core/core.hpp	/^typedef Mat_<double> Mat1d;$/;"	t	namespace:cv
Mat1f	core/core.hpp	/^typedef Mat_<float> Mat1f;$/;"	t	namespace:cv
Mat1i	core/core.hpp	/^typedef Mat_<int>   Mat1i;$/;"	t	namespace:cv
Mat1s	core/core.hpp	/^typedef Mat_<short> Mat1s;$/;"	t	namespace:cv
Mat1w	core/core.hpp	/^typedef Mat_<ushort> Mat1w;$/;"	t	namespace:cv
Mat2b	core/core.hpp	/^typedef Mat_<Vec2b> Mat2b;$/;"	t	namespace:cv
Mat2d	core/core.hpp	/^typedef Mat_<Vec2d> Mat2d;$/;"	t	namespace:cv
Mat2f	core/core.hpp	/^typedef Mat_<Vec2f> Mat2f;$/;"	t	namespace:cv
Mat2i	core/core.hpp	/^typedef Mat_<Vec2i> Mat2i;$/;"	t	namespace:cv
Mat2s	core/core.hpp	/^typedef Mat_<Vec2s> Mat2s;$/;"	t	namespace:cv
Mat2w	core/core.hpp	/^typedef Mat_<Vec2w> Mat2w;$/;"	t	namespace:cv
Mat3b	core/core.hpp	/^typedef Mat_<Vec3b> Mat3b;$/;"	t	namespace:cv
Mat3d	core/core.hpp	/^typedef Mat_<Vec3d> Mat3d;$/;"	t	namespace:cv
Mat3f	core/core.hpp	/^typedef Mat_<Vec3f> Mat3f;$/;"	t	namespace:cv
Mat3i	core/core.hpp	/^typedef Mat_<Vec3i> Mat3i;$/;"	t	namespace:cv
Mat3s	core/core.hpp	/^typedef Mat_<Vec3s> Mat3s;$/;"	t	namespace:cv
Mat3w	core/core.hpp	/^typedef Mat_<Vec3w> Mat3w;$/;"	t	namespace:cv
Mat4b	core/core.hpp	/^typedef Mat_<Vec4b> Mat4b;$/;"	t	namespace:cv
Mat4d	core/core.hpp	/^typedef Mat_<Vec4d> Mat4d;$/;"	t	namespace:cv
Mat4f	core/core.hpp	/^typedef Mat_<Vec4f> Mat4f;$/;"	t	namespace:cv
Mat4i	core/core.hpp	/^typedef Mat_<Vec4i> Mat4i;$/;"	t	namespace:cv
Mat4s	core/core.hpp	/^typedef Mat_<Vec4s> Mat4s;$/;"	t	namespace:cv
Mat4w	core/core.hpp	/^typedef Mat_<Vec4w> Mat4w;$/;"	t	namespace:cv
MatAllocator	core/core.hpp	/^    MatAllocator() {}$/;"	f	class:cv::MatAllocator	access:public	signature:()
MatAllocator	core/core.hpp	/^class CV_EXPORTS MatAllocator$/;"	c	namespace:cv
MatArg	core/core.hpp	/^class CV_EXPORTS MatArg;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
MatCommaInitializer_	core/core.hpp	/^    MatCommaInitializer_(Mat_<_Tp>* _m);$/;"	p	class:cv::MatCommaInitializer_	access:public	signature:(Mat_<_Tp>* _m)
MatCommaInitializer_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS MatCommaInitializer_$/;"	c	namespace:cv
MatCommaInitializer_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS MatCommaInitializer_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
MatCommaInitializer_	core/mat.hpp	/^template<typename _Tp> inline MatCommaInitializer_<_Tp>::MatCommaInitializer_(Mat_<_Tp>* _m) : it(_m) {}$/;"	f	class:cv::MatCommaInitializer_	signature:(Mat_<_Tp>* _m)
MatConstIterator	core/core.hpp	/^    MatConstIterator();$/;"	p	class:cv::MatConstIterator	access:public	signature:()
MatConstIterator	core/core.hpp	/^    MatConstIterator(const Mat* _m);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const Mat* _m)
MatConstIterator	core/core.hpp	/^    MatConstIterator(const Mat* _m, Point _pt);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const Mat* _m, Point _pt)
MatConstIterator	core/core.hpp	/^    MatConstIterator(const Mat* _m, const int* _idx);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const Mat* _m, const int* _idx)
MatConstIterator	core/core.hpp	/^    MatConstIterator(const Mat* _m, int _row, int _col=0);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const Mat* _m, int _row, int _col=0)
MatConstIterator	core/core.hpp	/^    MatConstIterator(const MatConstIterator& it);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const MatConstIterator& it)
MatConstIterator	core/core.hpp	/^class CV_EXPORTS MatConstIterator$/;"	c	namespace:cv
MatConstIterator	core/core.hpp	/^class CV_EXPORTS MatConstIterator;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
MatConstIterator	core/mat.hpp	/^inline MatConstIterator::MatConstIterator()$/;"	f	class:cv::MatConstIterator	signature:()
MatConstIterator	core/mat.hpp	/^inline MatConstIterator::MatConstIterator(const Mat* _m)$/;"	f	class:cv::MatConstIterator	signature:(const Mat* _m)
MatConstIterator	core/mat.hpp	/^inline MatConstIterator::MatConstIterator(const Mat* _m, Point _pt)$/;"	f	class:cv::MatConstIterator	signature:(const Mat* _m, Point _pt)
MatConstIterator	core/mat.hpp	/^inline MatConstIterator::MatConstIterator(const Mat* _m, int _row, int _col)$/;"	f	class:cv::MatConstIterator	signature:(const Mat* _m, int _row, int _col)
MatConstIterator	core/mat.hpp	/^inline MatConstIterator::MatConstIterator(const MatConstIterator& it)$/;"	f	class:cv::MatConstIterator	signature:(const MatConstIterator& it)
MatConstIterator_	core/core.hpp	/^    MatConstIterator_();$/;"	p	class:cv::MatConstIterator_	access:public	signature:()
MatConstIterator_	core/core.hpp	/^    MatConstIterator_(const MatConstIterator_& it);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const MatConstIterator_& it)
MatConstIterator_	core/core.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const Mat_<_Tp>* _m)
MatConstIterator_	core/core.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m, Point _pt);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const Mat_<_Tp>* _m, Point _pt)
MatConstIterator_	core/core.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m, const int* _idx);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const Mat_<_Tp>* _m, const int* _idx)
MatConstIterator_	core/core.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m, int _row, int _col=0);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const Mat_<_Tp>* _m, int _row, int _col=0)
MatConstIterator_	core/core.hpp	/^class CV_EXPORTS MatConstIterator_ : public MatConstIterator$/;"	c	namespace:cv	inherits:MatConstIterator
MatConstIterator_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS MatConstIterator_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
MatConstIterator_	core/mat.hpp	/^    MatConstIterator_(const MatConstIterator_& it)$/;"	f	class:cv::MatConstIterator_	signature:(const MatConstIterator_& it)
MatConstIterator_	core/mat.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m, Point _pt)$/;"	f	class:cv::MatConstIterator_	signature:(const Mat_<_Tp>* _m, Point _pt)
MatConstIterator_	core/mat.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m, int _row, int _col)$/;"	f	class:cv::MatConstIterator_	signature:(const Mat_<_Tp>* _m, int _row, int _col)
MatConstIterator_	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>::MatConstIterator_() {}$/;"	f	class:cv::MatConstIterator_	signature:()
MatConstIterator_	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>::MatConstIterator_(const Mat_<_Tp>* _m)$/;"	f	class:cv::MatConstIterator_	signature:(const Mat_<_Tp>* _m)
MatExpr	core/core.hpp	/^class CV_EXPORTS MatExpr;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
MatExpr	core/mat.hpp	/^    MatExpr() : op(0), flags(0), a(Mat()), b(Mat()), c(Mat()), alpha(0), beta(0), s(Scalar()) {}$/;"	f	class:cv::MatExpr	access:public	signature:()
MatExpr	core/mat.hpp	/^    MatExpr(const MatOp* _op, int _flags, const Mat& _a=Mat(), const Mat& _b=Mat(),$/;"	f	class:cv::MatExpr	access:public	signature:(const MatOp* _op, int _flags, const Mat& _a=Mat(), const Mat& _b=Mat(), const Mat& _c=Mat(), double _alpha=1, double _beta=1, const Scalar& _s=Scalar())
MatExpr	core/mat.hpp	/^    explicit MatExpr(const Mat& m);$/;"	p	class:cv::MatExpr	access:public	signature:(const Mat& m)
MatExpr	core/mat.hpp	/^class CV_EXPORTS MatExpr$/;"	c	namespace:cv
MatIterator_	core/core.hpp	/^    MatIterator_();$/;"	p	class:cv::MatIterator_	access:public	signature:()
MatIterator_	core/core.hpp	/^    MatIterator_(Mat_<_Tp>* _m);$/;"	p	class:cv::MatIterator_	access:public	signature:(Mat_<_Tp>* _m)
MatIterator_	core/core.hpp	/^    MatIterator_(Mat_<_Tp>* _m, int _row, int _col=0);$/;"	p	class:cv::MatIterator_	access:public	signature:(Mat_<_Tp>* _m, int _row, int _col=0)
MatIterator_	core/core.hpp	/^    MatIterator_(const MatIterator_& it);$/;"	p	class:cv::MatIterator_	access:public	signature:(const MatIterator_& it)
MatIterator_	core/core.hpp	/^    MatIterator_(const Mat_<_Tp>* _m, Point _pt);$/;"	p	class:cv::MatIterator_	access:public	signature:(const Mat_<_Tp>* _m, Point _pt)
MatIterator_	core/core.hpp	/^    MatIterator_(const Mat_<_Tp>* _m, const int* _idx);$/;"	p	class:cv::MatIterator_	access:public	signature:(const Mat_<_Tp>* _m, const int* _idx)
MatIterator_	core/core.hpp	/^class CV_EXPORTS MatIterator_ : public MatConstIterator_<_Tp>$/;"	c	namespace:cv	inherits:MatConstIterator_
MatIterator_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS MatIterator_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
MatIterator_	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_() : MatConstIterator_<_Tp>() {}$/;"	f	class:cv::MatIterator_	signature:()
MatIterator_	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m)$/;"	f	class:cv::MatIterator_	signature:(Mat_<_Tp>* _m)
MatIterator_	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m, int _row, int _col)$/;"	f	class:cv::MatIterator_	signature:(Mat_<_Tp>* _m, int _row, int _col)
MatIterator_	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(const MatIterator_& it)$/;"	f	class:cv::MatIterator_	signature:(const MatIterator_& it)
MatIterator_	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(const Mat_<_Tp>* _m, Point _pt)$/;"	f	class:cv::MatIterator_	signature:(const Mat_<_Tp>* _m, Point _pt)
MatIterator_	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(const Mat_<_Tp>* _m, const int* _idx)$/;"	f	class:cv::MatIterator_	signature:(const Mat_<_Tp>* _m, const int* _idx)
MatND	core/core.hpp	/^typedef Mat MatND;$/;"	t	namespace:cv
MatOp	core/mat.hpp	/^    MatOp() {};$/;"	f	class:cv::MatOp	access:public	signature:()
MatOp	core/mat.hpp	/^class CV_EXPORTS MatOp$/;"	c	namespace:cv
MatOp_Base	core/core.hpp	/^class CV_EXPORTS MatOp_Base;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
MatOp_Iter_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS MatOp_Iter_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
Mat_	core/core.hpp	/^    Mat_();$/;"	p	class:cv::Mat_	access:public	signature:()
Mat_	core/core.hpp	/^    Mat_(Size _size, const _Tp& value);$/;"	p	class:cv::Mat_	access:public	signature:(Size _size, const _Tp& value)
Mat_	core/core.hpp	/^    Mat_(const Mat& m);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat& m)
Mat_	core/core.hpp	/^    Mat_(const Mat_& m);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m)
Mat_	core/core.hpp	/^    Mat_(const Mat_& m, const Range& rowRange, const Range& colRange=Range::all());$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m, const Range& rowRange, const Range& colRange=Range::all())
Mat_	core/core.hpp	/^    Mat_(const Mat_& m, const Range* ranges);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m, const Range* ranges)
Mat_	core/core.hpp	/^    Mat_(const Mat_& m, const Rect& roi);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m, const Rect& roi)
Mat_	core/core.hpp	/^    Mat_(int _ndims, const int* _sizes);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes)
Mat_	core/core.hpp	/^    Mat_(int _ndims, const int* _sizes, _Tp* _data, const size_t* _steps=0);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes, _Tp* _data, const size_t* _steps=0)
Mat_	core/core.hpp	/^    Mat_(int _ndims, const int* _sizes, const _Tp& value);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes, const _Tp& value)
Mat_	core/core.hpp	/^    Mat_(int _rows, int _cols);$/;"	p	class:cv::Mat_	access:public	signature:(int _rows, int _cols)
Mat_	core/core.hpp	/^    Mat_(int _rows, int _cols, _Tp* _data, size_t _step=AUTO_STEP);$/;"	p	class:cv::Mat_	access:public	signature:(int _rows, int _cols, _Tp* _data, size_t _step=AUTO_STEP)
Mat_	core/core.hpp	/^    Mat_(int _rows, int _cols, const _Tp& value);$/;"	p	class:cv::Mat_	access:public	signature:(int _rows, int _cols, const _Tp& value)
Mat_	core/core.hpp	/^    explicit Mat_(Size _size);$/;"	p	class:cv::Mat_	access:public	signature:(Size _size)
Mat_	core/core.hpp	/^    explicit Mat_(const MatCommaInitializer_<_Tp>& commaInitializer);$/;"	p	class:cv::Mat_	access:public	signature:(const MatCommaInitializer_<_Tp>& commaInitializer)
Mat_	core/core.hpp	/^    explicit Mat_(const MatExpr& e);$/;"	p	class:cv::Mat_	access:public	signature:(const MatExpr& e)
Mat_	core/core.hpp	/^    explicit Mat_(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData=true);$/;"	p	class:cv::Mat_	access:public	signature:(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData=true)
Mat_	core/core.hpp	/^    explicit Mat_(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData=true);$/;"	p	class:cv::Mat_	access:public	signature:(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData=true)
Mat_	core/core.hpp	/^    explicit Mat_(const vector<_Tp>& vec, bool copyData=false);$/;"	p	class:cv::Mat_	access:public	signature:(const vector<_Tp>& vec, bool copyData=false)
Mat_	core/core.hpp	/^    template<int m, int n> explicit Mat_(const Matx<typename DataType<_Tp>::channel_type, m, n>& mtx, bool copyData=true);$/;"	p	class:cv::Mat_	access:public	signature:(const Matx<typename DataType<_Tp>::channel_type, m, n>& mtx, bool copyData=true)
Mat_	core/core.hpp	/^    template<int n> explicit Mat_(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData=true);$/;"	p	class:cv::Mat_	access:public	signature:(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData=true)
Mat_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Mat_ : public Mat$/;"	c	namespace:cv	inherits:Mat
Mat_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Mat_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
Mat_	core/mat.hpp	/^    Mat_<_Tp>::Mat_(const Matx<typename DataType<_Tp>::channel_type,m,n>& M, bool copyData)$/;"	f	class:cv::Mat_	signature:(const Matx<typename DataType<_Tp>::channel_type,m,n>& M, bool copyData)
Mat_	core/mat.hpp	/^    Mat_<_Tp>::Mat_(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData)$/;"	f	class:cv::Mat_	signature:(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData)
Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_()$/;"	f	class:cv::Mat_	signature:()
Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(Size _sz)$/;"	f	class:cv::Mat_	signature:(Size _sz)
Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(Size _sz, const _Tp& value)$/;"	f	class:cv::Mat_	signature:(Size _sz, const _Tp& value)
Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat& m)$/;"	f	class:cv::Mat_	signature:(const Mat& m)
Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const MatCommaInitializer_<_Tp>& commaInitializer)$/;"	f	class:cv::Mat_	signature:(const MatCommaInitializer_<_Tp>& commaInitializer)
Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const MatExpr& e)$/;"	f	class:cv::Mat_	signature:(const MatExpr& e)
Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_& m)$/;"	f	class:cv::Mat_	signature:(const Mat_& m)
Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_& m, const Range& rowRange, const Range& colRange)$/;"	f	class:cv::Mat_	signature:(const Mat_& m, const Range& rowRange, const Range& colRange)
Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_& m, const Rect& roi)$/;"	f	class:cv::Mat_	signature:(const Mat_& m, const Rect& roi)
Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_<_Tp>& m, const Range* ranges)$/;"	f	class:cv::Mat_	signature:(const Mat_<_Tp>& m, const Range* ranges)
Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData)$/;"	f	class:cv::Mat_	signature:(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData)
Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData)$/;"	f	class:cv::Mat_	signature:(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData)
Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const vector<_Tp>& vec, bool copyData)$/;"	f	class:cv::Mat_	signature:(const vector<_Tp>& vec, bool copyData)
Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(int _dims, const int* _sz)$/;"	f	class:cv::Mat_	signature:(int _dims, const int* _sz)
Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(int _dims, const int* _sz, const _Tp& _s)$/;"	f	class:cv::Mat_	signature:(int _dims, const int* _sz, const _Tp& _s)
Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(int _rows, int _cols)$/;"	f	class:cv::Mat_	signature:(int _rows, int _cols)
Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(int _rows, int _cols, _Tp* _data, size_t steps)$/;"	f	class:cv::Mat_	signature:(int _rows, int _cols, _Tp* _data, size_t steps)
Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(int _rows, int _cols, const _Tp& value)$/;"	f	class:cv::Mat_	signature:(int _rows, int _cols, const _Tp& value)
MatchPointToPart	features2d/features2d.hpp	/^    int MatchPointToPart(CvPoint pt) const;$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(CvPoint pt) const
Matrix	flann/matrix.h	/^    Matrix() : rows(0), cols(0), stride(0), data(NULL)$/;"	f	class:cvflann::Matrix	access:public	signature:()
Matrix	flann/matrix.h	/^    Matrix(T* data_, size_t rows_, size_t cols_, size_t stride_ = 0) :$/;"	f	class:cvflann::Matrix	access:public	signature:(T* data_, size_t rows_, size_t cols_, size_t stride_ = 0)
Matrix	flann/matrix.h	/^class Matrix$/;"	c	namespace:cvflann
Matx	core/core.hpp	/^    Matx();$/;"	p	class:cv::Matx	access:public	signature:()
Matx	core/core.hpp	/^    Matx(_Tp v0); \/\/!< 1x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0)
Matx	core/core.hpp	/^    Matx(_Tp v0, _Tp v1); \/\/!< 1x2 or 2x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1)
Matx	core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2); \/\/!< 1x3 or 3x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2)
Matx	core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3); \/\/!< 1x4, 2x2 or 4x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
Matx	core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4); \/\/!< 1x5 or 5x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)
Matx	core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5); \/\/!< 1x6, 2x3, 3x2 or 6x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)
Matx	core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6); \/\/!< 1x7 or 7x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6)
Matx	core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7); \/\/!< 1x8, 2x4, 4x2 or 8x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7)
Matx	core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8); \/\/!< 1x9, 3x3 or 9x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8)
Matx	core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9); \/\/!< 1x10, 2x5 or 5x2 or 10x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9)
Matx	core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11)
Matx	core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13, _Tp v14, _Tp v15)
Matx	core/core.hpp	/^    Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_AddOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_AddOp)
Matx	core/core.hpp	/^    Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_MulOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_MulOp)
Matx	core/core.hpp	/^    Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_SubOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_SubOp)
Matx	core/core.hpp	/^    Matx(const Matx<_Tp, n, m>& a, Matx_TOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, n, m>& a, Matx_TOp)
Matx	core/core.hpp	/^    explicit Matx(const _Tp* vals); \/\/!< initialize from a plain array$/;"	p	class:cv::Matx	access:public	signature:(const _Tp* vals)
Matx	core/core.hpp	/^    template<int l> Matx(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b, Matx_MatMulOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b, Matx_MatMulOp)
Matx	core/core.hpp	/^    template<typename _T2> Matx(const Matx<_Tp, m, n>& a, _T2 alpha, Matx_ScaleOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& a, _T2 alpha, Matx_ScaleOp)
Matx	core/core.hpp	/^template<typename _Tp, int m, int n> class CV_EXPORTS Matx$/;"	c	namespace:cv
Matx	core/core.hpp	/^template<typename _Tp, int m, int n> class CV_EXPORTS Matx;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
Matx	core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b, Matx_MatMulOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b, Matx_MatMulOp)
Matx	core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, _T2 alpha, Matx_ScaleOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& a, _T2 alpha, Matx_ScaleOp)
Matx	core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_AddOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_AddOp)
Matx	core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_MulOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_MulOp)
Matx	core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_SubOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_SubOp)
Matx	core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, n, m>& a, Matx_TOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, n, m>& a, Matx_TOp)
Matx	core/operations.hpp	/^inline Matx<_Tp,m,n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11)
Matx	core/operations.hpp	/^inline Matx<_Tp,m,n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13, _Tp v14, _Tp v15)
Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx()$/;"	f	class:cv::Matx	signature:()
Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0)$/;"	f	class:cv::Matx	signature:(_Tp v0)
Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1)$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1)
Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2)$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2)
Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3)$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)
Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)
Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6)
Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7)
Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8)
Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9)
Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(const _Tp* values)$/;"	f	class:cv::Matx	signature:(const _Tp* values)
Matx12d	core/core.hpp	/^typedef Matx<double, 1, 2> Matx12d;$/;"	t	namespace:cv
Matx12f	core/core.hpp	/^typedef Matx<float, 1, 2> Matx12f;$/;"	t	namespace:cv
Matx13d	core/core.hpp	/^typedef Matx<double, 1, 3> Matx13d;$/;"	t	namespace:cv
Matx13f	core/core.hpp	/^typedef Matx<float, 1, 3> Matx13f;$/;"	t	namespace:cv
Matx14d	core/core.hpp	/^typedef Matx<double, 1, 4> Matx14d;$/;"	t	namespace:cv
Matx14f	core/core.hpp	/^typedef Matx<float, 1, 4> Matx14f;$/;"	t	namespace:cv
Matx16d	core/core.hpp	/^typedef Matx<double, 1, 6> Matx16d;$/;"	t	namespace:cv
Matx16f	core/core.hpp	/^typedef Matx<float, 1, 6> Matx16f;$/;"	t	namespace:cv
Matx21d	core/core.hpp	/^typedef Matx<double, 2, 1> Matx21d;$/;"	t	namespace:cv
Matx21f	core/core.hpp	/^typedef Matx<float, 2, 1> Matx21f;$/;"	t	namespace:cv
Matx22d	core/core.hpp	/^typedef Matx<double, 2, 2> Matx22d;$/;"	t	namespace:cv
Matx22f	core/core.hpp	/^typedef Matx<float, 2, 2> Matx22f;$/;"	t	namespace:cv
Matx23d	core/core.hpp	/^typedef Matx<double, 2, 3> Matx23d;$/;"	t	namespace:cv
Matx23f	core/core.hpp	/^typedef Matx<float, 2, 3> Matx23f;$/;"	t	namespace:cv
Matx31d	core/core.hpp	/^typedef Matx<double, 3, 1> Matx31d;$/;"	t	namespace:cv
Matx31f	core/core.hpp	/^typedef Matx<float, 3, 1> Matx31f;$/;"	t	namespace:cv
Matx32d	core/core.hpp	/^typedef Matx<double, 3, 2> Matx32d;$/;"	t	namespace:cv
Matx32f	core/core.hpp	/^typedef Matx<float, 3, 2> Matx32f;$/;"	t	namespace:cv
Matx33d	core/core.hpp	/^typedef Matx<double, 3, 3> Matx33d;$/;"	t	namespace:cv
Matx33f	core/core.hpp	/^typedef Matx<float, 3, 3> Matx33f;$/;"	t	namespace:cv
Matx34d	core/core.hpp	/^typedef Matx<double, 3, 4> Matx34d;$/;"	t	namespace:cv
Matx34f	core/core.hpp	/^typedef Matx<float, 3, 4> Matx34f;$/;"	t	namespace:cv
Matx41d	core/core.hpp	/^typedef Matx<double, 4, 1> Matx41d;$/;"	t	namespace:cv
Matx41f	core/core.hpp	/^typedef Matx<float, 4, 1> Matx41f;$/;"	t	namespace:cv
Matx43d	core/core.hpp	/^typedef Matx<double, 4, 3> Matx43d;$/;"	t	namespace:cv
Matx43f	core/core.hpp	/^typedef Matx<float, 4, 3> Matx43f;$/;"	t	namespace:cv
Matx44d	core/core.hpp	/^typedef Matx<double, 4, 4> Matx44d;$/;"	t	namespace:cv
Matx44f	core/core.hpp	/^typedef Matx<float, 4, 4> Matx44f;$/;"	t	namespace:cv
Matx61d	core/core.hpp	/^typedef Matx<double, 6, 1> Matx61d;$/;"	t	namespace:cv
Matx61f	core/core.hpp	/^typedef Matx<float, 6, 1> Matx61f;$/;"	t	namespace:cv
Matx66d	core/core.hpp	/^typedef Matx<double, 6, 6> Matx66d;    $/;"	t	namespace:cv
Matx66f	core/core.hpp	/^typedef Matx<float, 6, 6> Matx66f;$/;"	t	namespace:cv
MatxCommaInitializer	core/core.hpp	/^    MatxCommaInitializer(Matx<_Tp, m, n>* _mtx);$/;"	p	class:cv::MatxCommaInitializer	access:public	signature:(Matx<_Tp, m, n>* _mtx)
MatxCommaInitializer	core/core.hpp	/^template<typename _Tp, int m, int n> class CV_EXPORTS MatxCommaInitializer$/;"	c	namespace:cv
MatxCommaInitializer	core/operations.hpp	/^MatxCommaInitializer<_Tp, m, n>::MatxCommaInitializer(Matx<_Tp, m, n>* _mtx)$/;"	f	class:cv::MatxCommaInitializer	signature:(Matx<_Tp, m, n>* _mtx)
Matx_AddOp	core/core.hpp	/^struct CV_EXPORTS Matx_AddOp {};$/;"	s	namespace:cv
Matx_DetOp	core/operations.hpp	/^template<typename _Tp, int m> struct CV_EXPORTS Matx_DetOp$/;"	s	namespace:cv
Matx_DetOp	core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_DetOp<_Tp, 1>$/;"	s	namespace:cv
Matx_DetOp	core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_DetOp<_Tp, 2>$/;"	s	namespace:cv
Matx_DetOp	core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_DetOp<_Tp, 3>$/;"	s	namespace:cv
Matx_FastInvOp	core/operations.hpp	/^template<typename _Tp, int m> struct CV_EXPORTS Matx_FastInvOp$/;"	s	namespace:cv
Matx_FastInvOp	core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_FastInvOp<_Tp, 2>$/;"	s	namespace:cv
Matx_FastInvOp	core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_FastInvOp<_Tp, 3>$/;"	s	namespace:cv
Matx_FastSolveOp	core/operations.hpp	/^template<typename _Tp, int m, int n> struct CV_EXPORTS Matx_FastSolveOp$/;"	s	namespace:cv
Matx_FastSolveOp	core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_FastSolveOp<_Tp, 2, 1>$/;"	s	namespace:cv
Matx_FastSolveOp	core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_FastSolveOp<_Tp, 3, 1>$/;"	s	namespace:cv
Matx_MatMulOp	core/core.hpp	/^struct CV_EXPORTS Matx_MatMulOp {};$/;"	s	namespace:cv
Matx_MulOp	core/core.hpp	/^struct CV_EXPORTS Matx_MulOp {};$/;"	s	namespace:cv
Matx_ScaleOp	core/core.hpp	/^struct CV_EXPORTS Matx_ScaleOp {};$/;"	s	namespace:cv
Matx_SubOp	core/core.hpp	/^struct CV_EXPORTS Matx_SubOp {};$/;"	s	namespace:cv
Matx_TOp	core/core.hpp	/^struct CV_EXPORTS Matx_TOp {};$/;"	s	namespace:cv
MaxDistance	flann/dist.h	/^struct MaxDistance$/;"	s	namespace:cvflann
MaxMeanShiftIteration	contrib/contrib.hpp	/^        MaxMeanShiftIteration   = 5,$/;"	e	enum:CvFuzzyMeanShiftTracker::__anon5
MaxSetSizeIteration	contrib/contrib.hpp	/^        MaxSetSizeIteration     = 5$/;"	e	enum:CvFuzzyMeanShiftTracker::__anon5
MeasurementMatr	video/tracking.hpp	/^    float* MeasurementMatr;     \/* =measurement_matrix->data.fl *\/$/;"	m	struct:CvKalman	access:public
MemStorage	core/core.hpp	/^typedef Ptr<CvMemStorage> MemStorage;$/;"	t	namespace:cv
Mesh3D	contrib/contrib.hpp	/^        Mesh3D();$/;"	p	class:cv::Mesh3D	access:public	signature:()
Mesh3D	contrib/contrib.hpp	/^        Mesh3D(const vector<Point3f>& vtx);$/;"	p	class:cv::Mesh3D	access:public	signature:(const vector<Point3f>& vtx)
Mesh3D	contrib/contrib.hpp	/^    class CV_EXPORTS Mesh3D$/;"	c	namespace:cv
MinKernelMass	contrib/contrib.hpp	/^        MinKernelMass           = 1000$/;"	e	enum:CvFuzzyMeanShiftTracker::__anon4
MinkowskiDistance	flann/dist.h	/^    MinkowskiDistance(int order_) : order(order_) {}$/;"	f	struct:cvflann::MinkowskiDistance	access:public	signature:(int order_)
MinkowskiDistance	flann/dist.h	/^struct MinkowskiDistance$/;"	s	namespace:cvflann
Moments	imgproc/imgproc.hpp	/^    Moments( const CvMoments& moments );$/;"	p	class:cv::Moments	access:public	signature:( const CvMoments& moments )
Moments	imgproc/imgproc.hpp	/^    Moments();$/;"	p	class:cv::Moments	access:public	signature:()
Moments	imgproc/imgproc.hpp	/^    Moments(double m00, double m10, double m01, double m20, double m11,$/;"	p	class:cv::Moments	access:public	signature:(double m00, double m10, double m01, double m20, double m11, double m02, double m30, double m21, double m12, double m03 )
Moments	imgproc/imgproc.hpp	/^class CV_EXPORTS_W_MAP Moments$/;"	c	namespace:cv
MouseCallback	highgui/highgui.hpp	/^typedef void (*MouseCallback )(int event, int x, int y, int flags, void* param);$/;"	t	namespace:cv
MouthRect	legacy/legacy.hpp	/^    CvRect MouthRect;$/;"	m	struct:CvFace	access:public
MserFeatureDetector	features2d/features2d.hpp	/^    MserFeatureDetector( CvMSERParams params=cvMSERParams() );$/;"	p	class:cv::MserFeatureDetector	access:public	signature:( CvMSERParams params=cvMSERParams() )
MserFeatureDetector	features2d/features2d.hpp	/^    MserFeatureDetector( int delta, int minArea, int maxArea, double maxVariation, double minDiversity,$/;"	p	class:cv::MserFeatureDetector	access:public	signature:( int delta, int minArea, int maxArea, double maxVariation, double minDiversity, int maxEvolution, double areaThreshold, double minMargin, int edgeBlurSize )
MserFeatureDetector	features2d/features2d.hpp	/^class CV_EXPORTS MserFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
N	legacy/legacy.hpp	/^    int N; \/\/graph size$/;"	m	struct:CvCliqueFinder	access:public
N1c	video/background_segm.hpp	/^    int    N1c;			\/* Number of color vectors used to model normal background color variation at a given pixel.			*\/$/;"	m	struct:CvFGDStatModelParams	access:public
N1cc	video/background_segm.hpp	/^    int    N1cc;		\/* Number of color co-occurrence vectors used to model normal background color variation at a given pixel.	*\/$/;"	m	struct:CvFGDStatModelParams	access:public
N2c	video/background_segm.hpp	/^    int    N2c;			\/* Number of color vectors retained at given pixel.  Must be > N1c, typically ~ 5\/3 of N1c.			*\/$/;"	m	struct:CvFGDStatModelParams	access:public
N2cc	video/background_segm.hpp	/^    int    N2cc;		\/* Number of color co-occurrence vectors retained at given pixel.  Must be > N1cc, typically ~ 5\/3 of N1cc.	*\/$/;"	m	struct:CvFGDStatModelParams	access:public
NAMED	core/core.hpp	/^        NAMED=64 \/\/!< the node has a name (i.e. it is element of a mapping)$/;"	e	enum:cv::FileNode::__anon149
NAME_EXPECTED	core/core.hpp	/^        NAME_EXPECTED=2,$/;"	e	enum:cv::FileStorage::__anon148
NARROW_PRESET	calib3d/calib3d.hpp	/^        BASIC_PRESET=0, FISH_EYE_PRESET=1, NARROW_PRESET=2 };$/;"	e	enum:cv::StereoBM::__anon92
NATIVE_DOUBLE	gpu/gpu.hpp	/^            NATIVE_DOUBLE = FEATURE_SET_COMPUTE_13$/;"	e	enum:cv::gpu::FeatureSet
NAryMatIterator	core/core.hpp	/^    NAryMatIterator();$/;"	p	class:cv::NAryMatIterator	access:public	signature:()
NAryMatIterator	core/core.hpp	/^    NAryMatIterator(const Mat** arrays, Mat* planes, int narrays=-1);$/;"	p	class:cv::NAryMatIterator	access:public	signature:(const Mat** arrays, Mat* planes, int narrays=-1)
NAryMatIterator	core/core.hpp	/^    NAryMatIterator(const Mat** arrays, uchar** ptrs, int narrays=-1);$/;"	p	class:cv::NAryMatIterator	access:public	signature:(const Mat** arrays, uchar** ptrs, int narrays=-1)
NAryMatIterator	core/core.hpp	/^class CV_EXPORTS NAryMatIterator$/;"	c	namespace:cv
NCVDebugOutputHandler	gpu/NCV.hpp	/^typedef void NCVDebugOutputHandler(const char* msg);$/;"	t
NCVMatrix	gpu/NCV.hpp	/^    NCVMatrix()$/;"	f	class:NCVMatrix	access:public	signature:()
NCVMatrix	gpu/NCV.hpp	/^    NCVMatrix(const NCVMatrix &);$/;"	p	class:NCVMatrix	access:private	signature:(const NCVMatrix &)
NCVMatrix	gpu/NCV.hpp	/^class NCVMatrix$/;"	c
NCVMatrix::NCVMatrix	gpu/NCV.hpp	/^    NCVMatrix()$/;"	f	class:NCVMatrix	access:public	signature:()
NCVMatrix::NCVMatrix	gpu/NCV.hpp	/^    NCVMatrix(const NCVMatrix &);$/;"	p	class:NCVMatrix	access:private	signature:(const NCVMatrix &)
NCVMatrix::_height	gpu/NCV.hpp	/^    Ncv32u _height;$/;"	m	class:NCVMatrix	access:protected
NCVMatrix::_memtype	gpu/NCV.hpp	/^    NCVMemoryType _memtype;$/;"	m	class:NCVMatrix	access:protected
NCVMatrix::_pitch	gpu/NCV.hpp	/^    Ncv32u _pitch;$/;"	m	class:NCVMatrix	access:protected
NCVMatrix::_ptr	gpu/NCV.hpp	/^    T *_ptr;$/;"	m	class:NCVMatrix	access:protected
NCVMatrix::_width	gpu/NCV.hpp	/^    Ncv32u _width;$/;"	m	class:NCVMatrix	access:protected
NCVMatrix::clear	gpu/NCV.hpp	/^    void clear()$/;"	f	class:NCVMatrix	access:public	signature:()
NCVMatrix::copy2D	gpu/NCV.hpp	/^    NCVStatus copy2D(NCVMatrix<T> &dst, NcvSize32u roi, cudaStream_t cuStream) const$/;"	f	class:NCVMatrix	access:public	signature:(NCVMatrix<T> &dst, NcvSize32u roi, cudaStream_t cuStream) const
NCVMatrix::copySolid	gpu/NCV.hpp	/^    NCVStatus copySolid(NCVMatrix<T> &dst, cudaStream_t cuStream, size_t howMuch=0) const$/;"	f	class:NCVMatrix	access:public	signature:(NCVMatrix<T> &dst, cudaStream_t cuStream, size_t howMuch=0) const
NCVMatrix::height	gpu/NCV.hpp	/^    Ncv32u height() const {return this->_height;}$/;"	f	class:NCVMatrix	access:public	signature:() const
NCVMatrix::memType	gpu/NCV.hpp	/^    NCVMemoryType memType() const {return this->_memtype;}$/;"	f	class:NCVMatrix	access:public	signature:() const
NCVMatrix::pitch	gpu/NCV.hpp	/^    Ncv32u pitch() const {return this->_pitch;}$/;"	f	class:NCVMatrix	access:public	signature:() const
NCVMatrix::ptr	gpu/NCV.hpp	/^    T *ptr() const {return this->_ptr;}$/;"	f	class:NCVMatrix	access:public	signature:() const
NCVMatrix::stride	gpu/NCV.hpp	/^    Ncv32u stride() const$/;"	f	class:NCVMatrix	access:public	signature:() const
NCVMatrix::width	gpu/NCV.hpp	/^    Ncv32u width() const {return this->_width;}$/;"	f	class:NCVMatrix	access:public	signature:() const
NCVMatrix::~NCVMatrix	gpu/NCV.hpp	/^    virtual ~NCVMatrix() {}$/;"	f	class:NCVMatrix	access:public	signature:()
NCVMatrixAlloc	gpu/NCV.hpp	/^    NCVMatrixAlloc();$/;"	p	class:NCVMatrixAlloc	access:private	signature:()
NCVMatrixAlloc	gpu/NCV.hpp	/^    NCVMatrixAlloc(INCVMemAllocator &allocator, Ncv32u width, Ncv32u height, Ncv32u pitch=0)$/;"	f	class:NCVMatrixAlloc	access:public	signature:(INCVMemAllocator &allocator, Ncv32u width, Ncv32u height, Ncv32u pitch=0)
NCVMatrixAlloc	gpu/NCV.hpp	/^    NCVMatrixAlloc(const NCVMatrixAlloc &);$/;"	p	class:NCVMatrixAlloc	access:private	signature:(const NCVMatrixAlloc &)
NCVMatrixAlloc	gpu/NCV.hpp	/^class NCVMatrixAlloc : public NCVMatrix<T>$/;"	c	inherits:NCVMatrix
NCVMatrixAlloc::NCVMatrixAlloc	gpu/NCV.hpp	/^    NCVMatrixAlloc();$/;"	p	class:NCVMatrixAlloc	access:private	signature:()
NCVMatrixAlloc::NCVMatrixAlloc	gpu/NCV.hpp	/^    NCVMatrixAlloc(INCVMemAllocator &allocator, Ncv32u width, Ncv32u height, Ncv32u pitch=0)$/;"	f	class:NCVMatrixAlloc	access:public	signature:(INCVMemAllocator &allocator, Ncv32u width, Ncv32u height, Ncv32u pitch=0)
NCVMatrixAlloc::NCVMatrixAlloc	gpu/NCV.hpp	/^    NCVMatrixAlloc(const NCVMatrixAlloc &);$/;"	p	class:NCVMatrixAlloc	access:private	signature:(const NCVMatrixAlloc &)
NCVMatrixAlloc::allocatedMem	gpu/NCV.hpp	/^    NCVMemSegment allocatedMem;$/;"	m	class:NCVMatrixAlloc	access:private
NCVMatrixAlloc::allocator	gpu/NCV.hpp	/^    INCVMemAllocator &allocator;$/;"	m	class:NCVMatrixAlloc	access:private
NCVMatrixAlloc::getAllocatorsAlignment	gpu/NCV.hpp	/^    Ncv32u getAllocatorsAlignment() const$/;"	f	class:NCVMatrixAlloc	access:public	signature:() const
NCVMatrixAlloc::getSegment	gpu/NCV.hpp	/^    NCVMemSegment getSegment() const$/;"	f	class:NCVMatrixAlloc	access:public	signature:() const
NCVMatrixAlloc::isMemAllocated	gpu/NCV.hpp	/^    NcvBool isMemAllocated() const$/;"	f	class:NCVMatrixAlloc	access:public	signature:() const
NCVMatrixAlloc::operator =	gpu/NCV.hpp	/^    NCVMatrixAlloc& operator=(const NCVMatrixAlloc &);$/;"	p	class:NCVMatrixAlloc	access:private	signature:(const NCVMatrixAlloc &)
NCVMatrixAlloc::~NCVMatrixAlloc	gpu/NCV.hpp	/^    ~NCVMatrixAlloc()$/;"	f	class:NCVMatrixAlloc	access:public	signature:()
NCVMatrixReuse	gpu/NCV.hpp	/^    NCVMatrixReuse();$/;"	p	class:NCVMatrixReuse	access:private	signature:()
NCVMatrixReuse	gpu/NCV.hpp	/^    NCVMatrixReuse(const NCVMatrix<T> &mat, NcvRect32u roi)$/;"	f	class:NCVMatrixReuse	access:public	signature:(const NCVMatrix<T> &mat, NcvRect32u roi)
NCVMatrixReuse	gpu/NCV.hpp	/^    NCVMatrixReuse(const NCVMatrixReuse &);$/;"	p	class:NCVMatrixReuse	access:private	signature:(const NCVMatrixReuse &)
NCVMatrixReuse	gpu/NCV.hpp	/^    NCVMatrixReuse(const NCVMemSegment &memSegment, Ncv32u alignment, Ncv32u width, Ncv32u height, Ncv32u pitch=0, NcvBool bSkipPitchCheck=false)$/;"	f	class:NCVMatrixReuse	access:public	signature:(const NCVMemSegment &memSegment, Ncv32u alignment, Ncv32u width, Ncv32u height, Ncv32u pitch=0, NcvBool bSkipPitchCheck=false)
NCVMatrixReuse	gpu/NCV.hpp	/^class NCVMatrixReuse : public NCVMatrix<T>$/;"	c	inherits:NCVMatrix
NCVMatrixReuse::NCVMatrixReuse	gpu/NCV.hpp	/^    NCVMatrixReuse();$/;"	p	class:NCVMatrixReuse	access:private	signature:()
NCVMatrixReuse::NCVMatrixReuse	gpu/NCV.hpp	/^    NCVMatrixReuse(const NCVMatrix<T> &mat, NcvRect32u roi)$/;"	f	class:NCVMatrixReuse	access:public	signature:(const NCVMatrix<T> &mat, NcvRect32u roi)
NCVMatrixReuse::NCVMatrixReuse	gpu/NCV.hpp	/^    NCVMatrixReuse(const NCVMatrixReuse &);$/;"	p	class:NCVMatrixReuse	access:private	signature:(const NCVMatrixReuse &)
NCVMatrixReuse::NCVMatrixReuse	gpu/NCV.hpp	/^    NCVMatrixReuse(const NCVMemSegment &memSegment, Ncv32u alignment, Ncv32u width, Ncv32u height, Ncv32u pitch=0, NcvBool bSkipPitchCheck=false)$/;"	f	class:NCVMatrixReuse	access:public	signature:(const NCVMemSegment &memSegment, Ncv32u alignment, Ncv32u width, Ncv32u height, Ncv32u pitch=0, NcvBool bSkipPitchCheck=false)
NCVMatrixReuse::bReused	gpu/NCV.hpp	/^    NcvBool bReused;$/;"	m	class:NCVMatrixReuse	access:private
NCVMatrixReuse::isMemReused	gpu/NCV.hpp	/^    NcvBool isMemReused() const$/;"	f	class:NCVMatrixReuse	access:public	signature:() const
NCVMemNativeAllocator	gpu/NCV.hpp	/^    NCVMemNativeAllocator();$/;"	p	class:NCVMemNativeAllocator	access:private	signature:()
NCVMemNativeAllocator	gpu/NCV.hpp	/^    NCVMemNativeAllocator(NCVMemoryType memT, Ncv32u alignment);$/;"	p	class:NCVMemNativeAllocator	access:public	signature:(NCVMemoryType memT, Ncv32u alignment)
NCVMemNativeAllocator	gpu/NCV.hpp	/^    NCVMemNativeAllocator(const NCVMemNativeAllocator &);$/;"	p	class:NCVMemNativeAllocator	access:private	signature:(const NCVMemNativeAllocator &)
NCVMemNativeAllocator	gpu/NCV.hpp	/^class NCV_EXPORTS NCVMemNativeAllocator : public INCVMemAllocator$/;"	c	inherits:INCVMemAllocator
NCVMemNativeAllocator::NCVMemNativeAllocator	gpu/NCV.hpp	/^    NCVMemNativeAllocator();$/;"	p	class:NCVMemNativeAllocator	access:private	signature:()
NCVMemNativeAllocator::NCVMemNativeAllocator	gpu/NCV.hpp	/^    NCVMemNativeAllocator(NCVMemoryType memT, Ncv32u alignment);$/;"	p	class:NCVMemNativeAllocator	access:public	signature:(NCVMemoryType memT, Ncv32u alignment)
NCVMemNativeAllocator::NCVMemNativeAllocator	gpu/NCV.hpp	/^    NCVMemNativeAllocator(const NCVMemNativeAllocator &);$/;"	p	class:NCVMemNativeAllocator	access:private	signature:(const NCVMemNativeAllocator &)
NCVMemNativeAllocator::_alignment	gpu/NCV.hpp	/^    Ncv32u _alignment;$/;"	m	class:NCVMemNativeAllocator	access:private
NCVMemNativeAllocator::_maxSize	gpu/NCV.hpp	/^    size_t _maxSize;$/;"	m	class:NCVMemNativeAllocator	access:private
NCVMemNativeAllocator::_memType	gpu/NCV.hpp	/^    NCVMemoryType _memType;$/;"	m	class:NCVMemNativeAllocator	access:private
NCVMemNativeAllocator::alignment	gpu/NCV.hpp	/^    virtual Ncv32u alignment(void) const;$/;"	p	class:NCVMemNativeAllocator	access:public	signature:(void) const
NCVMemNativeAllocator::alloc	gpu/NCV.hpp	/^    virtual NCVStatus alloc(NCVMemSegment &seg, size_t size);$/;"	p	class:NCVMemNativeAllocator	access:public	signature:(NCVMemSegment &seg, size_t size)
NCVMemNativeAllocator::currentSize	gpu/NCV.hpp	/^    size_t currentSize;$/;"	m	class:NCVMemNativeAllocator	access:private
NCVMemNativeAllocator::dealloc	gpu/NCV.hpp	/^    virtual NCVStatus dealloc(NCVMemSegment &seg);$/;"	p	class:NCVMemNativeAllocator	access:public	signature:(NCVMemSegment &seg)
NCVMemNativeAllocator::isCounting	gpu/NCV.hpp	/^    virtual NcvBool isCounting(void) const;$/;"	p	class:NCVMemNativeAllocator	access:public	signature:(void) const
NCVMemNativeAllocator::isInitialized	gpu/NCV.hpp	/^    virtual NcvBool isInitialized(void) const;$/;"	p	class:NCVMemNativeAllocator	access:public	signature:(void) const
NCVMemNativeAllocator::maxSize	gpu/NCV.hpp	/^    virtual size_t maxSize(void) const;$/;"	p	class:NCVMemNativeAllocator	access:public	signature:(void) const
NCVMemNativeAllocator::memType	gpu/NCV.hpp	/^    virtual NCVMemoryType memType(void) const;$/;"	p	class:NCVMemNativeAllocator	access:public	signature:(void) const
NCVMemNativeAllocator::~NCVMemNativeAllocator	gpu/NCV.hpp	/^    virtual ~NCVMemNativeAllocator();$/;"	p	class:NCVMemNativeAllocator	access:public	signature:()
NCVMemPtr	gpu/NCV.hpp	/^struct NCV_EXPORTS NCVMemPtr$/;"	s
NCVMemPtr::clear	gpu/NCV.hpp	/^    void clear();$/;"	p	struct:NCVMemPtr	access:public	signature:()
NCVMemPtr::memtype	gpu/NCV.hpp	/^    NCVMemoryType memtype;$/;"	m	struct:NCVMemPtr	access:public
NCVMemPtr::ptr	gpu/NCV.hpp	/^    void *ptr;$/;"	m	struct:NCVMemPtr	access:public
NCVMemSegment	gpu/NCV.hpp	/^struct NCV_EXPORTS NCVMemSegment$/;"	s
NCVMemSegment::begin	gpu/NCV.hpp	/^    NCVMemPtr begin;$/;"	m	struct:NCVMemSegment	access:public
NCVMemSegment::clear	gpu/NCV.hpp	/^    void clear();$/;"	p	struct:NCVMemSegment	access:public	signature:()
NCVMemSegment::size	gpu/NCV.hpp	/^    size_t size;$/;"	m	struct:NCVMemSegment	access:public
NCVMemStackAllocator	gpu/NCV.hpp	/^    NCVMemStackAllocator();$/;"	p	class:NCVMemStackAllocator	access:private	signature:()
NCVMemStackAllocator	gpu/NCV.hpp	/^    NCVMemStackAllocator(NCVMemoryType memT, size_t capacity, Ncv32u alignment, void *reusePtr=NULL);$/;"	p	class:NCVMemStackAllocator	access:public	signature:(NCVMemoryType memT, size_t capacity, Ncv32u alignment, void *reusePtr=NULL)
NCVMemStackAllocator	gpu/NCV.hpp	/^    NCVMemStackAllocator(const NCVMemStackAllocator &);$/;"	p	class:NCVMemStackAllocator	access:private	signature:(const NCVMemStackAllocator &)
NCVMemStackAllocator	gpu/NCV.hpp	/^    explicit NCVMemStackAllocator(Ncv32u alignment);$/;"	p	class:NCVMemStackAllocator	access:public	signature:(Ncv32u alignment)
NCVMemStackAllocator	gpu/NCV.hpp	/^class NCV_EXPORTS NCVMemStackAllocator : public INCVMemAllocator$/;"	c	inherits:INCVMemAllocator
NCVMemStackAllocator::NCVMemStackAllocator	gpu/NCV.hpp	/^    NCVMemStackAllocator();$/;"	p	class:NCVMemStackAllocator	access:private	signature:()
NCVMemStackAllocator::NCVMemStackAllocator	gpu/NCV.hpp	/^    NCVMemStackAllocator(NCVMemoryType memT, size_t capacity, Ncv32u alignment, void *reusePtr=NULL);$/;"	p	class:NCVMemStackAllocator	access:public	signature:(NCVMemoryType memT, size_t capacity, Ncv32u alignment, void *reusePtr=NULL)
NCVMemStackAllocator::NCVMemStackAllocator	gpu/NCV.hpp	/^    NCVMemStackAllocator(const NCVMemStackAllocator &);$/;"	p	class:NCVMemStackAllocator	access:private	signature:(const NCVMemStackAllocator &)
NCVMemStackAllocator::NCVMemStackAllocator	gpu/NCV.hpp	/^    explicit NCVMemStackAllocator(Ncv32u alignment);$/;"	p	class:NCVMemStackAllocator	access:public	signature:(Ncv32u alignment)
NCVMemStackAllocator::_alignment	gpu/NCV.hpp	/^    Ncv32u _alignment;$/;"	m	class:NCVMemStackAllocator	access:private
NCVMemStackAllocator::_maxSize	gpu/NCV.hpp	/^    size_t _maxSize;$/;"	m	class:NCVMemStackAllocator	access:private
NCVMemStackAllocator::_memType	gpu/NCV.hpp	/^    NCVMemoryType _memType;$/;"	m	class:NCVMemStackAllocator	access:private
NCVMemStackAllocator::alignment	gpu/NCV.hpp	/^    virtual Ncv32u alignment(void) const;$/;"	p	class:NCVMemStackAllocator	access:public	signature:(void) const
NCVMemStackAllocator::alloc	gpu/NCV.hpp	/^    virtual NCVStatus alloc(NCVMemSegment &seg, size_t size);$/;"	p	class:NCVMemStackAllocator	access:public	signature:(NCVMemSegment &seg, size_t size)
NCVMemStackAllocator::allocBegin	gpu/NCV.hpp	/^    Ncv8u *allocBegin;$/;"	m	class:NCVMemStackAllocator	access:private
NCVMemStackAllocator::bReusesMemory	gpu/NCV.hpp	/^    NcvBool bReusesMemory;$/;"	m	class:NCVMemStackAllocator	access:private
NCVMemStackAllocator::begin	gpu/NCV.hpp	/^    Ncv8u *begin;$/;"	m	class:NCVMemStackAllocator	access:private
NCVMemStackAllocator::currentSize	gpu/NCV.hpp	/^    size_t currentSize;$/;"	m	class:NCVMemStackAllocator	access:private
NCVMemStackAllocator::dealloc	gpu/NCV.hpp	/^    virtual NCVStatus dealloc(NCVMemSegment &seg);$/;"	p	class:NCVMemStackAllocator	access:public	signature:(NCVMemSegment &seg)
NCVMemStackAllocator::end	gpu/NCV.hpp	/^    Ncv8u *end;$/;"	m	class:NCVMemStackAllocator	access:private
NCVMemStackAllocator::isCounting	gpu/NCV.hpp	/^    virtual NcvBool isCounting(void) const;$/;"	p	class:NCVMemStackAllocator	access:public	signature:(void) const
NCVMemStackAllocator::isInitialized	gpu/NCV.hpp	/^    virtual NcvBool isInitialized(void) const;$/;"	p	class:NCVMemStackAllocator	access:public	signature:(void) const
NCVMemStackAllocator::maxSize	gpu/NCV.hpp	/^    virtual size_t maxSize(void) const;$/;"	p	class:NCVMemStackAllocator	access:public	signature:(void) const
NCVMemStackAllocator::memType	gpu/NCV.hpp	/^    virtual NCVMemoryType memType(void) const;$/;"	p	class:NCVMemStackAllocator	access:public	signature:(void) const
NCVMemStackAllocator::~NCVMemStackAllocator	gpu/NCV.hpp	/^    virtual ~NCVMemStackAllocator();$/;"	p	class:NCVMemStackAllocator	access:public	signature:()
NCVMemoryType	gpu/NCV.hpp	/^enum NCVMemoryType$/;"	g
NCVMemoryTypeDevice	gpu/NCV.hpp	/^    NCVMemoryTypeDevice$/;"	e	enum:NCVMemoryType
NCVMemoryTypeHostPageable	gpu/NCV.hpp	/^    NCVMemoryTypeHostPageable,$/;"	e	enum:NCVMemoryType
NCVMemoryTypeHostPinned	gpu/NCV.hpp	/^    NCVMemoryTypeHostPinned,$/;"	e	enum:NCVMemoryType
NCVMemoryTypeNone	gpu/NCV.hpp	/^    NCVMemoryTypeNone,$/;"	e	enum:NCVMemoryType
NCVStatus	gpu/NCV.hpp	/^enum NCVStatus$/;"	g
NCVVector	gpu/NCV.hpp	/^    NCVVector()$/;"	f	class:NCVVector	access:public	signature:()
NCVVector	gpu/NCV.hpp	/^    NCVVector(const NCVVector &);$/;"	p	class:NCVVector	access:private	signature:(const NCVVector &)
NCVVector	gpu/NCV.hpp	/^class NCVVector$/;"	c
NCVVector::NCVVector	gpu/NCV.hpp	/^    NCVVector()$/;"	f	class:NCVVector	access:public	signature:()
NCVVector::NCVVector	gpu/NCV.hpp	/^    NCVVector(const NCVVector &);$/;"	p	class:NCVVector	access:private	signature:(const NCVVector &)
NCVVector::_length	gpu/NCV.hpp	/^    size_t _length;$/;"	m	class:NCVVector	access:protected
NCVVector::_memtype	gpu/NCV.hpp	/^    NCVMemoryType _memtype;$/;"	m	class:NCVVector	access:protected
NCVVector::_ptr	gpu/NCV.hpp	/^    T *_ptr;$/;"	m	class:NCVVector	access:protected
NCVVector::clear	gpu/NCV.hpp	/^    void clear()$/;"	f	class:NCVVector	access:public	signature:()
NCVVector::copySolid	gpu/NCV.hpp	/^    NCVStatus copySolid(NCVVector<T> &dst, cudaStream_t cuStream, size_t howMuch=0) const$/;"	f	class:NCVVector	access:public	signature:(NCVVector<T> &dst, cudaStream_t cuStream, size_t howMuch=0) const
NCVVector::length	gpu/NCV.hpp	/^    size_t length() const {return this->_length;}$/;"	f	class:NCVVector	access:public	signature:() const
NCVVector::memType	gpu/NCV.hpp	/^    NCVMemoryType memType() const {return this->_memtype;}$/;"	f	class:NCVVector	access:public	signature:() const
NCVVector::ptr	gpu/NCV.hpp	/^    T *ptr() const {return this->_ptr;}$/;"	f	class:NCVVector	access:public	signature:() const
NCVVector::~NCVVector	gpu/NCV.hpp	/^    virtual ~NCVVector() {}$/;"	f	class:NCVVector	access:public	signature:()
NCVVectorAlloc	gpu/NCV.hpp	/^    NCVVectorAlloc();$/;"	p	class:NCVVectorAlloc	access:private	signature:()
NCVVectorAlloc	gpu/NCV.hpp	/^    NCVVectorAlloc(INCVMemAllocator &allocator, Ncv32u length)$/;"	f	class:NCVVectorAlloc	access:public	signature:(INCVMemAllocator &allocator, Ncv32u length)
NCVVectorAlloc	gpu/NCV.hpp	/^    NCVVectorAlloc(const NCVVectorAlloc &);$/;"	p	class:NCVVectorAlloc	access:private	signature:(const NCVVectorAlloc &)
NCVVectorAlloc	gpu/NCV.hpp	/^class NCVVectorAlloc : public NCVVector<T>$/;"	c	inherits:NCVVector
NCVVectorAlloc::NCVVectorAlloc	gpu/NCV.hpp	/^    NCVVectorAlloc();$/;"	p	class:NCVVectorAlloc	access:private	signature:()
NCVVectorAlloc::NCVVectorAlloc	gpu/NCV.hpp	/^    NCVVectorAlloc(INCVMemAllocator &allocator, Ncv32u length)$/;"	f	class:NCVVectorAlloc	access:public	signature:(INCVMemAllocator &allocator, Ncv32u length)
NCVVectorAlloc::NCVVectorAlloc	gpu/NCV.hpp	/^    NCVVectorAlloc(const NCVVectorAlloc &);$/;"	p	class:NCVVectorAlloc	access:private	signature:(const NCVVectorAlloc &)
NCVVectorAlloc::allocatedMem	gpu/NCV.hpp	/^    NCVMemSegment allocatedMem;$/;"	m	class:NCVVectorAlloc	access:private
NCVVectorAlloc::allocator	gpu/NCV.hpp	/^    INCVMemAllocator &allocator;$/;"	m	class:NCVVectorAlloc	access:private
NCVVectorAlloc::getAllocatorsAlignment	gpu/NCV.hpp	/^    Ncv32u getAllocatorsAlignment() const$/;"	f	class:NCVVectorAlloc	access:public	signature:() const
NCVVectorAlloc::getSegment	gpu/NCV.hpp	/^    NCVMemSegment getSegment() const$/;"	f	class:NCVVectorAlloc	access:public	signature:() const
NCVVectorAlloc::isMemAllocated	gpu/NCV.hpp	/^    NcvBool isMemAllocated() const$/;"	f	class:NCVVectorAlloc	access:public	signature:() const
NCVVectorAlloc::operator =	gpu/NCV.hpp	/^    NCVVectorAlloc& operator=(const NCVVectorAlloc<T>&);	$/;"	p	class:NCVVectorAlloc	access:private	signature:(const NCVVectorAlloc<T>&)
NCVVectorAlloc::~NCVVectorAlloc	gpu/NCV.hpp	/^    ~NCVVectorAlloc()$/;"	f	class:NCVVectorAlloc	access:public	signature:()
NCVVectorReuse	gpu/NCV.hpp	/^    NCVVectorReuse();$/;"	p	class:NCVVectorReuse	access:private	signature:()
NCVVectorReuse	gpu/NCV.hpp	/^    NCVVectorReuse(const NCVMemSegment &memSegment, Ncv32u length)$/;"	f	class:NCVVectorReuse	access:public	signature:(const NCVMemSegment &memSegment, Ncv32u length)
NCVVectorReuse	gpu/NCV.hpp	/^    NCVVectorReuse(const NCVVectorReuse &);$/;"	p	class:NCVVectorReuse	access:private	signature:(const NCVVectorReuse &)
NCVVectorReuse	gpu/NCV.hpp	/^    explicit NCVVectorReuse(const NCVMemSegment &memSegment)$/;"	f	class:NCVVectorReuse	access:public	signature:(const NCVMemSegment &memSegment)
NCVVectorReuse	gpu/NCV.hpp	/^class NCVVectorReuse : public NCVVector<T>$/;"	c	inherits:NCVVector
NCVVectorReuse::NCVVectorReuse	gpu/NCV.hpp	/^    NCVVectorReuse();$/;"	p	class:NCVVectorReuse	access:private	signature:()
NCVVectorReuse::NCVVectorReuse	gpu/NCV.hpp	/^    NCVVectorReuse(const NCVMemSegment &memSegment, Ncv32u length)$/;"	f	class:NCVVectorReuse	access:public	signature:(const NCVMemSegment &memSegment, Ncv32u length)
NCVVectorReuse::NCVVectorReuse	gpu/NCV.hpp	/^    NCVVectorReuse(const NCVVectorReuse &);$/;"	p	class:NCVVectorReuse	access:private	signature:(const NCVVectorReuse &)
NCVVectorReuse::NCVVectorReuse	gpu/NCV.hpp	/^    explicit NCVVectorReuse(const NCVMemSegment &memSegment)$/;"	f	class:NCVVectorReuse	access:public	signature:(const NCVMemSegment &memSegment)
NCVVectorReuse::bReused	gpu/NCV.hpp	/^    NcvBool bReused;$/;"	m	class:NCVVectorReuse	access:private
NCVVectorReuse::isMemReused	gpu/NCV.hpp	/^    NcvBool isMemReused() const$/;"	f	class:NCVVectorReuse	access:public	signature:() const
NCV_ALLOCATOR_BAD_ALLOC	gpu/NCV.hpp	/^    NCV_ALLOCATOR_BAD_ALLOC,$/;"	e	enum:NCVStatus
NCV_ALLOCATOR_BAD_DEALLOC	gpu/NCV.hpp	/^    NCV_ALLOCATOR_BAD_DEALLOC,$/;"	e	enum:NCVStatus
NCV_ALLOCATOR_BAD_REUSE	gpu/NCV.hpp	/^    NCV_ALLOCATOR_BAD_REUSE,$/;"	e	enum:NCVStatus
NCV_ALLOCATOR_DEALLOC_ORDER	gpu/NCV.hpp	/^    NCV_ALLOCATOR_DEALLOC_ORDER,$/;"	e	enum:NCVStatus
NCV_ALLOCATOR_INSUFFICIENT_CAPACITY	gpu/NCV.hpp	/^    NCV_ALLOCATOR_INSUFFICIENT_CAPACITY,$/;"	e	enum:NCVStatus
NCV_ALLOCATOR_NOT_INITIALIZED	gpu/NCV.hpp	/^    NCV_ALLOCATOR_NOT_INITIALIZED,$/;"	e	enum:NCVStatus
NCV_CT_ASSERT	gpu/NCV.hpp	88;"	d
NCV_CT_PREP_PASTE	gpu/NCV.hpp	82;"	d
NCV_CT_PREP_PASTE_AUX	gpu/NCV.hpp	81;"	d
NCV_CT_PREP_STRINGIZE	gpu/NCV.hpp	223;"	d
NCV_CT_PREP_STRINGIZE_AUX	gpu/NCV.hpp	222;"	d
NCV_CUDA_ERROR	gpu/NCV.hpp	/^    NCV_CUDA_ERROR,$/;"	e	enum:NCVStatus
NCV_DIMENSIONS_INVALID	gpu/NCV.hpp	/^    NCV_DIMENSIONS_INVALID,$/;"	e	enum:NCVStatus
NCV_EXPORTS	gpu/NCV.hpp	46;"	d
NCV_EXPORTS	gpu/NCV.hpp	48;"	d
NCV_FILE_ERROR	gpu/NCV.hpp	/^    NCV_FILE_ERROR,$/;"	e	enum:NCVStatus
NCV_HAAR_INVALID_PIXEL_STEP	gpu/NCV.hpp	/^    NCV_HAAR_INVALID_PIXEL_STEP,$/;"	e	enum:NCVStatus
NCV_HAAR_TOO_LARGE_FEATURES	gpu/NCV.hpp	/^    NCV_HAAR_TOO_LARGE_FEATURES,$/;"	e	enum:NCVStatus
NCV_HAAR_TOO_MANY_FEATURES_IN_CASCADE	gpu/NCV.hpp	/^    NCV_HAAR_TOO_MANY_FEATURES_IN_CASCADE,$/;"	e	enum:NCVStatus
NCV_HAAR_TOO_MANY_FEATURES_IN_CLASSIFIER	gpu/NCV.hpp	/^    NCV_HAAR_TOO_MANY_FEATURES_IN_CLASSIFIER,$/;"	e	enum:NCVStatus
NCV_HAAR_XML_LOADING_EXCEPTION	gpu/NCV.hpp	/^    NCV_HAAR_XML_LOADING_EXCEPTION,$/;"	e	enum:NCVStatus
NCV_INCONSISTENT_INPUT	gpu/NCV.hpp	/^    NCV_INCONSISTENT_INPUT,$/;"	e	enum:NCVStatus
NCV_INVALID_ROI	gpu/NCV.hpp	/^    NCV_INVALID_ROI,$/;"	e	enum:NCVStatus
NCV_INVALID_SCALE	gpu/NCV.hpp	/^    NCV_INVALID_SCALE,$/;"	e	enum:NCVStatus
NCV_INVALID_STEP	gpu/NCV.hpp	/^    NCV_INVALID_STEP,$/;"	e	enum:NCVStatus
NCV_MEM_COPY_ERROR	gpu/NCV.hpp	/^    NCV_MEM_COPY_ERROR,$/;"	e	enum:NCVStatus
NCV_MEM_INSUFFICIENT_CAPACITY	gpu/NCV.hpp	/^    NCV_MEM_INSUFFICIENT_CAPACITY,$/;"	e	enum:NCVStatus
NCV_MEM_RESIDENCE_ERROR	gpu/NCV.hpp	/^    NCV_MEM_RESIDENCE_ERROR,$/;"	e	enum:NCVStatus
NCV_NOIMPL_HAAR_TILTED_FEATURES	gpu/NCV.hpp	/^    NCV_NOIMPL_HAAR_TILTED_FEATURES,$/;"	e	enum:NCVStatus
NCV_NPP_ERROR	gpu/NCV.hpp	/^    NCV_NPP_ERROR,$/;"	e	enum:NCVStatus
NCV_NULL_PTR	gpu/NCV.hpp	/^    NCV_NULL_PTR,$/;"	e	enum:NCVStatus
NCV_RESET_SKIP_COND	gpu/NCV.hpp	348;"	d
NCV_SET_SKIP_COND	gpu/NCV.hpp	344;"	d
NCV_SKIP_COND_BEGIN	gpu/NCV.hpp	352;"	d
NCV_SKIP_COND_END	gpu/NCV.hpp	356;"	d
NCV_SUCCESS	gpu/NCV.hpp	/^    NCV_SUCCESS,$/;"	e	enum:NCVStatus
NCV_TEXTURE_BIND_ERROR	gpu/NCV.hpp	/^    NCV_TEXTURE_BIND_ERROR,$/;"	e	enum:NCVStatus
NCV_UNKNOWN_ERROR	gpu/NCV.hpp	/^    NCV_UNKNOWN_ERROR,$/;"	e	enum:NCVStatus
NCV_WARNING_HAAR_DETECTIONS_VECTOR_OVERFLOW	gpu/NCV.hpp	/^    NCV_WARNING_HAAR_DETECTIONS_VECTOR_OVERFLOW,$/;"	e	enum:NCVStatus
NEXT_AROUND_DST	imgproc/imgproc.hpp	/^        NEXT_AROUND_DST   = 0x22,$/;"	e	enum:cv::Subdiv2D::__anon28
NEXT_AROUND_LEFT	imgproc/imgproc.hpp	/^        NEXT_AROUND_LEFT  = 0x13,$/;"	e	enum:cv::Subdiv2D::__anon28
NEXT_AROUND_ORG	imgproc/imgproc.hpp	/^        NEXT_AROUND_ORG   = 0x00,$/;"	e	enum:cv::Subdiv2D::__anon28
NEXT_AROUND_RIGHT	imgproc/imgproc.hpp	/^        NEXT_AROUND_RIGHT = 0x31,$/;"	e	enum:cv::Subdiv2D::__anon28
NNIndex	flann/nn_index.h	/^class NNIndex$/;"	c	namespace:cvflann
NONE	core/core.hpp	/^        NONE=0, \/\/!< empty node$/;"	e	enum:cv::FileNode::__anon149
NONE	core/core.hpp	/^    enum { KIND_SHIFT=16, NONE=0<<KIND_SHIFT, MAT=1<<KIND_SHIFT,$/;"	e	enum:cv::_InputArray::__anon134
NORMAL	core/core.hpp	/^    enum { UNIFORM=0, NORMAL=1 };$/;"	e	enum:cv::RNG::__anon138
NORM_INF	core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon98
NORM_L1	core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon98
NORM_L2	core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon98
NORM_MINMAX	core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon98
NORM_RELATIVE	core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon98
NORM_TYPE_MASK	core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon98
NOT_DRAW_SINGLE_POINTS	features2d/features2d.hpp	/^          NOT_DRAW_SINGLE_POINTS = 2, \/\/ Single keypoints will not be drawn.$/;"	e	enum:cv::DrawMatchesFlags::__anon194
NO_INPUT_SCALE	ml/ml.hpp	/^    enum { UPDATE_WEIGHTS = 1, NO_INPUT_SCALE = 2, NO_OUTPUT_SCALE = 4 };$/;"	e	enum:CvANN_MLP::__anon84
NO_OUTPUT_SCALE	ml/ml.hpp	/^    enum { UPDATE_WEIGHTS = 1, NO_INPUT_SCALE = 2, NO_OUTPUT_SCALE = 4 };$/;"	e	enum:CvANN_MLP::__anon84
NO_UV	core/core.hpp	/^    enum { MODIFY_A=1, NO_UV=2, FULL_UV=4 };$/;"	e	enum:cv::SVD::__anon142
NPPST_CUDA_KERNEL_EXECUTION_ERROR	gpu/NCV.hpp	/^    NPPST_CUDA_KERNEL_EXECUTION_ERROR,        \/\/\/< CUDA kernel execution error$/;"	e	enum:NCVStatus
NPPST_ERROR	gpu/NCV.hpp	/^    NPPST_ERROR,                              \/\/\/< Unknown error$/;"	e	enum:NCVStatus
NPPST_INVALID_ROI	gpu/NCV.hpp	/^    NPPST_INVALID_ROI,                        \/\/\/< Invalid region of interest argument$/;"	e	enum:NCVStatus
NPPST_INVALID_SCALE	gpu/NCV.hpp	/^    NPPST_INVALID_SCALE,                      \/\/\/< Invalid scale parameter passed$/;"	e	enum:NCVStatus
NPPST_INVALID_STEP	gpu/NCV.hpp	/^    NPPST_INVALID_STEP,                       \/\/\/< Invalid image lines step argument (check sign, alignment, relation to image width)$/;"	e	enum:NCVStatus
NPPST_MEMCPY_ERROR	gpu/NCV.hpp	/^    NPPST_MEMCPY_ERROR,                       \/\/\/< CUDA memory copy error$/;"	e	enum:NCVStatus
NPPST_MEMFREE_ERR	gpu/NCV.hpp	/^    NPPST_MEMFREE_ERR,                        \/\/\/< CUDA memory deallocation error$/;"	e	enum:NCVStatus
NPPST_MEM_ALLOC_ERR	gpu/NCV.hpp	/^    NPPST_MEM_ALLOC_ERR,                      \/\/\/< CUDA memory allocation error$/;"	e	enum:NCVStatus
NPPST_MEM_INSUFFICIENT_BUFFER	gpu/NCV.hpp	/^    NPPST_MEM_INSUFFICIENT_BUFFER,            \/\/\/< Insufficient user-allocated buffer$/;"	e	enum:NCVStatus
NPPST_MEM_INTERNAL_ERROR	gpu/NCV.hpp	/^    NPPST_MEM_INTERNAL_ERROR,                 \/\/\/< Internal memory management error$/;"	e	enum:NCVStatus
NPPST_MEM_RESIDENCE_ERROR	gpu/NCV.hpp	/^    NPPST_MEM_RESIDENCE_ERROR,                \/\/\/< Memory residence error detected (check if pointers should be device or pinned)$/;"	e	enum:NCVStatus
NPPST_NULL_POINTER_ERROR	gpu/NCV.hpp	/^    NPPST_NULL_POINTER_ERROR,                 \/\/\/< NULL pointer argument error$/;"	e	enum:NCVStatus
NPPST_SUCCESS	gpu/NCV.hpp	/^    NPPST_SUCCESS = NCV_SUCCESS,              \/\/\/< Successful operation (same as NPP_NO_ERROR)$/;"	e	enum:NCVStatus
NPPST_TEXTURE_BIND_ERROR	gpu/NCV.hpp	/^    NPPST_TEXTURE_BIND_ERROR,                 \/\/\/< CUDA texture binding error or non-zero offset returned$/;"	e	enum:NCVStatus
NU	ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon74
NU_SVC	ml/ml.hpp	/^    enum { C_SVC=100, NU_SVC=101, ONE_CLASS=102, EPS_SVR=103, NU_SVR=104 };$/;"	e	enum:CvSVM::__anon72
NU_SVR	ml/ml.hpp	/^    enum { C_SVC=100, NU_SVC=101, ONE_CLASS=102, EPS_SVR=103, NU_SVR=104 };$/;"	e	enum:CvSVM::__anon72
Ncv16s	gpu/NCV.hpp	/^typedef              short Ncv16s;$/;"	t
Ncv16u	gpu/NCV.hpp	/^typedef     unsigned short Ncv16u;$/;"	t
Ncv32f	gpu/NCV.hpp	/^typedef              float Ncv32f;$/;"	t
Ncv32s	gpu/NCV.hpp	/^typedef                int Ncv32s;$/;"	t
Ncv32u	gpu/NCV.hpp	/^typedef       unsigned int Ncv32u;$/;"	t
Ncv64f	gpu/NCV.hpp	/^typedef             double Ncv64f;$/;"	t
Ncv64s	gpu/NCV.hpp	/^typedef          long long Ncv64s;$/;"	t
Ncv64u	gpu/NCV.hpp	/^    typedef uint64_t Ncv64u;$/;"	t
Ncv64u	gpu/NCV.hpp	/^    typedef unsigned long long Ncv64u;$/;"	t
Ncv8s	gpu/NCV.hpp	/^typedef               char Ncv8s;$/;"	t
Ncv8u	gpu/NCV.hpp	/^typedef      unsigned char Ncv8u;$/;"	t
NcvBool	gpu/NCV.hpp	/^typedef               bool NcvBool;$/;"	t
NcvCTprep	gpu/NCV.hpp	/^namespace NcvCTprep$/;"	n
NcvCTprep::CT_ASSERT_FAILURE	gpu/NCV.hpp	/^    struct CT_ASSERT_FAILURE<true> {};$/;"	s	namespace:NcvCTprep
NcvCTprep::assertTest	gpu/NCV.hpp	/^    struct assertTest{};$/;"	s	namespace:NcvCTprep
NcvRect32s	gpu/NCV.hpp	/^    __host__ __device__ NcvRect32s() : x(0), y(0), width(0), height(0) {};$/;"	f	struct:NcvRect32s	access:public	signature:()
NcvRect32s	gpu/NCV.hpp	/^    __host__ __device__ NcvRect32s(Ncv32s x, Ncv32s y, Ncv32s width, Ncv32s height) : x(x), y(y), width(width), height(height) {}$/;"	f	struct:NcvRect32s	access:public	signature:(Ncv32s x, Ncv32s y, Ncv32s width, Ncv32s height)
NcvRect32s	gpu/NCV.hpp	/^struct NcvRect32s$/;"	s
NcvRect32s::NcvRect32s	gpu/NCV.hpp	/^    __host__ __device__ NcvRect32s() : x(0), y(0), width(0), height(0) {};$/;"	f	struct:NcvRect32s	access:public	signature:()
NcvRect32s::NcvRect32s	gpu/NCV.hpp	/^    __host__ __device__ NcvRect32s(Ncv32s x, Ncv32s y, Ncv32s width, Ncv32s height) : x(x), y(y), width(width), height(height) {}$/;"	f	struct:NcvRect32s	access:public	signature:(Ncv32s x, Ncv32s y, Ncv32s width, Ncv32s height)
NcvRect32s::height	gpu/NCV.hpp	/^    Ncv32s height;     \/\/\/< Rectangle height.$/;"	m	struct:NcvRect32s	access:public
NcvRect32s::width	gpu/NCV.hpp	/^    Ncv32s width;      \/\/\/< Rectangle width.$/;"	m	struct:NcvRect32s	access:public
NcvRect32s::x	gpu/NCV.hpp	/^    Ncv32s x;          \/\/\/< x-coordinate of upper left corner.$/;"	m	struct:NcvRect32s	access:public
NcvRect32s::y	gpu/NCV.hpp	/^    Ncv32s y;          \/\/\/< y-coordinate of upper left corner.$/;"	m	struct:NcvRect32s	access:public
NcvRect32u	gpu/NCV.hpp	/^    __host__ __device__ NcvRect32u() : x(0), y(0), width(0), height(0) {};$/;"	f	struct:NcvRect32u	access:public	signature:()
NcvRect32u	gpu/NCV.hpp	/^    __host__ __device__ NcvRect32u(Ncv32u x, Ncv32u y, Ncv32u width, Ncv32u height) : x(x), y(y), width(width), height(height) {}$/;"	f	struct:NcvRect32u	access:public	signature:(Ncv32u x, Ncv32u y, Ncv32u width, Ncv32u height)
NcvRect32u	gpu/NCV.hpp	/^struct NcvRect32u$/;"	s
NcvRect32u::NcvRect32u	gpu/NCV.hpp	/^    __host__ __device__ NcvRect32u() : x(0), y(0), width(0), height(0) {};$/;"	f	struct:NcvRect32u	access:public	signature:()
NcvRect32u::NcvRect32u	gpu/NCV.hpp	/^    __host__ __device__ NcvRect32u(Ncv32u x, Ncv32u y, Ncv32u width, Ncv32u height) : x(x), y(y), width(width), height(height) {}$/;"	f	struct:NcvRect32u	access:public	signature:(Ncv32u x, Ncv32u y, Ncv32u width, Ncv32u height)
NcvRect32u::height	gpu/NCV.hpp	/^    Ncv32u height;     \/\/\/< Rectangle height.$/;"	m	struct:NcvRect32u	access:public
NcvRect32u::width	gpu/NCV.hpp	/^    Ncv32u width;      \/\/\/< Rectangle width.$/;"	m	struct:NcvRect32u	access:public
NcvRect32u::x	gpu/NCV.hpp	/^    Ncv32u x;          \/\/\/< x-coordinate of upper left corner.$/;"	m	struct:NcvRect32u	access:public
NcvRect32u::y	gpu/NCV.hpp	/^    Ncv32u y;          \/\/\/< y-coordinate of upper left corner.$/;"	m	struct:NcvRect32u	access:public
NcvRect8u	gpu/NCV.hpp	/^    __host__ __device__ NcvRect8u() : x(0), y(0), width(0), height(0) {};$/;"	f	struct:NcvRect8u	access:public	signature:()
NcvRect8u	gpu/NCV.hpp	/^    __host__ __device__ NcvRect8u(Ncv8u x, Ncv8u y, Ncv8u width, Ncv8u height) : x(x), y(y), width(width), height(height) {}$/;"	f	struct:NcvRect8u	access:public	signature:(Ncv8u x, Ncv8u y, Ncv8u width, Ncv8u height)
NcvRect8u	gpu/NCV.hpp	/^struct NcvRect8u$/;"	s
NcvRect8u::NcvRect8u	gpu/NCV.hpp	/^    __host__ __device__ NcvRect8u() : x(0), y(0), width(0), height(0) {};$/;"	f	struct:NcvRect8u	access:public	signature:()
NcvRect8u::NcvRect8u	gpu/NCV.hpp	/^    __host__ __device__ NcvRect8u(Ncv8u x, Ncv8u y, Ncv8u width, Ncv8u height) : x(x), y(y), width(width), height(height) {}$/;"	f	struct:NcvRect8u	access:public	signature:(Ncv8u x, Ncv8u y, Ncv8u width, Ncv8u height)
NcvRect8u::height	gpu/NCV.hpp	/^    Ncv8u height;$/;"	m	struct:NcvRect8u	access:public
NcvRect8u::width	gpu/NCV.hpp	/^    Ncv8u width;$/;"	m	struct:NcvRect8u	access:public
NcvRect8u::x	gpu/NCV.hpp	/^    Ncv8u x;$/;"	m	struct:NcvRect8u	access:public
NcvRect8u::y	gpu/NCV.hpp	/^    Ncv8u y;$/;"	m	struct:NcvRect8u	access:public
NcvSize32s	gpu/NCV.hpp	/^    __host__ __device__ NcvSize32s() : width(0), height(0) {};$/;"	f	struct:NcvSize32s	access:public	signature:()
NcvSize32s	gpu/NCV.hpp	/^    __host__ __device__ NcvSize32s(Ncv32s width, Ncv32s height) : width(width), height(height) {}$/;"	f	struct:NcvSize32s	access:public	signature:(Ncv32s width, Ncv32s height)
NcvSize32s	gpu/NCV.hpp	/^struct NcvSize32s$/;"	s
NcvSize32s::NcvSize32s	gpu/NCV.hpp	/^    __host__ __device__ NcvSize32s() : width(0), height(0) {};$/;"	f	struct:NcvSize32s	access:public	signature:()
NcvSize32s::NcvSize32s	gpu/NCV.hpp	/^    __host__ __device__ NcvSize32s(Ncv32s width, Ncv32s height) : width(width), height(height) {}$/;"	f	struct:NcvSize32s	access:public	signature:(Ncv32s width, Ncv32s height)
NcvSize32s::height	gpu/NCV.hpp	/^    Ncv32s height; \/\/\/< Rectangle height.$/;"	m	struct:NcvSize32s	access:public
NcvSize32s::width	gpu/NCV.hpp	/^    Ncv32s width;  \/\/\/< Rectangle width.$/;"	m	struct:NcvSize32s	access:public
NcvSize32u	gpu/NCV.hpp	/^    __host__ __device__ NcvSize32u() : width(0), height(0) {};$/;"	f	struct:NcvSize32u	access:public	signature:()
NcvSize32u	gpu/NCV.hpp	/^    __host__ __device__ NcvSize32u(Ncv32u width, Ncv32u height) : width(width), height(height) {}$/;"	f	struct:NcvSize32u	access:public	signature:(Ncv32u width, Ncv32u height)
NcvSize32u	gpu/NCV.hpp	/^struct NcvSize32u$/;"	s
NcvSize32u::NcvSize32u	gpu/NCV.hpp	/^    __host__ __device__ NcvSize32u() : width(0), height(0) {};$/;"	f	struct:NcvSize32u	access:public	signature:()
NcvSize32u::NcvSize32u	gpu/NCV.hpp	/^    __host__ __device__ NcvSize32u(Ncv32u width, Ncv32u height) : width(width), height(height) {}$/;"	f	struct:NcvSize32u	access:public	signature:(Ncv32u width, Ncv32u height)
NcvSize32u::height	gpu/NCV.hpp	/^    Ncv32u height; \/\/\/< Rectangle height.$/;"	m	struct:NcvSize32u	access:public
NcvSize32u::width	gpu/NCV.hpp	/^    Ncv32u width;  \/\/\/< Rectangle width.$/;"	m	struct:NcvSize32u	access:public
NcvTimer	gpu/NCV.hpp	/^typedef struct _NcvTimer *NcvTimer;$/;"	t	typeref:struct:_NcvTimer
NeuralNet_MLP	ml/ml.hpp	/^typedef CvANN_MLP NeuralNet_MLP;$/;"	t	namespace:cv
NewParam	legacy/blobtrack.hpp	/^    CvDefParam* NewParam(const char* name);$/;"	p	class:CvVSModule	access:private	signature:(const char* name)
Node	contrib/contrib.hpp	/^            Node() {}$/;"	f	struct:cv::Octree::Node	access:public	signature:()
Node	contrib/contrib.hpp	/^        struct Node$/;"	s	class:cv::Octree	access:public
Node	core/core.hpp	/^        Node() : idx(-1), left(-1), right(-1), boundary(0.f) {}$/;"	f	struct:cv::KDTree::Node	access:public	signature:()
Node	core/core.hpp	/^        Node(int _idx, int _left, int _right, float _boundary)$/;"	f	struct:cv::KDTree::Node	access:public	signature:(int _idx, int _left, int _right, float _boundary)
Node	core/core.hpp	/^    struct CV_EXPORTS Node$/;"	s	class:cv::SparseMat	access:public
Node	core/core.hpp	/^    struct Node$/;"	s	class:cv::KDTree	access:public
Node	flann/hierarchical_clustering_index.h	/^    struct Node$/;"	s	class:cvflann::HierarchicalClusteringIndex	access:private
Node	flann/kdtree_index.h	/^    struct Node$/;"	s	class:cvflann::KDTreeIndex	access:private
Node	flann/kdtree_single_index.h	/^    struct Node$/;"	s	class:cvflann::KDTreeSingleIndex	access:private
NodePtr	flann/hierarchical_clustering_index.h	/^    typedef Node* NodePtr;$/;"	t	class:cvflann::HierarchicalClusteringIndex	access:private
NodePtr	flann/kdtree_index.h	/^    typedef Node* NodePtr;$/;"	t	class:cvflann::KDTreeIndex	access:private
NodePtr	flann/kdtree_single_index.h	/^    typedef Node* NodePtr;$/;"	t	class:cvflann::KDTreeSingleIndex	access:private
NormalBayesClassifier	ml/ml.hpp	/^typedef CvNormalBayesClassifier NormalBayesClassifier;$/;"	t	namespace:cv
Null	gpu/gpu.hpp	/^            static Stream& Null();$/;"	p	class:cv::gpu::Stream	access:public	signature:()
ONE_CLASS	ml/ml.hpp	/^    enum { C_SVC=100, NU_SVC=101, ONE_CLASS=102, EPS_SVR=103, NU_SVR=104 };$/;"	e	enum:CvSVM::__anon72
OPENCV_ASSERT	core/core_c.h	1786;"	d
OPENCV_CALL	core/core_c.h	1792;"	d
OPENCV_ERRCHK	core/core_c.h	1782;"	d
OPENCV_ERROR	core/core_c.h	1779;"	d
OPENCV_FLANN_ALLOCATOR_H_	flann/allocator.h	32;"	d
OPENCV_FLANN_ALL_INDICES_H_	flann/all_indices.h	31;"	d
OPENCV_FLANN_ANY_H_	flann/any.h	2;"	d
OPENCV_FLANN_AUTOTUNED_INDEX_H_	flann/autotuned_index.h	31;"	d
OPENCV_FLANN_COMPOSITE_INDEX_H_	flann/composite_index.h	32;"	d
OPENCV_FLANN_CONFIG_H_	flann/config.h	31;"	d
OPENCV_FLANN_DATASET_H_	flann/matrix.h	32;"	d
OPENCV_FLANN_DEFINES_H_	flann/defines.h	31;"	d
OPENCV_FLANN_DIST_H_	flann/dist.h	32;"	d
OPENCV_FLANN_DUMMY_H_	flann/dummy.h	3;"	d
OPENCV_FLANN_DYNAMIC_BITSET_H_	flann/dynamic_bitset.h	36;"	d
OPENCV_FLANN_GENERAL_H_	flann/general.h	32;"	d
OPENCV_FLANN_GROUND_TRUTH_H_	flann/ground_truth.h	32;"	d
OPENCV_FLANN_HDF5_H_	flann/hdf5.h	31;"	d
OPENCV_FLANN_HEAP_H_	flann/heap.h	32;"	d
OPENCV_FLANN_HIERARCHICAL_CLUSTERING_INDEX_H_	flann/hierarchical_clustering_index.h	32;"	d
OPENCV_FLANN_INDEX_TESTING_H_	flann/index_testing.h	32;"	d
OPENCV_FLANN_KDTREE_INDEX_H_	flann/kdtree_index.h	32;"	d
OPENCV_FLANN_KDTREE_SINGLE_INDEX_H_	flann/kdtree_single_index.h	32;"	d
OPENCV_FLANN_KMEANS_INDEX_H_	flann/kmeans_index.h	32;"	d
OPENCV_FLANN_LINEAR_INDEX_H_	flann/linear_index.h	32;"	d
OPENCV_FLANN_LSH_INDEX_H_	flann/lsh_index.h	36;"	d
OPENCV_FLANN_LSH_TABLE_H_	flann/lsh_table.h	36;"	d
OPENCV_FLANN_OBJECT_FACTORY_H_	flann/object_factory.h	32;"	d
OPENCV_FLANN_PARAMS_H_	flann/params.h	31;"	d
OPENCV_FLANN_SAMPLING_H_	flann/sampling.h	31;"	d
OPENCV_FLANN_SAVING_H_	flann/saving.h	30;"	d
OPENCV_FLANN_SIMPLEX_DOWNHILL_H_	flann/simplex_downhill.h	32;"	d
OPENCV_RSTERR	core/core_c.h	1790;"	d
OPTFLOW_FARNEBACK_GAUSSIAN	video/tracking.hpp	/^enum { OPTFLOW_USE_INITIAL_FLOW=4, OPTFLOW_FARNEBACK_GAUSSIAN=256 };$/;"	e	enum:cv::__anon176
OPTFLOW_USE_INITIAL_FLOW	video/tracking.hpp	/^enum { OPTFLOW_USE_INITIAL_FLOW=4, OPTFLOW_FARNEBACK_GAUSSIAN=256 };$/;"	e	enum:cv::__anon176
ORB	features2d/features2d.hpp	/^  ORB(size_t n_features = 500, const CommonParams & detector_params = CommonParams());$/;"	p	class:cv::ORB	access:public	signature:(size_t n_features = 500, const CommonParams & detector_params = CommonParams())
ORB	features2d/features2d.hpp	/^class CV_EXPORTS ORB$/;"	c	namespace:cv
ObjectFactory	flann/object_factory.h	/^    ObjectFactory() {}$/;"	f	class:cvflann::ObjectFactory	access:private	signature:()
ObjectFactory	flann/object_factory.h	/^class ObjectFactory$/;"	c	namespace:cvflann
ObjectRegistry	flann/object_factory.h	/^    typedef std::map<UniqueIdType, ObjectCreator> ObjectRegistry;$/;"	t	class:cvflann::ObjectFactory	access:private
Octree	contrib/contrib.hpp	/^        Octree( const vector<Point3f>& points, int maxLevels = 10, int minPoints = 20 );$/;"	p	class:cv::Octree	access:public	signature:( const vector<Point3f>& points, int maxLevels = 10, int minPoints = 20 )
Octree	contrib/contrib.hpp	/^        Octree();$/;"	p	class:cv::Octree	access:public	signature:()
Octree	contrib/contrib.hpp	/^    class CV_EXPORTS Octree$/;"	c	namespace:cv
OneWayDescriptor	features2d/features2d.hpp	/^    OneWayDescriptor();$/;"	p	class:cv::OneWayDescriptor	access:public	signature:()
OneWayDescriptor	features2d/features2d.hpp	/^class CV_EXPORTS OneWayDescriptor$/;"	c	namespace:cv
OneWayDescriptorBase	features2d/features2d.hpp	/^    OneWayDescriptorBase(CvSize patch_size, int pose_count, const char* train_path = 0, const char* pca_config = 0,$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(CvSize patch_size, int pose_count, const char* train_path = 0, const char* pca_config = 0, const char* pca_hr_config = 0, const char* pca_desc_config = 0, int pyr_levels = 1, int pca_dim_high = 100, int pca_dim_low = 100)
OneWayDescriptorBase	features2d/features2d.hpp	/^    OneWayDescriptorBase(CvSize patch_size, int pose_count, const string &pca_filename, const string &train_path = string(), const string &images_list = string(),$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(CvSize patch_size, int pose_count, const string &pca_filename, const string &train_path = string(), const string &images_list = string(), float _scale_min = 0.7f, float _scale_max=1.5f, float _scale_step=1.2f, int pyr_levels = 1, int pca_dim_high = 100, int pca_dim_low = 100)
OneWayDescriptorBase	features2d/features2d.hpp	/^class CV_EXPORTS OneWayDescriptorBase$/;"	c	namespace:cv
OneWayDescriptorMatch	features2d/features2d.hpp	/^typedef OneWayDescriptorMatcher OneWayDescriptorMatch;$/;"	t	namespace:cv
OneWayDescriptorMatcher	features2d/features2d.hpp	/^    OneWayDescriptorMatcher( const Params& params=Params() );$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:( const Params& params=Params() )
OneWayDescriptorMatcher	features2d/features2d.hpp	/^class CV_EXPORTS OneWayDescriptorMatcher : public GenericDescriptorMatcher$/;"	c	namespace:cv	inherits:GenericDescriptorMatcher
OneWayDescriptorObject	features2d/features2d.hpp	/^    OneWayDescriptorObject(CvSize patch_size, int pose_count, const char* train_path, const char* pca_config,$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(CvSize patch_size, int pose_count, const char* train_path, const char* pca_config, const char* pca_hr_config = 0, const char* pca_desc_config = 0, int pyr_levels = 1)
OneWayDescriptorObject	features2d/features2d.hpp	/^    OneWayDescriptorObject(CvSize patch_size, int pose_count, const string &pca_filename,$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(CvSize patch_size, int pose_count, const string &pca_filename, const string &train_path = string (), const string &images_list = string (), float _scale_min = 0.7f, float _scale_max=1.5f, float _scale_step=1.2f, int pyr_levels = 1)
OneWayDescriptorObject	features2d/features2d.hpp	/^class CV_EXPORTS OneWayDescriptorObject : public OneWayDescriptorBase$/;"	c	namespace:cv	inherits:OneWayDescriptorBase
OpenGLCallback	highgui/highgui.hpp	/^typedef void (CV_CDECL *OpenGLCallback)(void* userdata);$/;"	t	namespace:cv
OpponentColorDescriptorExtractor	features2d/features2d.hpp	/^    OpponentColorDescriptorExtractor( const Ptr<DescriptorExtractor>& descriptorExtractor );$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:public	signature:( const Ptr<DescriptorExtractor>& descriptorExtractor )
OpponentColorDescriptorExtractor	features2d/features2d.hpp	/^class CV_EXPORTS OpponentColorDescriptorExtractor : public DescriptorExtractor$/;"	c	namespace:cv	inherits:DescriptorExtractor
OrbDescriptorExtractor	features2d/features2d.hpp	/^  OrbDescriptorExtractor(ORB::CommonParams params = ORB::CommonParams());$/;"	p	class:cv::OrbDescriptorExtractor	access:public	signature:(ORB::CommonParams params = ORB::CommonParams())
OrbDescriptorExtractor	features2d/features2d.hpp	/^class CV_EXPORTS OrbDescriptorExtractor : public cv::DescriptorExtractor$/;"	c	namespace:cv	inherits:cv::DescriptorExtractor
OrbFeatureDetector	features2d/features2d.hpp	/^  OrbFeatureDetector(size_t n_features = 700, ORB::CommonParams params = ORB::CommonParams());$/;"	p	class:cv::OrbFeatureDetector	access:public	signature:(size_t n_features = 700, ORB::CommonParams params = ORB::CommonParams())
OrbFeatureDetector	features2d/features2d.hpp	/^class CV_EXPORTS OrbFeatureDetector : public cv::FeatureDetector$/;"	c	namespace:cv	inherits:cv::FeatureDetector
OutputArray	core/core.hpp	/^typedef const _OutputArray& OutputArray;$/;"	t	namespace:cv
OutputArrayOfArrays	core/core.hpp	/^typedef OutputArray OutputArrayOfArrays;$/;"	t	namespace:cv
P	contrib/contrib.hpp	/^        CvMat* P; \/\/ parameters used to evaluate function with new params$/;"	m	class:cv::LevMarqSparse	access:public
P	ml/ml.hpp	/^    enum { C=0, GAMMA=1, P=2, NU=3, COEF=4, DEGREE=5 };$/;"	e	enum:CvSVM::__anon74
P1	calib3d/calib3d.hpp	/^    CV_PROP_RW int P1;$/;"	m	class:cv::StereoSGBM	access:public
P2	calib3d/calib3d.hpp	/^    CV_PROP_RW int P2;$/;"	m	class:cv::StereoSGBM	access:public
PATCH_HEIGHT	features2d/features2d.hpp	/^        static const int PATCH_HEIGHT = 24;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
PATCH_SIZE	features2d/features2d.hpp	/^        PATCH_SIZE = 31,$/;"	e	enum:cv::FernClassifier::__anon193
PATCH_SIZE	features2d/features2d.hpp	/^    static const int PATCH_SIZE = 48;$/;"	m	class:cv::BriefDescriptorExtractor	access:public
PATCH_SIZE	features2d/features2d.hpp	/^  static const uchar PATCH_SIZE = 32;$/;"	m	class:cv::RandomizedTree	access:public
PATCH_WIDTH	features2d/features2d.hpp	/^        static const int PATCH_WIDTH = 24;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
PCA	core/core.hpp	/^    PCA();$/;"	p	class:cv::PCA	access:public	signature:()
PCA	core/core.hpp	/^    PCA(InputArray data, InputArray mean, int flags, int maxComponents=0);$/;"	p	class:cv::PCA	access:public	signature:(InputArray data, InputArray mean, int flags, int maxComponents=0)
PCA	core/core.hpp	/^class CV_EXPORTS PCA$/;"	c	namespace:cv
PCABackProject	core/core.hpp	/^CV_EXPORTS_W void PCABackProject(InputArray data, InputArray mean,$/;"	p	namespace:cv	signature:(InputArray data, InputArray mean, InputArray eigenvectors, OutputArray result)
PCACompute	core/core.hpp	/^CV_EXPORTS_W void PCACompute(InputArray data, CV_OUT InputOutputArray mean,$/;"	p	namespace:cv	signature:(InputArray data, CV_OUT InputOutputArray mean, OutputArray eigenvectors, int maxComponents=0)
PCAProject	core/core.hpp	/^CV_EXPORTS_W void PCAProject(InputArray data, InputArray mean,$/;"	p	namespace:cv	signature:(InputArray data, InputArray mean, InputArray eigenvectors, OutputArray result)
PENALIZATION_CHARBONNIER	contrib/contrib.hpp	/^        enum {PENALIZATION_TICHONOV, PENALIZATION_CHARBONNIER, PENALIZATION_PERONA_MALIK};$/;"	e	enum:cv::StereoVar::__anon9
PENALIZATION_PERONA_MALIK	contrib/contrib.hpp	/^        enum {PENALIZATION_TICHONOV, PENALIZATION_CHARBONNIER, PENALIZATION_PERONA_MALIK};$/;"	e	enum:cv::StereoVar::__anon9
PENALIZATION_TICHONOV	contrib/contrib.hpp	/^        enum {PENALIZATION_TICHONOV, PENALIZATION_CHARBONNIER, PENALIZATION_PERONA_MALIK};$/;"	e	enum:cv::StereoVar::__anon9
PNCovariance	video/tracking.hpp	/^    float* PNCovariance;        \/* =process_noise_cov->data.fl *\/$/;"	m	struct:CvKalman	access:public
POLY	ml/ml.hpp	/^    enum { LINEAR=0, POLY=1, RBF=2, SIGMOID=3 };$/;"	e	enum:CvSVM::__anon73
POSE_COUNT	features2d/features2d.hpp	/^        static const int POSE_COUNT = 500;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
PREFILTER_NORMALIZED_RESPONSE	calib3d/calib3d.hpp	/^    enum { PREFILTER_NORMALIZED_RESPONSE = 0, PREFILTER_XSOBEL = 1,$/;"	e	enum:cv::StereoBM::__anon92
PREFILTER_XSOBEL	calib3d/calib3d.hpp	/^    enum { PREFILTER_NORMALIZED_RESPONSE = 0, PREFILTER_XSOBEL = 1,$/;"	e	enum:cv::StereoBM::__anon92
PREFILTER_XSOBEL	gpu/gpu.hpp	/^            enum { BASIC_PRESET = 0, PREFILTER_XSOBEL = 1 };$/;"	e	enum:cv::gpu::StereoBM_GPU::__anon55
PREV_AROUND_DST	imgproc/imgproc.hpp	/^        PREV_AROUND_DST   = 0x33,$/;"	e	enum:cv::Subdiv2D::__anon28
PREV_AROUND_LEFT	imgproc/imgproc.hpp	/^        PREV_AROUND_LEFT  = 0x20,$/;"	e	enum:cv::Subdiv2D::__anon28
PREV_AROUND_ORG	imgproc/imgproc.hpp	/^        PREV_AROUND_ORG   = 0x11,$/;"	e	enum:cv::Subdiv2D::__anon28
PREV_AROUND_RIGHT	imgproc/imgproc.hpp	/^        PREV_AROUND_RIGHT = 0x02$/;"	e	enum:cv::Subdiv2D::__anon28
PROFILE_DOG	legacy/blobtrack.hpp	536;"	d
PROFILE_EPANECHNIKOV	legacy/blobtrack.hpp	535;"	d
PROJ_SPHERICAL_EQRECT	imgproc/imgproc.hpp	/^    PROJ_SPHERICAL_EQRECT = 1$/;"	e	enum:cv::__anon18
PROJ_SPHERICAL_ORTHO	imgproc/imgproc.hpp	/^    PROJ_SPHERICAL_ORTHO = 0,$/;"	e	enum:cv::__anon18
PTLOC_ERROR	imgproc/imgproc.hpp	/^        PTLOC_ERROR = -2,$/;"	e	enum:cv::Subdiv2D::__anon27
PTLOC_INSIDE	imgproc/imgproc.hpp	/^        PTLOC_INSIDE = 0,$/;"	e	enum:cv::Subdiv2D::__anon27
PTLOC_ON_EDGE	imgproc/imgproc.hpp	/^        PTLOC_ON_EDGE = 2$/;"	e	enum:cv::Subdiv2D::__anon27
PTLOC_OUTSIDE_RECT	imgproc/imgproc.hpp	/^        PTLOC_OUTSIDE_RECT = -1,$/;"	e	enum:cv::Subdiv2D::__anon27
PTLOC_VERTEX	imgproc/imgproc.hpp	/^        PTLOC_VERTEX = 1,$/;"	e	enum:cv::Subdiv2D::__anon27
ParamGrid	ml/ml.hpp	/^typedef CvParamGrid ParamGrid;$/;"	t	namespace:cv
ParamUpdate	legacy/blobtrack.hpp	/^    virtual void ParamUpdate();$/;"	p	class:CvVSModule	access:public	signature:()
Params	features2d/features2d.hpp	/^        Params( const string& filename );$/;"	p	class:cv::FernDescriptorMatcher::Params	access:public	signature:( const string& filename )
Params	features2d/features2d.hpp	/^        Params( float initFeatureScale=1.f, int featureScaleLevels=1, float featureScaleMul=0.1f,$/;"	p	class:cv::DenseFeatureDetector::Params	access:public	signature:( float initFeatureScale=1.f, int featureScaleLevels=1, float featureScaleMul=0.1f, int initXyStep=6, int initImgBound=0, bool varyXyStepWithScale=true, bool varyImgBoundWithScale=false )
Params	features2d/features2d.hpp	/^        Params( int maxCorners=1000, double qualityLevel=0.01, double minDistance=1.,$/;"	p	class:cv::GoodFeaturesToTrackDetector::Params	access:public	signature:( int maxCorners=1000, double qualityLevel=0.01, double minDistance=1., int blockSize=3, bool useHarrisDetector=false, double k=0.04 )
Params	features2d/features2d.hpp	/^        Params( int nclasses=0,$/;"	p	class:cv::FernDescriptorMatcher::Params	access:public	signature:( int nclasses=0, int patchSize=FernClassifier::PATCH_SIZE, int signatureSize=FernClassifier::DEFAULT_SIGNATURE_SIZE, int nstructs=FernClassifier::DEFAULT_STRUCTS, int structSize=FernClassifier::DEFAULT_STRUCT_SIZE, int nviews=FernClassifier::DEFAULT_VIEWS, int compressionMethod=FernClassifier::COMPRESSION_NONE, const PatchGenerator& patchGenerator=PatchGenerator() )
Params	features2d/features2d.hpp	/^        Params( int poseCount = POSE_COUNT,$/;"	p	class:cv::OneWayDescriptorMatcher::Params	access:public	signature:( int poseCount = POSE_COUNT, Size patchSize = Size(PATCH_WIDTH, PATCH_HEIGHT), string pcaFilename = string(), string trainPath = string(), string trainImagesList = string(), float minScale = GET_MIN_SCALE(), float maxScale = GET_MAX_SCALE(), float stepScale = GET_STEP_SCALE() )
Params	features2d/features2d.hpp	/^      Params();$/;"	p	struct:cv::SimpleBlobDetector::Params	access:public	signature:()
Params	features2d/features2d.hpp	/^    class CV_EXPORTS Params$/;"	c	class:cv::DenseFeatureDetector	access:public
Params	features2d/features2d.hpp	/^    class CV_EXPORTS Params$/;"	c	class:cv::FernDescriptorMatcher	access:public
Params	features2d/features2d.hpp	/^    class CV_EXPORTS Params$/;"	c	class:cv::GoodFeaturesToTrackDetector	access:public
Params	features2d/features2d.hpp	/^    class CV_EXPORTS Params$/;"	c	class:cv::OneWayDescriptorMatcher	access:public
Params	features2d/features2d.hpp	/^  struct CV_EXPORTS Params$/;"	s	class:cv::SimpleBlobDetector	access:public
PatchGenerator	features2d/features2d.hpp	/^    PatchGenerator();$/;"	p	class:cv::PatchGenerator	access:public	signature:()
PatchGenerator	features2d/features2d.hpp	/^    PatchGenerator(double _backgroundMin, double _backgroundMax,$/;"	p	class:cv::PatchGenerator	access:public	signature:(double _backgroundMin, double _backgroundMax, double _noiseRange, bool _randomBlur=true, double _lambdaMin=0.6, double _lambdaMax=1.5, double _thetaMin=-CV_PI, double _thetaMax=CV_PI, double _phiMin=-CV_PI, double _phiMax=CV_PI )
PatchGenerator	features2d/features2d.hpp	/^class CV_EXPORTS PatchGenerator$/;"	c	namespace:cv
Pbc	video/background_segm.hpp	/^    float                 Pbc;$/;"	m	struct:CvBGPixelStat	access:public
Pbcc	video/background_segm.hpp	/^    float                 Pbcc;$/;"	m	struct:CvBGPixelStat	access:public
PixelSize	core/wimage.hpp	/^    int PixelSize() const {return Channels() * ChannelSize(); }$/;"	f	class:cv::WImage	access:public	signature:() const
PixelTestFn	features2d/features2d.hpp	/^    typedef void(*PixelTestFn)(const Mat&, const std::vector<KeyPoint>&, Mat&);$/;"	t	class:cv::BriefDescriptorExtractor	access:protected
PlanarObjectDetector	objdetect/objdetect.hpp	/^    PlanarObjectDetector();$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:()
PlanarObjectDetector	objdetect/objdetect.hpp	/^    PlanarObjectDetector(const FileNode& node);$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const FileNode& node)
PlanarObjectDetector	objdetect/objdetect.hpp	/^    PlanarObjectDetector(const vector<Mat>& pyr, int _npoints=300,$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const vector<Mat>& pyr, int _npoints=300, int _patchSize=FernClassifier::PATCH_SIZE, int _nstructs=FernClassifier::DEFAULT_STRUCTS, int _structSize=FernClassifier::DEFAULT_STRUCT_SIZE, int _nviews=FernClassifier::DEFAULT_VIEWS, const LDetector& detector=LDetector(), const PatchGenerator& patchGenerator=PatchGenerator())
PlanarObjectDetector	objdetect/objdetect.hpp	/^class CV_EXPORTS PlanarObjectDetector$/;"	c	namespace:cv
Point	core/core.hpp	/^typedef Point2i Point;$/;"	t	namespace:cv
Point2d	core/core.hpp	/^typedef Point_<double> Point2d;$/;"	t	namespace:cv
Point2f	core/core.hpp	/^typedef Point_<float> Point2f;$/;"	t	namespace:cv
Point2i	core/core.hpp	/^typedef Point_<int> Point2i;$/;"	t	namespace:cv
Point3_	core/core.hpp	/^    Point3_();$/;"	p	class:cv::Point3_	access:public	signature:()
Point3_	core/core.hpp	/^    Point3_(_Tp _x, _Tp _y, _Tp _z);$/;"	p	class:cv::Point3_	access:public	signature:(_Tp _x, _Tp _y, _Tp _z)
Point3_	core/core.hpp	/^    Point3_(const CvPoint3D32f& pt);$/;"	p	class:cv::Point3_	access:public	signature:(const CvPoint3D32f& pt)
Point3_	core/core.hpp	/^    Point3_(const Point3_& pt);$/;"	p	class:cv::Point3_	access:public	signature:(const Point3_& pt)
Point3_	core/core.hpp	/^    Point3_(const Vec<_Tp, 3>& v);$/;"	p	class:cv::Point3_	access:public	signature:(const Vec<_Tp, 3>& v)
Point3_	core/core.hpp	/^    explicit Point3_(const Point_<_Tp>& pt);$/;"	p	class:cv::Point3_	access:public	signature:(const Point_<_Tp>& pt)
Point3_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Point3_$/;"	c	namespace:cv
Point3_	core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_() : x(0), y(0), z(0) {}$/;"	f	class:cv::Point3_	signature:()
Point3_	core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_(_Tp _x, _Tp _y, _Tp _z) : x(_x), y(_y), z(_z) {}$/;"	f	class:cv::Point3_	signature:(_Tp _x, _Tp _y, _Tp _z)
Point3_	core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_(const CvPoint3D32f& pt) :$/;"	f	class:cv::Point3_	signature:(const CvPoint3D32f& pt)
Point3_	core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_(const Point3_& pt) : x(pt.x), y(pt.y), z(pt.z) {}$/;"	f	class:cv::Point3_	signature:(const Point3_& pt)
Point3_	core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_(const Point_<_Tp>& pt) : x(pt.x), y(pt.y), z(_Tp()) {}$/;"	f	class:cv::Point3_	signature:(const Point_<_Tp>& pt)
Point3_	core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_(const Vec<_Tp, 3>& v) : x(v[0]), y(v[1]), z(v[2]) {}$/;"	f	class:cv::Point3_	signature:(const Vec<_Tp, 3>& v)
Point3d	core/core.hpp	/^typedef Point3_<double> Point3d;$/;"	t	namespace:cv
Point3f	core/core.hpp	/^typedef Point3_<float> Point3f;$/;"	t	namespace:cv
Point3i	core/core.hpp	/^typedef Point3_<int> Point3i;$/;"	t	namespace:cv
Point_	core/core.hpp	/^    Point_();$/;"	p	class:cv::Point_	access:public	signature:()
Point_	core/core.hpp	/^    Point_(_Tp _x, _Tp _y);$/;"	p	class:cv::Point_	access:public	signature:(_Tp _x, _Tp _y)
Point_	core/core.hpp	/^    Point_(const CvPoint& pt);$/;"	p	class:cv::Point_	access:public	signature:(const CvPoint& pt)
Point_	core/core.hpp	/^    Point_(const CvPoint2D32f& pt);$/;"	p	class:cv::Point_	access:public	signature:(const CvPoint2D32f& pt)
Point_	core/core.hpp	/^    Point_(const Point_& pt);$/;"	p	class:cv::Point_	access:public	signature:(const Point_& pt)
Point_	core/core.hpp	/^    Point_(const Size_<_Tp>& sz);$/;"	p	class:cv::Point_	access:public	signature:(const Size_<_Tp>& sz)
Point_	core/core.hpp	/^    Point_(const Vec<_Tp, 2>& v);$/;"	p	class:cv::Point_	access:public	signature:(const Vec<_Tp, 2>& v)
Point_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Point_$/;"	c	namespace:cv
Point_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Point_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
Point_	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_() : x(0), y(0) {}$/;"	f	class:cv::Point_	signature:()
Point_	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(_Tp _x, _Tp _y) : x(_x), y(_y) {}$/;"	f	class:cv::Point_	signature:(_Tp _x, _Tp _y)
Point_	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(const CvPoint& pt) : x((_Tp)pt.x), y((_Tp)pt.y) {}$/;"	f	class:cv::Point_	signature:(const CvPoint& pt)
Point_	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(const CvPoint2D32f& pt)$/;"	f	class:cv::Point_	signature:(const CvPoint2D32f& pt)
Point_	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(const Point_& pt) : x(pt.x), y(pt.y) {}$/;"	f	class:cv::Point_	signature:(const Point_& pt)
Point_	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(const Size_<_Tp>& sz) : x(sz.width), y(sz.height) {}$/;"	f	class:cv::Point_	signature:(const Size_<_Tp>& sz)
Point_	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(const Vec<_Tp,2>& v) : x(v[0]), y(v[1]) {}$/;"	f	class:cv::Point_	signature:(const Vec<_Tp,2>& v)
PooledAllocator	flann/allocator.h	/^    PooledAllocator(int blocksize = BLOCKSIZE)$/;"	f	class:cvflann::PooledAllocator	access:public	signature:(int blocksize = BLOCKSIZE)
PooledAllocator	flann/allocator.h	/^class PooledAllocator$/;"	c	namespace:cvflann
PosterErrorCovariance	video/tracking.hpp	/^    float* PosterErrorCovariance;\/* =error_cov_post->data.fl *\/$/;"	m	struct:CvKalman	access:public
PosterState	video/tracking.hpp	/^    float* PosterState;         \/* =state_pre->data.fl *\/$/;"	m	struct:CvKalman	access:public
Predict	legacy/blobtrack.hpp	/^    virtual CvBlob* Predict() = 0;$/;"	p	class:CvBlobTrackPredictor	access:public	signature:()
PriorErrorCovariance	video/tracking.hpp	/^    float* PriorErrorCovariance;\/* =error_cov_pre->data.fl *\/$/;"	m	struct:CvKalman	access:public
PriorState	video/tracking.hpp	/^    float* PriorState;          \/* =state_post->data.fl *\/$/;"	m	struct:CvKalman	access:public
Process	legacy/blobtrack.hpp	/^    virtual CvBlob* Process(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackPostProcOne	access:public	signature:(CvBlob* pBlob)
Process	legacy/blobtrack.hpp	/^    virtual CvBlob* Process(CvBlob* pBlobPrev, IplImage* pImg, IplImage* pImgFG = NULL) = 0;$/;"	p	class:CvBlobTrackerOne	access:public	signature:(CvBlob* pBlobPrev, IplImage* pImg, IplImage* pImgFG = NULL)
Process	legacy/blobtrack.hpp	/^    virtual int     Process(CvBlob* pBlob, IplImage* pImg, IplImage* pFG) = 0;$/;"	p	class:CvBlobTrackAnalysisOne	access:public	signature:(CvBlob* pBlob, IplImage* pImg, IplImage* pFG)
Process	legacy/blobtrack.hpp	/^    virtual void        Process(IplImage* pImg, IplImage* pMask = NULL) = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:(IplImage* pImg, IplImage* pMask = NULL)
Process	legacy/blobtrack.hpp	/^    virtual void    Process() = 0;$/;"	p	class:CvBlobTrackPostProc	access:public	signature:()
Process	legacy/blobtrack.hpp	/^    virtual void    Process(IplImage* pImg = NULL, IplImage* pFG = NULL) = 0;$/;"	p	class:CvBlobTrackGen	access:public	signature:(IplImage* pImg = NULL, IplImage* pFG = NULL)
Process	legacy/blobtrack.hpp	/^    virtual void    Process(IplImage* pImg) = 0;$/;"	p	class:CvFGDetector	access:public	signature:(IplImage* pImg)
Process	legacy/blobtrack.hpp	/^    virtual void    Process(IplImage* pImg, IplImage* pFG) = 0;$/;"	p	class:CvBlobTrackAnalysis	access:public	signature:(IplImage* pImg, IplImage* pFG)
Process	legacy/blobtrack.hpp	/^    virtual void    Process(IplImage* pImg, IplImage* pFG) = 0;$/;"	p	class:CvBlobTrackFVGen	access:public	signature:(IplImage* pImg, IplImage* pFG)
Process	legacy/blobtrack.hpp	/^    virtual void    Process(IplImage* pImg, IplImage* pImgFG = NULL) = 0;$/;"	p	class:CvBlobTracker	access:public	signature:(IplImage* pImg, IplImage* pImgFG = NULL)
ProcessBlob	legacy/blobtrack.hpp	/^    virtual void ProcessBlob(int BlobIndex, CvBlob* pBlob, IplImage* \/*pImg*\/, IplImage* \/*pImgFG*\/ = NULL);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobIndex, CvBlob* pBlob, IplImage* , IplImage* = NULL)
ProjectPCASample	features2d/features2d.hpp	/^    void ProjectPCASample(IplImage* patch, CvMat* avg, CvMat* eigenvectors, CvMat* pca_coeffs) const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(IplImage* patch, CvMat* avg, CvMat* eigenvectors, CvMat* pca_coeffs) const
Ptr	core/core.hpp	/^    Ptr();$/;"	p	class:cv::Ptr	access:public	signature:()
Ptr	core/core.hpp	/^    Ptr(_Tp* _obj);$/;"	p	class:cv::Ptr	access:public	signature:(_Tp* _obj)
Ptr	core/core.hpp	/^    Ptr(const Ptr& ptr);$/;"	p	class:cv::Ptr	access:public	signature:(const Ptr& ptr)
Ptr	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Ptr$/;"	c	namespace:cv
Ptr	core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::Ptr() : obj(0), refcount(0) {}$/;"	f	class:cv::Ptr	signature:()
Ptr	core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::Ptr(_Tp* _obj) : obj(_obj)$/;"	f	class:cv::Ptr	signature:(_Tp* _obj)
Ptr	core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::Ptr(const Ptr<_Tp>& ptr)$/;"	f	class:cv::Ptr	signature:(const Ptr<_Tp>& ptr)
PtrElemStep	gpu/devmem2d.hpp	/^        typedef PtrElemStep_<unsigned char> PtrElemStep;$/;"	t	namespace:cv::gpu
PtrElemStep_	gpu/devmem2d.hpp	/^            PtrElemStep_(const DevMem2D_<T>& mem) : PtrStep_<T>(mem) $/;"	f	struct:cv::gpu::PtrElemStep_	access:public	signature:(const DevMem2D_<T>& mem)
PtrElemStep_	gpu/devmem2d.hpp	/^        template<typename T> struct PtrElemStep_ : public PtrStep_<T>$/;"	s	namespace:cv::gpu	inherits:PtrStep_
PtrElemStepf	gpu/devmem2d.hpp	/^        typedef PtrElemStep_<float> PtrElemStepf;$/;"	t	namespace:cv::gpu
PtrElemStepi	gpu/devmem2d.hpp	/^        typedef PtrElemStep_<int> PtrElemStepi;$/;"	t	namespace:cv::gpu
PtrStep	gpu/devmem2d.hpp	/^        typedef PtrStep_<unsigned char> PtrStep;$/;"	t	namespace:cv::gpu
PtrStep_	gpu/devmem2d.hpp	/^            PtrStep_() : data(0), step(0) {}            $/;"	f	struct:cv::gpu::PtrStep_	access:public	signature:()
PtrStep_	gpu/devmem2d.hpp	/^            PtrStep_(const DevMem2D_<T>& mem) : data(mem.data), step(mem.step) {}$/;"	f	struct:cv::gpu::PtrStep_	access:public	signature:(const DevMem2D_<T>& mem)
PtrStep_	gpu/devmem2d.hpp	/^        template<typename T> struct PtrStep_$/;"	s	namespace:cv::gpu
PtrStepf	gpu/devmem2d.hpp	/^        typedef PtrStep_<float> PtrStepf;$/;"	t	namespace:cv::gpu
PtrStepi	gpu/devmem2d.hpp	/^        typedef PtrStep_<int> PtrStepi;$/;"	t	namespace:cv::gpu
Push	legacy/legacy.hpp	/^    virtual bool Push( const CvPoint2D32f** points = 0 );$/;"	p	class:CvCalibFilter	access:public	signature:( const CvPoint2D32f** points = 0 )
Pv	video/background_segm.hpp	/^    float          Pv, Pvb;$/;"	m	struct:CvBGPixelCCStatTable	access:public
Pv	video/background_segm.hpp	/^    float          Pv, Pvb;$/;"	m	struct:CvBGPixelCStatTable	access:public
Pvb	video/background_segm.hpp	/^    float          Pv, Pvb;$/;"	m	struct:CvBGPixelCCStatTable	access:public
Pvb	video/background_segm.hpp	/^    float          Pv, Pvb;$/;"	m	struct:CvBGPixelCStatTable	access:public
PyrDownBuf	gpu/gpu.hpp	/^            PyrDownBuf() : image_type(-1) {}$/;"	f	struct:cv::gpu::PyrDownBuf	access:public	signature:()
PyrDownBuf	gpu/gpu.hpp	/^            PyrDownBuf(Size image_size, int image_type_) : image_type(-1) { create(image_size, image_type_); }$/;"	f	struct:cv::gpu::PyrDownBuf	access:public	signature:(Size image_size, int image_type_)
PyrDownBuf	gpu/gpu.hpp	/^        struct CV_EXPORTS PyrDownBuf$/;"	s	namespace:cv::gpu
PyrDownBuf	gpu/gpu.hpp	/^        struct CV_EXPORTS PyrDownBuf;$/;"	m	namespace:cv::gpu	typeref:struct:cv::gpu::CV_EXPORTS
PyrUpBuf	gpu/gpu.hpp	/^            PyrUpBuf() : image_type(-1) {}$/;"	f	struct:cv::gpu::PyrUpBuf	access:public	signature:()
PyrUpBuf	gpu/gpu.hpp	/^            PyrUpBuf(Size image_size, int image_type_) : image_type(-1) { create(image_size, image_type_); }$/;"	f	struct:cv::gpu::PyrUpBuf	access:public	signature:(Size image_size, int image_type_)
PyrUpBuf	gpu/gpu.hpp	/^        struct CV_EXPORTS PyrUpBuf$/;"	s	namespace:cv::gpu
PyrUpBuf	gpu/gpu.hpp	/^        struct CV_EXPORTS PyrUpBuf;$/;"	m	namespace:cv::gpu	typeref:struct:cv::gpu::CV_EXPORTS
PyramidAdaptedFeatureDetector	features2d/features2d.hpp	/^    PyramidAdaptedFeatureDetector( const Ptr<FeatureDetector>& detector, int maxLevel=2 );$/;"	p	class:cv::PyramidAdaptedFeatureDetector	access:public	signature:( const Ptr<FeatureDetector>& detector, int maxLevel=2 )
PyramidAdaptedFeatureDetector	features2d/features2d.hpp	/^class CV_EXPORTS PyramidAdaptedFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
QuadEdge	imgproc/imgproc.hpp	/^        QuadEdge();$/;"	p	struct:cv::Subdiv2D::QuadEdge	access:public	signature:()
QuadEdge	imgproc/imgproc.hpp	/^        QuadEdge(int edgeidx);$/;"	p	struct:cv::Subdiv2D::QuadEdge	access:public	signature:(int edgeidx)
QuadEdge	imgproc/imgproc.hpp	/^    struct CV_EXPORTS QuadEdge$/;"	s	class:cv::Subdiv2D	access:protected
RAND_DIM	flann/kdtree_index.h	/^        RAND_DIM=5$/;"	e	enum:cvflann::KDTreeIndex::__anon206
RANSAC	calib3d/calib3d.hpp	/^    RANSAC=CV_RANSAC \/\/!< RANSAC algorithm$/;"	e	enum:cv::__anon87
RBF	ml/ml.hpp	/^    enum { LINEAR=0, POLY=1, RBF=2, SIGMOID=3 };$/;"	e	enum:CvSVM::__anon73
READ	core/core.hpp	/^        READ=0, \/\/! read mode$/;"	e	enum:cv::FileStorage::__anon147
REAL	core/core.hpp	/^        REAL=2, \/\/!< floating-point number$/;"	e	enum:cv::FileNode::__anon149
REAL	ml/ml.hpp	/^    enum { DISCRETE=0, REAL=1, LOGIT=2, GENTLE=3 };$/;"	e	enum:CvBoost::__anon79
RECT	legacy/blobtrack.hpp	/^    enum {RECT, ELLIPSE} shape;$/;"	e	enum:CvDrawShape::__anon177
REF	core/core.hpp	/^        REF=4, \/\/!< integer of size size_t. Typically used for storing complex dynamic structures where some elements reference the others $/;"	e	enum:cv::FileNode::__anon149
RETINA_COLORSAMPLINGMETHOD	contrib/retina.hpp	/^    enum RETINA_COLORSAMPLINGMETHOD$/;"	g	namespace:cv
RETINA_COLOR_BAYER	contrib/retina.hpp	/^        RETINA_COLOR_BAYER\/\/\/ standard bayer sampling$/;"	e	enum:cv::RETINA_COLORSAMPLINGMETHOD
RETINA_COLOR_DIAGONAL	contrib/retina.hpp	/^        RETINA_COLOR_DIAGONAL,\/\/\/ color sampling is RGBRGBRGB..., line 2 BRGBRGBRG..., line 3, GBRGBRGBR...$/;"	e	enum:cv::RETINA_COLORSAMPLINGMETHOD
RETINA_COLOR_RANDOM	contrib/retina.hpp	/^        RETINA_COLOR_RANDOM, \/\/\/ each pixel position is either R, G or B in a random choice$/;"	e	enum:cv::RETINA_COLORSAMPLINGMETHOD
RETR_CCOMP	imgproc/imgproc.hpp	/^    RETR_CCOMP=CV_RETR_CCOMP, \/\/!< retrieve the connected components (that can possibly be nested)$/;"	e	enum:cv::__anon25
RETR_EXTERNAL	imgproc/imgproc.hpp	/^    RETR_EXTERNAL=CV_RETR_EXTERNAL, \/\/!< retrieve only the most external (top-level) contours$/;"	e	enum:cv::__anon25
RETR_LIST	imgproc/imgproc.hpp	/^    RETR_LIST=CV_RETR_LIST, \/\/!< retrieve all the contours without any hierarchical information$/;"	e	enum:cv::__anon25
RETR_TREE	imgproc/imgproc.hpp	/^    RETR_TREE=CV_RETR_TREE \/\/!< retrieve all the contours and the whole hierarchy$/;"	e	enum:cv::__anon25
RNG	core/core.hpp	/^    RNG();$/;"	p	class:cv::RNG	access:public	signature:()
RNG	core/core.hpp	/^    RNG(uint64 _state);$/;"	p	class:cv::RNG	access:public	signature:(uint64 _state)
RNG	core/core.hpp	/^class CV_EXPORTS RNG$/;"	c	namespace:cv
RNG	core/operations.hpp	/^inline RNG::RNG() { state = 0xffffffff; }$/;"	f	class:cv::RNG	signature:()
RNG	core/operations.hpp	/^inline RNG::RNG(uint64 _state) { state = _state ? _state : 0xffffffff; }$/;"	f	class:cv::RNG	signature:(uint64 _state)
RPROP	ml/ml.hpp	/^    enum { BACKPROP=0, RPROP=1 };$/;"	e	enum:CvANN_MLP_TrainParams::__anon82
RQDecomp3x3	calib3d/calib3d.hpp	/^CV_EXPORTS_W Vec3d RQDecomp3x3( InputArray src, OutputArray mtxR, OutputArray mtxQ,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray mtxR, OutputArray mtxQ, OutputArray Qx=noArray(), OutputArray Qy=noArray(), OutputArray Qz=noArray())
RTTIImpl	core/operations.hpp	/^template<typename _ClsName> struct CV_EXPORTS RTTIImpl$/;"	s	namespace:cv
RTreeClassifier	features2d/features2d.hpp	/^  RTreeClassifier();$/;"	p	class:cv::RTreeClassifier	access:public	signature:()
RTreeClassifier	features2d/features2d.hpp	/^class CV_EXPORTS RTreeClassifier$/;"	c	namespace:cv
RTreeNode	features2d/features2d.hpp	/^  RTreeNode() {}$/;"	f	struct:cv::RTreeNode	access:public	signature:()
RTreeNode	features2d/features2d.hpp	/^  RTreeNode(uchar x1, uchar y1, uchar x2, uchar y2)$/;"	f	struct:cv::RTreeNode	access:public	signature:(uchar x1, uchar y1, uchar x2, uchar y2)
RTreeNode	features2d/features2d.hpp	/^struct CV_EXPORTS RTreeNode$/;"	s	namespace:cv
RadiusResultSet	flann/result_set.h	/^    RadiusResultSet(DistanceType radius_, int* indices_, DistanceType* dists_, int capacity_) :$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:(DistanceType radius_, int* indices_, DistanceType* dists_, int capacity_)
RadiusResultSet	flann/result_set.h	/^class RadiusResultSet : public ResultSet<DistanceType>$/;"	c	namespace:cvflann	inherits:ResultSet
RadiusUniqueResultSet	flann/result_set.h	/^    RadiusUniqueResultSet(DistanceType radius) :$/;"	f	class:cvflann::RadiusUniqueResultSet	access:public	signature:(DistanceType radius)
RadiusUniqueResultSet	flann/result_set.h	/^class RadiusUniqueResultSet : public UniqueResultSet<DistanceType>$/;"	c	namespace:cvflann	inherits:UniqueResultSet
RandS	legacy/legacy.hpp	/^    struct CvRandState* RandS; \/* Array of structures to generate random vectors *\/$/;"	m	struct:CvConDensation	typeref:struct:CvConDensation::CvRandState	access:public
RandomSample	legacy/legacy.hpp	/^    float* RandomSample;    \/* RandomVector to update sample set     *\/$/;"	m	struct:CvConDensation	access:public
RandomTreeParams	ml/ml.hpp	/^typedef CvRTParams RandomTreeParams;$/;"	t	namespace:cv
RandomTrees	ml/ml.hpp	/^typedef CvRTrees RandomTrees;$/;"	t	namespace:cv
RandomizedTree	features2d/features2d.hpp	/^  RandomizedTree();$/;"	p	class:cv::RandomizedTree	access:public	signature:()
RandomizedTree	features2d/features2d.hpp	/^class CV_EXPORTS RandomizedTree$/;"	c	namespace:cv
Range	core/core.hpp	/^    Range();$/;"	p	class:cv::Range	access:public	signature:()
Range	core/core.hpp	/^    Range(const CvSlice& slice);$/;"	p	class:cv::Range	access:public	signature:(const CvSlice& slice)
Range	core/core.hpp	/^    Range(int _start, int _end);$/;"	p	class:cv::Range	access:public	signature:(int _start, int _end)
Range	core/core.hpp	/^class CV_EXPORTS Range$/;"	c	namespace:cv
Range	core/operations.hpp	/^inline Range::Range() : start(0), end(0) {}$/;"	f	class:cv::Range	signature:()
Range	core/operations.hpp	/^inline Range::Range(const CvSlice& slice) : start(slice.start_index), end(slice.end_index)$/;"	f	class:cv::Range	signature:(const CvSlice& slice)
Range	core/operations.hpp	/^inline Range::Range(int _start, int _end) : start(_start), end(_end) {}$/;"	f	class:cv::Range	signature:(int _start, int _end)
Read	features2d/features2d.hpp	/^    void Read (const FileNode &fn);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(const FileNode &fn)
ReadByName	features2d/features2d.hpp	/^    int ReadByName(CvFileStorage* fs, CvFileNode* parent, const char* name);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(CvFileStorage* fs, CvFileNode* parent, const char* name)
ReadByName	features2d/features2d.hpp	/^    int ReadByName(const FileNode &parent, const char* name);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(const FileNode &parent, const char* name)
Rect	core/core.hpp	/^typedef Rect_<int> Rect;$/;"	t	namespace:cv
Rect_	core/core.hpp	/^    Rect_();$/;"	p	class:cv::Rect_	access:public	signature:()
Rect_	core/core.hpp	/^    Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height);$/;"	p	class:cv::Rect_	access:public	signature:(_Tp _x, _Tp _y, _Tp _width, _Tp _height)
Rect_	core/core.hpp	/^    Rect_(const CvRect& r);$/;"	p	class:cv::Rect_	access:public	signature:(const CvRect& r)
Rect_	core/core.hpp	/^    Rect_(const Point_<_Tp>& org, const Size_<_Tp>& sz);$/;"	p	class:cv::Rect_	access:public	signature:(const Point_<_Tp>& org, const Size_<_Tp>& sz)
Rect_	core/core.hpp	/^    Rect_(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2);$/;"	p	class:cv::Rect_	access:public	signature:(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2)
Rect_	core/core.hpp	/^    Rect_(const Rect_& r);$/;"	p	class:cv::Rect_	access:public	signature:(const Rect_& r)
Rect_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Rect_$/;"	c	namespace:cv
Rect_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Rect_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
Rect_	core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_() : x(0), y(0), width(0), height(0) {}$/;"	f	class:cv::Rect_	signature:()
Rect_	core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height) : x(_x), y(_y), width(_width), height(_height) {}$/;"	f	class:cv::Rect_	signature:(_Tp _x, _Tp _y, _Tp _width, _Tp _height)
Rect_	core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_(const CvRect& r) : x((_Tp)r.x), y((_Tp)r.y), width((_Tp)r.width), height((_Tp)r.height) {}$/;"	f	class:cv::Rect_	signature:(const CvRect& r)
Rect_	core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_(const Point_<_Tp>& org, const Size_<_Tp>& sz) :$/;"	f	class:cv::Rect_	signature:(const Point_<_Tp>& org, const Size_<_Tp>& sz)
Rect_	core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2)$/;"	f	class:cv::Rect_	signature:(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2)
Rect_	core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_(const Rect_<_Tp>& r) : x(r.x), y(r.y), width(r.width), height(r.height) {}$/;"	f	class:cv::Rect_	signature:(const Rect_<_Tp>& r)
Rectify	legacy/legacy.hpp	/^    virtual bool Rectify( CvMat** srcarr, CvMat** dstarr );$/;"	p	class:CvCalibFilter	access:public	signature:( CvMat** srcarr, CvMat** dstarr )
Rectify	legacy/legacy.hpp	/^    virtual bool Rectify( IplImage** srcarr, IplImage** dstarr );$/;"	p	class:CvCalibFilter	access:public	signature:( IplImage** srcarr, IplImage** dstarr )
Release	legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackAnalysis	access:public	signature:()
Release	legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackAnalysisOne	access:public	signature:()
Release	legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackFVGen	access:public	signature:()
Release	legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackGen	access:public	signature:()
Release	legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackPostProc	access:public	signature:()
Release	legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackPostProcOne	access:public	signature:()
Release	legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackPredictor	access:public	signature:()
Release	legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTracker	access:public	signature:()
Release	legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvBlobTrackerAuto	access:public	signature:()
Release	legacy/blobtrack.hpp	/^    virtual void    Release() = 0;$/;"	p	class:CvFGDetector	access:public	signature:()
Release	legacy/blobtrack.hpp	/^    virtual void Release() =  0;$/;"	p	class:CvBlobTrackerOne	access:public	signature:()
Release	legacy/blobtrack.hpp	/^    virtual void Release() = 0;$/;"	p	class:CvProb	access:public	signature:()
Release	legacy/blobtrack.hpp	/^    virtual void Release() = 0;$/;"	p	class:CvVSModule	access:public	signature:()
Release	legacy/blobtrack.hpp	/^    virtual void Release()=0;$/;"	p	class:CvBlobDetector	access:public	signature:()
ReleaseImage	core/wimage.hpp	/^    void ReleaseImage() {$/;"	f	class:cv::WImageBuffer	access:public	signature:()
ReleaseImage	core/wimage.hpp	/^    void ReleaseImage() {$/;"	f	class:cv::WImageBufferC	access:public	signature:()
ResizeMethod	contrib/contrib.hpp	/^    enum ResizeMethod {$/;"	g	class:CvFuzzyMeanShiftTracker	access:public
ResultSet	flann/result_set.h	/^class ResultSet$/;"	c	namespace:cvflann
ResultType	features2d/features2d.hpp	/^    typedef int ResultType;$/;"	t	struct:cv::Hamming	access:public
ResultType	features2d/features2d.hpp	/^    typedef int ResultType;$/;"	t	struct:cv::HammingLUT	access:public
ResultType	features2d/features2d.hpp	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cv::L1	access:public
ResultType	features2d/features2d.hpp	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cv::L2	access:public
ResultType	features2d/features2d.hpp	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cv::SL2	access:public
ResultType	flann/dist.h	/^    typedef int ResultType;$/;"	t	struct:cvflann::Hamming	access:public
ResultType	flann/dist.h	/^    typedef int ResultType;$/;"	t	struct:cvflann::Hamming2	access:public
ResultType	flann/dist.h	/^    typedef int ResultType;$/;"	t	struct:cvflann::HammingLUT	access:public
ResultType	flann/dist.h	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cvflann::ChiSquareDistance	access:public
ResultType	flann/dist.h	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cvflann::HellingerDistance	access:public
ResultType	flann/dist.h	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cvflann::HistIntersectionDistance	access:public
ResultType	flann/dist.h	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cvflann::KL_Divergence	access:public
ResultType	flann/dist.h	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cvflann::L1	access:public
ResultType	flann/dist.h	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cvflann::L2	access:public
ResultType	flann/dist.h	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cvflann::L2_Simple	access:public
ResultType	flann/dist.h	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cvflann::MaxDistance	access:public
ResultType	flann/dist.h	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cvflann::MinkowskiDistance	access:public
Retina	contrib/retina.hpp	/^        Retina(const std::string parametersSaveFile, Size inputSize);$/;"	p	class:cv::Retina	access:public	signature:(const std::string parametersSaveFile, Size inputSize)
Retina	contrib/retina.hpp	/^        Retina(const std::string parametersSaveFile, Size inputSize, const bool colorMode, RETINA_COLORSAMPLINGMETHOD colorSamplingMethod=RETINA_COLOR_BAYER, const bool useRetinaLogSampling=false, const double reductionFactor=1.0, const double samplingStrenght=10.0);$/;"	p	class:cv::Retina	access:public	signature:(const std::string parametersSaveFile, Size inputSize, const bool colorMode, RETINA_COLORSAMPLINGMETHOD colorSamplingMethod=RETINA_COLOR_BAYER, const bool useRetinaLogSampling=false, const double reductionFactor=1.0, const double samplingStrenght=10.0)
Retina	contrib/retina.hpp	/^    class CV_EXPORTS Retina {$/;"	c	namespace:cv
RightEyeRect	legacy/legacy.hpp	/^    CvRect RightEyeRect;$/;"	m	struct:CvFace	access:public
Rodrigues	calib3d/calib3d.hpp	/^CV_EXPORTS_W void Rodrigues(InputArray src, OutputArray dst, OutputArray jacobian=noArray());$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, OutputArray jacobian=noArray())
RotatedRect	core/core.hpp	/^    RotatedRect();$/;"	p	class:cv::RotatedRect	access:public	signature:()
RotatedRect	core/core.hpp	/^    RotatedRect(const CvBox2D& box);$/;"	p	class:cv::RotatedRect	access:public	signature:(const CvBox2D& box)
RotatedRect	core/core.hpp	/^    RotatedRect(const Point2f& _center, const Size2f& _size, float _angle);$/;"	p	class:cv::RotatedRect	access:public	signature:(const Point2f& _center, const Size2f& _size, float _angle)
RotatedRect	core/core.hpp	/^class CV_EXPORTS RotatedRect$/;"	c	namespace:cv
RotatedRect	core/operations.hpp	/^inline RotatedRect::RotatedRect() { angle = 0; }$/;"	f	class:cv::RotatedRect	signature:()
RotatedRect	core/operations.hpp	/^inline RotatedRect::RotatedRect(const CvBox2D& box)$/;"	f	class:cv::RotatedRect	signature:(const CvBox2D& box)
RotatedRect	core/operations.hpp	/^inline RotatedRect::RotatedRect(const Point2f& _center, const Size2f& _size, float _angle)$/;"	f	class:cv::RotatedRect	signature:(const Point2f& _center, const Size2f& _size, float _angle)
Row	core/wimage.hpp	/^    inline T* Row(int r) {$/;"	f	class:cv::WImage	access:public	signature:(int r)
Row	core/wimage.hpp	/^    inline const T* Row(int r) const {$/;"	f	class:cv::WImage	access:public	signature:(int r) const
S	contrib/contrib.hpp	/^        CvMat* S; \/\/big matrix of block Sjk  , each block has size num_cam_params x num_cam_params $/;"	m	class:cv::LevMarqSparse	access:public
SADWindowSize	calib3d/calib3d.hpp	/^    CV_PROP_RW int SADWindowSize;$/;"	m	class:cv::StereoSGBM	access:public
SADWindowSize	calib3d/calib3d.hpp	/^    int SADWindowSize; \/\/ ~5x5..21x21$/;"	m	struct:CvStereoBMState	access:public
SAMPLE_MEAN	flann/kdtree_index.h	/^        SAMPLE_MEAN = 100,$/;"	e	enum:cvflann::KDTreeIndex::__anon206
SAVED	flann/defines.h	/^    SAVED = 254,$/;"	e	enum:cvflann::flann_algorithm_t
SCALE_IMAGE	objdetect/objdetect.hpp	/^    enum { DO_CANNY_PRUNING = 1, SCALE_IMAGE = 2,$/;"	e	enum:cv::CascadeClassifier::__anon201
SEQ	core/core.hpp	/^        SEQ=5, \/\/!< sequence$/;"	e	enum:cv::FileNode::__anon149
SF_DIR	gpu/gpu.hpp	/^                SF_DIR,$/;"	e	enum:cv::gpu::SURF_GPU::KeypointLayout
SF_FEATURE_STRIDE	gpu/gpu.hpp	/^                SF_FEATURE_STRIDE$/;"	e	enum:cv::gpu::SURF_GPU::KeypointLayout
SF_HESSIAN	gpu/gpu.hpp	/^                SF_HESSIAN,$/;"	e	enum:cv::gpu::SURF_GPU::KeypointLayout
SF_LAPLACIAN	gpu/gpu.hpp	/^                SF_LAPLACIAN,$/;"	e	enum:cv::gpu::SURF_GPU::KeypointLayout
SF_SIZE	gpu/gpu.hpp	/^                SF_SIZE,$/;"	e	enum:cv::gpu::SURF_GPU::KeypointLayout
SF_X	gpu/gpu.hpp	/^                SF_X = 0,$/;"	e	enum:cv::gpu::SURF_GPU::KeypointLayout
SF_Y	gpu/gpu.hpp	/^                SF_Y,$/;"	e	enum:cv::gpu::SURF_GPU::KeypointLayout
SIFT	features2d/features2d.hpp	/^    SIFT( const CommonParams& _commParams,$/;"	p	class:cv::SIFT	access:public	signature:( const CommonParams& _commParams, const DetectorParams& _detectorParams = DetectorParams(), const DescriptorParams& _descriptorParams = DescriptorParams() )
SIFT	features2d/features2d.hpp	/^    SIFT( double _magnification, bool _isNormalize=true,$/;"	p	class:cv::SIFT	access:public	signature:( double _magnification, bool _isNormalize=true, bool _recalculateAngles = true, int _nOctaves=CommonParams::DEFAULT_NOCTAVES, int _nOctaveLayers=CommonParams::DEFAULT_NOCTAVE_LAYERS, int _firstOctave=CommonParams::DEFAULT_FIRST_OCTAVE, int _angleMode=CommonParams::FIRST_ANGLE )
SIFT	features2d/features2d.hpp	/^    SIFT( double _threshold, double _edgeThreshold,$/;"	p	class:cv::SIFT	access:public	signature:( double _threshold, double _edgeThreshold, int _nOctaves=CommonParams::DEFAULT_NOCTAVES, int _nOctaveLayers=CommonParams::DEFAULT_NOCTAVE_LAYERS, int _firstOctave=CommonParams::DEFAULT_FIRST_OCTAVE, int _angleMode=CommonParams::FIRST_ANGLE )
SIFT	features2d/features2d.hpp	/^    SIFT();$/;"	p	class:cv::SIFT	access:public	signature:()
SIFT	features2d/features2d.hpp	/^class CV_EXPORTS SIFT$/;"	c	namespace:cv
SIGMOID	ml/ml.hpp	/^    enum { LINEAR=0, POLY=1, RBF=2, SIGMOID=3 };$/;"	e	enum:CvSVM::__anon73
SIGMOID_SYM	ml/ml.hpp	/^    enum { IDENTITY = 0, SIGMOID_SYM = 1, GAUSSIAN = 2 };$/;"	e	enum:CvANN_MLP::__anon83
SL2	features2d/features2d.hpp	/^struct CV_EXPORTS SL2$/;"	s	namespace:cv
SMALL_POLICY	flann/any.h	/^SMALL_POLICY(bool);$/;"	p	namespace:cdiggins::anyimpl	signature:(bool)
SMALL_POLICY	flann/any.h	/^SMALL_POLICY(float);$/;"	p	namespace:cdiggins::anyimpl	signature:(float)
SMALL_POLICY	flann/any.h	/^SMALL_POLICY(signed char);$/;"	p	namespace:cdiggins::anyimpl	signature:(signed char)
SMALL_POLICY	flann/any.h	/^SMALL_POLICY(signed int);$/;"	p	namespace:cdiggins::anyimpl	signature:(signed int)
SMALL_POLICY	flann/any.h	/^SMALL_POLICY(signed long);$/;"	p	namespace:cdiggins::anyimpl	signature:(signed long)
SMALL_POLICY	flann/any.h	/^SMALL_POLICY(signed short);$/;"	p	namespace:cdiggins::anyimpl	signature:(signed short)
SMALL_POLICY	flann/any.h	/^SMALL_POLICY(unsigned char);$/;"	p	namespace:cdiggins::anyimpl	signature:(unsigned char)
SMALL_POLICY	flann/any.h	/^SMALL_POLICY(unsigned int);$/;"	p	namespace:cdiggins::anyimpl	signature:(unsigned int)
SMALL_POLICY	flann/any.h	/^SMALL_POLICY(unsigned long);$/;"	p	namespace:cdiggins::anyimpl	signature:(unsigned long)
SMALL_POLICY	flann/any.h	/^SMALL_POLICY(unsigned short);$/;"	p	namespace:cdiggins::anyimpl	signature:(unsigned short)
SMALL_POLICY	flann/any.h	114;"	d
SMALL_POLICY	flann/any.h	130;"	d
SORT_ASCENDING	core/core.hpp	/^	SORT_ASCENDING=0,$/;"	e	enum:cv::__anon140
SORT_DESCENDING	core/core.hpp	/^	SORT_DESCENDING=16$/;"	e	enum:cv::__anon140
SORT_EVERY_COLUMN	core/core.hpp	/^	SORT_EVERY_COLUMN=1,$/;"	e	enum:cv::__anon140
SORT_EVERY_ROW	core/core.hpp	/^	SORT_EVERY_ROW=0,$/;"	e	enum:cv::__anon140
SQERR	ml/ml.hpp	/^    enum { DEFAULT=0, GINI=1, MISCLASS=3, SQERR=4 };$/;"	e	enum:CvBoost::__anon80
SQUARED_LOSS	ml/ml.hpp	/^    enum {SQUARED_LOSS=0, ABSOLUTE_LOSS, HUBER_LOSS=3, DEVIANCE_LOSS};$/;"	e	enum:CvGBTrees::__anon81
SSD	contrib/contrib.hpp	/^        virtual void SSD(const Mat& img, Point pt, Mat& ssd) const;$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(const Mat& img, Point pt, Mat& ssd) const
STARTED	calib3d/calib3d.hpp	/^    enum { DONE=0, STARTED=1, CALC_J=2, CHECK_ERR=3 };$/;"	e	enum:CvLevMarq::__anon86
START_AUTO_STEP	ml/ml.hpp	/^    enum { START_E_STEP=1, START_M_STEP=2, START_AUTO_STEP=0 };$/;"	e	enum:CvEM::__anon76
START_E_STEP	ml/ml.hpp	/^    enum { START_E_STEP=1, START_M_STEP=2, START_AUTO_STEP=0 };$/;"	e	enum:CvEM::__anon76
START_M_STEP	ml/ml.hpp	/^    enum { START_E_STEP=1, START_M_STEP=2, START_AUTO_STEP=0 };$/;"	e	enum:CvEM::__anon76
STD_VECTOR	core/core.hpp	/^        MATX=2<<KIND_SHIFT, STD_VECTOR=3<<KIND_SHIFT,$/;"	e	enum:cv::_InputArray::__anon134
STD_VECTOR_MAT	core/core.hpp	/^        STD_VECTOR_MAT=5<<KIND_SHIFT, EXPR=6<<KIND_SHIFT };$/;"	e	enum:cv::_InputArray::__anon134
STD_VECTOR_VECTOR	core/core.hpp	/^        STD_VECTOR_VECTOR=4<<KIND_SHIFT,$/;"	e	enum:cv::_InputArray::__anon134
STR	core/core.hpp	/^        STR=3, \/\/!< text string in UTF-8 encoding$/;"	e	enum:cv::FileNode::__anon149
STRING	core/core.hpp	/^        STRING=STR, \/\/!< synonym for STR$/;"	e	enum:cv::FileNode::__anon149
SUBMATRIX_FLAG	core/core.hpp	/^    enum { MAGIC_VAL=0x42FF0000, AUTO_STEP=0, CONTINUOUS_FLAG=CV_MAT_CONT_FLAG, SUBMATRIX_FLAG=CV_SUBMAT_FLAG };$/;"	e	enum:cv::Mat::__anon137
SURF	features2d/features2d.hpp	/^    CV_WRAP SURF();$/;"	p	class:cv::SURF	access:public	signature:()
SURF	features2d/features2d.hpp	/^    CV_WRAP SURF(double _hessianThreshold, int _nOctaves=4,$/;"	p	class:cv::SURF	access:public	signature:(double _hessianThreshold, int _nOctaves=4, int _nOctaveLayers=2, bool _extended=false, bool _upright=false)
SURF	features2d/features2d.hpp	/^class CV_EXPORTS_W SURF : public CvSURFParams$/;"	c	namespace:cv	inherits:CvSURFParams
SURF_GPU	gpu/gpu.hpp	/^            SURF_GPU();$/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:()
SURF_GPU	gpu/gpu.hpp	/^            explicit SURF_GPU(double _hessianThreshold, int _nOctaves=4,$/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:(double _hessianThreshold, int _nOctaves=4, int _nOctaveLayers=2, bool _extended=false, float _keypointsRatio=0.01f, bool _upright = false)
SURF_GPU	gpu/gpu.hpp	/^        class CV_EXPORTS SURF_GPU : public CvSURFParams$/;"	c	namespace:cv::gpu	inherits:CvSURFParams
SVBackSubst	core/core.hpp	/^CV_EXPORTS_W void SVBackSubst( InputArray w, InputArray u, InputArray vt,$/;"	p	namespace:cv	signature:( InputArray w, InputArray u, InputArray vt, InputArray rhs, CV_OUT OutputArray dst )
SVD	core/core.hpp	/^    SVD( InputArray src, int flags=0 );$/;"	p	class:cv::SVD	access:public	signature:( InputArray src, int flags=0 )
SVD	core/core.hpp	/^    SVD();$/;"	p	class:cv::SVD	access:public	signature:()
SVD	core/core.hpp	/^class CV_EXPORTS SVD$/;"	c	namespace:cv
SVD	core/mat.hpp	/^inline SVD::SVD( InputArray m, int flags ) { operator ()(m, flags); }$/;"	f	class:cv::SVD	signature:( InputArray m, int flags )
SVD	core/mat.hpp	/^inline SVD::SVD() {}$/;"	f	class:cv::SVD	signature:()
SVDecomp	core/core.hpp	/^CV_EXPORTS_W void SVDecomp( InputArray src, CV_OUT OutputArray w,$/;"	p	namespace:cv	signature:( InputArray src, CV_OUT OutputArray w, CV_OUT OutputArray u, CV_OUT OutputArray vt, int flags=0 )
SVM	ml/ml.hpp	/^typedef CvSVM SVM;$/;"	t	namespace:cv
SVMKernel	ml/ml.hpp	/^typedef CvSVMKernel SVMKernel;$/;"	t	namespace:cv
SVMParams	ml/ml.hpp	/^typedef CvSVMParams SVMParams;$/;"	t	namespace:cv
SVMSolver	ml/ml.hpp	/^typedef CvSVMSolver SVMSolver;$/;"	t	namespace:cv
SVM_C	ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon71
SVM_COEF	ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon71
SVM_DEGREE	ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon71
SVM_GAMMA	ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon71
SVM_NU	ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon71
SVM_P	ml/ml.hpp	/^    enum { SVM_C=0, SVM_GAMMA=1, SVM_P=2, SVM_NU=3, SVM_COEF=4, SVM_DEGREE=5 };$/;"	e	enum:CvParamGrid::__anon71
SamplesNum	legacy/legacy.hpp	/^    int SamplesNum;         \/* Number of the Samples                 *\/$/;"	m	struct:CvConDensation	access:public
Save	features2d/features2d.hpp	/^    void Save(const char* path);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(const char* path)
SaveCameraParams	legacy/legacy.hpp	/^    virtual bool SaveCameraParams( const char* filename );$/;"	p	class:CvCalibFilter	access:public	signature:( const char* filename )
SavePCADescriptors	features2d/features2d.hpp	/^    void SavePCADescriptors(CvFileStorage* fs) const;$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(CvFileStorage* fs) const
SavePCADescriptors	features2d/features2d.hpp	/^    void SavePCADescriptors(const char* filename);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(const char* filename)
SavePCAall	features2d/features2d.hpp	/^    void SavePCAall (FileStorage &fs) const;$/;"	p	class:cv::OneWayDescriptorBase	access:protected	signature:(FileStorage &fs) const
SaveState	legacy/blobtrack.hpp	/^    virtual void SaveState(CvFileStorage*);$/;"	p	class:CvVSModule	access:public	signature:(CvFileStorage*)
SavedIndexParams	flann/flann_base.hpp	/^    SavedIndexParams(std::string filename)$/;"	f	struct:cvflann::SavedIndexParams	access:public	signature:(std::string filename)
SavedIndexParams	flann/flann_base.hpp	/^struct SavedIndexParams : public IndexParams$/;"	s	namespace:cvflann	inherits:IndexParams
SavedIndexParams	flann/miniflann.hpp	/^    SavedIndexParams(const std::string& filename);$/;"	p	struct:cv::flann::SavedIndexParams	access:public	signature:(const std::string& filename)
SavedIndexParams	flann/miniflann.hpp	/^struct CV_EXPORTS SavedIndexParams : public IndexParams$/;"	s	namespace:cv::flann	inherits:IndexParams
Scalar	core/core.hpp	/^typedef Scalar_<double> Scalar;$/;"	t	namespace:cv
Scalar_	core/core.hpp	/^    Scalar_();$/;"	p	class:cv::Scalar_	access:public	signature:()
Scalar_	core/core.hpp	/^    Scalar_(_Tp v0);$/;"	p	class:cv::Scalar_	access:public	signature:(_Tp v0)
Scalar_	core/core.hpp	/^    Scalar_(_Tp v0, _Tp v1, _Tp v2=0, _Tp v3=0);$/;"	p	class:cv::Scalar_	access:public	signature:(_Tp v0, _Tp v1, _Tp v2=0, _Tp v3=0)
Scalar_	core/core.hpp	/^    Scalar_(const CvScalar& s);$/;"	p	class:cv::Scalar_	access:public	signature:(const CvScalar& s)
Scalar_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Scalar_ : public Vec<_Tp, 4>$/;"	c	namespace:cv	inherits:Vec
Scalar_	core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp>::Scalar_()$/;"	f	class:cv::Scalar_	signature:()
Scalar_	core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp>::Scalar_(_Tp v0)$/;"	f	class:cv::Scalar_	signature:(_Tp v0)
Scalar_	core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp>::Scalar_(_Tp v0, _Tp v1, _Tp v2, _Tp v3)$/;"	f	class:cv::Scalar_	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
Scalar_	core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp>::Scalar_(const CvScalar& s)$/;"	f	class:cv::Scalar_	signature:(const CvScalar& s)
Scale	legacy/blobtrack.hpp	/^    virtual void Scale(float factor = 0, int x = -1, int y = -1) = 0;$/;"	p	class:CvProb	access:public	signature:(float factor = 0, int x = -1, int y = -1)
ScaleAfter	legacy/blobtrack.hpp	/^    int     ScaleAfter;$/;"	m	struct:CvBlobTrackerParamLH	access:public
Scharr	gpu/gpu.hpp	/^        CV_EXPORTS void Scharr(const GpuMat& src, GpuMat& dst, int ddepth, int dx, int dy, double scale = 1,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, int dx, int dy, double scale = 1, int rowBorderType = BORDER_DEFAULT, int columnBorderType = -1, Stream& stream = Stream::Null())
Scharr	imgproc/imgproc.hpp	/^CV_EXPORTS_W void Scharr( InputArray src, OutputArray dst, int ddepth,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale=1, double delta=0, int borderType=BORDER_DEFAULT )
ScoreIndexPair	flann/lsh_index.h	/^    typedef std::pair<float, unsigned int> ScoreIndexPair;$/;"	t	class:cvflann::LshIndex	access:private
SearchParams	flann/miniflann.hpp	/^    SearchParams( int checks = 32, float eps = 0, bool sorted = true );$/;"	p	struct:cv::flann::SearchParams	access:public	signature:( int checks = 32, float eps = 0, bool sorted = true )
SearchParams	flann/miniflann.hpp	/^struct CV_EXPORTS SearchParams : public IndexParams$/;"	s	namespace:cv::flann	inherits:IndexParams
SearchParams	flann/params.h	/^    SearchParams(int checks = 32, float eps = 0, bool sorted = true )$/;"	f	struct:cvflann::SearchParams	access:public	signature:(int checks = 32, float eps = 0, bool sorted = true )
SearchParams	flann/params.h	/^struct SearchParams : public IndexParams$/;"	s	namespace:cvflann	inherits:IndexParams
SearchWindow	contrib/contrib.hpp	/^        SearchWindow();$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:()
SearchWindow	contrib/contrib.hpp	/^    class SearchWindow$/;"	c	class:CvFuzzyMeanShiftTracker	access:private
SelectWorkingSet	ml/ml.hpp	/^    typedef bool (CvSVMSolver::*SelectWorkingSet)( int& i, int& j );$/;"	t	class:CvSVMSolver	access:public
SelfSimDescriptor	contrib/contrib.hpp	/^        SelfSimDescriptor();$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:()
SelfSimDescriptor	contrib/contrib.hpp	/^        SelfSimDescriptor(const SelfSimDescriptor& ss);$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(const SelfSimDescriptor& ss)
SelfSimDescriptor	contrib/contrib.hpp	/^        SelfSimDescriptor(int _ssize, int _lsize,$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(int _ssize, int _lsize, int _startDistanceBucket=DEFAULT_START_DISTANCE_BUCKET, int _numberOfDistanceBuckets=DEFAULT_NUM_DISTANCE_BUCKETS, int _nangles=DEFAULT_NUM_ANGLES)
SelfSimDescriptor	contrib/contrib.hpp	/^    class CV_EXPORTS SelfSimDescriptor$/;"	c	namespace:cv
Seq	core/core.hpp	/^    Seq();$/;"	p	class:cv::Seq	access:public	signature:()
Seq	core/core.hpp	/^    Seq(MemStorage& storage, int headerSize = sizeof(CvSeq));$/;"	p	class:cv::Seq	access:public	signature:(MemStorage& storage, int headerSize = sizeof(CvSeq))
Seq	core/core.hpp	/^    Seq(const CvSeq* seq);$/;"	p	class:cv::Seq	access:public	signature:(const CvSeq* seq)
Seq	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Seq$/;"	c	namespace:cv
Seq	core/operations.hpp	/^template<typename _Tp> inline Seq<_Tp>::Seq( MemStorage& storage,$/;"	f	class:cv::Seq	signature:( MemStorage& storage, int headerSize )
Seq	core/operations.hpp	/^template<typename _Tp> inline Seq<_Tp>::Seq( const CvSeq* _seq ) : seq((CvSeq*)_seq)$/;"	f	class:cv::Seq	signature:( const CvSeq* _seq )
Seq	core/operations.hpp	/^template<typename _Tp> inline Seq<_Tp>::Seq() : seq(0) {}$/;"	f	class:cv::Seq	signature:()
SeqIterator	core/core.hpp	/^    SeqIterator();$/;"	p	class:cv::SeqIterator	access:public	signature:()
SeqIterator	core/core.hpp	/^    SeqIterator(const Seq<_Tp>& seq, bool seekEnd=false);$/;"	p	class:cv::SeqIterator	access:public	signature:(const Seq<_Tp>& seq, bool seekEnd=false)
SeqIterator	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS SeqIterator : public CvSeqReader$/;"	c	namespace:cv	inherits:CvSeqReader
SeqIterator	core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>::SeqIterator()$/;"	f	class:cv::SeqIterator	signature:()
SeqIterator	core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>::SeqIterator(const Seq<_Tp>& seq, bool seekEnd)$/;"	f	class:cv::SeqIterator	signature:(const Seq<_Tp>& seq, bool seekEnd)
SetBlob	legacy/blobtrack.hpp	/^    virtual void    SetBlob(int \/*BlobIndex*\/, CvBlob* \/*pBlob*\/);$/;"	p	class:CvBlobTracker	access:public	signature:(int , CvBlob* )
SetBlobByID	legacy/blobtrack.hpp	/^    virtual void    SetBlobByID(int BlobID, CvBlob* pBlob);$/;"	p	class:CvBlobTracker	access:public	signature:(int BlobID, CvBlob* pBlob)
SetBlobHyp	legacy/blobtrack.hpp	/^    virtual void    SetBlobHyp(int \/*BlobIndex*\/, CvBlob* \/*pBlob*\/);$/;"	p	class:CvBlobTracker	access:public	signature:(int , CvBlob* )
SetCameraCount	legacy/legacy.hpp	/^    virtual void SetCameraCount( int cameraCount );$/;"	p	class:CvCalibFilter	access:public	signature:( int cameraCount )
SetCameraParams	legacy/legacy.hpp	/^    virtual bool SetCameraParams( CvCamera* params );$/;"	p	class:CvCalibFilter	access:public	signature:( CvCamera* params )
SetCollision	legacy/blobtrack.hpp	/^    virtual void SetCollision(int \/*CollisionFlag*\/){}; \/* call in case of blob collision situation*\/$/;"	f	class:CvBlobTrackerOne	access:public	signature:(int )
SetEtalon	legacy/legacy.hpp	/^        SetEtalon( CvCalibEtalonType etalonType, double* etalonParams,$/;"	p	class:CvCalibFilter	access:public	signature:( CvCalibEtalonType etalonType, double* etalonParams, int pointCount = 0, CvPoint2D32f* points = 0 )
SetFileName	legacy/blobtrack.hpp	/^    virtual void    SetFileName(char* \/*DataBaseName*\/){};$/;"	f	class:CvBlobTrackAnalysis	access:public	signature:(char* )
SetFileName	legacy/blobtrack.hpp	/^    virtual void    SetFileName(char* pFileName) = 0;$/;"	p	class:CvBlobTrackGen	access:public	signature:(char* pFileName)
SetFrames	legacy/legacy.hpp	/^    virtual bool SetFrames( int totalFrames );$/;"	p	class:CvCalibFilter	access:public	signature:( int totalFrames )
SetIpl	core/wimage.hpp	/^    void SetIpl(IplImage* image) {$/;"	f	class:cv::WImage	access:protected	signature:(IplImage* image)
SetIpl	core/wimage.hpp	/^    void SetIpl(IplImage* image) {$/;"	f	class:cv::WImageC	access:protected	signature:(IplImage* image)
SetIpl	core/wimage.hpp	/^    void SetIpl(IplImage* img) {$/;"	f	class:cv::WImageBuffer	access:public	signature:(IplImage* img)
SetIpl	core/wimage.hpp	/^    void SetIpl(IplImage* img) {$/;"	f	class:cv::WImageBufferC	access:public	signature:(IplImage* img)
SetLabeledFeatures	features2d/features2d.hpp	/^    void SetLabeledFeatures(const vector<cv::KeyPoint>& features) {m_train_features = features;};$/;"	f	class:cv::OneWayDescriptorObject	access:public	signature:(const vector<cv::KeyPoint>& features)
SetModuleName	legacy/blobtrack.hpp	/^    void SetModuleName(const char* name);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name)
SetNickName	legacy/blobtrack.hpp	/^    void SetNickName(const char* pStr);$/;"	p	class:CvVSModule	access:public	signature:(const char* pStr)
SetPCADimHigh	features2d/features2d.hpp	/^    void SetPCADimHigh(int pca_dim_high) {m_pca_dim_high = pca_dim_high;};$/;"	f	class:cv::OneWayDescriptor	access:public	signature:(int pca_dim_high)
SetPCADimLow	features2d/features2d.hpp	/^    void SetPCADimLow(int pca_dim_low) {m_pca_dim_low = pca_dim_low;};$/;"	f	class:cv::OneWayDescriptor	access:public	signature:(int pca_dim_low)
SetPCAHigh	features2d/features2d.hpp	/^    void SetPCAHigh(CvMat* avg, CvMat* eigenvectors);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(CvMat* avg, CvMat* eigenvectors)
SetPCALow	features2d/features2d.hpp	/^    void SetPCALow(CvMat* avg, CvMat* eigenvectors);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(CvMat* avg, CvMat* eigenvectors)
SetParam	legacy/blobtrack.hpp	/^    void   SetParam(const char* name, double val);$/;"	p	class:CvVSModule	access:public	signature:(const char* name, double val)
SetParamStr	legacy/blobtrack.hpp	/^    void   SetParamStr(const char* name, const char* str);$/;"	p	class:CvVSModule	access:public	signature:(const char* name, const char* str)
SetShapes	legacy/blobtrack.hpp	/^    void SetShapes( const CvDrawShape* shapes, int num );$/;"	p	class:CvImageDrawer	access:public	signature:( const CvDrawShape* shapes, int num )
SetTransforms	features2d/features2d.hpp	/^    void SetTransforms(CvAffinePose* poses, CvMat** transforms);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(CvAffinePose* poses, CvMat** transforms)
SetTypeName	legacy/blobtrack.hpp	/^    void SetTypeName(const char* name);$/;"	p	class:CvVSModule	access:protected	signature:(const char* name)
SetZero	core/wimage.hpp	/^    void SetZero() { cvSetZero(image_); }$/;"	f	class:cv::WImage	access:public	signature:()
SiftDescriptorExtractor	features2d/features2d.hpp	/^    SiftDescriptorExtractor( const SIFT::DescriptorParams& descriptorParams=SIFT::DescriptorParams(),$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:( const SIFT::DescriptorParams& descriptorParams=SIFT::DescriptorParams(), const SIFT::CommonParams& commonParams=SIFT::CommonParams() )
SiftDescriptorExtractor	features2d/features2d.hpp	/^    SiftDescriptorExtractor( double magnification, bool isNormalize=true, bool recalculateAngles=true,$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:( double magnification, bool isNormalize=true, bool recalculateAngles=true, int nOctaves=SIFT::CommonParams::DEFAULT_NOCTAVES, int nOctaveLayers=SIFT::CommonParams::DEFAULT_NOCTAVE_LAYERS, int firstOctave=SIFT::CommonParams::DEFAULT_FIRST_OCTAVE, int angleMode=SIFT::CommonParams::FIRST_ANGLE )
SiftDescriptorExtractor	features2d/features2d.hpp	/^class CV_EXPORTS SiftDescriptorExtractor : public DescriptorExtractor$/;"	c	namespace:cv	inherits:DescriptorExtractor
SiftFeatureDetector	features2d/features2d.hpp	/^    SiftFeatureDetector( const SIFT::DetectorParams& detectorParams=SIFT::DetectorParams(),$/;"	p	class:cv::SiftFeatureDetector	access:public	signature:( const SIFT::DetectorParams& detectorParams=SIFT::DetectorParams(), const SIFT::CommonParams& commonParams=SIFT::CommonParams() )
SiftFeatureDetector	features2d/features2d.hpp	/^    SiftFeatureDetector( double threshold, double edgeThreshold,$/;"	p	class:cv::SiftFeatureDetector	access:public	signature:( double threshold, double edgeThreshold, int nOctaves=SIFT::CommonParams::DEFAULT_NOCTAVES, int nOctaveLayers=SIFT::CommonParams::DEFAULT_NOCTAVE_LAYERS, int firstOctave=SIFT::CommonParams::DEFAULT_FIRST_OCTAVE, int angleMode=SIFT::CommonParams::FIRST_ANGLE )
SiftFeatureDetector	features2d/features2d.hpp	/^class CV_EXPORTS SiftFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
SimpleBlobDetector	features2d/features2d.hpp	/^  SimpleBlobDetector(const SimpleBlobDetector::Params &parameters = SimpleBlobDetector::Params());$/;"	p	class:cv::SimpleBlobDetector	access:public	signature:(const SimpleBlobDetector::Params &parameters = SimpleBlobDetector::Params())
SimpleBlobDetector	features2d/features2d.hpp	/^class CV_EXPORTS SimpleBlobDetector : public cv::FeatureDetector$/;"	c	namespace:cv	inherits:cv::FeatureDetector
Size	core/core.hpp	/^typedef Size2i Size;$/;"	t	namespace:cv
Size2f	core/core.hpp	/^typedef Size_<float> Size2f;$/;"	t	namespace:cv
Size2i	core/core.hpp	/^typedef Size_<int> Size2i;$/;"	t	namespace:cv
Size_	core/core.hpp	/^    Size_();$/;"	p	class:cv::Size_	access:public	signature:()
Size_	core/core.hpp	/^    Size_(_Tp _width, _Tp _height);$/;"	p	class:cv::Size_	access:public	signature:(_Tp _width, _Tp _height)
Size_	core/core.hpp	/^    Size_(const CvSize& sz);$/;"	p	class:cv::Size_	access:public	signature:(const CvSize& sz)
Size_	core/core.hpp	/^    Size_(const CvSize2D32f& sz);$/;"	p	class:cv::Size_	access:public	signature:(const CvSize2D32f& sz)
Size_	core/core.hpp	/^    Size_(const Point_<_Tp>& pt);$/;"	p	class:cv::Size_	access:public	signature:(const Point_<_Tp>& pt)
Size_	core/core.hpp	/^    Size_(const Size_& sz);$/;"	p	class:cv::Size_	access:public	signature:(const Size_& sz)
Size_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Size_$/;"	c	namespace:cv
Size_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Size_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
Size_	core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_()$/;"	f	class:cv::Size_	signature:()
Size_	core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_(_Tp _width, _Tp _height)$/;"	f	class:cv::Size_	signature:(_Tp _width, _Tp _height)
Size_	core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_(const CvSize& sz)$/;"	f	class:cv::Size_	signature:(const CvSize& sz)
Size_	core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_(const CvSize2D32f& sz)$/;"	f	class:cv::Size_	signature:(const CvSize2D32f& sz)
Size_	core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_(const Point_<_Tp>& pt) : width(pt.x), height(pt.y) {}$/;"	f	class:cv::Size_	signature:(const Point_<_Tp>& pt)
Size_	core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_(const Size_& sz)$/;"	f	class:cv::Size_	signature:(const Size_& sz)
SkipProcess	legacy/blobtrack.hpp	/^    virtual void SkipProcess(CvBlob* \/*pBlobPrev*\/, IplImage* \/*pImg*\/, IplImage* \/*pImgFG*\/ = NULL){};$/;"	f	class:CvBlobTrackerOne	access:public	signature:(CvBlob* , IplImage* , IplImage* = NULL)
Sobel	gpu/gpu.hpp	/^        CV_EXPORTS void Sobel(const GpuMat& src, GpuMat& dst, int ddepth, int dx, int dy, int ksize = 3, double scale = 1,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, int dx, int dy, int ksize = 3, double scale = 1, int rowBorderType = BORDER_DEFAULT, int columnBorderType = -1, Stream& stream = Stream::Null())
Sobel	imgproc/imgproc.hpp	/^CV_EXPORTS_W void Sobel( InputArray src, OutputArray dst, int ddepth,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize=3, double scale=1, double delta=0, int borderType=BORDER_DEFAULT )
SortScoreIndexPairOnSecond	flann/lsh_index.h	/^    struct SortScoreIndexPairOnSecond$/;"	s	class:cvflann::LshIndex	access:private
SparseMat	core/core.hpp	/^    SparseMat();$/;"	p	class:cv::SparseMat	access:public	signature:()
SparseMat	core/core.hpp	/^    SparseMat(const CvSparseMat* m);$/;"	p	class:cv::SparseMat	access:public	signature:(const CvSparseMat* m)
SparseMat	core/core.hpp	/^    SparseMat(const SparseMat& m);$/;"	p	class:cv::SparseMat	access:public	signature:(const SparseMat& m)
SparseMat	core/core.hpp	/^    SparseMat(int dims, const int* _sizes, int _type);$/;"	p	class:cv::SparseMat	access:public	signature:(int dims, const int* _sizes, int _type)
SparseMat	core/core.hpp	/^    explicit SparseMat(const Mat& m);$/;"	p	class:cv::SparseMat	access:public	signature:(const Mat& m)
SparseMat	core/core.hpp	/^class CV_EXPORTS SparseMat$/;"	c	namespace:cv
SparseMat	core/mat.hpp	/^inline SparseMat::SparseMat()$/;"	f	class:cv::SparseMat	signature:()
SparseMat	core/mat.hpp	/^inline SparseMat::SparseMat(const SparseMat& m)$/;"	f	class:cv::SparseMat	signature:(const SparseMat& m)
SparseMat	core/mat.hpp	/^inline SparseMat::SparseMat(int _dims, const int* _sizes, int _type)$/;"	f	class:cv::SparseMat	signature:(int _dims, const int* _sizes, int _type)
SparseMatConstIterator	core/core.hpp	/^    SparseMatConstIterator();$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:()
SparseMatConstIterator	core/core.hpp	/^    SparseMatConstIterator(const SparseMat* _m);$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:(const SparseMat* _m)
SparseMatConstIterator	core/core.hpp	/^    SparseMatConstIterator(const SparseMatConstIterator& it);$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:(const SparseMatConstIterator& it)
SparseMatConstIterator	core/core.hpp	/^class CV_EXPORTS SparseMatConstIterator$/;"	c	namespace:cv
SparseMatConstIterator	core/mat.hpp	/^inline SparseMatConstIterator::SparseMatConstIterator()$/;"	f	class:cv::SparseMatConstIterator	signature:()
SparseMatConstIterator	core/mat.hpp	/^inline SparseMatConstIterator::SparseMatConstIterator(const SparseMatConstIterator& it)$/;"	f	class:cv::SparseMatConstIterator	signature:(const SparseMatConstIterator& it)
SparseMatConstIterator_	core/core.hpp	/^    SparseMatConstIterator_();$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:()
SparseMatConstIterator_	core/core.hpp	/^    SparseMatConstIterator_(const SparseMatConstIterator_& it);$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:(const SparseMatConstIterator_& it)
SparseMatConstIterator_	core/core.hpp	/^    SparseMatConstIterator_(const SparseMat_<_Tp>* _m);$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:(const SparseMat_<_Tp>* _m)
SparseMatConstIterator_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS SparseMatConstIterator_ : public SparseMatConstIterator$/;"	c	namespace:cv	inherits:SparseMatConstIterator
SparseMatConstIterator_	core/mat.hpp	/^SparseMatConstIterator_<_Tp>::SparseMatConstIterator_()$/;"	f	class:cv::SparseMatConstIterator_	signature:()
SparseMatConstIterator_	core/mat.hpp	/^SparseMatConstIterator_<_Tp>::SparseMatConstIterator_(const SparseMatConstIterator_<_Tp>& it)$/;"	f	class:cv::SparseMatConstIterator_	signature:(const SparseMatConstIterator_<_Tp>& it)
SparseMatConstIterator_	core/mat.hpp	/^SparseMatConstIterator_<_Tp>::SparseMatConstIterator_(const SparseMat_<_Tp>* _m)$/;"	f	class:cv::SparseMatConstIterator_	signature:(const SparseMat_<_Tp>* _m)
SparseMatIterator	core/core.hpp	/^    SparseMatIterator();$/;"	p	class:cv::SparseMatIterator	access:public	signature:()
SparseMatIterator	core/core.hpp	/^    SparseMatIterator(SparseMat* _m);$/;"	p	class:cv::SparseMatIterator	access:public	signature:(SparseMat* _m)
SparseMatIterator	core/core.hpp	/^    SparseMatIterator(SparseMat* _m, const int* idx);$/;"	p	class:cv::SparseMatIterator	access:public	signature:(SparseMat* _m, const int* idx)
SparseMatIterator	core/core.hpp	/^    SparseMatIterator(const SparseMatIterator& it);$/;"	p	class:cv::SparseMatIterator	access:public	signature:(const SparseMatIterator& it)
SparseMatIterator	core/core.hpp	/^class CV_EXPORTS SparseMatIterator : public SparseMatConstIterator$/;"	c	namespace:cv	inherits:SparseMatConstIterator
SparseMatIterator	core/mat.hpp	/^inline SparseMatIterator::SparseMatIterator()$/;"	f	class:cv::SparseMatIterator	signature:()
SparseMatIterator	core/mat.hpp	/^inline SparseMatIterator::SparseMatIterator(SparseMat* _m)$/;"	f	class:cv::SparseMatIterator	signature:(SparseMat* _m)
SparseMatIterator	core/mat.hpp	/^inline SparseMatIterator::SparseMatIterator(const SparseMatIterator& it)$/;"	f	class:cv::SparseMatIterator	signature:(const SparseMatIterator& it)
SparseMatIterator_	core/core.hpp	/^    SparseMatIterator_();$/;"	p	class:cv::SparseMatIterator_	access:public	signature:()
SparseMatIterator_	core/core.hpp	/^    SparseMatIterator_(SparseMat_<_Tp>* _m);$/;"	p	class:cv::SparseMatIterator_	access:public	signature:(SparseMat_<_Tp>* _m)
SparseMatIterator_	core/core.hpp	/^    SparseMatIterator_(const SparseMatIterator_& it);$/;"	p	class:cv::SparseMatIterator_	access:public	signature:(const SparseMatIterator_& it)
SparseMatIterator_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS SparseMatIterator_ : public SparseMatConstIterator_<_Tp>$/;"	c	namespace:cv	inherits:SparseMatConstIterator_
SparseMatIterator_	core/mat.hpp	/^SparseMatIterator_<_Tp>::SparseMatIterator_()$/;"	f	class:cv::SparseMatIterator_	signature:()
SparseMatIterator_	core/mat.hpp	/^SparseMatIterator_<_Tp>::SparseMatIterator_(SparseMat_<_Tp>* _m)$/;"	f	class:cv::SparseMatIterator_	signature:(SparseMat_<_Tp>* _m)
SparseMatIterator_	core/mat.hpp	/^SparseMatIterator_<_Tp>::SparseMatIterator_(const SparseMatIterator_<_Tp>& it)$/;"	f	class:cv::SparseMatIterator_	signature:(const SparseMatIterator_<_Tp>& it)
SparseMat_	core/core.hpp	/^    SparseMat_();$/;"	p	class:cv::SparseMat_	access:public	signature:()
SparseMat_	core/core.hpp	/^    SparseMat_(const CvSparseMat* m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const CvSparseMat* m)
SparseMat_	core/core.hpp	/^    SparseMat_(const Mat& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const Mat& m)
SparseMat_	core/core.hpp	/^    SparseMat_(const SparseMat& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const SparseMat& m)
SparseMat_	core/core.hpp	/^    SparseMat_(const SparseMat_& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const SparseMat_& m)
SparseMat_	core/core.hpp	/^    SparseMat_(int dims, const int* _sizes);$/;"	p	class:cv::SparseMat_	access:public	signature:(int dims, const int* _sizes)
SparseMat_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS SparseMat_ : public SparseMat$/;"	c	namespace:cv	inherits:SparseMat
SparseMat_	core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_()$/;"	f	class:cv::SparseMat_	signature:()
SparseMat_	core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const CvSparseMat* m)$/;"	f	class:cv::SparseMat_	signature:(const CvSparseMat* m)
SparseMat_	core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const Mat& m)$/;"	f	class:cv::SparseMat_	signature:(const Mat& m)
SparseMat_	core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const SparseMat& m)$/;"	f	class:cv::SparseMat_	signature:(const SparseMat& m)
SparseMat_	core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const SparseMat_<_Tp>& m)$/;"	f	class:cv::SparseMat_	signature:(const SparseMat_<_Tp>& m)
SparseMat_	core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(int _dims, const int* _sizes)$/;"	f	class:cv::SparseMat_	signature:(int _dims, const int* _sizes)
SpeedLevel	flann/lsh_table.h	/^    enum SpeedLevel$/;"	g	class:cvflann::lsh::LshTable	access:private
SpinImageModel	contrib/contrib.hpp	/^        SpinImageModel();$/;"	p	class:cv::SpinImageModel	access:public	signature:()
SpinImageModel	contrib/contrib.hpp	/^        explicit SpinImageModel(const Mesh3D& mesh);$/;"	p	class:cv::SpinImageModel	access:public	signature:(const Mesh3D& mesh)
SpinImageModel	contrib/contrib.hpp	/^    class CV_EXPORTS SpinImageModel$/;"	c	namespace:cv
Split	core/internal.hpp	/^        typedef tbb::split Split;$/;"	t	namespace:cv
Stage	objdetect/objdetect.hpp	/^        struct CV_EXPORTS Stage$/;"	s	class:cv::CascadeClassifier::Data	access:public
StarAdjuster	features2d/features2d.hpp	/^    StarAdjuster(double initial_thresh=30.0, double min_thresh=2., double max_thresh=200.);$/;"	p	class:cv::StarAdjuster	access:public	signature:(double initial_thresh=30.0, double min_thresh=2., double max_thresh=200.)
StarAdjuster	features2d/features2d.hpp	/^class CV_EXPORTS StarAdjuster: public AdjusterAdapter$/;"	c	namespace:cv	inherits:AdjusterAdapter
StarDetector	features2d/features2d.hpp	/^    CV_WRAP StarDetector();$/;"	p	class:cv::StarDetector	access:public	signature:()
StarDetector	features2d/features2d.hpp	/^    CV_WRAP StarDetector(int _maxSize, int _responseThreshold,$/;"	p	class:cv::StarDetector	access:public	signature:(int _maxSize, int _responseThreshold, int _lineThresholdProjected, int _lineThresholdBinarized, int _suppressNonmaxSize)
StarDetector	features2d/features2d.hpp	/^class CV_EXPORTS_W StarDetector : public CvStarDetectorParams$/;"	c	namespace:cv	inherits:CvStarDetectorParams
StarFeatureDetector	features2d/features2d.hpp	/^    StarFeatureDetector( const CvStarDetectorParams& params=cvStarDetectorParams() );$/;"	p	class:cv::StarFeatureDetector	access:public	signature:( const CvStarDetectorParams& params=cvStarDetectorParams() )
StarFeatureDetector	features2d/features2d.hpp	/^    StarFeatureDetector( int maxSize, int responseThreshold=30, int lineThresholdProjected = 10,$/;"	p	class:cv::StarFeatureDetector	access:public	signature:( int maxSize, int responseThreshold=30, int lineThresholdProjected = 10, int lineThresholdBinarized=8, int suppressNonmaxSize=5 )
StarFeatureDetector	features2d/features2d.hpp	/^class CV_EXPORTS StarFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
StartFrame	legacy/blobtrack.hpp	/^    int         StartFrame;$/;"	m	struct:CvBlobTrack	access:public
StartStopTimer	flann/timer.h	/^    StartStopTimer()$/;"	f	class:cvflann::StartStopTimer	access:public	signature:()
StartStopTimer	flann/timer.h	/^class StartStopTimer$/;"	c	namespace:cvflann
StatModel	ml/ml.hpp	/^typedef CvStatModel StatModel;$/;"	t	namespace:cv
State	legacy/legacy.hpp	/^    float* State;           \/* Vector of State                       *\/$/;"	m	struct:CvConDensation	access:public
StaticAssert	gpu/devmem2d.hpp	/^        template <> struct StaticAssert<true> {static __CV_GPU_HOST_DEVICE__ void check(){}};        $/;"	s	namespace:cv::gpu
StereoBM	calib3d/calib3d.hpp	/^    CV_WRAP StereoBM();$/;"	p	class:cv::StereoBM	access:public	signature:()
StereoBM	calib3d/calib3d.hpp	/^    CV_WRAP StereoBM(int preset, int ndisparities=0, int SADWindowSize=21);$/;"	p	class:cv::StereoBM	access:public	signature:(int preset, int ndisparities=0, int SADWindowSize=21)
StereoBM	calib3d/calib3d.hpp	/^class CV_EXPORTS_W StereoBM$/;"	c	namespace:cv
StereoBM_GPU	gpu/gpu.hpp	/^            StereoBM_GPU();$/;"	p	class:cv::gpu::StereoBM_GPU	access:public	signature:()
StereoBM_GPU	gpu/gpu.hpp	/^            StereoBM_GPU(int preset, int ndisparities = DEFAULT_NDISP, int winSize = DEFAULT_WINSZ);$/;"	p	class:cv::gpu::StereoBM_GPU	access:public	signature:(int preset, int ndisparities = DEFAULT_NDISP, int winSize = DEFAULT_WINSZ)
StereoBM_GPU	gpu/gpu.hpp	/^        class CV_EXPORTS StereoBM_GPU$/;"	c	namespace:cv::gpu
StereoBeliefPropagation	gpu/gpu.hpp	/^            StereoBeliefPropagation(int ndisp, int iters, int levels,$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(int ndisp, int iters, int levels, float max_data_term, float data_weight, float max_disc_term, float disc_single_jump, int msg_type = CV_32F)
StereoBeliefPropagation	gpu/gpu.hpp	/^            explicit StereoBeliefPropagation(int ndisp  = DEFAULT_NDISP,$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(int ndisp = DEFAULT_NDISP, int iters = DEFAULT_ITERS, int levels = DEFAULT_LEVELS, int msg_type = CV_32F)
StereoBeliefPropagation	gpu/gpu.hpp	/^        class CV_EXPORTS StereoBeliefPropagation$/;"	c	namespace:cv::gpu
StereoConstantSpaceBP	gpu/gpu.hpp	/^            StereoConstantSpaceBP(int ndisp, int iters, int levels, int nr_plane,$/;"	p	class:cv::gpu::StereoConstantSpaceBP	access:public	signature:(int ndisp, int iters, int levels, int nr_plane, float max_data_term, float data_weight, float max_disc_term, float disc_single_jump, int min_disp_th = 0, int msg_type = CV_32F)
StereoConstantSpaceBP	gpu/gpu.hpp	/^            explicit StereoConstantSpaceBP(int ndisp    = DEFAULT_NDISP,$/;"	p	class:cv::gpu::StereoConstantSpaceBP	access:public	signature:(int ndisp = DEFAULT_NDISP, int iters = DEFAULT_ITERS, int levels = DEFAULT_LEVELS, int nr_plane = DEFAULT_NR_PLANE, int msg_type = CV_32F)
StereoConstantSpaceBP	gpu/gpu.hpp	/^        class CV_EXPORTS StereoConstantSpaceBP$/;"	c	namespace:cv::gpu
StereoSGBM	calib3d/calib3d.hpp	/^    CV_WRAP StereoSGBM();$/;"	p	class:cv::StereoSGBM	access:public	signature:()
StereoSGBM	calib3d/calib3d.hpp	/^    CV_WRAP StereoSGBM(int minDisparity, int numDisparities, int SADWindowSize,$/;"	p	class:cv::StereoSGBM	access:public	signature:(int minDisparity, int numDisparities, int SADWindowSize, int P1=0, int P2=0, int disp12MaxDiff=0, int preFilterCap=0, int uniquenessRatio=0, int speckleWindowSize=0, int speckleRange=0, bool fullDP=false)
StereoSGBM	calib3d/calib3d.hpp	/^class CV_EXPORTS_W StereoSGBM$/;"	c	namespace:cv
StereoVar	contrib/contrib.hpp	/^        CV_WRAP StereoVar();$/;"	p	class:cv::StereoVar	access:public	signature:()
StereoVar	contrib/contrib.hpp	/^        CV_WRAP StereoVar(int levels, double pyrScale, int nIt, int minDisp, int maxDisp, int poly_n, double poly_sigma, float fi, float lambda, int penalization, int cycle, int flags);$/;"	p	class:cv::StereoVar	access:public	signature:(int levels, double pyrScale, int nIt, int minDisp, int maxDisp, int poly_n, double poly_sigma, float fi, float lambda, int penalization, int cycle, int flags)
StereoVar	contrib/contrib.hpp	/^    class CV_EXPORTS StereoVar$/;"	c	namespace:cv
Stop	legacy/legacy.hpp	/^    virtual void Stop( bool calibrate = false );$/;"	p	class:CvCalibFilter	access:public	signature:( bool calibrate = false )
Str	legacy/blobtrack.hpp	/^    char*               Str;$/;"	m	struct:CvDefParam	access:public
Stream	gpu/gpu.hpp	/^            Stream();$/;"	p	class:cv::gpu::Stream	access:public	signature:()
Stream	gpu/gpu.hpp	/^            Stream(const Stream&);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const Stream&)
Stream	gpu/gpu.hpp	/^            explicit Stream(Impl* impl);$/;"	p	class:cv::gpu::Stream	access:private	signature:(Impl* impl)
Stream	gpu/gpu.hpp	/^        class CV_EXPORTS Stream$/;"	c	namespace:cv::gpu
StreamAccessor	gpu/stream_accessor.hpp	/^        struct StreamAccessor$/;"	s	namespace:cv::gpu
String	core/core.hpp	/^typedef std::string String;$/;"	t	namespace:cv
Subdiv2D	imgproc/imgproc.hpp	/^    CV_WRAP Subdiv2D();$/;"	p	class:cv::Subdiv2D	access:public	signature:()
Subdiv2D	imgproc/imgproc.hpp	/^    CV_WRAP Subdiv2D(Rect rect);$/;"	p	class:cv::Subdiv2D	access:public	signature:(Rect rect)
Subdiv2D	imgproc/imgproc.hpp	/^class CV_EXPORTS_W Subdiv2D$/;"	c	namespace:cv
SurfAdjuster	features2d/features2d.hpp	/^    SurfAdjuster( double initial_thresh=400.f, double min_thresh=2, double max_thresh=1000 );$/;"	p	class:cv::SurfAdjuster	access:public	signature:( double initial_thresh=400.f, double min_thresh=2, double max_thresh=1000 )
SurfAdjuster	features2d/features2d.hpp	/^class CV_EXPORTS SurfAdjuster: public AdjusterAdapter$/;"	c	namespace:cv	inherits:AdjusterAdapter
SurfDescriptorExtractor	features2d/features2d.hpp	/^    SurfDescriptorExtractor( int nOctaves=4, int nOctaveLayers=2, bool extended=false, bool upright=false );$/;"	p	class:cv::SurfDescriptorExtractor	access:public	signature:( int nOctaves=4, int nOctaveLayers=2, bool extended=false, bool upright=false )
SurfDescriptorExtractor	features2d/features2d.hpp	/^class CV_EXPORTS SurfDescriptorExtractor : public DescriptorExtractor$/;"	c	namespace:cv	inherits:DescriptorExtractor
SurfFeatureDetector	features2d/features2d.hpp	/^    SurfFeatureDetector( double hessianThreshold=400., int octaves=3, int octaveLayers=4, bool upright=false );$/;"	p	class:cv::SurfFeatureDetector	access:public	signature:( double hessianThreshold=400., int octaves=3, int octaveLayers=4, bool upright=false )
SurfFeatureDetector	features2d/features2d.hpp	/^class CV_EXPORTS SurfFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
T	video/background_segm.hpp	/^    float  T;			\/* "A percentage value which determines when new features can be recognized as new background." (Typically 0.9).*\/$/;"	m	struct:CvFGDStatModelParams	access:public
THRESH_BINARY	imgproc/imgproc.hpp	/^enum { THRESH_BINARY=CV_THRESH_BINARY, THRESH_BINARY_INV=CV_THRESH_BINARY_INV,$/;"	e	enum:cv::__anon16
THRESH_BINARY_INV	imgproc/imgproc.hpp	/^enum { THRESH_BINARY=CV_THRESH_BINARY, THRESH_BINARY_INV=CV_THRESH_BINARY_INV,$/;"	e	enum:cv::__anon16
THRESH_MASK	imgproc/imgproc.hpp	/^       THRESH_TOZERO_INV=CV_THRESH_TOZERO_INV, THRESH_MASK=CV_THRESH_MASK,$/;"	e	enum:cv::__anon16
THRESH_OTSU	imgproc/imgproc.hpp	/^       THRESH_OTSU=CV_THRESH_OTSU };$/;"	e	enum:cv::__anon16
THRESH_TOZERO	imgproc/imgproc.hpp	/^       THRESH_TRUNC=CV_THRESH_TRUNC, THRESH_TOZERO=CV_THRESH_TOZERO,$/;"	e	enum:cv::__anon16
THRESH_TOZERO_INV	imgproc/imgproc.hpp	/^       THRESH_TOZERO_INV=CV_THRESH_TOZERO_INV, THRESH_MASK=CV_THRESH_MASK,$/;"	e	enum:cv::__anon16
THRESH_TRUNC	imgproc/imgproc.hpp	/^       THRESH_TRUNC=CV_THRESH_TRUNC, THRESH_TOZERO=CV_THRESH_TOZERO,$/;"	e	enum:cv::__anon16
TM_CCOEFF	imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon24
TM_CCOEFF_NORMED	imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon24
TM_CCORR	imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon24
TM_CCORR_NORMED	imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon24
TM_SQDIFF	imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon24
TM_SQDIFF_NORMED	imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon24
TRUE	core/internal.hpp	91;"	d
TYPE_MASK	core/core.hpp	/^        TYPE_MASK=7,$/;"	e	enum:cv::FileNode::__anon149
TYPE_MASK	core/core.hpp	/^enum { MAGIC_MASK=0xFFFF0000, TYPE_MASK=0x00000FFF, DEPTH_MASK=7 };$/;"	e	enum:cv::__anon136
T_GeometriccConsistency	contrib/contrib.hpp	/^        float T_GeometriccConsistency;$/;"	m	class:cv::SpinImageModel	access:public
T_GroupingCorespondances	contrib/contrib.hpp	/^        float T_GroupingCorespondances;$/;"	m	class:cv::SpinImageModel	access:public
TargetArchs	gpu/gpu.hpp	/^            TargetArchs();$/;"	p	class:cv::gpu::TargetArchs	access:private	signature:()
TargetArchs	gpu/gpu.hpp	/^        class CV_EXPORTS TargetArchs$/;"	c	namespace:cv::gpu
Temp	legacy/legacy.hpp	/^    float* Temp;            \/* Temporary vector                      *\/$/;"	m	struct:CvConDensation	access:public
Temp1	video/tracking.hpp	/^    float* Temp1;               \/* temp1->data.fl *\/$/;"	m	struct:CvKalman	access:public
Temp2	video/tracking.hpp	/^    float* Temp2;               \/* temp2->data.fl *\/$/;"	m	struct:CvKalman	access:public
TermCriteria	core/core.hpp	/^    TermCriteria();$/;"	p	class:cv::TermCriteria	access:public	signature:()
TermCriteria	core/core.hpp	/^    TermCriteria(const CvTermCriteria& criteria);$/;"	p	class:cv::TermCriteria	access:public	signature:(const CvTermCriteria& criteria)
TermCriteria	core/core.hpp	/^    TermCriteria(int _type, int _maxCount, double _epsilon);$/;"	p	class:cv::TermCriteria	access:public	signature:(int _type, int _maxCount, double _epsilon)
TermCriteria	core/core.hpp	/^class CV_EXPORTS TermCriteria$/;"	c	namespace:cv
TermCriteria	core/operations.hpp	/^inline TermCriteria::TermCriteria() : type(0), maxCount(0), epsilon(0) {}$/;"	f	class:cv::TermCriteria	signature:()
TermCriteria	core/operations.hpp	/^inline TermCriteria::TermCriteria(const CvTermCriteria& criteria)$/;"	f	class:cv::TermCriteria	signature:(const CvTermCriteria& criteria)
TermCriteria	core/operations.hpp	/^inline TermCriteria::TermCriteria(int _type, int _maxCount, double _epsilon)$/;"	f	class:cv::TermCriteria	signature:(int _type, int _maxCount, double _epsilon)
ThisClass	flann/object_factory.h	/^    typedef ObjectFactory<BaseClass,UniqueIdType,ObjectCreator> ThisClass;$/;"	t	class:cvflann::ObjectFactory	access:private
TickMeter	contrib/contrib.hpp	/^        TickMeter();$/;"	p	class:cv::TickMeter	access:public	signature:()
TickMeter	contrib/contrib.hpp	/^    class CV_EXPORTS TickMeter$/;"	c	namespace:cv
Tn	ml/ml.hpp	/^    int Tn;$/;"	m	struct:CvDTreeNode	access:public
TrackID	legacy/blobtrack.hpp	/^    int         TrackID;$/;"	m	struct:CvBlobTrack	access:public
TrackbarCallback	highgui/highgui.hpp	/^typedef void (CV_CDECL *TrackbarCallback)(int pos, void* userdata);$/;"	t	namespace:cv
TrackingState	contrib/contrib.hpp	/^    enum TrackingState$/;"	g	class:CvFuzzyMeanShiftTracker	access:public
TrainData	ml/ml.hpp	/^typedef CvMLData TrainData;$/;"	t	namespace:cv
TransferParamsFromChild	legacy/blobtrack.hpp	/^    void TransferParamsFromChild(CvVSModule* pM, const char* prefix = NULL);$/;"	p	class:CvVSModule	access:public	signature:(CvVSModule* pM, const char* prefix = NULL)
TransferParamsToChild	legacy/blobtrack.hpp	/^    void TransferParamsToChild(CvVSModule* pM, char* prefix = NULL);$/;"	p	class:CvVSModule	access:public	signature:(CvVSModule* pM, char* prefix = NULL)
True	flann/dist.h	/^class True$/;"	c	namespace:cvflann
Type	features2d/features2d.hpp	/^    typedef T Type;$/;"	t	struct:cv::Accumulator	access:public
Type	features2d/features2d.hpp	/^template<> struct Accumulator<char>   { typedef float Type; };$/;"	t	struct:cv::Accumulator	access:public
Type	features2d/features2d.hpp	/^template<> struct Accumulator<short>  { typedef float Type; };$/;"	t	struct:cv::Accumulator	access:public
Type	features2d/features2d.hpp	/^template<> struct Accumulator<unsigned char>  { typedef float Type; };$/;"	t	struct:cv::Accumulator	access:public
Type	features2d/features2d.hpp	/^template<> struct Accumulator<unsigned short> { typedef float Type; };$/;"	t	struct:cv::Accumulator	access:public
Type	flann/dist.h	/^struct Accumulator { typedef T Type; };$/;"	t	struct:cvflann::Accumulator	access:public
Type	flann/dist.h	/^struct Accumulator<char>   { typedef float Type; };$/;"	t	struct:cvflann::Accumulator	access:public
Type	flann/dist.h	/^struct Accumulator<int> { typedef float Type; };$/;"	t	struct:cvflann::Accumulator	access:public
Type	flann/dist.h	/^struct Accumulator<short>  { typedef float Type; };$/;"	t	struct:cvflann::Accumulator	access:public
Type	flann/dist.h	/^struct Accumulator<unsigned char>  { typedef float Type; };$/;"	t	struct:cvflann::Accumulator	access:public
Type	flann/dist.h	/^struct Accumulator<unsigned int> { typedef float Type; };$/;"	t	struct:cvflann::Accumulator	access:public
Type	flann/dist.h	/^struct Accumulator<unsigned short> { typedef float Type; };$/;"	t	struct:cvflann::Accumulator	access:public
U	contrib/contrib.hpp	/^        CvMat** U; \/\/size of array is equal to number of cameras$/;"	m	class:cv::LevMarqSparse	access:public
UNDEFINED	core/core.hpp	/^        UNDEFINED=0, $/;"	e	enum:cv::FileStorage::__anon148
UNIFORM	core/core.hpp	/^    enum { UNIFORM=0, NORMAL=1 };$/;"	e	enum:cv::RNG::__anon138
UPDATE_WEIGHTS	ml/ml.hpp	/^    enum { UPDATE_WEIGHTS = 1, NO_INPUT_SCALE = 2, NO_OUTPUT_SCALE = 4 };$/;"	e	enum:CvANN_MLP::__anon84
USER	core/core.hpp	/^        USER=16, \/\/!< a registered object (e.g. a matrix)$/;"	e	enum:cv::FileNode::__anon149
USE_AUTO_PARAMS	contrib/contrib.hpp	/^        enum {USE_INITIAL_DISPARITY = 1, USE_EQUALIZE_HIST = 2, USE_SMART_ID = 4, USE_AUTO_PARAMS = 8, USE_MEDIAN_FILTERING = 16};$/;"	e	enum:cv::StereoVar::__anon7
USE_EQUALIZE_HIST	contrib/contrib.hpp	/^        enum {USE_INITIAL_DISPARITY = 1, USE_EQUALIZE_HIST = 2, USE_SMART_ID = 4, USE_AUTO_PARAMS = 8, USE_MEDIAN_FILTERING = 16};$/;"	e	enum:cv::StereoVar::__anon7
USE_INITIAL_DISPARITY	contrib/contrib.hpp	/^        enum {USE_INITIAL_DISPARITY = 1, USE_EQUALIZE_HIST = 2, USE_SMART_ID = 4, USE_AUTO_PARAMS = 8, USE_MEDIAN_FILTERING = 16};$/;"	e	enum:cv::StereoVar::__anon7
USE_MEDIAN_FILTERING	contrib/contrib.hpp	/^        enum {USE_INITIAL_DISPARITY = 1, USE_EQUALIZE_HIST = 2, USE_SMART_ID = 4, USE_AUTO_PARAMS = 8, USE_MEDIAN_FILTERING = 16};$/;"	e	enum:cv::StereoVar::__anon7
USE_SMART_ID	contrib/contrib.hpp	/^        enum {USE_INITIAL_DISPARITY = 1, USE_EQUALIZE_HIST = 2, USE_SMART_ID = 4, USE_AUTO_PARAMS = 8, USE_MEDIAN_FILTERING = 16};$/;"	e	enum:cv::StereoVar::__anon7
Undistort	legacy/legacy.hpp	/^    virtual bool Undistort( CvMat** src, CvMat** dst );$/;"	p	class:CvCalibFilter	access:public	signature:( CvMat** src, CvMat** dst )
Undistort	legacy/legacy.hpp	/^    virtual bool Undistort( IplImage** src, IplImage** dst );$/;"	p	class:CvCalibFilter	access:public	signature:( IplImage** src, IplImage** dst )
UniqueRandom	flann/random.h	/^    UniqueRandom(int n)$/;"	f	class:cvflann::UniqueRandom	access:public	signature:(int n)
UniqueRandom	flann/random.h	/^class UniqueRandom$/;"	c	namespace:cvflann
UniqueResultSet	flann/result_set.h	/^    UniqueResultSet() :$/;"	f	class:cvflann::UniqueResultSet	access:public	signature:()
UniqueResultSet	flann/result_set.h	/^class UniqueResultSet : public ResultSet<DistanceType>$/;"	c	namespace:cvflann	inherits:ResultSet
UntypedMatrix	flann/matrix.h	/^    UntypedMatrix(void* data_, long rows_, long cols_) :$/;"	f	class:cvflann::UntypedMatrix	access:public	signature:(void* data_, long rows_, long cols_)
UntypedMatrix	flann/matrix.h	/^class UntypedMatrix$/;"	c	namespace:cvflann
Update	legacy/blobtrack.hpp	/^    virtual void    Update(CvBlob* pBlob) = 0;$/;"	p	class:CvBlobTrackPredictor	access:public	signature:(CvBlob* pBlob)
Update	legacy/blobtrack.hpp	/^    virtual void Update(CvBlob* \/*pBlob*\/, IplImage* \/*pImg*\/, IplImage* \/*pImgFG*\/ = NULL){};$/;"	f	class:CvBlobTrackerOne	access:public	signature:(CvBlob* , IplImage* , IplImage* = NULL)
Update	legacy/blobtrack.hpp	/^    virtual void Update(IplImage* pImg, IplImage* pImgFG = NULL);$/;"	p	class:CvBlobTracker	access:public	signature:(IplImage* pImg, IplImage* pImgFG = NULL)
UpdateBlob	legacy/blobtrack.hpp	/^    virtual void UpdateBlob(int \/*BlobIndex*\/, CvBlob* \/*pBlob*\/, IplImage* \/*pImg*\/, IplImage* \/*pImgFG*\/ = NULL);$/;"	p	class:CvBlobTracker	access:public	signature:(int , CvBlob* , IplImage* , IplImage* = NULL)
UsePPData	legacy/blobtrack.hpp	/^    int                     UsePPData;$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
V	contrib/contrib.hpp	/^        CvMat** V; \/\/size of array is equal to number of points$/;"	m	class:cv::LevMarqSparse	access:public
V	objdetect/objdetect.hpp	/^    CvLSVMFilterPosition V;$/;"	m	struct:__anon197	access:public
VALUE_EXPECTED	core/core.hpp	/^        VALUE_EXPECTED=1,$/;"	e	enum:cv::FileStorage::__anon148
VCycle_MyFAS	contrib/contrib.hpp	/^        void VCycle_MyFAS(Mat &I1_h, Mat &I2_h, Mat &I2x_h, Mat &u_h, int level);$/;"	p	class:cv::StereoVar	access:private	signature:(Mat &I1_h, Mat &I2_h, Mat &I2x_h, Mat &u_h, int level)
Value	legacy/blobtrack.hpp	/^    virtual double Value(int* \/*comp*\/, int \/*x*\/ = 0, int \/*y*\/ = 0){return -1;};$/;"	f	class:CvProb	access:public	signature:(int* , int = 0, int = 0)
ValueType	features2d/features2d.hpp	/^    typedef T ValueType;$/;"	t	struct:cv::L1	access:public
ValueType	features2d/features2d.hpp	/^    typedef T ValueType;$/;"	t	struct:cv::L2	access:public
ValueType	features2d/features2d.hpp	/^    typedef T ValueType;$/;"	t	struct:cv::SL2	access:public
ValueType	features2d/features2d.hpp	/^    typedef unsigned char ValueType;$/;"	t	struct:cv::Hamming	access:public
ValueType	features2d/features2d.hpp	/^    typedef unsigned char ValueType;$/;"	t	struct:cv::HammingLUT	access:public
VariationalSolver	contrib/contrib.hpp	/^        void VariationalSolver(Mat &I1_h, Mat &I2_h, Mat &I2x_h, Mat &u_h, int level);$/;"	p	class:cv::StereoVar	access:private	signature:(Mat &I1_h, Mat &I2_h, Mat &I2x_h, Mat &u_h, int level)
Vec	core/core.hpp	/^    Vec();$/;"	p	class:cv::Vec	access:public	signature:()
Vec	core/core.hpp	/^    Vec(_Tp v0); \/\/!< 1-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0)
Vec	core/core.hpp	/^    Vec(_Tp v0, _Tp v1); \/\/!< 2-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1)
Vec	core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2); \/\/!< 3-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2)
Vec	core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3); \/\/!< 4-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
Vec	core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4); \/\/!< 5-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)
Vec	core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5); \/\/!< 6-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)
Vec	core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6); \/\/!< 7-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6)
Vec	core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7); \/\/!< 8-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7)
Vec	core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8); \/\/!< 9-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8)
Vec	core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9); \/\/!< 10-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9)
Vec	core/core.hpp	/^    Vec(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_AddOp);$/;"	p	class:cv::Vec	access:public	signature:(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_AddOp)
Vec	core/core.hpp	/^    Vec(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_SubOp);$/;"	p	class:cv::Vec	access:public	signature:(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_SubOp)
Vec	core/core.hpp	/^    Vec(const Vec<_Tp, cn>& v);$/;"	p	class:cv::Vec	access:public	signature:(const Vec<_Tp, cn>& v)
Vec	core/core.hpp	/^    explicit Vec(const _Tp* values);$/;"	p	class:cv::Vec	access:public	signature:(const _Tp* values)
Vec	core/core.hpp	/^    template<typename _T2> Vec(const Matx<_Tp, cn, 1>& a, _T2 alpha, Matx_ScaleOp);$/;"	p	class:cv::Vec	access:public	signature:(const Matx<_Tp, cn, 1>& a, _T2 alpha, Matx_ScaleOp)
Vec	core/core.hpp	/^template<typename _Tp, int cn> class CV_EXPORTS Vec : public Matx<_Tp, cn, 1>$/;"	c	namespace:cv	inherits:Matx
Vec	core/core.hpp	/^template<typename _Tp, int cn> class CV_EXPORTS Vec;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
Vec	core/operations.hpp	/^Vec<_Tp, cn>::Vec(const Matx<_Tp, cn, 1>& a, _T2 alpha, Matx_ScaleOp op)$/;"	f	class:cv::Vec	signature:(const Matx<_Tp, cn, 1>& a, _T2 alpha, Matx_ScaleOp op)
Vec	core/operations.hpp	/^Vec<_Tp, cn>::Vec(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_AddOp op)$/;"	f	class:cv::Vec	signature:(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_AddOp op)
Vec	core/operations.hpp	/^Vec<_Tp, cn>::Vec(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_SubOp op)$/;"	f	class:cv::Vec	signature:(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_SubOp op)
Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec()$/;"	f	class:cv::Vec	signature:()
Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0)$/;"	f	class:cv::Vec	signature:(_Tp v0)
Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1)$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1)
Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2)$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2)
Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3)$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)
Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)
Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6)
Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7)
Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8)
Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9)
Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(const Vec<_Tp, cn>& m)$/;"	f	class:cv::Vec	signature:(const Vec<_Tp, cn>& m)
Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(const _Tp* values)$/;"	f	class:cv::Vec	signature:(const _Tp* values)
Vec2b	core/core.hpp	/^typedef Vec<uchar, 2> Vec2b;$/;"	t	namespace:cv
Vec2d	core/core.hpp	/^typedef Vec<double, 2> Vec2d;$/;"	t	namespace:cv
Vec2f	core/core.hpp	/^typedef Vec<float, 2> Vec2f;$/;"	t	namespace:cv
Vec2i	core/core.hpp	/^typedef Vec<int, 2> Vec2i;$/;"	t	namespace:cv
Vec2s	core/core.hpp	/^typedef Vec<short, 2> Vec2s;$/;"	t	namespace:cv
Vec2w	core/core.hpp	/^typedef Vec<ushort, 2> Vec2w;$/;"	t	namespace:cv
Vec3b	core/core.hpp	/^typedef Vec<uchar, 3> Vec3b;$/;"	t	namespace:cv
Vec3d	core/core.hpp	/^typedef Vec<double, 3> Vec3d;$/;"	t	namespace:cv
Vec3f	core/core.hpp	/^typedef Vec<float, 3> Vec3f;$/;"	t	namespace:cv
Vec3i	core/core.hpp	/^typedef Vec<int, 3> Vec3i;$/;"	t	namespace:cv
Vec3s	core/core.hpp	/^typedef Vec<short, 3> Vec3s;$/;"	t	namespace:cv
Vec3w	core/core.hpp	/^typedef Vec<ushort, 3> Vec3w;$/;"	t	namespace:cv
Vec4b	core/core.hpp	/^typedef Vec<uchar, 4> Vec4b;$/;"	t	namespace:cv
Vec4d	core/core.hpp	/^typedef Vec<double, 4> Vec4d;$/;"	t	namespace:cv
Vec4f	core/core.hpp	/^typedef Vec<float, 4> Vec4f;$/;"	t	namespace:cv
Vec4i	core/core.hpp	/^typedef Vec<int, 4> Vec4i;$/;"	t	namespace:cv
Vec4s	core/core.hpp	/^typedef Vec<short, 4> Vec4s;$/;"	t	namespace:cv
Vec4w	core/core.hpp	/^typedef Vec<ushort, 4> Vec4w;    $/;"	t	namespace:cv
Vec6d	core/core.hpp	/^typedef Vec<double, 6> Vec6d;$/;"	t	namespace:cv
Vec6f	core/core.hpp	/^typedef Vec<float, 6> Vec6f;$/;"	t	namespace:cv
Vec6i	core/core.hpp	/^typedef Vec<int, 6> Vec6i;$/;"	t	namespace:cv
Vec8i	core/core.hpp	/^typedef Vec<int, 8> Vec8i;$/;"	t	namespace:cv
VecCommaInitializer	core/core.hpp	/^    VecCommaInitializer(Vec<_Tp, m>* _vec);$/;"	p	class:cv::VecCommaInitializer	access:public	signature:(Vec<_Tp, m>* _vec)
VecCommaInitializer	core/core.hpp	/^template<typename _Tp, int m> class CV_EXPORTS VecCommaInitializer : public MatxCommaInitializer<_Tp, m, 1>$/;"	c	namespace:cv	inherits:MatxCommaInitializer
VecCommaInitializer	core/operations.hpp	/^VecCommaInitializer<_Tp, cn>::VecCommaInitializer(Vec<_Tp, cn>* _vec)$/;"	f	class:cv::VecCommaInitializer	signature:(Vec<_Tp, cn>* _vec)
VecReaderProxy	core/operations.hpp	/^    VecReaderProxy( FileNodeIterator* _it ) : it(_it) {}$/;"	f	class:cv::VecReaderProxy	access:public	signature:( FileNodeIterator* _it )
VecReaderProxy	core/operations.hpp	/^template<typename _Tp, int numflag> class CV_EXPORTS VecReaderProxy$/;"	c	namespace:cv
VecReaderProxy	core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS VecReaderProxy<_Tp,1>$/;"	c	namespace:cv
VecWriterProxy	core/operations.hpp	/^    VecWriterProxy( FileStorage* _fs ) : fs(_fs) {}$/;"	f	class:cv::VecWriterProxy	access:public	signature:( FileStorage* _fs )
VecWriterProxy	core/operations.hpp	/^template<typename _Tp, int numflag> class CV_EXPORTS VecWriterProxy$/;"	c	namespace:cv
VecWriterProxy	core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS VecWriterProxy<_Tp,1>$/;"	c	namespace:cv
Vector	core/operations.hpp	/^    Vector() {}$/;"	f	class:cv::Vector	access:public	signature:()
Vector	core/operations.hpp	/^    Vector(_Tp* _data, size_t _size, bool _copyData=false)$/;"	f	class:cv::Vector	access:public	signature:(_Tp* _data, size_t _size, bool _copyData=false)
Vector	core/operations.hpp	/^    Vector(const Vector& d) { *this = d; }$/;"	f	class:cv::Vector	access:public	signature:(const Vector& d)
Vector	core/operations.hpp	/^    Vector(const Vector& d, const Range& r_)$/;"	f	class:cv::Vector	access:public	signature:(const Vector& d, const Range& r_)
Vector	core/operations.hpp	/^    Vector(const std::vector<_Tp>& vec, bool _copyData=false)$/;"	f	class:cv::Vector	access:public	signature:(const std::vector<_Tp>& vec, bool _copyData=false)
Vector	core/operations.hpp	/^    Vector(size_t _size)  { resize(_size); }$/;"	f	class:cv::Vector	access:public	signature:(size_t _size)
Vector	core/operations.hpp	/^    Vector(size_t _size, const _Tp& val)$/;"	f	class:cv::Vector	access:public	signature:(size_t _size, const _Tp& val)
Vector	core/operations.hpp	/^    template<int n> Vector(const Vec<_Tp, n>& vec)$/;"	f	class:cv::Vector	access:public	signature:(const Vec<_Tp, n>& vec)
Vector	core/operations.hpp	/^template <typename _Tp> class CV_EXPORTS Vector$/;"	c	namespace:cv
VectorDescriptorMatch	features2d/features2d.hpp	/^typedef VectorDescriptorMatcher VectorDescriptorMatch;$/;"	t	namespace:cv
VectorDescriptorMatcher	features2d/features2d.hpp	/^    VectorDescriptorMatcher( const Ptr<DescriptorExtractor>& extractor, const Ptr<DescriptorMatcher>& matcher );$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:( const Ptr<DescriptorExtractor>& extractor, const Ptr<DescriptorMatcher>& matcher )
VectorDescriptorMatcher	features2d/features2d.hpp	/^class CV_EXPORTS VectorDescriptorMatcher : public GenericDescriptorMatcher$/;"	c	namespace:cv	inherits:GenericDescriptorMatcher
Vertex	imgproc/imgproc.hpp	/^        Vertex();$/;"	p	struct:cv::Subdiv2D::Vertex	access:public	signature:()
Vertex	imgproc/imgproc.hpp	/^        Vertex(Point2f pt, bool _isvirtual, int _firstEdge=0);$/;"	p	struct:cv::Subdiv2D::Vertex	access:public	signature:(Point2f pt, bool _isvirtual, int _firstEdge=0)
Vertex	imgproc/imgproc.hpp	/^    struct CV_EXPORTS Vertex$/;"	s	class:cv::Subdiv2D	access:protected
VideoCapture	highgui/highgui.hpp	/^    CV_WRAP VideoCapture();$/;"	p	class:cv::VideoCapture	access:public	signature:()
VideoCapture	highgui/highgui.hpp	/^    CV_WRAP VideoCapture(const string& filename);$/;"	p	class:cv::VideoCapture	access:public	signature:(const string& filename)
VideoCapture	highgui/highgui.hpp	/^    CV_WRAP VideoCapture(int device);$/;"	p	class:cv::VideoCapture	access:public	signature:(int device)
VideoCapture	highgui/highgui.hpp	/^class CV_EXPORTS_W VideoCapture$/;"	c	namespace:cv
VideoWriter	highgui/highgui.hpp	/^    CV_WRAP VideoWriter();$/;"	p	class:cv::VideoWriter	access:public	signature:()
VideoWriter	highgui/highgui.hpp	/^    CV_WRAP VideoWriter(const string& filename, int fourcc, double fps,$/;"	p	class:cv::VideoWriter	access:public	signature:(const string& filename, int fourcc, double fps, Size frameSize, bool isColor=true)
VideoWriter	highgui/highgui.hpp	/^class CV_EXPORTS_W VideoWriter$/;"	c	namespace:cv
View	core/wimage.hpp	/^    WImageView<T> View(int c, int r, int width, int height);$/;"	p	class:cv::WImage	access:public	signature:(int c, int r, int width, int height)
View	core/wimage.hpp	/^    WImageViewC<T, C> View(int c, int r, int width, int height);$/;"	p	class:cv::WImageC	access:public	signature:(int c, int r, int width, int height)
View	core/wimage.hpp	/^WImageView<T> WImage<T>::View(int c, int r, int width, int height) {$/;"	f	class:cv::WImage	signature:(int c, int r, int width, int height)
View	core/wimage.hpp	/^WImageViewC<T, C> WImageC<T, C>::View(int c, int r, int width, int height) {$/;"	f	class:cv::WImageC	signature:(int c, int r, int width, int height)
Vis_index	contrib/contrib.hpp	/^        CvMat* Vis_index; \/\/ matrix which element is index of measurement for point i and camera j$/;"	m	class:cv::LevMarqSparse	access:public
W	contrib/contrib.hpp	/^        CvMat** W;$/;"	m	class:cv::LevMarqSparse	access:public
WARP_INVERSE_MAP	imgproc/imgproc.hpp	/^    WARP_INVERSE_MAP=CV_WARP_INVERSE_MAP$/;"	e	enum:cv::__anon14
WIN32	core/internal.hpp	55;"	d
WIN32	core/internal.hpp	77;"	d
WIN32_LEAN_AND_MEAN	gpu/NCV.hpp	52;"	d
WINDOW_AUTOSIZE	highgui/highgui.hpp	/^enum { WINDOW_AUTOSIZE=1 };$/;"	e	enum:cv::__anon159
WImage	core/wimage.hpp	/^    WImage(const WImage&);$/;"	p	class:cv::WImage	access:protected	signature:(const WImage&)
WImage	core/wimage.hpp	/^    explicit WImage(IplImage* img) : image_(img) {$/;"	f	class:cv::WImage	access:protected	signature:(IplImage* img)
WImage	core/wimage.hpp	/^class WImage$/;"	c	namespace:cv
WImage1_16s	core/wimage.hpp	/^typedef WImageC<short, 1>        WImage1_16s;$/;"	t	namespace:cv
WImage1_16u	core/wimage.hpp	/^typedef WImageC<ushort, 1>        WImage1_16u;$/;"	t	namespace:cv
WImage1_b	core/wimage.hpp	/^typedef WImageC<uchar, 1>        WImage1_b;$/;"	t	namespace:cv
WImage1_f	core/wimage.hpp	/^typedef WImageC<float, 1>        WImage1_f;$/;"	t	namespace:cv
WImage3_16s	core/wimage.hpp	/^typedef WImageC<short, 3>        WImage3_16s;$/;"	t	namespace:cv
WImage3_16u	core/wimage.hpp	/^typedef WImageC<ushort, 3>        WImage3_16u;$/;"	t	namespace:cv
WImage3_b	core/wimage.hpp	/^typedef WImageC<uchar, 3>        WImage3_b;$/;"	t	namespace:cv
WImage3_f	core/wimage.hpp	/^typedef WImageC<float, 3>        WImage3_f;$/;"	t	namespace:cv
WImageBuffer	core/wimage.hpp	/^    WImageBuffer() : WImage<T>(0) {}$/;"	f	class:cv::WImageBuffer	access:public	signature:()
WImageBuffer	core/wimage.hpp	/^    WImageBuffer(const WImageBuffer&);$/;"	p	class:cv::WImageBuffer	access:private	signature:(const WImageBuffer&)
WImageBuffer	core/wimage.hpp	/^    WImageBuffer(int width, int height, int nchannels) : WImage<T>(0) {$/;"	f	class:cv::WImageBuffer	access:public	signature:(int width, int height, int nchannels)
WImageBuffer	core/wimage.hpp	/^    explicit WImageBuffer(IplImage* img) : WImage<T>(img) {}$/;"	f	class:cv::WImageBuffer	access:public	signature:(IplImage* img)
WImageBuffer	core/wimage.hpp	/^class WImageBuffer : public WImage<T>$/;"	c	namespace:cv	inherits:WImage
WImageBuffer1_16s	core/wimage.hpp	/^typedef WImageBufferC<short, 1>  WImageBuffer1_16s;$/;"	t	namespace:cv
WImageBuffer1_16u	core/wimage.hpp	/^typedef WImageBufferC<ushort, 1>  WImageBuffer1_16u;$/;"	t	namespace:cv
WImageBuffer1_b	core/wimage.hpp	/^typedef WImageBufferC<uchar, 1>  WImageBuffer1_b;$/;"	t	namespace:cv
WImageBuffer1_f	core/wimage.hpp	/^typedef WImageBufferC<float, 1>  WImageBuffer1_f;$/;"	t	namespace:cv
WImageBuffer3_16s	core/wimage.hpp	/^typedef WImageBufferC<short, 3>  WImageBuffer3_16s;$/;"	t	namespace:cv
WImageBuffer3_16u	core/wimage.hpp	/^typedef WImageBufferC<ushort, 3>  WImageBuffer3_16u;$/;"	t	namespace:cv
WImageBuffer3_b	core/wimage.hpp	/^typedef WImageBufferC<uchar, 3>  WImageBuffer3_b;$/;"	t	namespace:cv
WImageBuffer3_f	core/wimage.hpp	/^typedef WImageBufferC<float, 3>  WImageBuffer3_f;$/;"	t	namespace:cv
WImageBufferC	core/wimage.hpp	/^    WImageBufferC() : WImageC<T, C>(0) {}$/;"	f	class:cv::WImageBufferC	access:public	signature:()
WImageBufferC	core/wimage.hpp	/^    WImageBufferC(const WImageBufferC&);$/;"	p	class:cv::WImageBufferC	access:private	signature:(const WImageBufferC&)
WImageBufferC	core/wimage.hpp	/^    WImageBufferC(int width, int height) : WImageC<T, C>(0) {$/;"	f	class:cv::WImageBufferC	access:public	signature:(int width, int height)
WImageBufferC	core/wimage.hpp	/^    explicit WImageBufferC(IplImage* img) : WImageC<T, C>(img) {}$/;"	f	class:cv::WImageBufferC	access:public	signature:(IplImage* img)
WImageBufferC	core/wimage.hpp	/^class WImageBufferC : public WImageC<T, C>$/;"	c	namespace:cv	inherits:WImageC
WImageBuffer_16s	core/wimage.hpp	/^typedef WImageBuffer<short>      WImageBuffer_16s;$/;"	t	namespace:cv
WImageBuffer_16u	core/wimage.hpp	/^typedef WImageBuffer<ushort>      WImageBuffer_16u;$/;"	t	namespace:cv
WImageBuffer_b	core/wimage.hpp	/^typedef WImageBuffer<uchar>      WImageBuffer_b;$/;"	t	namespace:cv
WImageBuffer_f	core/wimage.hpp	/^typedef WImageBuffer<float>      WImageBuffer_f;$/;"	t	namespace:cv
WImageC	core/wimage.hpp	/^    WImageC(const WImageC&);$/;"	p	class:cv::WImageC	access:protected	signature:(const WImageC&)
WImageC	core/wimage.hpp	/^    explicit WImageC(IplImage* img) : WImage<T>(img) {$/;"	f	class:cv::WImageC	access:public	signature:(IplImage* img)
WImageC	core/wimage.hpp	/^class WImageC : public WImage<T>$/;"	c	namespace:cv	inherits:WImage
WImageView	core/wimage.hpp	/^    WImageView(IplImage* img) : WImage<T>(img) {}$/;"	f	class:cv::WImageView	access:public	signature:(IplImage* img)
WImageView	core/wimage.hpp	/^    WImageView(T* data, int width, int height, int channels, int width_step = -1);$/;"	p	class:cv::WImageView	access:public	signature:(T* data, int width, int height, int channels, int width_step = -1)
WImageView	core/wimage.hpp	/^    WImageView(WImage<T>* img, int c, int r, int width, int height);$/;"	p	class:cv::WImageView	access:public	signature:(WImage<T>* img, int c, int r, int width, int height)
WImageView	core/wimage.hpp	/^    WImageView(const WImage<T>& img) : WImage<T>(0) {$/;"	f	class:cv::WImageView	access:public	signature:(const WImage<T>& img)
WImageView	core/wimage.hpp	/^WImageView<T>::WImageView(T* data, int width, int height, int nchannels, int width_step)$/;"	f	class:cv::WImageView	signature:(T* data, int width, int height, int nchannels, int width_step)
WImageView	core/wimage.hpp	/^WImageView<T>::WImageView(WImage<T>* img, int c, int r, int width, int height)$/;"	f	class:cv::WImageView	signature:(WImage<T>* img, int c, int r, int width, int height)
WImageView	core/wimage.hpp	/^class WImageView : public WImage<T>$/;"	c	namespace:cv	inherits:WImage
WImageView1_16s	core/wimage.hpp	/^typedef WImageViewC<short, 1>    WImageView1_16s;$/;"	t	namespace:cv
WImageView1_16u	core/wimage.hpp	/^typedef WImageViewC<ushort, 1>    WImageView1_16u;$/;"	t	namespace:cv
WImageView1_b	core/wimage.hpp	/^typedef WImageViewC<uchar, 1>    WImageView1_b;$/;"	t	namespace:cv
WImageView1_f	core/wimage.hpp	/^typedef WImageViewC<float, 1>    WImageView1_f;$/;"	t	namespace:cv
WImageView3_16s	core/wimage.hpp	/^typedef WImageViewC<short, 3>    WImageView3_16s;$/;"	t	namespace:cv
WImageView3_16u	core/wimage.hpp	/^typedef WImageViewC<ushort, 3>    WImageView3_16u;$/;"	t	namespace:cv
WImageView3_b	core/wimage.hpp	/^typedef WImageViewC<uchar, 3>    WImageView3_b;$/;"	t	namespace:cv
WImageView3_f	core/wimage.hpp	/^typedef WImageViewC<float, 3>    WImageView3_f;$/;"	t	namespace:cv
WImageViewC	core/wimage.hpp	/^    WImageViewC();$/;"	p	class:cv::WImageViewC	access:public	signature:()
WImageViewC	core/wimage.hpp	/^    WImageViewC(IplImage* img) : WImageC<T, C>(img) {}$/;"	f	class:cv::WImageViewC	access:public	signature:(IplImage* img)
WImageViewC	core/wimage.hpp	/^    WImageViewC(T* data, int width, int height, int width_step = -1);$/;"	p	class:cv::WImageViewC	access:public	signature:(T* data, int width, int height, int width_step = -1)
WImageViewC	core/wimage.hpp	/^    WImageViewC(WImageC<T, C>* img,$/;"	p	class:cv::WImageViewC	access:public	signature:(WImageC<T, C>* img, int c, int r, int width, int height)
WImageViewC	core/wimage.hpp	/^    WImageViewC(const WImageC<T, C>& img) : WImageC<T, C>(0) {$/;"	f	class:cv::WImageViewC	access:public	signature:(const WImageC<T, C>& img)
WImageViewC	core/wimage.hpp	/^    WImageViewC(const WImageViewC<T, C>& img) : WImageC<T, C>(0) {$/;"	f	class:cv::WImageViewC	access:public	signature:(const WImageViewC<T, C>& img)
WImageViewC	core/wimage.hpp	/^WImageViewC<T, C>::WImageViewC() : WImageC<T, C>(0) {$/;"	f	class:cv::WImageViewC	signature:()
WImageViewC	core/wimage.hpp	/^WImageViewC<T, C>::WImageViewC(T* data, int width, int height, int width_step)$/;"	f	class:cv::WImageViewC	signature:(T* data, int width, int height, int width_step)
WImageViewC	core/wimage.hpp	/^WImageViewC<T, C>::WImageViewC(WImageC<T, C>* img, int c, int r, int width, int height)$/;"	f	class:cv::WImageViewC	signature:(WImageC<T, C>* img, int c, int r, int width, int height)
WImageViewC	core/wimage.hpp	/^class WImageViewC : public WImageC<T, C>$/;"	c	namespace:cv	inherits:WImageC
WImageView_16s	core/wimage.hpp	/^typedef WImageView<short>        WImageView_16s;$/;"	t	namespace:cv
WImageView_16u	core/wimage.hpp	/^typedef WImageView<ushort>        WImageView_16u;$/;"	t	namespace:cv
WImageView_b	core/wimage.hpp	/^typedef WImageView<uchar>        WImageView_b;$/;"	t	namespace:cv
WImageView_f	core/wimage.hpp	/^typedef WImageView<float>        WImageView_f;$/;"	t	namespace:cv
WImage_16s	core/wimage.hpp	/^typedef WImage<short>            WImage_16s;$/;"	t	namespace:cv
WImage_16u	core/wimage.hpp	/^typedef WImage<ushort>            WImage_16u;$/;"	t	namespace:cv
WImage_b	core/wimage.hpp	/^typedef WImage<uchar>            WImage_b;$/;"	t	namespace:cv
WImage_f	core/wimage.hpp	/^typedef WImage<float>            WImage_f;$/;"	t	namespace:cv
WORDSIZE	flann/allocator.h	/^const size_t     WORDSIZE=16;$/;"	m	namespace:cvflann
WRITE	core/core.hpp	/^        WRITE=1, \/\/! write mode$/;"	e	enum:cv::FileStorage::__anon147
WString	core/core.hpp	/^typedef std::basic_string<wchar_t> WString;$/;"	t	namespace:cv
Width	core/wimage.hpp	/^    int Width() const {return image_->width; }$/;"	f	class:cv::WImage	access:public	signature:() const
WidthStep	core/wimage.hpp	/^    int WidthStep() const {return image_->widthStep; }$/;"	f	class:cv::WImage	access:public	signature:() const
Write	features2d/features2d.hpp	/^    void Write (FileStorage &fs) const;$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(FileStorage &fs) const
Write	features2d/features2d.hpp	/^    void Write(CvFileStorage* fs, const char* name);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(CvFileStorage* fs, const char* name)
Write	legacy/blobtrack.hpp	/^    virtual void Write(CvFileStorage* fs, const char* name)$/;"	f	class:CvBlobSeq	access:public	signature:(CvFileStorage* fs, const char* name)
WriteStructContext	core/operations.hpp	/^    WriteStructContext(FileStorage& _fs, const string& name,$/;"	p	class:cv::WriteStructContext	access:public	signature:(FileStorage& _fs, const string& name, int flags, const string& typeName=string())
WriteStructContext	core/operations.hpp	/^class CV_EXPORTS WriteStructContext$/;"	c	namespace:cv
X	contrib/contrib.hpp	/^        CvMat* X; \/\/measurement $/;"	m	class:cv::LevMarqSparse	access:public
Xcoef	legacy/legacy.hpp	/^    double Xcoef;$/;"	m	struct:CvStereoLineCoeff	access:public
XcoefA	legacy/legacy.hpp	/^    double XcoefA;$/;"	m	struct:CvStereoLineCoeff	access:public
XcoefAB	legacy/legacy.hpp	/^    double XcoefAB;$/;"	m	struct:CvStereoLineCoeff	access:public
XcoefB	legacy/legacy.hpp	/^    double XcoefB;$/;"	m	struct:CvStereoLineCoeff	access:public
YAPE	features2d/features2d.hpp	/^typedef LDetector YAPE;$/;"	t	namespace:cv
Ycoef	legacy/legacy.hpp	/^    double Ycoef;$/;"	m	struct:CvStereoLineCoeff	access:public
YcoefA	legacy/legacy.hpp	/^    double YcoefA;$/;"	m	struct:CvStereoLineCoeff	access:public
YcoefAB	legacy/legacy.hpp	/^    double YcoefAB;$/;"	m	struct:CvStereoLineCoeff	access:public
YcoefB	legacy/legacy.hpp	/^    double YcoefB;$/;"	m	struct:CvStereoLineCoeff	access:public
Yj	contrib/contrib.hpp	/^        CvMat** Yj; \/\/length of array is i = num_points$/;"	m	class:cv::LevMarqSparse	access:public
Zcoef	legacy/legacy.hpp	/^    double Zcoef;$/;"	m	struct:CvStereoLineCoeff	access:public
ZcoefA	legacy/legacy.hpp	/^    double ZcoefA;$/;"	m	struct:CvStereoLineCoeff	access:public
ZcoefAB	legacy/legacy.hpp	/^    double ZcoefAB;$/;"	m	struct:CvStereoLineCoeff	access:public
ZcoefB	legacy/legacy.hpp	/^    double ZcoefB;$/;"	m	struct:CvStereoLineCoeff	access:public
ZeroIterator	flann/dist.h	/^struct ZeroIterator$/;"	s	namespace:cvflann
_CRT_SECURE_NO_DEPRECATE	core/types_c.h	47;"	d
_CV_ALWAYS_NO_PROFILE_	core/internal.hpp	84;"	d
_CV_ALWAYS_PROFILE_	core/internal.hpp	83;"	d
_CvPixelPosition32f	legacy/compat.hpp	/^typedef struct _CvPixelPosition32f$/;"	s
_CvPixelPosition32f::bottomline	legacy/compat.hpp	/^    float*  bottomline;$/;"	m	struct:_CvPixelPosition32f	access:public
_CvPixelPosition32f::currline	legacy/compat.hpp	/^    float*  currline;$/;"	m	struct:_CvPixelPosition32f	access:public
_CvPixelPosition32f::height	legacy/compat.hpp	/^    int     height;$/;"	m	struct:_CvPixelPosition32f	access:public
_CvPixelPosition32f::step	legacy/compat.hpp	/^    int     step;$/;"	m	struct:_CvPixelPosition32f	access:public
_CvPixelPosition32f::step_arr	legacy/compat.hpp	/^    int     step_arr[3];$/;"	m	struct:_CvPixelPosition32f	access:public
_CvPixelPosition32f::topline	legacy/compat.hpp	/^    float*  topline;$/;"	m	struct:_CvPixelPosition32f	access:public
_CvPixelPosition32f::width	legacy/compat.hpp	/^    int     width;$/;"	m	struct:_CvPixelPosition32f	access:public
_CvPixelPosition32f::x	legacy/compat.hpp	/^    int     x;$/;"	m	struct:_CvPixelPosition32f	access:public
_CvPixelPosition8s	legacy/compat.hpp	/^typedef struct _CvPixelPosition8s$/;"	s
_CvPixelPosition8s::bottomline	legacy/compat.hpp	/^    schar*  bottomline;$/;"	m	struct:_CvPixelPosition8s	access:public
_CvPixelPosition8s::currline	legacy/compat.hpp	/^    schar*  currline;$/;"	m	struct:_CvPixelPosition8s	access:public
_CvPixelPosition8s::height	legacy/compat.hpp	/^    int     height;$/;"	m	struct:_CvPixelPosition8s	access:public
_CvPixelPosition8s::step	legacy/compat.hpp	/^    int     step;$/;"	m	struct:_CvPixelPosition8s	access:public
_CvPixelPosition8s::step_arr	legacy/compat.hpp	/^    int     step_arr[3];$/;"	m	struct:_CvPixelPosition8s	access:public
_CvPixelPosition8s::topline	legacy/compat.hpp	/^    schar*  topline;$/;"	m	struct:_CvPixelPosition8s	access:public
_CvPixelPosition8s::width	legacy/compat.hpp	/^    int     width;$/;"	m	struct:_CvPixelPosition8s	access:public
_CvPixelPosition8s::x	legacy/compat.hpp	/^    int     x;$/;"	m	struct:_CvPixelPosition8s	access:public
_CvPixelPosition8u	legacy/compat.hpp	/^typedef struct _CvPixelPosition8u$/;"	s
_CvPixelPosition8u::bottomline	legacy/compat.hpp	/^    uchar*  bottomline;    \/* pointer to the start of the first line           *\/$/;"	m	struct:_CvPixelPosition8u	access:public
_CvPixelPosition8u::currline	legacy/compat.hpp	/^    uchar*  currline;      \/* pointer to the start of the current pixel line   *\/$/;"	m	struct:_CvPixelPosition8u	access:public
_CvPixelPosition8u::height	legacy/compat.hpp	/^    int     height;                 \/* height of the image  ( in pixels )               *\/$/;"	m	struct:_CvPixelPosition8u	access:public
_CvPixelPosition8u::step	legacy/compat.hpp	/^    int     step;                   \/* distance between lines ( in elements of single   *\/$/;"	m	struct:_CvPixelPosition8u	access:public
_CvPixelPosition8u::step_arr	legacy/compat.hpp	/^    int     step_arr[3];            \/* array: ( 0, -step, step ). It is used for        *\/$/;"	m	struct:_CvPixelPosition8u	access:public
_CvPixelPosition8u::topline	legacy/compat.hpp	/^    uchar*  topline;       \/* pointer to the start of the top pixel line       *\/$/;"	m	struct:_CvPixelPosition8u	access:public
_CvPixelPosition8u::width	legacy/compat.hpp	/^    int     width;                  \/* width of the image  ( in pixels )                *\/$/;"	m	struct:_CvPixelPosition8u	access:public
_CvPixelPosition8u::x	legacy/compat.hpp	/^    int     x;                      \/* current x coordinate ( in pixels )               *\/$/;"	m	struct:_CvPixelPosition8u	access:public
_GetLabeledFeatures	features2d/features2d.hpp	/^    vector<cv::KeyPoint> _GetLabeledFeatures() const;$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:() const
_InputArray	core/core.hpp	/^    _InputArray();$/;"	p	class:cv::_InputArray	access:public	signature:()
_InputArray	core/core.hpp	/^    _InputArray(const Mat& m);$/;"	p	class:cv::_InputArray	access:public	signature:(const Mat& m)
_InputArray	core/core.hpp	/^    _InputArray(const MatExpr& expr);$/;"	p	class:cv::_InputArray	access:public	signature:(const MatExpr& expr)
_InputArray	core/core.hpp	/^    _InputArray(const Scalar& s);$/;"	p	class:cv::_InputArray	access:public	signature:(const Scalar& s)
_InputArray	core/core.hpp	/^    _InputArray(const double& val);$/;"	p	class:cv::_InputArray	access:public	signature:(const double& val)
_InputArray	core/core.hpp	/^    _InputArray(const vector<Mat>& vec);$/;"	p	class:cv::_InputArray	access:public	signature:(const vector<Mat>& vec)
_InputArray	core/core.hpp	/^    template<typename _Tp, int m, int n> _InputArray(const Matx<_Tp, m, n>& matx);$/;"	p	class:cv::_InputArray	access:public	signature:(const Matx<_Tp, m, n>& matx)
_InputArray	core/core.hpp	/^    template<typename _Tp> _InputArray(const vector<_Tp>& vec);$/;"	p	class:cv::_InputArray	access:public	signature:(const vector<_Tp>& vec)
_InputArray	core/core.hpp	/^    template<typename _Tp> _InputArray(const vector<vector<_Tp> >& vec);$/;"	p	class:cv::_InputArray	access:public	signature:(const vector<vector<_Tp> >& vec)
_InputArray	core/core.hpp	/^class CV_EXPORTS _InputArray$/;"	c	namespace:cv
_InputArray	core/mat.hpp	/^inline _InputArray::_InputArray(const Scalar& s)$/;"	f	class:cv::_InputArray	signature:(const Scalar& s)
_InputArray	core/mat.hpp	/^template<typename _Tp, int m, int n> inline _InputArray::_InputArray(const Matx<_Tp, m, n>& mtx)$/;"	f	class:cv::_InputArray	signature:(const Matx<_Tp, m, n>& mtx)
_InputArray	core/mat.hpp	/^template<typename _Tp> inline _InputArray::_InputArray(const vector<_Tp>& vec)$/;"	f	class:cv::_InputArray	signature:(const vector<_Tp>& vec)
_InputArray	core/mat.hpp	/^template<typename _Tp> inline _InputArray::_InputArray(const vector<vector<_Tp> >& vec)$/;"	f	class:cv::_InputArray	signature:(const vector<vector<_Tp> >& vec)
_IplConvKernel	core/types_c.h	/^typedef struct _IplConvKernel$/;"	s
_IplConvKernel::anchorX	core/types_c.h	/^    int  anchorX;$/;"	m	struct:_IplConvKernel	access:public
_IplConvKernel::anchorY	core/types_c.h	/^    int  anchorY;$/;"	m	struct:_IplConvKernel	access:public
_IplConvKernel::nCols	core/types_c.h	/^    int  nCols;$/;"	m	struct:_IplConvKernel	access:public
_IplConvKernel::nRows	core/types_c.h	/^    int  nRows;$/;"	m	struct:_IplConvKernel	access:public
_IplConvKernel::nShiftR	core/types_c.h	/^    int  nShiftR;$/;"	m	struct:_IplConvKernel	access:public
_IplConvKernel::values	core/types_c.h	/^    int *values;$/;"	m	struct:_IplConvKernel	access:public
_IplConvKernelFP	core/types_c.h	/^typedef struct _IplConvKernelFP$/;"	s
_IplConvKernelFP::anchorX	core/types_c.h	/^    int  anchorX;$/;"	m	struct:_IplConvKernelFP	access:public
_IplConvKernelFP::anchorY	core/types_c.h	/^    int  anchorY;$/;"	m	struct:_IplConvKernelFP	access:public
_IplConvKernelFP::nCols	core/types_c.h	/^    int  nCols;$/;"	m	struct:_IplConvKernelFP	access:public
_IplConvKernelFP::nRows	core/types_c.h	/^    int  nRows;$/;"	m	struct:_IplConvKernelFP	access:public
_IplConvKernelFP::values	core/types_c.h	/^    float *values;$/;"	m	struct:_IplConvKernelFP	access:public
_IplImage	core/types_c.h	/^typedef struct _IplImage$/;"	s
_IplImage::BorderConst	core/types_c.h	/^    int  BorderConst[4];    \/* Ditto.                                 *\/$/;"	m	struct:_IplImage	access:public
_IplImage::BorderMode	core/types_c.h	/^    int  BorderMode[4];     \/* Ignored by OpenCV.                     *\/$/;"	m	struct:_IplImage	access:public
_IplImage::ID	core/types_c.h	/^    int  ID;                \/* version (=0)*\/$/;"	m	struct:_IplImage	access:public
_IplImage::align	core/types_c.h	/^    int  align;             \/* Alignment of image rows (4 or 8).$/;"	m	struct:_IplImage	access:public
_IplImage::alphaChannel	core/types_c.h	/^    int  alphaChannel;      \/* Ignored by OpenCV *\/$/;"	m	struct:_IplImage	access:public
_IplImage::channelSeq	core/types_c.h	/^    char channelSeq[4];     \/* ditto *\/$/;"	m	struct:_IplImage	access:public
_IplImage::colorModel	core/types_c.h	/^    char colorModel[4];     \/* Ignored by OpenCV *\/$/;"	m	struct:_IplImage	access:public
_IplImage::dataOrder	core/types_c.h	/^    int  dataOrder;         \/* 0 - interleaved color channels, 1 - separate color channels.$/;"	m	struct:_IplImage	access:public
_IplImage::depth	core/types_c.h	/^    int  depth;             \/* Pixel depth in bits: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16S,$/;"	m	struct:_IplImage	access:public
_IplImage::height	core/types_c.h	/^    int  height;            \/* Image height in pixels.                          *\/$/;"	m	struct:_IplImage	access:public
_IplImage::imageData	core/types_c.h	/^    char *imageData;        \/* Pointer to aligned image data.         *\/$/;"	m	struct:_IplImage	access:public
_IplImage::imageDataOrigin	core/types_c.h	/^    char *imageDataOrigin;  \/* Pointer to very origin of image data$/;"	m	struct:_IplImage	access:public
_IplImage::imageId	core/types_c.h	/^    void  *imageId;                 \/* "           " *\/$/;"	m	struct:_IplImage	access:public
_IplImage::imageSize	core/types_c.h	/^    int  imageSize;         \/* Image data size in bytes$/;"	m	struct:_IplImage	access:public
_IplImage::maskROI	core/types_c.h	/^    struct _IplImage *maskROI;      \/* Must be NULL. *\/$/;"	m	struct:_IplImage	typeref:struct:_IplImage::_IplImage	access:public
_IplImage::nChannels	core/types_c.h	/^    int  nChannels;         \/* Most of OpenCV functions support 1,2,3 or 4 channels *\/$/;"	m	struct:_IplImage	access:public
_IplImage::nSize	core/types_c.h	/^    int  nSize;             \/* sizeof(IplImage) *\/$/;"	m	struct:_IplImage	access:public
_IplImage::origin	core/types_c.h	/^    int  origin;            \/* 0 - top-left origin,$/;"	m	struct:_IplImage	access:public
_IplImage::roi	core/types_c.h	/^    struct _IplROI *roi;    \/* Image ROI. If NULL, the whole image is selected. *\/$/;"	m	struct:_IplImage	typeref:struct:_IplImage::_IplROI	access:public
_IplImage::tileInfo	core/types_c.h	/^    struct _IplTileInfo *tileInfo;  \/* "           " *\/$/;"	m	struct:_IplImage	typeref:struct:_IplImage::_IplTileInfo	access:public
_IplImage::width	core/types_c.h	/^    int  width;             \/* Image width in pixels.                           *\/$/;"	m	struct:_IplImage	access:public
_IplImage::widthStep	core/types_c.h	/^    int  widthStep;         \/* Size of aligned image row in bytes.    *\/$/;"	m	struct:_IplImage	access:public
_IplROI	core/types_c.h	/^typedef struct _IplROI$/;"	s
_IplROI::coi	core/types_c.h	/^    int  coi; \/* 0 - no COI (all channels are selected), 1 - 0th channel is selected ...*\/$/;"	m	struct:_IplROI	access:public
_IplROI::height	core/types_c.h	/^    int  height;$/;"	m	struct:_IplROI	access:public
_IplROI::width	core/types_c.h	/^    int  width;$/;"	m	struct:_IplROI	access:public
_IplROI::xOffset	core/types_c.h	/^    int  xOffset;$/;"	m	struct:_IplROI	access:public
_IplROI::yOffset	core/types_c.h	/^    int  yOffset;$/;"	m	struct:_IplROI	access:public
_OPENCV_FLANN_HPP_	flann/flann.hpp	44;"	d
_OPENCV_MINIFLANN_HPP_	flann/miniflann.hpp	44;"	d
_OutputArray	core/core.hpp	/^    _OutputArray();$/;"	p	class:cv::_OutputArray	access:public	signature:()
_OutputArray	core/core.hpp	/^    _OutputArray(Mat& m);$/;"	p	class:cv::_OutputArray	access:public	signature:(Mat& m)
_OutputArray	core/core.hpp	/^    _OutputArray(vector<Mat>& vec);$/;"	p	class:cv::_OutputArray	access:public	signature:(vector<Mat>& vec)
_OutputArray	core/core.hpp	/^    template<typename _Tp, int m, int n> _OutputArray(Matx<_Tp, m, n>& matx);$/;"	p	class:cv::_OutputArray	access:public	signature:(Matx<_Tp, m, n>& matx)
_OutputArray	core/core.hpp	/^    template<typename _Tp> _OutputArray(vector<_Tp>& vec);$/;"	p	class:cv::_OutputArray	access:public	signature:(vector<_Tp>& vec)
_OutputArray	core/core.hpp	/^    template<typename _Tp> _OutputArray(vector<vector<_Tp> >& vec);$/;"	p	class:cv::_OutputArray	access:public	signature:(vector<vector<_Tp> >& vec)
_OutputArray	core/core.hpp	/^class CV_EXPORTS _OutputArray : public _InputArray$/;"	c	namespace:cv	inherits:_InputArray
_OutputArray	core/mat.hpp	/^template<typename _Tp, int m, int n> inline _OutputArray::_OutputArray(Matx<_Tp, m, n>& mtx) : _InputArray(mtx) {}$/;"	f	class:cv::_OutputArray	signature:(Matx<_Tp, m, n>& mtx)
_OutputArray	core/mat.hpp	/^template<typename _Tp> inline _OutputArray::_OutputArray(vector<_Tp>& vec) : _InputArray(vec) {}$/;"	f	class:cv::_OutputArray	signature:(vector<_Tp>& vec)
_OutputArray	core/mat.hpp	/^template<typename _Tp> inline _OutputArray::_OutputArray(vector<vector<_Tp> >& vec) : _InputArray(vec) {}$/;"	f	class:cv::_OutputArray	signature:(vector<vector<_Tp> >& vec)
_WIN32	core/internal.hpp	58;"	d
_WIN32	core/internal.hpp	80;"	d
_WIN32_WINNT	core/internal.hpp	64;"	d
__BEGIN__	core/internal.hpp	94;"	d
__CV_BEGIN__	core/core_c.h	1853;"	d
__CV_END__	core/core_c.h	1854;"	d
__CV_EXIT__	core/core_c.h	1855;"	d
__CV_GPU_HOST_DEVICE__	gpu/devmem2d.hpp	142;"	d
__CV_GPU_HOST_DEVICE__	gpu/devmem2d.hpp	59;"	d
__END__	core/internal.hpp	95;"	d
__OPENCV_ALL_HPP__	opencv.hpp	44;"	d
__OPENCV_BACKGROUND_SEGM_HPP__	video/background_segm.hpp	44;"	d
__OPENCV_CALIB3D_HPP__	calib3d/calib3d.hpp	44;"	d
__OPENCV_COMPAT_HPP__	legacy/compat.hpp	51;"	d
__OPENCV_CONTRIB_HPP__	contrib/contrib.hpp	44;"	d
__OPENCV_CONTRIB_RETINA_HPP__	contrib/retina.hpp	66;"	d
__OPENCV_CORE_C_H__	core/core_c.h	45;"	d
__OPENCV_CORE_EIGEN_HPP__	core/eigen.hpp	44;"	d
__OPENCV_CORE_HPP__	core/core.hpp	47;"	d
__OPENCV_CORE_INTERNAL_HPP__	core/internal.hpp	49;"	d
__OPENCV_CORE_MATRIX_OPERATIONS_HPP__	core/mat.hpp	44;"	d
__OPENCV_CORE_OPERATIONS_HPP__	core/operations.hpp	44;"	d
__OPENCV_CORE_TYPES_H__	core/types_c.h	44;"	d
__OPENCV_CORE_WIMAGE_HPP__	core/wimage.hpp	101;"	d
__OPENCV_CVSTREAMS_H__	legacy/streams.hpp	43;"	d
__OPENCV_FEATURES_2D_HPP__	features2d/features2d.hpp	44;"	d
__OPENCV_GPUMAT_HPP__	gpu/gpumat.hpp	44;"	d
__OPENCV_GPU_DEVMEM2D_HPP__	gpu/devmem2d.hpp	44;"	d
__OPENCV_GPU_HPP__	gpu/gpu.hpp	44;"	d
__OPENCV_GPU_MATRIX_OPERATIONS_HPP__	gpu/matrix_operations.hpp	44;"	d
__OPENCV_GPU_STREAM_ACCESSOR_HPP__	gpu/stream_accessor.hpp	44;"	d
__OPENCV_HIGHGUI_HPP__	highgui/highgui.hpp	44;"	d
__OPENCV_HIGHGUI_H__	highgui/highgui_c.h	43;"	d
__OPENCV_IMGPROC_HPP__	imgproc/imgproc.hpp	48;"	d
__OPENCV_IMGPROC_IMGPROC_C_H__	imgproc/imgproc_c.h	44;"	d
__OPENCV_IMGPROC_TYPES_C_H__	imgproc/types_c.h	44;"	d
__OPENCV_LEGACY_HPP__	legacy/legacy.hpp	43;"	d
__OPENCV_ML_HPP__	ml/ml.hpp	42;"	d
__OPENCV_OBJDETECT_HPP__	objdetect/objdetect.hpp	44;"	d
__OPENCV_TRACKING_HPP__	video/tracking.hpp	48;"	d
__OPENCV_VERSION_HPP__	core/version.hpp	48;"	d
__OPENCV_VIDEOSURVEILLANCE_H__	legacy/blobtrack.hpp	44;"	d
__OPENCV_VIDEO_HPP__	video/video.hpp	44;"	d
__align__	gpu/NCV.hpp	103;"	d
__anon156::height	core/types_c.h	/^    int height;$/;"	m	struct:__anon156	access:public
__anon156::width	core/types_c.h	/^    int width;$/;"	m	struct:__anon156	access:public
__anon182::callback	legacy/legacy.hpp	/^    CvCallback callback;$/;"	m	union:__anon182	access:public
__anon182::data	legacy/legacy.hpp	/^    void* data;$/;"	m	union:__anon182	access:public
__anon185::id	legacy/legacy.hpp	/^    int id;$/;"	m	struct:__anon185	access:public
__anon185::p	legacy/legacy.hpp	/^    CvPoint2D32f p; \/\/ pgruebele: So we do not loose precision, this needs to be float$/;"	m	struct:__anon185	access:public
__anon186::id	legacy/legacy.hpp	/^    int id;$/;"	m	struct:__anon186	access:public
__anon186::p	legacy/legacy.hpp	/^    CvPoint3D32f p;             \/\/ location of the tracked object$/;"	m	struct:__anon186	access:public
__anon187::mat	legacy/legacy.hpp	/^    float mat[4][4];              \/* maps camera coordinates to world coordinates *\/$/;"	m	struct:__anon187	access:public
__anon187::principal_point	legacy/legacy.hpp	/^    CvPoint2D32f principal_point; \/* copied from intrinsics so this structure *\/$/;"	m	struct:__anon187	access:public
__anon187::valid	legacy/legacy.hpp	/^    CvBool valid;$/;"	m	struct:__anon187	access:public
__anon188::distortion	legacy/legacy.hpp	/^    float distortion[4];$/;"	m	struct:__anon188	access:public
__anon188::focal_length	legacy/legacy.hpp	/^    float focal_length[2];$/;"	m	struct:__anon188	access:public
__anon188::principal_point	legacy/legacy.hpp	/^    CvPoint2D32f principal_point;$/;"	m	struct:__anon188	access:public
__anon196::l	objdetect/objdetect.hpp	/^    int l;$/;"	m	struct:__anon196	access:public
__anon196::x	objdetect/objdetect.hpp	/^    int x;$/;"	m	struct:__anon196	access:public
__anon196::y	objdetect/objdetect.hpp	/^    int y;$/;"	m	struct:__anon196	access:public
__anon197::H	objdetect/objdetect.hpp	/^    float *H;$/;"	m	struct:__anon197	access:public
__anon197::V	objdetect/objdetect.hpp	/^    CvLSVMFilterPosition V;$/;"	m	struct:__anon197	access:public
__anon197::fineFunction	objdetect/objdetect.hpp	/^    float fineFunction[4];$/;"	m	struct:__anon197	access:public
__anon197::numFeatures	objdetect/objdetect.hpp	/^    int numFeatures;$/;"	m	struct:__anon197	access:public
__anon197::sizeX	objdetect/objdetect.hpp	/^    int sizeX;$/;"	m	struct:__anon197	access:public
__anon197::sizeY	objdetect/objdetect.hpp	/^    int sizeY;$/;"	m	struct:__anon197	access:public
_alignment	gpu/NCV.hpp	/^    Ncv32u _alignment;$/;"	m	class:NCVMemNativeAllocator	access:private
_alignment	gpu/NCV.hpp	/^    Ncv32u _alignment;$/;"	m	class:NCVMemStackAllocator	access:private
_convertValarrayGrayBuffer2cvMat	contrib/retina.hpp	/^        void _convertValarrayGrayBuffer2cvMat(const std::valarray<double> &grayMatrixToConvert, const unsigned int nbRows, const unsigned int nbColumns, const bool colorMode, Mat &outBuffer);$/;"	p	class:cv::Retina	access:protected	signature:(const std::valarray<double> &grayMatrixToConvert, const unsigned int nbRows, const unsigned int nbColumns, const bool colorMode, Mat &outBuffer)
_height	gpu/NCV.hpp	/^    Ncv32u _height;$/;"	m	class:NCVMatrix	access:protected
_init	contrib/retina.hpp	/^        void _init(const std::string parametersSaveFile, Size inputSize, const bool colorMode, RETINA_COLORSAMPLINGMETHOD colorSamplingMethod=RETINA_COLOR_BAYER, const bool useRetinaLogSampling=false, const double reductionFactor=1.0, const double samplingStrenght=10.0);$/;"	p	class:cv::Retina	access:protected	signature:(const std::string parametersSaveFile, Size inputSize, const bool colorMode, RETINA_COLORSAMPLINGMETHOD colorSamplingMethod=RETINA_COLOR_BAYER, const bool useRetinaLogSampling=false, const double reductionFactor=1.0, const double samplingStrenght=10.0)
_inputBuffer	contrib/retina.hpp	/^        std::valarray<double> _inputBuffer;$/;"	m	class:cv::Retina	access:protected
_length	gpu/NCV.hpp	/^    size_t _length;$/;"	m	class:NCVVector	access:protected
_log	flann/logger.h	/^    int _log(int level, const char* fmt, va_list arglist)$/;"	f	class:cvflann::Logger	access:private	signature:(int level, const char* fmt, va_list arglist)
_maxSize	gpu/NCV.hpp	/^    size_t _maxSize;$/;"	m	class:NCVMemNativeAllocator	access:private
_maxSize	gpu/NCV.hpp	/^    size_t _maxSize;$/;"	m	class:NCVMemStackAllocator	access:private
_memType	gpu/NCV.hpp	/^    NCVMemoryType _memType;$/;"	m	class:NCVMemNativeAllocator	access:private
_memType	gpu/NCV.hpp	/^    NCVMemoryType _memType;$/;"	m	class:NCVMemStackAllocator	access:private
_memtype	gpu/NCV.hpp	/^    NCVMemoryType _memtype;$/;"	m	class:NCVMatrix	access:protected
_memtype	gpu/NCV.hpp	/^    NCVMemoryType _memtype;$/;"	m	class:NCVVector	access:protected
_ncv_hpp_	gpu/NCV.hpp	43;"	d
_npp_staging_hpp_	gpu/NPP_staging.hpp	43;"	d
_parametersSaveFile	contrib/retina.hpp	/^        FileStorage _parametersSaveFile;$/;"	m	class:cv::Retina	access:protected
_parametersSaveFileName	contrib/retina.hpp	/^        std::string _parametersSaveFileName;$/;"	m	class:cv::Retina	access:protected
_pitch	gpu/NCV.hpp	/^    Ncv32u _pitch;$/;"	m	class:NCVMatrix	access:protected
_ptr	gpu/NCV.hpp	/^    T *_ptr;$/;"	m	class:NCVMatrix	access:protected
_ptr	gpu/NCV.hpp	/^    T *_ptr;$/;"	m	class:NCVVector	access:protected
_retinaFilter	contrib/retina.hpp	/^        RetinaFilter* _retinaFilter;$/;"	m	class:cv::Retina	access:protected
_setDestination	flann/logger.h	/^    void _setDestination(const char* name)$/;"	f	class:cvflann::Logger	access:private	signature:(const char* name)
_width	gpu/NCV.hpp	/^    Ncv32u _width;$/;"	m	class:NCVMatrix	access:protected
a	core/mat.hpp	/^    Mat a, b, c;$/;"	m	class:cv::MatExpr	access:public
abs	core/core.hpp	71;"	d
abs	core/mat.hpp	/^    virtual void abs(const MatExpr& expr, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, MatExpr& res) const
abs	core/mat.hpp	/^CV_EXPORTS MatExpr abs(const Mat& m);$/;"	p	namespace:cv	signature:(const Mat& m)
abs	core/mat.hpp	/^CV_EXPORTS MatExpr abs(const MatExpr& e);$/;"	p	namespace:cv	signature:(const MatExpr& e)
abs	core/mat.hpp	/^template<typename _Tp> static inline MatExpr abs(const Mat_<_Tp>& m)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& m)
abs	core/operations.hpp	/^double abs(const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a)
abs	flann/dist.h	/^inline T abs(T x) { return (x<0) ? -x : x; }$/;"	f	namespace:cvflann	signature:(T x)
abs	flann/dist.h	/^inline double abs<double>(double x) { return fabs(x); }$/;"	f	namespace:cvflann	signature:(double x)
abs	flann/dist.h	/^inline float abs<float>(float x) { return fabsf(x); }$/;"	f	namespace:cvflann	signature:(float x)
abs	flann/dist.h	/^inline int abs<int>(int x) { return ::abs(x); }$/;"	f	namespace:cvflann	signature:(int x)
abs	flann/dist.h	/^inline long double abs<long double>(long double x) { return fabsl(x); }$/;"	f	namespace:cvflann	signature:(long double x)
absSum	gpu/gpu.hpp	/^        CV_EXPORTS Scalar absSum(const GpuMat& src);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src)
absSum	gpu/gpu.hpp	/^        CV_EXPORTS Scalar absSum(const GpuMat& src, GpuMat& buf);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& buf)
absdiff	core/core.hpp	/^CV_EXPORTS_W void absdiff(InputArray src1, InputArray src2, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst)
absdiff	gpu/gpu.hpp	/^        CV_EXPORTS void absdiff(const GpuMat& a, const GpuMat& b, GpuMat& c, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c, Stream& stream = Stream::Null())
absdiff	gpu/gpu.hpp	/^        CV_EXPORTS void absdiff(const GpuMat& a, const Scalar& s, GpuMat& c, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const Scalar& s, GpuMat& c, Stream& stream = Stream::Null())
accum_dist	flann/dist.h	/^    inline ResultType accum_dist(const U& a, const V& b, int) const$/;"	f	struct:cvflann::ChiSquareDistance	access:public	signature:(const U& a, const V& b, int) const
accum_dist	flann/dist.h	/^    inline ResultType accum_dist(const U& a, const V& b, int) const$/;"	f	struct:cvflann::HellingerDistance	access:public	signature:(const U& a, const V& b, int) const
accum_dist	flann/dist.h	/^    inline ResultType accum_dist(const U& a, const V& b, int) const$/;"	f	struct:cvflann::HistIntersectionDistance	access:public	signature:(const U& a, const V& b, int) const
accum_dist	flann/dist.h	/^    inline ResultType accum_dist(const U& a, const V& b, int) const$/;"	f	struct:cvflann::KL_Divergence	access:public	signature:(const U& a, const V& b, int) const
accum_dist	flann/dist.h	/^    inline ResultType accum_dist(const U& a, const V& b, int) const$/;"	f	struct:cvflann::L1	access:public	signature:(const U& a, const V& b, int) const
accum_dist	flann/dist.h	/^    inline ResultType accum_dist(const U& a, const V& b, int) const$/;"	f	struct:cvflann::L2	access:public	signature:(const U& a, const V& b, int) const
accum_dist	flann/dist.h	/^    inline ResultType accum_dist(const U& a, const V& b, int) const$/;"	f	struct:cvflann::L2_Simple	access:public	signature:(const U& a, const V& b, int) const
accum_dist	flann/dist.h	/^    inline ResultType accum_dist(const U& a, const V& b, int) const$/;"	f	struct:cvflann::MinkowskiDistance	access:public	signature:(const U& a, const V& b, int) const
accumulate	imgproc/imgproc.hpp	/^CV_EXPORTS_W void accumulate( InputArray src, InputOutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, InputOutputArray dst, InputArray mask=noArray() )
accumulateProduct	imgproc/imgproc.hpp	/^CV_EXPORTS_W void accumulateProduct( InputArray src1, InputArray src2,$/;"	p	namespace:cv	signature:( InputArray src1, InputArray src2, InputOutputArray dst, InputArray mask=noArray() )
accumulateSquare	imgproc/imgproc.hpp	/^CV_EXPORTS_W void accumulateSquare( InputArray src, InputOutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, InputOutputArray dst, InputArray mask=noArray() )
accumulateWeighted	imgproc/imgproc.hpp	/^CV_EXPORTS_W void accumulateWeighted( InputArray src, InputOutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, InputOutputArray dst, double alpha, InputArray mask=noArray() )
activ_func	ml/ml.hpp	/^    int activ_func;$/;"	m	class:CvANN_MLP	access:protected
active_var_mask	ml/ml.hpp	/^    CvMat* active_var_mask;$/;"	m	class:CvRTrees	access:protected
active_vars	ml/ml.hpp	/^    CvMat* active_vars;$/;"	m	class:CvBoost	access:protected
active_vars_abs	ml/ml.hpp	/^    CvMat* active_vars_abs;$/;"	m	class:CvBoost	access:protected
adaptiveFilter	contrib/contrib.hpp	/^    void adaptiveFilter();$/;"	p	class:CvAdaptiveSkinDetector	access:protected	signature:()
adaptiveThreshold	imgproc/imgproc.hpp	/^CV_EXPORTS_W void adaptiveThreshold( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C )
add	core/core.hpp	/^CV_EXPORTS_W void add(InputArray src1, InputArray src2, OutputArray dst,$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst, InputArray mask=noArray(), int dtype=-1)
add	core/mat.hpp	/^    virtual void add(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const
add	core/mat.hpp	/^    virtual void add(const MatExpr& expr1, const Scalar& s, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const Scalar& s, MatExpr& res) const
add	features2d/features2d.hpp	/^        void add( const vector<Mat>& images, const vector<vector<KeyPoint> >& keypoints );$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( const vector<Mat>& images, const vector<vector<KeyPoint> >& keypoints )
add	features2d/features2d.hpp	/^    virtual void add( const vector<Mat>& descriptors );$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const vector<Mat>& descriptors )
add	features2d/features2d.hpp	/^    virtual void add( const vector<Mat>& descriptors );$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:( const vector<Mat>& descriptors )
add	features2d/features2d.hpp	/^    virtual void add( const vector<Mat>& images,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints )
add	features2d/features2d.hpp	/^    virtual void add( const vector<Mat>& imgCollection,$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:( const vector<Mat>& imgCollection, vector<vector<KeyPoint> >& pointCollection )
add	features2d/features2d.hpp	/^    void add( const Mat& descriptors );$/;"	p	class:cv::BOWTrainer	access:public	signature:( const Mat& descriptors )
add	flann/lsh_table.h	/^    void add(Matrix<ElementType> dataset)$/;"	f	class:cvflann::lsh::LshTable	access:public	signature:(Matrix<ElementType> dataset)
add	flann/lsh_table.h	/^    void add(unsigned int value, const ElementType* feature)$/;"	f	class:cvflann::lsh::LshTable	access:public	signature:(unsigned int value, const ElementType* feature)
add	gpu/gpu.hpp	/^            void add(const std::vector<GpuMat>& descCollection);$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const std::vector<GpuMat>& descCollection)
add	gpu/gpu.hpp	/^        CV_EXPORTS void add(const GpuMat& a, const GpuMat& b, GpuMat& c, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c, Stream& stream = Stream::Null())
add	gpu/gpu.hpp	/^        CV_EXPORTS void add(const GpuMat& a, const Scalar& sc, GpuMat& c, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const Scalar& sc, GpuMat& c, Stream& stream = Stream::Null())
addCurve	contrib/contrib.hpp	/^    void addCurve(CvFuzzyCurve *curve, double value = 0);$/;"	p	class:CvFuzzyFunction	access:public	signature:(CvFuzzyCurve *curve, double value = 0)
addExample	features2d/features2d.hpp	/^  void addExample(int class_id, uchar* patch_data);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int class_id, uchar* patch_data)
addPoint	contrib/contrib.hpp	/^    void addPoint(double x, double y);$/;"	p	class:CvFuzzyCurve	access:public	signature:(double x, double y)
addPoint	flann/result_set.h	/^    inline void addPoint(DistanceType dist, int index)$/;"	f	class:cvflann::KNNUniqueResultSet	access:public	signature:(DistanceType dist, int index)
addPoint	flann/result_set.h	/^    virtual void addPoint(DistanceType dist, int index) = 0;$/;"	p	class:cvflann::ResultSet	access:public	signature:(DistanceType dist, int index)
addPoint	flann/result_set.h	/^    void addPoint(DistanceType dist, int index)$/;"	f	class:cvflann::KNNResultSet	access:public	signature:(DistanceType dist, int index)
addPoint	flann/result_set.h	/^    void addPoint(DistanceType dist, int index)$/;"	f	class:cvflann::KNNSimpleResultSet	access:public	signature:(DistanceType dist, int index)
addPoint	flann/result_set.h	/^    void addPoint(DistanceType dist, int index)$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:(DistanceType dist, int index)
addPoint	flann/result_set.h	/^    void addPoint(DistanceType dist, int index)$/;"	f	class:cvflann::RadiusUniqueResultSet	access:public	signature:(DistanceType dist, int index)
addRule	contrib/contrib.hpp	/^    void addRule(CvFuzzyCurve *c1, CvFuzzyCurve *c2, CvFuzzyCurve *o1);$/;"	p	class:CvFuzzyController	access:public	signature:(CvFuzzyCurve *c1, CvFuzzyCurve *c2, CvFuzzyCurve *o1)
addText	highgui/highgui.hpp	/^CV_EXPORTS void addText( const Mat& img, const string& text, Point org, CvFont font);$/;"	p	namespace:cv	signature:( const Mat& img, const string& text, Point org, CvFont font)
addValue	flann/simplex_downhill.h	/^void addValue(int pos, float val, float* vals, T* point, T* points, int n)$/;"	f	namespace:cvflann	signature:(int pos, float val, float* vals, T* point, T* points, int n)
addWeighted	core/core.hpp	/^CV_EXPORTS_W void addWeighted(InputArray src1, double alpha, InputArray src2,$/;"	p	namespace:cv	signature:(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, int dtype=-1)
addedDescCount	features2d/features2d.hpp	/^    int addedDescCount;$/;"	m	class:cv::FlannBasedMatcher	access:protected
addref	core/core.hpp	/^    void addref();$/;"	p	class:cv::Mat	access:public	signature:()
addref	core/core.hpp	/^    void addref();$/;"	p	class:cv::Ptr	access:public	signature:()
addref	core/core.hpp	/^    void addref();$/;"	p	class:cv::SparseMat	access:public	signature:()
addref	core/mat.hpp	/^inline void Mat::addref()$/;"	f	class:cv::Mat	signature:()
addref	core/mat.hpp	/^inline void SparseMat::addref()$/;"	f	class:cv::SparseMat	signature:()
addref	core/operations.hpp	/^    void addref() { if( hdr.refcount ) CV_XADD(hdr.refcount, 1); }$/;"	f	class:cv::Vector	access:public	signature:()
addref	core/operations.hpp	/^template<typename _Tp> inline void Ptr<_Tp>::addref()$/;"	f	class:cv::Ptr	signature:()
addref	legacy/legacy.hpp	/^    void addref() const$/;"	f	class:CvMatrix	access:public	signature:() const
address	core/core.hpp	/^    const_pointer address(const_reference r) { return &r; }$/;"	f	class:cv::Allocator	access:public	signature:(const_reference r)
address	core/core.hpp	/^    pointer address(reference r) { return &r; }$/;"	f	class:cv::Allocator	access:public	signature:(reference r)
adj_matr	legacy/legacy.hpp	/^    int**    adj_matr;$/;"	m	struct:CvCliqueFinder	access:public
adjustROI	core/core.hpp	/^    Mat& adjustROI( int dtop, int dbottom, int dleft, int dright );$/;"	p	class:cv::Mat	access:public	signature:( int dtop, int dbottom, int dleft, int dright )
adjustROI	core/core.hpp	/^    Mat_& adjustROI( int dtop, int dbottom, int dleft, int dright );$/;"	p	class:cv::Mat_	access:public	signature:( int dtop, int dbottom, int dleft, int dright )
adjustROI	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::adjustROI( int dtop, int dbottom, int dleft, int dright )$/;"	f	class:cv::Mat_	signature:( int dtop, int dbottom, int dleft, int dright )
adjustROI	gpu/gpumat.hpp	/^        GpuMat& adjustROI( int dtop, int dbottom, int dleft, int dright );$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( int dtop, int dbottom, int dleft, int dright )
adjuster_	features2d/features2d.hpp	/^    const Ptr<AdjusterAdapter> adjuster_;$/;"	m	class:cv::DynamicAdaptedFeatureDetector	access:private
algo	flann/miniflann.hpp	/^    cvflann::flann_algorithm_t algo;$/;"	m	class:cv::flann::Index	access:protected
align	core/types_c.h	/^    int  align;             \/* Alignment of image rows (4 or 8).$/;"	m	struct:_IplImage	access:public
alignPtr	core/core.hpp	/^template<typename _Tp> static inline _Tp* alignPtr(_Tp* ptr, int n=(int)sizeof(_Tp))$/;"	f	namespace:cv	signature:(_Tp* ptr, int n=(int)sizeof(_Tp))
alignSize	core/core.hpp	/^static inline size_t alignSize(size_t sz, int n)$/;"	f	namespace:cv	signature:(size_t sz, int n)
alignUp	gpu/NCV.hpp	/^NCV_EXPORTS Ncv32u alignUp(Ncv32u what, Ncv32u alignment);$/;"	p	signature:(Ncv32u what, Ncv32u alignment)
alignment	gpu/NCV.hpp	/^    virtual Ncv32u alignment(void) const = 0;$/;"	p	class:INCVMemAllocator	access:public	signature:(void) const
alignment	gpu/NCV.hpp	/^    virtual Ncv32u alignment(void) const;$/;"	p	class:NCVMemNativeAllocator	access:public	signature:(void) const
alignment	gpu/NCV.hpp	/^    virtual Ncv32u alignment(void) const;$/;"	p	class:NCVMemStackAllocator	access:public	signature:(void) const
all	core/core.hpp	/^    static Matx all(_Tp alpha);$/;"	p	class:cv::Matx	access:public	signature:(_Tp alpha)
all	core/core.hpp	/^    static Range all();$/;"	p	class:cv::Range	access:public	signature:()
all	core/core.hpp	/^    static Scalar_<_Tp> all(_Tp v0);$/;"	p	class:cv::Scalar_	access:public	signature:(_Tp v0)
all	core/core.hpp	/^    static Vec all(_Tp alpha);$/;"	p	class:cv::Vec	access:public	signature:(_Tp alpha)
all	core/operations.hpp	/^inline Range Range::all() { return Range(INT_MIN, INT_MAX); }$/;"	f	class:cv::Range	signature:()
all	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn> Vec<_Tp, cn>::all(_Tp alpha)$/;"	f	class:cv::Vec	signature:(_Tp alpha)
all	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n> Matx<_Tp, m, n>::all(_Tp alpha)$/;"	f	class:cv::Matx	signature:(_Tp alpha)
all	core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp> Scalar_<_Tp>::all(_Tp v0)$/;"	f	class:cv::Scalar_	signature:(_Tp v0)
alloc	gpu/NCV.hpp	/^    virtual NCVStatus alloc(NCVMemSegment &seg, size_t size) = 0;$/;"	p	class:INCVMemAllocator	access:public	signature:(NCVMemSegment &seg, size_t size)
alloc	gpu/NCV.hpp	/^    virtual NCVStatus alloc(NCVMemSegment &seg, size_t size);$/;"	p	class:NCVMemNativeAllocator	access:public	signature:(NCVMemSegment &seg, size_t size)
alloc	gpu/NCV.hpp	/^    virtual NCVStatus alloc(NCVMemSegment &seg, size_t size);$/;"	p	class:NCVMemStackAllocator	access:public	signature:(NCVMemSegment &seg, size_t size)
allocBegin	gpu/NCV.hpp	/^    Ncv8u *allocBegin;$/;"	m	class:NCVMemStackAllocator	access:private
allocPosteriorsAligned	features2d/features2d.hpp	/^  void allocPosteriorsAligned(int num_leaves, int num_classes);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int num_leaves, int num_classes)
alloc_type	gpu/gpu.hpp	/^            int alloc_type;$/;"	m	class:cv::gpu::CudaMem	access:public
alloca	core/internal.hpp	294;"	d
alloca	core/internal.hpp	295;"	d
allocate	core/core.hpp	/^    pointer allocate(size_type count, const void* =0)$/;"	f	class:cv::Allocator	access:public	signature:(size_type count, const void* =0)
allocate	core/core.hpp	/^    virtual void allocate(int dims, const int* sizes, int type, int*& refcount,$/;"	p	class:cv::MatAllocator	access:public	signature:(int dims, const int* sizes, int type, int*& refcount, uchar*& datastart, uchar*& data, size_t* step)
allocate	core/core.hpp	/^    void allocate(size_t _size);$/;"	p	class:cv::AutoBuffer	access:public	signature:(size_t _size)
allocate	core/core.hpp	/^template<typename _Tp> static inline _Tp* allocate(size_t n)$/;"	f	namespace:cv	signature:(size_t n)
allocate	core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline void AutoBuffer<_Tp, fixed_size>::allocate(size_t _size)$/;"	f	class:cv::AutoBuffer	signature:(size_t _size)
allocate	flann/allocator.h	/^    T* allocate(size_t count = 1)$/;"	f	class:cvflann::PooledAllocator	access:public	signature:(size_t count = 1)
allocate	flann/allocator.h	/^T* allocate(size_t count = 1)$/;"	f	namespace:cvflann	signature:(size_t count = 1)
allocateMemory	flann/allocator.h	/^    void* allocateMemory(int size)$/;"	f	class:cvflann::PooledAllocator	access:public	signature:(int size)
allocatedMem	gpu/NCV.hpp	/^    NCVMemSegment allocatedMem;$/;"	m	class:NCVMatrixAlloc	access:private
allocatedMem	gpu/NCV.hpp	/^    NCVMemSegment allocatedMem;$/;"	m	class:NCVVectorAlloc	access:private
allocator	core/core.hpp	/^    MatAllocator* allocator;$/;"	m	class:cv::Mat	access:public
allocator	gpu/NCV.hpp	/^    INCVMemAllocator &allocator;$/;"	m	class:NCVMatrixAlloc	access:private
allocator	gpu/NCV.hpp	/^    INCVMemAllocator &allocator;$/;"	m	class:NCVVectorAlloc	access:private
allzero	contrib/contrib.hpp	/^        const static Point3f allzero;$/;"	m	class:cv::Mesh3D	access:public
alpha	core/mat.hpp	/^    double alpha, beta;$/;"	m	class:cv::MatExpr	access:public
alpha	ml/ml.hpp	/^    double alpha;$/;"	m	struct:CvDTreeNode	access:public
alpha	ml/ml.hpp	/^    double* alpha;$/;"	m	class:CvSVMSolver	access:public
alpha	ml/ml.hpp	/^    double* alpha;$/;"	m	struct:CvSVMDecisionFunc	access:public
alpha	objdetect/objdetect.hpp	/^    float* alpha;$/;"	m	struct:CvHaarClassifier	access:public
alpha1	video/background_segm.hpp	/^    float  alpha1;		\/* How quickly we forget old background pixel values seen.  Typically set to 0.1  				*\/$/;"	m	struct:CvFGDStatModelParams	access:public
alpha2	video/background_segm.hpp	/^    float  alpha2;		\/* "Controls speed of feature learning". Depends on T. Typical value circa 0.005. 				*\/$/;"	m	struct:CvFGDStatModelParams	access:public
alpha3	video/background_segm.hpp	/^    float  alpha3;		\/* Alternate to alpha2, used (e.g.) for quicker initial convergence. Typical value 0.1.				*\/$/;"	m	struct:CvFGDStatModelParams	access:public
alphaChannel	core/types_c.h	/^    int  alphaChannel;      \/* Ignored by OpenCV *\/$/;"	m	struct:_IplImage	access:public
alpha_count	ml/ml.hpp	/^    int alpha_count;$/;"	m	class:CvSVMSolver	access:public
alpha_status	ml/ml.hpp	/^    schar* alpha_status;$/;"	m	class:CvSVMSolver	access:public
analizeValue	core/core.hpp	/^    _Tp analizeValue(const std::string& str, bool space_delete=false);$/;"	p	class:cv::CommandLineParser	access:protected	signature:(const std::string& str, bool space_delete=false)
analizeValue	core/core.hpp	/^double CommandLineParser::analizeValue<double>(const std::string& str, bool space_delete);$/;"	p	class:cv::CommandLineParser	signature:(const std::string& str, bool space_delete)
analizeValue	core/core.hpp	/^float CommandLineParser::analizeValue<float>(const std::string& str, bool space_delete);$/;"	p	class:cv::CommandLineParser	signature:(const std::string& str, bool space_delete)
analizeValue	core/core.hpp	/^int CommandLineParser::analizeValue<int>(const std::string& str, bool space_delete);$/;"	p	class:cv::CommandLineParser	signature:(const std::string& str, bool space_delete)
analizeValue	core/core.hpp	/^std::string CommandLineParser::analizeValue<std::string>(const std::string& str, bool space_delete);$/;"	p	class:cv::CommandLineParser	signature:(const std::string& str, bool space_delete)
analizeValue	core/core.hpp	/^unsigned CommandLineParser::analizeValue<unsigned int>(const std::string& str, bool space_delete);$/;"	p	class:cv::CommandLineParser	signature:(const std::string& str, bool space_delete)
anchor	gpu/gpu.hpp	/^            Point anchor;$/;"	m	class:cv::gpu::BaseFilter_GPU	access:public
anchor	gpu/gpu.hpp	/^            int ksize, anchor;$/;"	m	class:cv::gpu::BaseColumnFilter_GPU	access:public
anchor	gpu/gpu.hpp	/^            int ksize, anchor;$/;"	m	class:cv::gpu::BaseRowFilter_GPU	access:public
anchor	imgproc/imgproc.hpp	/^    Point anchor;$/;"	m	class:cv::BaseFilter	access:public
anchor	imgproc/imgproc.hpp	/^    Point anchor;$/;"	m	class:cv::FilterEngine	access:public
anchor	imgproc/imgproc.hpp	/^    int ksize, anchor;$/;"	m	class:cv::BaseColumnFilter	access:public
anchor	imgproc/imgproc.hpp	/^    int ksize, anchor;$/;"	m	class:cv::BaseRowFilter	access:public
anchorX	core/types_c.h	/^    int  anchorX;$/;"	m	struct:_IplConvKernel	access:public
anchorX	core/types_c.h	/^    int  anchorX;$/;"	m	struct:_IplConvKernelFP	access:public
anchorY	core/types_c.h	/^    int  anchorY;$/;"	m	struct:_IplConvKernel	access:public
anchorY	core/types_c.h	/^    int  anchorY;$/;"	m	struct:_IplConvKernelFP	access:public
angle	core/core.hpp	/^    float angle;    \/\/< the rotation angle. When the angle is 0, 90, 180, 270 etc., the rectangle becomes an up-right rectangle. $/;"	m	class:cv::RotatedRect	access:public
angle	core/types_c.h	/^    float angle;          \/* Angle between the horizontal axis           *\/$/;"	m	struct:CvBox2D	access:public
angle	features2d/features2d.hpp	/^    CV_PROP_RW float angle; \/\/!< computed orientation of the keypoint (-1 if not applicable)$/;"	m	class:cv::KeyPoint	access:public
angleMode	features2d/features2d.hpp	/^        int angleMode;   \/\/ it is not used now$/;"	m	struct:cv::SIFT::CommonParams	access:public
any	flann/any.h	/^    any()$/;"	f	struct:cdiggins::any	access:public	signature:()
any	flann/any.h	/^    any(const T& x)$/;"	f	struct:cdiggins::any	access:public	signature:(const T& x)
any	flann/any.h	/^    any(const any& x)$/;"	f	struct:cdiggins::any	access:public	signature:(const any& x)
any	flann/any.h	/^    any(const char* x)$/;"	f	struct:cdiggins::any	access:public	signature:(const char* x)
any	flann/any.h	/^struct any$/;"	s	namespace:cdiggins
any	flann/params.h	/^typedef cdiggins::any any;$/;"	t	namespace:cvflann
anyimpl	flann/any.h	/^namespace anyimpl$/;"	n	namespace:cdiggins
appearance_profile	legacy/blobtrack.hpp	/^    int     appearance_profile;$/;"	m	struct:CvBlobTrackerParamMS	access:public
apply	gpu/gpu.hpp	/^            virtual void apply(const GpuMat& src, GpuMat& dst, Rect roi = Rect(0,0,-1,-1), Stream& stream = Stream::Null()) = 0;$/;"	p	class:cv::gpu::FilterEngine_GPU	access:public	signature:(const GpuMat& src, GpuMat& dst, Rect roi = Rect(0,0,-1,-1), Stream& stream = Stream::Null())
apply	imgproc/imgproc.hpp	/^    virtual void apply( const Mat& src, Mat& dst,$/;"	p	class:cv::FilterEngine	access:public	signature:( const Mat& src, Mat& dst, const Rect& srcRoi=Rect(0,0,-1,-1), Point dstOfs=Point(0,0), bool isolated=false)
applyQuantization	features2d/features2d.hpp	/^  inline void applyQuantization(int num_quant_bits) { makePosteriors2(num_quant_bits); }$/;"	f	class:cv::RandomizedTree	access:public	signature:(int num_quant_bits)
approxPolyDP	imgproc/imgproc.hpp	/^CV_EXPORTS_W void approxPolyDP( InputArray curve,$/;"	p	namespace:cv	signature:( InputArray curve, OutputArray approxCurve, double epsilon, bool closed )
arcLength	imgproc/imgproc.hpp	/^CV_EXPORTS_W double arcLength( InputArray curve, bool closed );$/;"	p	namespace:cv	signature:( InputArray curve, bool closed )
area	core/core.hpp	/^    _Tp area() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
area	core/core.hpp	/^    _Tp area() const;$/;"	p	class:cv::Size_	access:public	signature:() const
area	core/operations.hpp	/^template<typename _Tp> inline _Tp Rect_<_Tp>::area() const { return width*height; }$/;"	f	class:cv::Rect_	signature:() const
area	core/operations.hpp	/^template<typename _Tp> inline _Tp Size_<_Tp>::area() const { return width*height; }$/;"	f	class:cv::Size_	signature:() const
area	imgproc/types_c.h	/^    double area;    \/* area of the connected component  *\/$/;"	m	struct:CvConnectedComp	access:public
areaThreshold	features2d/features2d.hpp	/^    double areaThreshold;$/;"	m	struct:CvMSERParams	access:public
arr	core/core_c.h	/^CVAPI(CvScalar)  cvSum( const CvArr* arr );$/;"	v
arr	core/core_c.h	/^CVAPI(CvSize) cvGetSize( const CvArr* arr );$/;"	v
arr	core/core_c.h	/^CVAPI(int)  cvCountNonZero( const CvArr* arr );$/;"	v
arr	core/core_c.h	/^CVAPI(int) cvGetElemType( const CvArr* arr );$/;"	v
arr	core/core_c.h	/^CVAPI(void)  cvCreateData( CvArr* arr );$/;"	v
arr	core/core_c.h	/^CVAPI(void)  cvReleaseData( CvArr* arr );$/;"	v
arr	core/core_c.h	/^CVAPI(void)  cvSetZero( CvArr* arr );$/;"	v
arr	core/operations.hpp	/^    const _Tp* arr;$/;"	m	class:cv::GreaterEqIdx	access:public
arr	core/operations.hpp	/^    const _Tp* arr;$/;"	m	class:cv::LessThanIdx	access:public
array_iterator	core/core_c.h	/^CVAPI(int) cvNextNArraySlice( CvNArrayIterator* array_iterator );$/;"	v
arrays	core/core.hpp	/^    const Mat** arrays;$/;"	m	class:cv::NAryMatIterator	access:public
as	flann/matrix.h	/^    Matrix<T> as()$/;"	f	class:cvflann::UntypedMatrix	access:public	signature:()
ascii	core/core_c.h	/^    const int*  ascii; 			\/* font data and metrics *\/$/;"	m	struct:CvFont	access:public
ask_for_proj	contrib/contrib.hpp	/^        void ask_for_proj(CvMat &_vis,bool once=false);$/;"	p	class:cv::LevMarqSparse	access:public	signature:(CvMat &_vis,bool once=false)
ask_for_projac	contrib/contrib.hpp	/^        void ask_for_projac(CvMat &_vis);$/;"	p	class:cv::LevMarqSparse	access:public	signature:(CvMat &_vis)
assertTest	gpu/NCV.hpp	/^    struct assertTest{};$/;"	s	namespace:NcvCTprep
assign	core/mat.hpp	/^    virtual void assign(const MatExpr& expr, Mat& m, int type=-1) const = 0;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m, int type=-1) const
assign	flann/any.h	/^    any& assign(const T& x)$/;"	f	struct:cdiggins::any	access:public	signature:(const T& x)
assign	flann/any.h	/^    any& assign(const any& x)$/;"	f	struct:cdiggins::any	access:public	signature:(const any& x)
assignTo	core/core.hpp	/^    void assignTo( Mat& m, int type=-1 ) const;$/;"	p	class:cv::Mat	access:public	signature:( Mat& m, int type=-1 ) const
assignTo	core/core.hpp	/^    void assignTo( SparseMat& m, int type=-1 ) const;$/;"	p	class:cv::SparseMat	access:public	signature:( SparseMat& m, int type=-1 ) const
assignTo	core/mat.hpp	/^inline void Mat::assignTo( Mat& m, int type ) const$/;"	f	class:cv::Mat	signature:( Mat& m, int type ) const
assignTo	core/mat.hpp	/^inline void SparseMat::assignTo( SparseMat& m, int type ) const$/;"	f	class:cv::SparseMat	signature:( SparseMat& m, int type ) const
assignTo	gpu/gpumat.hpp	/^        void assignTo( GpuMat& m, int type=-1 ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( GpuMat& m, int type=-1 ) const
assignTo	gpu/gpumat.hpp	/^    inline void GpuMat::assignTo(GpuMat& m, int type) const$/;"	f	class:cv::gpu::GpuMat	signature:(GpuMat& m, int type) const
at	core/core.hpp	/^    template<typename _Tp, int n> _Tp& at(const Vec<int, n>& idx);$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx)
at	core/core.hpp	/^    template<typename _Tp, int n> const _Tp& at(const Vec<int, n>& idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx) const
at	core/core.hpp	/^    template<typename _Tp> _Tp& at(Point pt);$/;"	p	class:cv::Mat	access:public	signature:(Point pt)
at	core/core.hpp	/^    template<typename _Tp> _Tp& at(const int* idx);$/;"	p	class:cv::Mat	access:public	signature:(const int* idx)
at	core/core.hpp	/^    template<typename _Tp> _Tp& at(int i0, int i1);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1)
at	core/core.hpp	/^    template<typename _Tp> _Tp& at(int i0, int i1, int i2);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2)
at	core/core.hpp	/^    template<typename _Tp> _Tp& at(int i0=0);$/;"	p	class:cv::Mat	access:public	signature:(int i0=0)
at	core/core.hpp	/^    template<typename _Tp> const _Tp& at(Point pt) const;$/;"	p	class:cv::Mat	access:public	signature:(Point pt) const
at	core/core.hpp	/^    template<typename _Tp> const _Tp& at(const int* idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const int* idx) const
at	core/core.hpp	/^    template<typename _Tp> const _Tp& at(int i0, int i1) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1) const
at	core/core.hpp	/^    template<typename _Tp> const _Tp& at(int i0, int i1, int i2) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2) const
at	core/core.hpp	/^    template<typename _Tp> const _Tp& at(int i0=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0=0) const
at	core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat::at(Point pt)$/;"	f	class:cv::Mat	signature:(Point pt)
at	core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat::at(const int* idx)$/;"	f	class:cv::Mat	signature:(const int* idx)
at	core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat::at(int i0)$/;"	f	class:cv::Mat	signature:(int i0)
at	core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat::at(int i0, int i1)$/;"	f	class:cv::Mat	signature:(int i0, int i1)
at	core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat::at(int i0, int i1, int i2)$/;"	f	class:cv::Mat	signature:(int i0, int i1, int i2)
at	core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat::at(Point pt) const$/;"	f	class:cv::Mat	signature:(Point pt) const
at	core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat::at(const int* idx) const$/;"	f	class:cv::Mat	signature:(const int* idx) const
at	core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat::at(int i0) const$/;"	f	class:cv::Mat	signature:(int i0) const
at	core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat::at(int i0, int i1) const$/;"	f	class:cv::Mat	signature:(int i0, int i1) const
at	core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat::at(int i0, int i1, int i2) const$/;"	f	class:cv::Mat	signature:(int i0, int i1, int i2) const
attach	legacy/legacy.hpp	/^    void attach( IplImage* img, bool use_refcount=true )$/;"	f	class:CvImage	access:public	signature:( IplImage* img, bool use_refcount=true )
attempts	features2d/features2d.hpp	/^    int attempts;$/;"	m	class:cv::BOWKMeansTrainer	access:protected
attr	core/types_c.h	/^    const char** attr;         \/* NULL-terminated array of (attribute_name,attribute_value) pairs. *\/$/;"	m	struct:CvAttrList	access:public
augAssignAdd	core/mat.hpp	/^    virtual void augAssignAdd(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
augAssignAnd	core/mat.hpp	/^    virtual void augAssignAnd(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
augAssignDivide	core/mat.hpp	/^    virtual void augAssignDivide(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
augAssignMultiply	core/mat.hpp	/^    virtual void augAssignMultiply(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
augAssignOr	core/mat.hpp	/^    virtual void augAssignOr(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
augAssignSubtract	core/mat.hpp	/^    virtual void augAssignSubtract(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
augAssignXor	core/mat.hpp	/^    virtual void augAssignXor(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
autoParams	contrib/contrib.hpp	/^        void autoParams();$/;"	p	class:cv::StereoVar	access:private	signature:()
avergeTexThreshold	gpu/gpu.hpp	/^            float avergeTexThreshold;$/;"	m	class:cv::gpu::StereoBM_GPU	access:public
avg	ml/ml.hpp	/^    CvMat** avg;$/;"	m	class:CvNormalBayesClassifier	access:protected
b	core/mat.hpp	/^    Mat a, b, c;$/;"	m	class:cv::MatExpr	access:public
b	ml/ml.hpp	/^    double* b;$/;"	m	class:CvSVMSolver	access:public
b	objdetect/objdetect.hpp	/^	float* b;$/;"	m	struct:CvLatentSvmDetector	access:public
bReused	gpu/NCV.hpp	/^    NcvBool bReused;$/;"	m	class:NCVMatrixReuse	access:private
bReused	gpu/NCV.hpp	/^    NcvBool bReused;$/;"	m	class:NCVVectorReuse	access:private
bReusesMemory	gpu/NCV.hpp	/^    NcvBool bReusesMemory;$/;"	m	class:NCVMemStackAllocator	access:private
bShadowDetection	video/background_segm.hpp	/^    bool bShadowDetection;\/\/default 1 - do shadow detection$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
back	core/core.hpp	/^    _Tp& back();$/;"	p	class:cv::Seq	access:public	signature:()
back	core/core.hpp	/^    const _Tp& back() const;$/;"	p	class:cv::Seq	access:public	signature:() const
back	core/operations.hpp	/^    _Tp& back() { CV_DbgAssert(!empty()); return hdr.data[hdr.size-1]; }$/;"	f	class:cv::Vector	access:public	signature:()
back	core/operations.hpp	/^    const _Tp& back() const { CV_DbgAssert(!empty()); return hdr.data[hdr.size-1]; }$/;"	f	class:cv::Vector	access:public	signature:() const
back	core/operations.hpp	/^template<typename _Tp> inline _Tp& Seq<_Tp>::back()$/;"	f	class:cv::Seq	signature:()
back	core/operations.hpp	/^template<typename _Tp> inline const _Tp& Seq<_Tp>::back() const$/;"	f	class:cv::Seq	signature:() const
backProject	core/core.hpp	/^    Mat backProject(InputArray vec) const;$/;"	p	class:cv::PCA	access:public	signature:(InputArray vec) const
backProject	core/core.hpp	/^    void backProject(InputArray vec, OutputArray result) const;$/;"	p	class:cv::PCA	access:public	signature:(InputArray vec, OutputArray result) const
backSubst	core/core.hpp	/^    static void backSubst( InputArray w, InputArray u,$/;"	p	class:cv::SVD	access:public	signature:( InputArray w, InputArray u, InputArray vt, InputArray rhs, OutputArray dst )
backSubst	core/core.hpp	/^    template<typename _Tp, int m, int n, int nm, int nb> static void backSubst( const Matx<_Tp, nm, 1>& w,$/;"	p	class:cv::SVD	access:public	signature:( const Matx<_Tp, nm, 1>& w, const Matx<_Tp, m, nm>& u, const Matx<_Tp, n, nm>& vt, const Matx<_Tp, m, nb>& rhs, Matx<_Tp, n, nb>& dst )
backSubst	core/core.hpp	/^    void backSubst( InputArray rhs, OutputArray dst ) const;$/;"	p	class:cv::SVD	access:public	signature:( InputArray rhs, OutputArray dst ) const
backSubst	core/mat.hpp	/^SVD::backSubst( const Matx<_Tp, nm, 1>& w, const Matx<_Tp, m, nm>& u,$/;"	f	class:cv::SVD	signature:( const Matx<_Tp, nm, 1>& w, const Matx<_Tp, m, nm>& u, const Matx<_Tp, n, nm>& vt, const Matx<_Tp, m, nb>& rhs, Matx<_Tp, n, nb>& dst )
backgroundMax	features2d/features2d.hpp	/^    double backgroundMin, backgroundMax;$/;"	m	class:cv::PatchGenerator	access:public
backgroundMin	features2d/features2d.hpp	/^    double backgroundMin, backgroundMax;$/;"	m	class:cv::PatchGenerator	access:public
backgroundRatio	video/background_segm.hpp	/^    double backgroundRatio;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
backgroundRatio	video/background_segm.hpp	/^    float backgroundRatio;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
bad_any_cast	flann/any.h	/^struct bad_any_cast$/;"	s	namespace:cdiggins::anyimpl
base	features2d/features2d.hpp	/^    Ptr<OneWayDescriptorBase> base;$/;"	m	class:cv::OneWayDescriptorMatcher	access:protected
base	flann/allocator.h	/^    void*   base;     \/* Pointer to base of current block of storage. *\/$/;"	m	class:cvflann::PooledAllocator	access:private
baseFeatureSize	features2d/features2d.hpp	/^    double baseFeatureSize;$/;"	m	class:cv::LDetector	access:public
base_any_policy	flann/any.h	/^struct base_any_policy$/;"	s	namespace:cdiggins::anyimpl
base_value	ml/ml.hpp	/^    float base_value;$/;"	m	class:CvGBTrees	access:protected
beg1	legacy/blobtrack.hpp	/^    int beg1,beg2;$/;"	m	struct:CvTracksTimePos	access:public
beg2	legacy/blobtrack.hpp	/^    int beg1,beg2;$/;"	m	struct:CvTracksTimePos	access:public
begin	contrib/contrib.hpp	/^            int begin, end;$/;"	m	struct:cv::Octree::Node	access:public
begin	core/core.hpp	/^    FileNodeIterator begin() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
begin	core/core.hpp	/^    SeqIterator<_Tp> begin() const;$/;"	p	class:cv::Seq	access:public	signature:() const
begin	core/core.hpp	/^    SparseMatConstIterator begin() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
begin	core/core.hpp	/^    SparseMatConstIterator_<_Tp> begin() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
begin	core/core.hpp	/^    SparseMatIterator begin();$/;"	p	class:cv::SparseMat	access:public	signature:()
begin	core/core.hpp	/^    SparseMatIterator_<_Tp> begin();$/;"	p	class:cv::SparseMat_	access:public	signature:()
begin	core/core.hpp	/^    const_iterator begin() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
begin	core/core.hpp	/^    iterator begin();$/;"	p	class:cv::Mat_	access:public	signature:()
begin	core/core.hpp	/^    template<typename _Tp> MatConstIterator_<_Tp> begin() const;$/;"	p	class:cv::Mat	access:public	signature:() const
begin	core/core.hpp	/^    template<typename _Tp> MatIterator_<_Tp> begin();$/;"	p	class:cv::Mat	access:public	signature:()
begin	core/core.hpp	/^    template<typename _Tp> SparseMatConstIterator_<_Tp> begin() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
begin	core/core.hpp	/^    template<typename _Tp> SparseMatIterator_<_Tp> begin();$/;"	p	class:cv::SparseMat	access:public	signature:()
begin	core/mat.hpp	/^inline SparseMatConstIterator SparseMat::begin() const$/;"	f	class:cv::SparseMat	signature:() const
begin	core/mat.hpp	/^inline SparseMatIterator SparseMat::begin()$/;"	f	class:cv::SparseMat	signature:()
begin	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> Mat::begin() const$/;"	f	class:cv::Mat	signature:() const
begin	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> Mat_<_Tp>::begin() const$/;"	f	class:cv::Mat_	signature:() const
begin	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> Mat::begin()$/;"	f	class:cv::Mat	signature:()
begin	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> Mat_<_Tp>::begin()$/;"	f	class:cv::Mat_	signature:()
begin	core/mat.hpp	/^template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat::begin() const$/;"	f	class:cv::SparseMat	signature:() const
begin	core/mat.hpp	/^template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat_<_Tp>::begin() const$/;"	f	class:cv::SparseMat_	signature:() const
begin	core/mat.hpp	/^template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat::begin()$/;"	f	class:cv::SparseMat	signature:()
begin	core/mat.hpp	/^template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat_<_Tp>::begin()$/;"	f	class:cv::SparseMat_	signature:()
begin	core/operations.hpp	/^    _Tp* begin() { return hdr.data; }$/;"	f	class:cv::Vector	access:public	signature:()
begin	core/operations.hpp	/^    const _Tp* begin() const { return hdr.data; }$/;"	f	class:cv::Vector	access:public	signature:() const
begin	core/operations.hpp	/^inline FileNodeIterator FileNode::begin() const$/;"	f	class:cv::FileNode	signature:() const
begin	core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp> Seq<_Tp>::begin() const$/;"	f	class:cv::Seq	signature:() const
begin	gpu/NCV.hpp	/^    NCVMemPtr begin;$/;"	m	struct:NCVMemSegment	access:public
begin	gpu/NCV.hpp	/^    Ncv8u *begin;$/;"	m	class:NCVMemStackAllocator	access:private
begin	gpu/devmem2d.hpp	/^            thrust::device_ptr<T> begin() const { return thrust::device_ptr<T>(data); }$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:() const
begin	gpu/devmem2d.hpp	/^            thrust::device_ptr<T> begin() const { return thrust::device_ptr<T>(data); }$/;"	f	struct:cv::gpu::PtrStep_	access:public	signature:() const
bestIndex_	flann/autotuned_index.h	/^    NNIndex<Distance>* bestIndex_;$/;"	m	class:cvflann::AutotunedIndex	access:private
bestParams_	flann/autotuned_index.h	/^    IndexParams bestParams_;$/;"	m	class:cvflann::AutotunedIndex	access:private
bestSearchParams_	flann/autotuned_index.h	/^    SearchParams bestSearchParams_;$/;"	m	class:cvflann::AutotunedIndex	access:private
best_score	legacy/legacy.hpp	/^    int best_score;$/;"	m	struct:CvCliqueFinder	access:public
best_weight	legacy/legacy.hpp	/^    float best_weight;$/;"	m	struct:CvCliqueFinder	access:public
beta	core/mat.hpp	/^    double alpha, beta;$/;"	m	class:cv::MatExpr	access:public
between	contrib/contrib.hpp	/^    bool between(double x, double x1, double x2);$/;"	p	class:CvFuzzyCurve	access:private	signature:(double x, double x1, double x2)
bg_model	video/background_segm.hpp	/^CVAPI(void) cvReleaseBGStatModel( CvBGStatModel** bg_model );$/;"	v
bg_threshold	video/background_segm.hpp	/^    double  bg_threshold, std_threshold, minArea;$/;"	m	struct:CvGaussBGStatModelParams	access:public
bgmodel	video/background_segm.hpp	/^    Mat bgmodel;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
bgmodel	video/background_segm.hpp	/^    Mat bgmodel;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
bgmodelUsedModes	video/background_segm.hpp	/^    Mat bgmodelUsedModes;\/\/keep track of number of modes per pixel$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
big_any_policy	flann/any.h	/^struct big_any_policy : typed_base_any_policy<T>$/;"	s	namespace:cdiggins::anyimpl	inherits:typed_base_any_policy
bilateralFilter	imgproc/imgproc.hpp	/^CV_EXPORTS_W void bilateralFilter( InputArray src, OutputArray dst, int d,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType=BORDER_DEFAULT )
binSize	contrib/contrib.hpp	/^        float binSize;$/;"	m	class:cv::SpinImageModel	access:public
bins	core/types_c.h	/^    CvArr*  bins;$/;"	m	struct:CvHistogram	access:public
bitset_	flann/dynamic_bitset.h	/^    std::vector<size_t> bitset_;$/;"	m	class:DynamicBitset	access:private
bitwise_and	core/core.hpp	/^CV_EXPORTS_W void bitwise_and(InputArray src1, InputArray src2,$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst, InputArray mask=noArray())
bitwise_and	gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_and(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat(), Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat(), Stream& stream = Stream::Null())
bitwise_not	core/core.hpp	/^CV_EXPORTS_W void bitwise_not(InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, InputArray mask=noArray())
bitwise_not	gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_not(const GpuMat& src, GpuMat& dst, const GpuMat& mask=GpuMat(), Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, const GpuMat& mask=GpuMat(), Stream& stream = Stream::Null())
bitwise_or	core/core.hpp	/^CV_EXPORTS_W void bitwise_or(InputArray src1, InputArray src2,$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst, InputArray mask=noArray())
bitwise_or	gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_or(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat(), Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat(), Stream& stream = Stream::Null())
bitwise_xor	core/core.hpp	/^CV_EXPORTS_W void bitwise_xor(InputArray src1, InputArray src2,$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst, InputArray mask=noArray())
bitwise_xor	gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_xor(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat(), Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat(), Stream& stream = Stream::Null())
blendLinear	gpu/gpu.hpp	/^        CV_EXPORTS void blendLinear(const GpuMat& img1, const GpuMat& img2, const GpuMat& weights1, const GpuMat& weights2, $/;"	p	namespace:cv::gpu	signature:(const GpuMat& img1, const GpuMat& img2, const GpuMat& weights1, const GpuMat& weights2, GpuMat& result, Stream& stream = Stream::Null())
blobColor	features2d/features2d.hpp	/^      uchar blobColor;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
blockSize	features2d/features2d.hpp	/^        int blockSize;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
blockSize	objdetect/objdetect.hpp	/^    CV_PROP Size blockSize;$/;"	m	struct:cv::HOGDescriptor	access:public
blockStride	objdetect/objdetect.hpp	/^    CV_PROP Size blockStride;$/;"	m	struct:cv::HOGDescriptor	access:public
block_hists	gpu/gpu.hpp	/^            GpuMat block_hists, block_hists_buf;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
block_hists_buf	gpu/gpu.hpp	/^            GpuMat block_hists, block_hists_buf;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
block_size	core/types_c.h	/^    int block_size;               \/* Block size.                              *\/$/;"	m	struct:CvMemStorage	access:public
block_size	gpu/gpu.hpp	/^            Size block_size;$/;"	m	struct:cv::gpu::ConvolveBuf	access:private
block_size	gpu/gpu.hpp	/^            Size block_size;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
block_stride	gpu/gpu.hpp	/^            Size block_stride;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
blocksize	flann/allocator.h	/^    int     blocksize;$/;"	m	class:cvflann::PooledAllocator	access:private
blur	gpu/gpu.hpp	/^        static inline void blur(const GpuMat& src, GpuMat& dst, Size ksize, Point anchor = Point(-1,-1), Stream& stream = Stream::Null()) { boxFilter(src, dst, -1, ksize, anchor, stream); }$/;"	f	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Size ksize, Point anchor = Point(-1,-1), Stream& stream = Stream::Null())
blur	imgproc/imgproc.hpp	/^CV_EXPORTS_W void blur( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, Size ksize, Point anchor=Point(-1,-1), int borderType=BORDER_DEFAULT )
boost_type	ml/ml.hpp	/^    CV_PROP_RW int boost_type;$/;"	m	struct:CvBoostParams	access:public
border	legacy/legacy.hpp	/^    CvPoint2D32f border[2][4];$/;"	m	struct:CvStereoCamera	access:public
borderElemSize	imgproc/imgproc.hpp	/^    int borderElemSize;$/;"	m	class:cv::FilterEngine	access:public
borderInterpolate	imgproc/imgproc.hpp	/^CV_EXPORTS_W int borderInterpolate( int p, int len, int borderType );$/;"	p	namespace:cv	signature:( int p, int len, int borderType )
borderTab	imgproc/imgproc.hpp	/^    vector<int> borderTab;$/;"	m	class:cv::FilterEngine	access:public
bottom	core/types_c.h	/^    CvMemBlock* bottom;           \/* First allocated block.                   *\/$/;"	m	struct:CvMemStorage	access:public
bottomRight	imgproc/imgproc.hpp	/^    Point2f bottomRight;$/;"	m	class:cv::Subdiv2D	access:protected
bottomline	legacy/compat.hpp	/^    float*  bottomline;$/;"	m	struct:_CvPixelPosition32f	access:public
bottomline	legacy/compat.hpp	/^    schar*  bottomline;$/;"	m	struct:_CvPixelPosition8s	access:public
bottomline	legacy/compat.hpp	/^    uchar*  bottomline;    \/* pointer to the start of the first line           *\/$/;"	m	struct:_CvPixelPosition8u	access:public
boundary	core/core.hpp	/^        float boundary;$/;"	m	struct:cv::KDTree::Node	access:public
boundingRect	core/core.hpp	/^    Rect boundingRect() const;$/;"	p	class:cv::RotatedRect	access:public	signature:() const
boundingRect	imgproc/imgproc.hpp	/^CV_EXPORTS_W Rect boundingRect( InputArray points );$/;"	p	namespace:cv	signature:( InputArray points )
boxFilter	gpu/gpu.hpp	/^        CV_EXPORTS void boxFilter(const GpuMat& src, GpuMat& dst, int ddepth, Size ksize, Point anchor = Point(-1,-1), Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, Size ksize, Point anchor = Point(-1,-1), Stream& stream = Stream::Null())
boxFilter	imgproc/imgproc.hpp	/^CV_EXPORTS_W void boxFilter( InputArray src, OutputArray dst, int ddepth,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor=Point(-1,-1), bool normalize=true, int borderType=BORDER_DEFAULT )
boxMax	video/background_segm.hpp	/^    uchar boxMax[3];$/;"	m	struct:CvBGCodeBookElem	access:public
boxMin	video/background_segm.hpp	/^    uchar boxMin[3];$/;"	m	struct:CvBGCodeBookElem	access:public
bp_dw_scale	ml/ml.hpp	/^    CV_PROP_RW double bp_dw_scale, bp_moment_scale;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
bp_moment_scale	ml/ml.hpp	/^    CV_PROP_RW double bp_dw_scale, bp_moment_scale;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
br	core/core.hpp	/^    Point_<_Tp> br() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
br	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp> Rect_<_Tp>::br() const { return Point_<_Tp>(x+width, y+height); }$/;"	f	class:cv::Rect_	signature:() const
branching_	flann/hierarchical_clustering_index.h	/^    int branching_;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
branching_	flann/kmeans_index.h	/^    int branching_;$/;"	m	class:cvflann::KMeansIndex	access:private
bucket_size_max_	flann/lsh_table.h	/^    size_t bucket_size_max_;$/;"	m	struct:cvflann::lsh::LshStats	access:public
bucket_size_mean_	flann/lsh_table.h	/^    size_t bucket_size_mean_;$/;"	m	struct:cvflann::lsh::LshStats	access:public
bucket_size_median_	flann/lsh_table.h	/^    size_t bucket_size_median_;$/;"	m	struct:cvflann::lsh::LshStats	access:public
bucket_size_min_	flann/lsh_table.h	/^    size_t bucket_size_min_;$/;"	m	struct:cvflann::lsh::LshStats	access:public
bucket_size_std_dev	flann/lsh_table.h	/^    size_t bucket_size_std_dev;$/;"	m	struct:cvflann::lsh::LshStats	access:public
bucket_sizes_	flann/lsh_table.h	/^    std::vector<unsigned int> bucket_sizes_;$/;"	m	struct:cvflann::lsh::LshStats	access:public
buckets_space_	flann/lsh_table.h	/^    BucketsSpace buckets_space_;$/;"	m	class:cvflann::lsh::LshTable	access:private
buckets_speed_	flann/lsh_table.h	/^    BucketsSpeed buckets_speed_;$/;"	m	class:cvflann::lsh::LshTable	access:private
buf	core/core.hpp	/^        size_t buf[2];$/;"	m	struct:cv::Mat::MStep	access:public
buf	core/core.hpp	/^    _Tp buf[fixed_size+buffer_padding];$/;"	m	class:cv::AutoBuffer	access:protected
buf	gpu/gpu.hpp	/^            GpuMat buf;$/;"	m	struct:cv::gpu::PyrDownBuf	access:private
buf	gpu/gpu.hpp	/^            GpuMat buf;$/;"	m	struct:cv::gpu::PyrUpBuf	access:private
buf	ml/ml.hpp	/^    CvMat* buf;$/;"	m	struct:CvDTreeTrainData	access:public
buf	ml/ml.hpp	/^    float* buf[2];$/;"	m	class:CvSVMSolver	access:public
bufStep	imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
bufType	imgproc/imgproc.hpp	/^    int srcType, dstType, bufType;$/;"	m	class:cv::FilterEngine	access:public
buf_count	ml/ml.hpp	/^    int buf_count, buf_size;$/;"	m	struct:CvDTreeTrainData	access:public
buf_idx	ml/ml.hpp	/^    int buf_idx;$/;"	m	struct:CvDTreeNode	access:public
buf_size	ml/ml.hpp	/^    int buf_count, buf_size;$/;"	m	struct:CvDTreeTrainData	access:public
buffer	calib3d/calib3d.hpp	/^    Mat buffer;$/;"	m	class:cv::StereoSGBM	access:protected
buffer_padding	core/core.hpp	/^    enum { buffer_padding = (int)((16 + sizeof(_Tp) - 1)\/sizeof(_Tp)) };$/;"	e	enum:cv::AutoBuffer::__anon145
build	core/core.hpp	/^    CV_WRAP void build(InputArray points, InputArray labels,$/;"	p	class:cv::KDTree	access:public	signature:(InputArray points, InputArray labels, bool copyAndReorderPoints=false)
build	core/core.hpp	/^    CV_WRAP void build(InputArray points, bool copyAndReorderPoints=false);$/;"	p	class:cv::KDTree	access:public	signature:(InputArray points, bool copyAndReorderPoints=false)
build	flann/miniflann.hpp	/^    CV_WRAP virtual void build(InputArray features, const IndexParams& params, cvflann::flann_distance_t distType=cvflann::FLANN_DIST_L2);$/;"	p	class:cv::flann::Index	access:public	signature:(InputArray features, const IndexParams& params, cvflann::flann_distance_t distType=cvflann::FLANN_DIST_L2)
buildIndex	flann/autotuned_index.h	/^    virtual void buildIndex()$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:()
buildIndex	flann/composite_index.h	/^    void buildIndex()$/;"	f	class:cvflann::CompositeIndex	access:public	signature:()
buildIndex	flann/flann_base.hpp	/^    void buildIndex()$/;"	f	class:cvflann::Index	access:public	signature:()
buildIndex	flann/hierarchical_clustering_index.h	/^    void buildIndex()$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:public	signature:()
buildIndex	flann/kdtree_index.h	/^    void buildIndex()$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:()
buildIndex	flann/kdtree_single_index.h	/^    void buildIndex()$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:()
buildIndex	flann/kmeans_index.h	/^    void buildIndex()$/;"	f	class:cvflann::KMeansIndex	access:public	signature:()
buildIndex	flann/linear_index.h	/^    void buildIndex()$/;"	f	class:cvflann::LinearIndex	access:public	signature:()
buildIndex	flann/lsh_index.h	/^    void buildIndex()$/;"	f	class:cvflann::LshIndex	access:public	signature:()
buildIndex	flann/nn_index.h	/^    virtual void buildIndex() = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:()
buildNext	contrib/contrib.hpp	/^        virtual void buildNext(size_t node_ind);$/;"	p	class:cv::Octree	access:private	signature:(size_t node_ind)
buildOctree	contrib/contrib.hpp	/^        void buildOctree();$/;"	p	class:cv::Mesh3D	access:public	signature:()
buildPyramid	imgproc/imgproc.hpp	/^CV_EXPORTS void buildPyramid( InputArray src, OutputArrayOfArrays dst, int maxlevel );$/;"	p	namespace:cv	signature:( InputArray src, OutputArrayOfArrays dst, int maxlevel )
buildTimeCost	flann/autotuned_index.h	/^        float buildTimeCost;$/;"	m	struct:cvflann::AutotunedIndex::CostData	access:public
buildTree	contrib/contrib.hpp	/^        virtual void buildTree( const vector<Point3f>& points, int maxLevels = 10, int minPoints = 20 );$/;"	p	class:cv::Octree	access:public	signature:( const vector<Point3f>& points, int maxLevels = 10, int minPoints = 20 )
buildWarpCylindricalMaps	gpu/gpu.hpp	/^        CV_EXPORTS void buildWarpCylindricalMaps(Size src_size, Rect dst_roi, const Mat& R, double f, double s,$/;"	p	namespace:cv::gpu	signature:(Size src_size, Rect dst_roi, const Mat& R, double f, double s, GpuMat& map_x, GpuMat& map_y, Stream& stream = Stream::Null())
buildWarpPlaneMaps	gpu/gpu.hpp	/^        CV_EXPORTS void buildWarpPlaneMaps(Size src_size, Rect dst_roi, const Mat& R, double f, double s, double dist,$/;"	p	namespace:cv::gpu	signature:(Size src_size, Rect dst_roi, const Mat& R, double f, double s, double dist, GpuMat& map_x, GpuMat& map_y, Stream& stream = Stream::Null())
buildWarpSphericalMaps	gpu/gpu.hpp	/^        CV_EXPORTS void buildWarpSphericalMaps(Size src_size, Rect dst_roi, const Mat& R, double f, double s,$/;"	p	namespace:cv::gpu	signature:(Size src_size, Rect dst_roi, const Mat& R, double f, double s, GpuMat& map_x, GpuMat& map_y, Stream& stream = Stream::Null())
build_weight_	flann/autotuned_index.h	/^    float build_weight_;$/;"	m	class:cvflann::AutotunedIndex	access:private
builtWith	gpu/gpu.hpp	/^            static bool builtWith(FeatureSet feature_set);$/;"	p	class:cv::gpu::TargetArchs	access:public	signature:(FeatureSet feature_set)
bundleAdjust	contrib/contrib.hpp	/^        static void bundleAdjust(vector<Point3d>& points, \/\/ positions of points in global coordinate system (input and output)$/;"	p	class:cv::LevMarqSparse	access:public	signature:(vector<Point3d>& points, const vector<vector<Point2d> >& imagePoints, const vector<vector<int> >& visibility, vector<Mat>& cameraMatrix, vector<Mat>& R, vector<Mat>& T, vector<Mat>& distCoeffs, const TermCriteria& criteria= TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, DBL_EPSILON), BundleAdjustCallback cb = 0, void* user_data = 0)
byteBitsLookUp	features2d/features2d.hpp	/^    static unsigned char byteBitsLookUp(unsigned char b);$/;"	p	struct:cv::HammingLUT	access:public	signature:(unsigned char b)
byteBitsLookUp	flann/dist.h	/^    static unsigned char byteBitsLookUp(unsigned char b)$/;"	f	struct:cvflann::HammingLUT	access:public	signature:(unsigned char b)
bytes_	features2d/features2d.hpp	/^    int bytes_;$/;"	m	class:cv::BriefDescriptorExtractor	access:protected
c	core/mat.hpp	/^    Mat a, b, c;$/;"	m	class:cv::MatExpr	access:public
c	ml/ml.hpp	/^            float c;$/;"	m	struct:CvDTreeSplit::__anon77::__anon78	access:public
c	ml/ml.hpp	/^    CvMat*  c;$/;"	m	class:CvNormalBayesClassifier	access:protected
cache_line_size	ml/ml.hpp	/^    int cache_line_size;$/;"	m	class:CvSVMSolver	access:public
cache_size	ml/ml.hpp	/^    int cache_size;$/;"	m	class:CvSVMSolver	access:public
calc	ml/ml.hpp	/^    virtual void calc( int vcount, int n, const float** vecs, const float* another, float* results );$/;"	p	struct:CvSVMKernel	access:public	signature:( int vcount, int n, const float** vecs, const float* another, float* results )
calcBackProject	imgproc/imgproc.hpp	/^CV_EXPORTS void calcBackProject( const Mat* images, int nimages,$/;"	p	namespace:cv	signature:( const Mat* images, int nimages, const int* channels, InputArray hist, OutputArray backProject, const float** ranges, double scale=1, bool uniform=true )
calcBackProject	imgproc/imgproc.hpp	/^CV_EXPORTS void calcBackProject( const Mat* images, int nimages,$/;"	p	namespace:cv	signature:( const Mat* images, int nimages, const int* channels, const SparseMat& hist, OutputArray backProject, const float** ranges, double scale=1, bool uniform=true )
calcBackProject	imgproc/imgproc.hpp	/^CV_EXPORTS_W void calcBackProject( InputArrayOfArrays images, const vector<int>& channels,$/;"	p	namespace:cv	signature:( InputArrayOfArrays images, const vector<int>& channels, InputArray hist, OutputArray dst, const vector<float>& ranges, double scale )
calcBestProbAndMatchIdx	features2d/features2d.hpp	/^    void calcBestProbAndMatchIdx( const Mat& image, const Point2f& pt,$/;"	p	class:cv::FernDescriptorMatcher	access:protected	signature:( const Mat& image, const Point2f& pt, float& bestProb, int& bestMatchIdx, vector<float>& signature )
calcCat	objdetect/objdetect.hpp	/^    virtual int calcCat(int featureIdx) const;$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(int featureIdx) const
calcCovarMatrix	core/core.hpp	/^CV_EXPORTS void calcCovarMatrix( const Mat* samples, int nsamples, Mat& covar, Mat& mean,$/;"	p	namespace:cv	signature:( const Mat* samples, int nsamples, Mat& covar, Mat& mean, int flags, int ctype=CV_64F)
calcCovarMatrix	core/core.hpp	/^CV_EXPORTS_W void calcCovarMatrix( InputArray samples, OutputArray covar,$/;"	p	namespace:cv	signature:( InputArray samples, OutputArray covar, OutputArray mean, int flags, int ctype=CV_64F)
calcGlobalOrientation	video/tracking.hpp	/^CV_EXPORTS_W double calcGlobalOrientation( InputArray orientation, InputArray mask,$/;"	p	namespace:cv	signature:( InputArray orientation, InputArray mask, InputArray mhi, double timestamp, double duration )
calcHist	gpu/gpu.hpp	/^        CV_EXPORTS void calcHist(const GpuMat& src, GpuMat& hist, GpuMat& buf, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& hist, GpuMat& buf, Stream& stream = Stream::Null())
calcHist	gpu/gpu.hpp	/^        CV_EXPORTS void calcHist(const GpuMat& src, GpuMat& hist, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& hist, Stream& stream = Stream::Null())
calcHist	imgproc/imgproc.hpp	/^CV_EXPORTS void calcHist( const Mat* images, int nimages,$/;"	p	namespace:cv	signature:( const Mat* images, int nimages, const int* channels, InputArray mask, OutputArray hist, int dims, const int* histSize, const float** ranges, bool uniform=true, bool accumulate=false )
calcHist	imgproc/imgproc.hpp	/^CV_EXPORTS void calcHist( const Mat* images, int nimages,$/;"	p	namespace:cv	signature:( const Mat* images, int nimages, const int* channels, InputArray mask, SparseMat& hist, int dims, const int* histSize, const float** ranges, bool uniform=true, bool accumulate=false )
calcHist	imgproc/imgproc.hpp	/^CV_EXPORTS_W void calcHist( InputArrayOfArrays images,$/;"	p	namespace:cv	signature:( InputArrayOfArrays images, const vector<int>& channels, InputArray mask, OutputArray hist, const vector<int>& histSize, const vector<float>& ranges, bool accumulate=false )
calcLikelihood	ml/ml.hpp	/^    CV_WRAP virtual double calcLikelihood( const cv::Mat &sample ) const;$/;"	p	class:CvEM	access:public	signature:( const cv::Mat &sample ) const
calcMotionGradient	video/tracking.hpp	/^CV_EXPORTS_W void calcMotionGradient( InputArray mhi, OutputArray mask,$/;"	p	namespace:cv	signature:( InputArray mhi, OutputArray mask, OutputArray orientation, double delta1, double delta2, int apertureSize=3 )
calcOpticalFlowFarneback	video/tracking.hpp	/^CV_EXPORTS_W void calcOpticalFlowFarneback( InputArray prev, InputArray next,$/;"	p	namespace:cv	signature:( InputArray prev, InputArray next, CV_OUT InputOutputArray flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags )
calcOpticalFlowPyrLK	video/tracking.hpp	/^CV_EXPORTS_W void calcOpticalFlowPyrLK( InputArray prevImg, InputArray nextImg,$/;"	p	namespace:cv	signature:( InputArray prevImg, InputArray nextImg, InputArray prevPts, CV_OUT InputOutputArray nextPts, OutputArray status, OutputArray err, Size winSize=Size(21,21), int maxLevel=3, TermCriteria criteria=TermCriteria( TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), double derivLambda=0.5, int flags=0, double minEigThreshold=1e-4)
calcOrd	objdetect/objdetect.hpp	/^    virtual double calcOrd(int featureIdx) const;$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(int featureIdx) const
calcOutput	contrib/contrib.hpp	/^        int calcOutput(double edgeDensity, double density);$/;"	p	class:CvFuzzyMeanShiftTracker::FuzzyResizer	access:public	signature:(double edgeDensity, double density)
calcOutput	contrib/contrib.hpp	/^    double calcOutput(double param1, double param2);$/;"	p	class:CvFuzzyController	access:public	signature:(double param1, double param2)
calcSpinMapCoo	contrib/contrib.hpp	/^        static Point2f calcSpinMapCoo(const Point3f& point, const Point3f& vertex, const Point3f& normal);$/;"	p	class:cv::SpinImageModel	access:public	signature:(const Point3f& point, const Point3f& vertex, const Point3f& normal)
calcValue	contrib/contrib.hpp	/^    double calcValue();$/;"	p	class:CvFuzzyFunction	access:public	signature:()
calcValue	contrib/contrib.hpp	/^    double calcValue(double param);$/;"	p	class:CvFuzzyCurve	access:public	signature:(double param)
calcValue	contrib/contrib.hpp	/^    double calcValue(double param1, double param2);$/;"	p	class:CvFuzzyRule	access:public	signature:(double param1, double param2)
calcVoronoi	imgproc/imgproc.hpp	/^    void calcVoronoi();$/;"	p	class:cv::Subdiv2D	access:protected	signature:()
calc_activ_func	ml/ml.hpp	/^    virtual void calc_activ_func( CvMat* xf, const double* bias ) const;$/;"	p	class:CvANN_MLP	access:protected	signature:( CvMat* xf, const double* bias ) const
calc_activ_func_deriv	ml/ml.hpp	/^    virtual void calc_activ_func_deriv( CvMat* xf, CvMat* deriv, const double* bias ) const;$/;"	p	class:CvANN_MLP	access:public	signature:( CvMat* xf, CvMat* deriv, const double* bias ) const
calc_error	ml/ml.hpp	/^    virtual float calc_error( CvMLData* _data, int type , std::vector<float> *resp = 0 ); \/\/ type in {CV_TRAIN_ERROR, CV_TEST_ERROR}$/;"	p	class:CvBoost	access:public	signature:( CvMLData* _data, int type , std::vector<float> *resp = 0 )
calc_error	ml/ml.hpp	/^    virtual float calc_error( CvMLData* _data, int type , std::vector<float> *resp = 0 ); \/\/ type in {CV_TRAIN_ERROR, CV_TEST_ERROR}$/;"	p	class:CvRTrees	access:public	signature:( CvMLData* _data, int type , std::vector<float> *resp = 0 )
calc_error	ml/ml.hpp	/^    virtual float calc_error( CvMLData* _data, int type,$/;"	p	class:CvGBTrees	access:public	signature:( CvMLData* _data, int type, std::vector<float> *resp = 0 )
calc_error	ml/ml.hpp	/^    virtual float calc_error( CvMLData* trainData, int type, std::vector<float> *resp = 0 );$/;"	p	class:CvDTree	access:public	signature:( CvMLData* trainData, int type, std::vector<float> *resp = 0 )
calc_func	ml/ml.hpp	/^    Calc calc_func;$/;"	m	struct:CvSVMKernel	access:public
calc_input_scale	ml/ml.hpp	/^    virtual void calc_input_scale( const CvVectors* vecs, int flags );$/;"	p	class:CvANN_MLP	access:protected	signature:( const CvVectors* vecs, int flags )
calc_linear	ml/ml.hpp	/^    virtual void calc_linear( int vec_count, int vec_size, const float** vecs,$/;"	p	struct:CvSVMKernel	access:public	signature:( int vec_count, int vec_size, const float** vecs, const float* another, float* results )
calc_node_dir	ml/ml.hpp	/^    virtual double calc_node_dir( CvDTreeNode* n );$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n )
calc_node_dir	ml/ml.hpp	/^    virtual double calc_node_dir( CvDTreeNode* node );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* node )
calc_node_dir	ml/ml.hpp	/^    virtual double calc_node_dir( CvDTreeNode* node );$/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* node )
calc_node_value	ml/ml.hpp	/^    virtual void calc_node_value( CvDTreeNode* n );$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n )
calc_node_value	ml/ml.hpp	/^    virtual void calc_node_value( CvDTreeNode* node );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* node )
calc_non_rbf_base	ml/ml.hpp	/^    virtual void calc_non_rbf_base( int vec_count, int vec_size, const float** vecs,$/;"	p	struct:CvSVMKernel	access:public	signature:( int vec_count, int vec_size, const float** vecs, const float* another, float* results, double alpha, double beta )
calc_output_scale	ml/ml.hpp	/^    virtual void calc_output_scale( const CvVectors* vecs, int flags );$/;"	p	class:CvANN_MLP	access:protected	signature:( const CvVectors* vecs, int flags )
calc_poly	ml/ml.hpp	/^    virtual void calc_poly( int vec_count, int vec_size, const float** vecs,$/;"	p	struct:CvSVMKernel	access:public	signature:( int vec_count, int vec_size, const float** vecs, const float* another, float* results )
calc_rbf	ml/ml.hpp	/^    virtual void calc_rbf( int vec_count, int vec_size, const float** vecs,$/;"	p	struct:CvSVMKernel	access:public	signature:( int vec_count, int vec_size, const float** vecs, const float* another, float* results )
calc_rho	ml/ml.hpp	/^    virtual void calc_rho( double& rho, double& r );$/;"	p	class:CvSVMSolver	access:public	signature:( double& rho, double& r )
calc_rho_func	ml/ml.hpp	/^    CalcRho calc_rho_func;$/;"	m	class:CvSVMSolver	access:public
calc_rho_nu_svm	ml/ml.hpp	/^    virtual void calc_rho_nu_svm( double& rho, double& r );$/;"	p	class:CvSVMSolver	access:public	signature:( double& rho, double& r )
calc_sigmoid	ml/ml.hpp	/^    virtual void calc_sigmoid( int vec_count, int vec_size, const float** vecs,$/;"	p	struct:CvSVMKernel	access:public	signature:( int vec_count, int vec_size, const float** vecs, const float* another, float* results )
calc_var_importance	ml/ml.hpp	/^    CV_PROP_RW bool calc_var_importance; \/\/ true <=> RF processes variable importance$/;"	m	struct:CvRTParams	access:public
calibrateCamera	calib3d/calib3d.hpp	/^CV_EXPORTS_W double calibrateCamera( InputArrayOfArrays objectPoints,$/;"	p	namespace:cv	signature:( InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, CV_OUT InputOutputArray cameraMatrix, CV_OUT InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags=0 )
calibrationMatrixValues	calib3d/calib3d.hpp	/^CV_EXPORTS_W void calibrationMatrixValues( InputArray cameraMatrix,$/;"	p	namespace:cv	signature:( InputArray cameraMatrix, Size imageSize, double apertureWidth, double apertureHeight, CV_OUT double& fovx, CV_OUT double& fovy, CV_OUT double& focalLength, CV_OUT Point2d& principalPoint, CV_OUT double& aspectRatio )
callback	legacy/legacy.hpp	/^    CvCallback callback;$/;"	m	union:__anon182	access:public
camera	legacy/legacy.hpp	/^    CvCamera* camera[2]; \/* two individual camera parameters *\/$/;"	m	struct:CvStereoCamera	access:public
cameraCount	legacy/legacy.hpp	/^    int     cameraCount;$/;"	m	class:CvCalibFilter	access:protected
cameraParams	legacy/legacy.hpp	/^    CvCamera cameraParams[MAX_CAMERAS];$/;"	m	class:CvCalibFilter	access:protected
canMapHostMemory	gpu/gpu.hpp	/^            static bool canMapHostMemory();$/;"	p	class:cv::gpu::CudaMem	access:public	signature:()
cand_weight	legacy/legacy.hpp	/^    float* cand_weight;$/;"	m	struct:CvCliqueFinder	access:public
cap	highgui/highgui.hpp	/^    Ptr<CvCapture> cap;$/;"	m	class:cv::VideoCapture	access:protected
capacity	core/operations.hpp	/^        size_t capacity;$/;"	m	struct:cv::Vector::Hdr	access:public
capacity	core/operations.hpp	/^    size_t capacity() const { return hdr.capacity; }$/;"	f	class:cv::Vector	access:public	signature:() const
capacity	flann/result_set.h	/^    int capacity;$/;"	m	class:cvflann::KNNResultSet	access:private
capacity	flann/result_set.h	/^    int capacity;$/;"	m	class:cvflann::KNNSimpleResultSet	access:private
capacity	flann/result_set.h	/^    size_t capacity;$/;"	m	class:cvflann::RadiusResultSet	access:private
capacity_	flann/result_set.h	/^    unsigned int capacity_;$/;"	m	class:cvflann::KNNRadiusUniqueResultSet	access:private
capacity_	flann/result_set.h	/^    unsigned int capacity_;$/;"	m	class:cvflann::KNNUniqueResultSet	access:protected
capture	highgui/highgui_c.h	/^CVAPI(IplImage*) cvQueryFrame( CvCapture* capture );$/;"	v
capture	highgui/highgui_c.h	/^CVAPI(int)    cvGetCaptureDomain( CvCapture* capture);  $/;"	v
capture	highgui/highgui_c.h	/^CVAPI(int) cvGrabFrame( CvCapture* capture );$/;"	v
capture	highgui/highgui_c.h	/^CVAPI(void) cvReleaseCapture( CvCapture** capture );$/;"	v
cartToPolar	core/core.hpp	/^CV_EXPORTS_W void cartToPolar(InputArray x, InputArray y,$/;"	p	namespace:cv	signature:(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees=false)
cartToPolar	gpu/gpu.hpp	/^        CV_EXPORTS void cartToPolar(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, GpuMat& angle, bool angleInDegrees = false, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, GpuMat& angle, bool angleInDegrees = false, Stream& stream = Stream::Null())
cascade	objdetect/objdetect.hpp	/^CVAPI(void) cvReleaseHaarClassifierCascade( CvHaarClassifierCascade** cascade );$/;"	v
cast	flann/any.h	/^    T& cast()$/;"	f	struct:cdiggins::any	access:public	signature:()
cast	flann/any.h	/^    const T& cast() const$/;"	f	struct:cdiggins::any	access:public	signature:() const
cat_count	ml/ml.hpp	/^    CvMat* cat_count;$/;"	m	struct:CvDTreeTrainData	access:public
cat_map	ml/ml.hpp	/^    CvMat* cat_map;$/;"	m	struct:CvDTreeTrainData	access:public
cat_ofs	ml/ml.hpp	/^    CvMat* cat_ofs;$/;"	m	struct:CvDTreeTrainData	access:public
cat_var_count	ml/ml.hpp	/^    int ord_var_count, cat_var_count, work_var_count;$/;"	m	struct:CvDTreeTrainData	access:public
cb	contrib/contrib.hpp	/^        BundleAdjustCallback cb;$/;"	m	class:cv::LevMarqSparse	access:public
cbBounds	video/background_segm.hpp	/^    uchar cbBounds[3];$/;"	m	struct:CvBGCodeBookModel	access:public
cb_index_	flann/kmeans_index.h	/^    float cb_index_;$/;"	m	class:cvflann::KMeansIndex	access:private
cbmap	video/background_segm.hpp	/^    CvBGCodeBookElem** cbmap;$/;"	m	struct:CvBGCodeBookModel	access:public
cctable	video/background_segm.hpp	/^    CvBGPixelCCStatTable* cctable;$/;"	m	struct:CvBGPixelStat	access:public
cdiggins	flann/any.h	/^namespace cdiggins$/;"	n
cdiggins::any	flann/any.h	/^struct any$/;"	s	namespace:cdiggins
cdiggins::any::any	flann/any.h	/^    any()$/;"	f	struct:cdiggins::any	access:public	signature:()
cdiggins::any::any	flann/any.h	/^    any(const T& x)$/;"	f	struct:cdiggins::any	access:public	signature:(const T& x)
cdiggins::any::any	flann/any.h	/^    any(const any& x)$/;"	f	struct:cdiggins::any	access:public	signature:(const any& x)
cdiggins::any::any	flann/any.h	/^    any(const char* x)$/;"	f	struct:cdiggins::any	access:public	signature:(const char* x)
cdiggins::any::assign	flann/any.h	/^    any& assign(const T& x)$/;"	f	struct:cdiggins::any	access:public	signature:(const T& x)
cdiggins::any::assign	flann/any.h	/^    any& assign(const any& x)$/;"	f	struct:cdiggins::any	access:public	signature:(const any& x)
cdiggins::any::cast	flann/any.h	/^    T& cast()$/;"	f	struct:cdiggins::any	access:public	signature:()
cdiggins::any::cast	flann/any.h	/^    const T& cast() const$/;"	f	struct:cdiggins::any	access:public	signature:() const
cdiggins::any::compatible	flann/any.h	/^    bool compatible(const any& x) const$/;"	f	struct:cdiggins::any	access:public	signature:(const any& x) const
cdiggins::any::empty	flann/any.h	/^    bool empty() const$/;"	f	struct:cdiggins::any	access:public	signature:() const
cdiggins::any::has_type	flann/any.h	/^    bool has_type()$/;"	f	struct:cdiggins::any	access:public	signature:()
cdiggins::any::object	flann/any.h	/^    void* object;$/;"	m	struct:cdiggins::any	access:private
cdiggins::any::operator <<	flann/any.h	/^    friend std::ostream& operator <<(std::ostream& out, const any& any_val);$/;"	p	struct:cdiggins::any	access:friend	signature:(std::ostream& out, const any& any_val)
cdiggins::any::operator =	flann/any.h	/^    any& operator=(const T& x)$/;"	f	struct:cdiggins::any	access:public	signature:(const T& x)
cdiggins::any::operator =	flann/any.h	/^    any& operator=(const char* x)$/;"	f	struct:cdiggins::any	access:public	signature:(const char* x)
cdiggins::any::policy	flann/any.h	/^    anyimpl::base_any_policy* policy;$/;"	m	struct:cdiggins::any	access:private
cdiggins::any::reset	flann/any.h	/^    void reset()$/;"	f	struct:cdiggins::any	access:public	signature:()
cdiggins::any::swap	flann/any.h	/^    any& swap(any& x)$/;"	f	struct:cdiggins::any	access:public	signature:(any& x)
cdiggins::any::type	flann/any.h	/^    const std::type_info& type() const$/;"	f	struct:cdiggins::any	access:public	signature:() const
cdiggins::any::~any	flann/any.h	/^    ~any()$/;"	f	struct:cdiggins::any	access:public	signature:()
cdiggins::anyimpl	flann/any.h	/^namespace anyimpl$/;"	n	namespace:cdiggins
cdiggins::anyimpl::SMALL_POLICY	flann/any.h	/^SMALL_POLICY(bool);$/;"	p	namespace:cdiggins::anyimpl	signature:(bool)
cdiggins::anyimpl::SMALL_POLICY	flann/any.h	/^SMALL_POLICY(float);$/;"	p	namespace:cdiggins::anyimpl	signature:(float)
cdiggins::anyimpl::SMALL_POLICY	flann/any.h	/^SMALL_POLICY(signed char);$/;"	p	namespace:cdiggins::anyimpl	signature:(signed char)
cdiggins::anyimpl::SMALL_POLICY	flann/any.h	/^SMALL_POLICY(signed int);$/;"	p	namespace:cdiggins::anyimpl	signature:(signed int)
cdiggins::anyimpl::SMALL_POLICY	flann/any.h	/^SMALL_POLICY(signed long);$/;"	p	namespace:cdiggins::anyimpl	signature:(signed long)
cdiggins::anyimpl::SMALL_POLICY	flann/any.h	/^SMALL_POLICY(signed short);$/;"	p	namespace:cdiggins::anyimpl	signature:(signed short)
cdiggins::anyimpl::SMALL_POLICY	flann/any.h	/^SMALL_POLICY(unsigned char);$/;"	p	namespace:cdiggins::anyimpl	signature:(unsigned char)
cdiggins::anyimpl::SMALL_POLICY	flann/any.h	/^SMALL_POLICY(unsigned int);$/;"	p	namespace:cdiggins::anyimpl	signature:(unsigned int)
cdiggins::anyimpl::SMALL_POLICY	flann/any.h	/^SMALL_POLICY(unsigned long);$/;"	p	namespace:cdiggins::anyimpl	signature:(unsigned long)
cdiggins::anyimpl::SMALL_POLICY	flann/any.h	/^SMALL_POLICY(unsigned short);$/;"	p	namespace:cdiggins::anyimpl	signature:(unsigned short)
cdiggins::anyimpl::bad_any_cast	flann/any.h	/^struct bad_any_cast$/;"	s	namespace:cdiggins::anyimpl
cdiggins::anyimpl::base_any_policy	flann/any.h	/^struct base_any_policy$/;"	s	namespace:cdiggins::anyimpl
cdiggins::anyimpl::base_any_policy::clone	flann/any.h	/^    virtual void clone(void* const* src, void** dest) = 0;$/;"	p	struct:cdiggins::anyimpl::base_any_policy	access:public	signature:(void* const* src, void** dest)
cdiggins::anyimpl::base_any_policy::copy_from_value	flann/any.h	/^    virtual void copy_from_value(void const* src, void** dest) = 0;$/;"	p	struct:cdiggins::anyimpl::base_any_policy	access:public	signature:(void const* src, void** dest)
cdiggins::anyimpl::base_any_policy::get_size	flann/any.h	/^    virtual size_t get_size() = 0;$/;"	p	struct:cdiggins::anyimpl::base_any_policy	access:public	signature:()
cdiggins::anyimpl::base_any_policy::get_value	flann/any.h	/^    virtual void* get_value(void** src) = 0;$/;"	p	struct:cdiggins::anyimpl::base_any_policy	access:public	signature:(void** src)
cdiggins::anyimpl::base_any_policy::move	flann/any.h	/^    virtual void move(void* const* src, void** dest) = 0;$/;"	p	struct:cdiggins::anyimpl::base_any_policy	access:public	signature:(void* const* src, void** dest)
cdiggins::anyimpl::base_any_policy::print	flann/any.h	/^    virtual void print(std::ostream& out, void* const* src) = 0;$/;"	p	struct:cdiggins::anyimpl::base_any_policy	access:public	signature:(std::ostream& out, void* const* src)
cdiggins::anyimpl::base_any_policy::static_delete	flann/any.h	/^    virtual void static_delete(void** x) = 0;$/;"	p	struct:cdiggins::anyimpl::base_any_policy	access:public	signature:(void** x)
cdiggins::anyimpl::base_any_policy::type	flann/any.h	/^    virtual const std::type_info& type() = 0;$/;"	p	struct:cdiggins::anyimpl::base_any_policy	access:public	signature:()
cdiggins::anyimpl::big_any_policy	flann/any.h	/^struct big_any_policy : typed_base_any_policy<T>$/;"	s	namespace:cdiggins::anyimpl	inherits:typed_base_any_policy
cdiggins::anyimpl::big_any_policy::clone	flann/any.h	/^    virtual void clone(void* const* src, void** dest)$/;"	f	struct:cdiggins::anyimpl::big_any_policy	access:public	signature:(void* const* src, void** dest)
cdiggins::anyimpl::big_any_policy::copy_from_value	flann/any.h	/^    virtual void copy_from_value(void const* src, void** dest)$/;"	f	struct:cdiggins::anyimpl::big_any_policy	access:public	signature:(void const* src, void** dest)
cdiggins::anyimpl::big_any_policy::get_value	flann/any.h	/^    virtual void* get_value(void** src) { return *src; }$/;"	f	struct:cdiggins::anyimpl::big_any_policy	access:public	signature:(void** src)
cdiggins::anyimpl::big_any_policy::move	flann/any.h	/^    virtual void move(void* const* src, void** dest)$/;"	f	struct:cdiggins::anyimpl::big_any_policy	access:public	signature:(void* const* src, void** dest)
cdiggins::anyimpl::big_any_policy::print	flann/any.h	/^    virtual void print(std::ostream& out, void* const* src) { out << *reinterpret_cast<T const*>(*src); }$/;"	f	struct:cdiggins::anyimpl::big_any_policy	access:public	signature:(std::ostream& out, void* const* src)
cdiggins::anyimpl::big_any_policy::static_delete	flann/any.h	/^    virtual void static_delete(void** x)$/;"	f	struct:cdiggins::anyimpl::big_any_policy	access:public	signature:(void** x)
cdiggins::anyimpl::choose_policy	flann/any.h	/^struct choose_policy$/;"	s	namespace:cdiggins::anyimpl
cdiggins::anyimpl::choose_policy	flann/any.h	/^struct choose_policy<T*>$/;"	s	namespace:cdiggins::anyimpl
cdiggins::anyimpl::choose_policy	flann/any.h	/^struct choose_policy<any>$/;"	s	namespace:cdiggins::anyimpl
cdiggins::anyimpl::choose_policy::type	flann/any.h	/^    typedef big_any_policy<T> type;$/;"	t	struct:cdiggins::anyimpl::choose_policy	access:public
cdiggins::anyimpl::choose_policy::type	flann/any.h	/^    typedef small_any_policy<T*> type;$/;"	t	struct:cdiggins::anyimpl::choose_policy	access:public
cdiggins::anyimpl::choose_policy::type	flann/any.h	/^    typedef void type;$/;"	t	struct:cdiggins::anyimpl::choose_policy	access:public
cdiggins::anyimpl::empty_any	flann/any.h	/^struct empty_any$/;"	s	namespace:cdiggins::anyimpl
cdiggins::anyimpl::get_policy	flann/any.h	/^base_any_policy* get_policy()$/;"	f	namespace:cdiggins::anyimpl	signature:()
cdiggins::anyimpl::small_any_policy	flann/any.h	/^struct small_any_policy : typed_base_any_policy<T>$/;"	s	namespace:cdiggins::anyimpl	inherits:typed_base_any_policy
cdiggins::anyimpl::small_any_policy::clone	flann/any.h	/^    virtual void clone(void* const* src, void** dest) { *dest = *src; }$/;"	f	struct:cdiggins::anyimpl::small_any_policy	access:public	signature:(void* const* src, void** dest)
cdiggins::anyimpl::small_any_policy::copy_from_value	flann/any.h	/^    virtual void copy_from_value(void const* src, void** dest)$/;"	f	struct:cdiggins::anyimpl::small_any_policy	access:public	signature:(void const* src, void** dest)
cdiggins::anyimpl::small_any_policy::get_value	flann/any.h	/^    virtual void* get_value(void** src) { return reinterpret_cast<void*>(src); }$/;"	f	struct:cdiggins::anyimpl::small_any_policy	access:public	signature:(void** src)
cdiggins::anyimpl::small_any_policy::move	flann/any.h	/^    virtual void move(void* const* src, void** dest) { *dest = *src; }$/;"	f	struct:cdiggins::anyimpl::small_any_policy	access:public	signature:(void* const* src, void** dest)
cdiggins::anyimpl::small_any_policy::print	flann/any.h	/^    virtual void print(std::ostream& out, void* const* src) { out << *reinterpret_cast<T const*>(src); }$/;"	f	struct:cdiggins::anyimpl::small_any_policy	access:public	signature:(std::ostream& out, void* const* src)
cdiggins::anyimpl::small_any_policy::static_delete	flann/any.h	/^    virtual void static_delete(void**) { }$/;"	f	struct:cdiggins::anyimpl::small_any_policy	access:public	signature:(void**)
cdiggins::anyimpl::typed_base_any_policy	flann/any.h	/^struct typed_base_any_policy : base_any_policy$/;"	s	namespace:cdiggins::anyimpl	inherits:base_any_policy
cdiggins::anyimpl::typed_base_any_policy::get_size	flann/any.h	/^    virtual size_t get_size() { return sizeof(T); }$/;"	f	struct:cdiggins::anyimpl::typed_base_any_policy	access:public	signature:()
cdiggins::anyimpl::typed_base_any_policy::type	flann/any.h	/^    virtual const std::type_info& type() { return typeid(T); }$/;"	f	struct:cdiggins::anyimpl::typed_base_any_policy	access:public	signature:()
cdiggins::operator <<	flann/any.h	/^inline std::ostream& operator <<(std::ostream& out, const any& any_val)$/;"	f	namespace:cdiggins	signature:(std::ostream& out, const any& any_val)
ce	legacy/legacy.hpp	/^    int* ce;$/;"	m	struct:CvCliqueFinder	access:public
cellSize	objdetect/objdetect.hpp	/^    CV_PROP Size cellSize;$/;"	m	struct:cv::HOGDescriptor	access:public
cell_bit_size_	flann/dynamic_bitset.h	/^    static const unsigned int cell_bit_size_ = CHAR_BIT * sizeof(size_t);$/;"	m	class:DynamicBitset	access:private
cell_size	gpu/gpu.hpp	/^            Size cell_size;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
center	core/core.hpp	/^    Point2f center; \/\/< the rectangle mass center$/;"	m	class:cv::RotatedRect	access:public
center	core/types_c.h	/^    CvPoint2D32f center;  \/* Center of the box.                          *\/$/;"	m	struct:CvBox2D	access:public
centersAlgFunction	flann/hierarchical_clustering_index.h	/^    typedef void (HierarchicalClusteringIndex::* centersAlgFunction)(int, int*, int, int*, int&);$/;"	t	class:cvflann::HierarchicalClusteringIndex	access:private
centersAlgFunction	flann/kmeans_index.h	/^    typedef void (KMeansIndex::* centersAlgFunction)(int, int*, int, int*, int&);$/;"	t	class:cvflann::KMeansIndex	access:public
centers_init_	flann/hierarchical_clustering_index.h	/^    flann_centers_init_t centers_init_;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
centers_init_	flann/kmeans_index.h	/^    flann_centers_init_t centers_init_;$/;"	m	class:cvflann::KMeansIndex	access:private
centre	contrib/contrib.hpp	/^    double value, centre;$/;"	m	class:CvFuzzyCurve	access:private
chahge_var_idx	ml/ml.hpp	/^    void chahge_var_idx( int vi, bool state ); \/\/ state == true to set vi-variable as predictor$/;"	p	class:CvMLData	access:public	signature:( int vi, bool state )
chain	legacy/legacy.hpp	/^    CvSeq* chain;$/;"	m	struct:CvLCMEdge	access:public
chamerMatching	contrib/contrib.hpp	/^    CV_EXPORTS int chamerMatching( Mat& img, Mat& templ,$/;"	p	namespace:cv	signature:( Mat& img, Mat& templ, vector<vector<Point> >& results, vector<float>& cost, double templScale=1, int maxMatches = 20, double minMatchDistance = 1.0, int padX = 3, int padY = 3, int scales = 5, double minScale = 0.6, double maxScale = 1.6, double orientationWeight = 0.5, double truncate = 20)
change_values	ml/ml.hpp	/^    virtual void change_values(CvDTree* tree, const int k = 0);$/;"	p	class:CvGBTrees	access:protected	signature:(CvDTree* tree, const int k = 0)
change_var_type	ml/ml.hpp	/^    void change_var_type( int var_idx, int type); \/\/ type in { CV_VAR_ORDERED, CV_VAR_CATEGORICAL }    $/;"	p	class:CvMLData	access:public	signature:( int var_idx, int type)
channelSeq	core/types_c.h	/^    char channelSeq[4];     \/* ditto *\/$/;"	m	struct:_IplImage	access:public
channel_type	core/core.hpp	/^    typedef _Tp channel_type;$/;"	t	class:cv::DataType	access:public
channel_type	core/core.hpp	/^    typedef int channel_type;$/;"	t	class:cv::DataType	access:public
channel_type	core/core.hpp	/^    typedef typename DataType<_Tp>::channel_type channel_type;$/;"	t	class:cv::Mat_	access:public
channel_type	core/core.hpp	/^    typedef value_type channel_type;$/;"	t	class:cv::DataType	access:public
channels	core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, channels = cn, type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::Vec::__anon114
channels	core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, rows = m, cols = n, channels = rows*cols,$/;"	e	enum:cv::Matx::__anon113
channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon116
channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon117
channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon118
channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon119
channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon120
channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon121
channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon122
channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon123
channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon124
channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon126
channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon127
channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon128
channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon130
channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon133
channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 3,$/;"	e	enum:cv::DataType::__anon129
channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon131
channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon132
channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = cn,$/;"	e	enum:cv::DataType::__anon125
channels	core/core.hpp	/^    enum { generic_type = 1, depth = -1, channels = 1, fmt=0,$/;"	e	enum:cv::DataType::__anon115
channels	core/core.hpp	/^    int channels() const;$/;"	p	class:cv::Mat	access:public	signature:() const
channels	core/core.hpp	/^    int channels() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
channels	core/core.hpp	/^    int channels() const;$/;"	p	class:cv::Seq	access:public	signature:() const
channels	core/core.hpp	/^    int channels() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
channels	core/core.hpp	/^    int channels() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
channels	core/core.hpp	/^    virtual int channels(int i=-1) const;$/;"	p	class:cv::_InputArray	access:public	signature:(int i=-1) const
channels	core/mat.hpp	/^inline int Mat::channels() const { return CV_MAT_CN(flags); }$/;"	f	class:cv::Mat	signature:() const
channels	core/mat.hpp	/^inline int SparseMat::channels() const$/;"	f	class:cv::SparseMat	signature:() const
channels	core/mat.hpp	/^template<typename _Tp> inline int Mat_<_Tp>::channels() const$/;"	f	class:cv::Mat_	signature:() const
channels	core/mat.hpp	/^template<typename _Tp> inline int SparseMat_<_Tp>::channels() const$/;"	f	class:cv::SparseMat_	signature:() const
channels	core/operations.hpp	/^template<typename _Tp> inline int Seq<_Tp>::channels() const$/;"	f	class:cv::Seq	signature:() const
channels	gpu/gpu.hpp	/^            int channels() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
channels	gpu/gpumat.hpp	/^        int channels() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
channels	gpu/matrix_operations.hpp	/^inline int CudaMem::channels() const { return CV_MAT_CN(flags); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
channels	legacy/legacy.hpp	/^    int channels() const { return image ? image->nChannels : 0; }$/;"	f	class:CvImage	access:public	signature:() const
channels	legacy/legacy.hpp	/^    int channels() const { return matrix ? CV_MAT_CN(matrix->type) : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
check	gpu/devmem2d.hpp	/^        template <> struct StaticAssert<true> {static __CV_GPU_HOST_DEVICE__ void check(){}};        $/;"	f	struct:cv::gpu::StaticAssert	access:public	signature:()
check	imgproc/imgproc.hpp	/^    void check() const;$/;"	p	class:cv::Subdiv2D	access:protected	signature:() const
check	ml/ml.hpp	/^    bool check() const;$/;"	p	struct:CvParamGrid	access:public	signature:() const
check	ml/ml.hpp	51;"	d
checkDetectorSize	gpu/gpu.hpp	/^            bool checkDetectorSize() const;$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:() const
checkDetectorSize	objdetect/objdetect.hpp	/^    CV_WRAP bool checkDetectorSize() const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:() const
checkHardwareSupport	core/core.hpp	/^CV_EXPORTS_W bool checkHardwareSupport(int feature);$/;"	p	namespace:cv	signature:(int feature)
checkIfGpuCallReasonable	gpu/gpu.hpp	/^            static bool checkIfGpuCallReasonable();$/;"	p	class:cv::gpu::StereoBM_GPU	access:public	signature:()
checkMasks	features2d/features2d.hpp	/^	void checkMasks( const vector<Mat>& masks, int queryDescriptorsCount ) const;$/;"	p	class:cv::DescriptorMatcher	access:protected	signature:( const vector<Mat>& masks, int queryDescriptorsCount ) const
checkRange	core/core.hpp	/^CV_EXPORTS_W bool checkRange(InputArray a, bool quiet=true, CV_OUT Point* pt=0,$/;"	p	namespace:cv	signature:(InputArray a, bool quiet=true, CV_OUT Point* pt=0, double minVal=-DBL_MAX, double maxVal=DBL_MAX)
checkVector	core/core.hpp	/^    int checkVector(int elemChannels, int depth=-1, bool requireContinuous=true) const;$/;"	p	class:cv::Mat	access:public	signature:(int elemChannels, int depth=-1, bool requireContinuous=true) const
child	objdetect/objdetect.hpp	/^    int child;$/;"	m	struct:CvHaarStageClassifier	access:public
child1	flann/kdtree_index.h	/^        Node* child1, * child2;$/;"	m	struct:cvflann::KDTreeIndex::Node	access:public
child1	flann/kdtree_single_index.h	/^        Node* child1, * child2;$/;"	m	struct:cvflann::KDTreeSingleIndex::Node	access:public
child2	flann/kdtree_index.h	/^        Node* child1, * child2;$/;"	m	struct:cvflann::KDTreeIndex::Node	access:public
child2	flann/kdtree_single_index.h	/^        Node* child1, * child2;$/;"	m	struct:cvflann::KDTreeSingleIndex::Node	access:public
children	contrib/contrib.hpp	/^            int children[8];$/;"	m	struct:cv::Octree::Node	access:public
childs	flann/hierarchical_clustering_index.h	/^        Node** childs;$/;"	m	struct:cvflann::HierarchicalClusteringIndex::Node	access:public
childs	flann/kmeans_index.h	/^        KMeansNode** childs;$/;"	m	struct:cvflann::KMeansIndex::KMeansNode	access:public
chooseCenters	flann/hierarchical_clustering_index.h	/^    centersAlgFunction chooseCenters;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
chooseCenters	flann/kmeans_index.h	/^    centersAlgFunction chooseCenters;$/;"	m	class:cvflann::KMeansIndex	access:public
chooseCentersGonzales	flann/hierarchical_clustering_index.h	/^    void chooseCentersGonzales(int k, int* indices, int indices_length, int* centers, int& centers_length)$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:private	signature:(int k, int* indices, int indices_length, int* centers, int& centers_length)
chooseCentersGonzales	flann/kmeans_index.h	/^    void chooseCentersGonzales(int k, int* indices, int indices_length, int* centers, int& centers_length)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(int k, int* indices, int indices_length, int* centers, int& centers_length)
chooseCentersKMeanspp	flann/hierarchical_clustering_index.h	/^    void chooseCentersKMeanspp(int k, int* indices, int indices_length, int* centers, int& centers_length)$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:private	signature:(int k, int* indices, int indices_length, int* centers, int& centers_length)
chooseCentersKMeanspp	flann/kmeans_index.h	/^    void chooseCentersKMeanspp(int k, int* indices, int indices_length, int* centers, int& centers_length)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(int k, int* indices, int indices_length, int* centers, int& centers_length)
chooseCentersRandom	flann/hierarchical_clustering_index.h	/^    void chooseCentersRandom(int k, int* indices, int indices_length, int* centers, int& centers_length)$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:private	signature:(int k, int* indices, int indices_length, int* centers, int& centers_length)
chooseCentersRandom	flann/kmeans_index.h	/^    void chooseCentersRandom(int k, int* indices, int indices_length, int* centers, int& centers_length)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(int k, int* indices, int indices_length, int* centers, int& centers_length)
choose_policy	flann/any.h	/^struct choose_policy$/;"	s	namespace:cdiggins::anyimpl
choose_policy	flann/any.h	/^struct choose_policy<T*>$/;"	s	namespace:cdiggins::anyimpl
choose_policy	flann/any.h	/^struct choose_policy<any>$/;"	s	namespace:cdiggins::anyimpl
circle	core/core.hpp	/^CV_EXPORTS_W void circle(Mat& img, Point center, int radius,$/;"	p	namespace:cv	signature:(Mat& img, Point center, int radius, const Scalar& color, int thickness=1, int lineType=8, int shift=0)
classCounters	features2d/features2d.hpp	/^    vector<int> classCounters;$/;"	m	class:cv::FernClassifier	access:protected
class_count	ml/ml.hpp	/^    int class_count;$/;"	m	class:CvGBTrees	access:protected
class_id	features2d/features2d.hpp	/^    CV_PROP_RW int class_id; \/\/!< object class (if the keypoints need to be clustered by an object they belong to) $/;"	m	class:cv::KeyPoint	access:public
class_idx	ml/ml.hpp	/^    int class_idx;$/;"	m	struct:CvDTreeNode	access:public
class_labels	ml/ml.hpp	/^    CvMat* class_labels;$/;"	m	class:CvGBTrees	access:protected
class_labels	ml/ml.hpp	/^    CvMat* class_labels;$/;"	m	class:CvSVM	access:protected
class_map	ml/ml.hpp	/^    std::map<std::string, int> class_map;$/;"	m	class:CvMLData	access:protected
class_weights	ml/ml.hpp	/^    CvMat*      class_weights; \/\/ for CV_SVM_C_SVC$/;"	m	struct:CvSVMParams	access:public
class_weights	ml/ml.hpp	/^    CvMat* class_weights;$/;"	m	class:CvSVM	access:protected
classes	features2d/features2d.hpp	/^  inline int classes() const { return classes_; }$/;"	f	class:cv::RTreeClassifier	access:public	signature:() const
classes	features2d/features2d.hpp	/^  int classes() { return classes_; }$/;"	f	class:cv::RandomizedTree	access:public	signature:()
classes_	features2d/features2d.hpp	/^  int classes_;$/;"	m	class:cv::RTreeClassifier	access:private
classes_	features2d/features2d.hpp	/^  int classes_;$/;"	m	class:cv::RandomizedTree	access:private
classifier	features2d/features2d.hpp	/^    Ptr<FernClassifier> classifier;$/;"	m	class:cv::FernDescriptorMatcher	access:protected
classifier	objdetect/objdetect.hpp	/^    CvHaarClassifier* classifier;$/;"	m	struct:CvHaarStageClassifier	access:public
classifier_	features2d/features2d.hpp	/^    RTreeClassifier classifier_;$/;"	m	class:cv::CalonderDescriptorExtractor	access:protected
classifiers	objdetect/objdetect.hpp	/^        vector<DTree> classifiers;$/;"	m	class:cv::CascadeClassifier::Data	access:public
classify	features2d/features2d.hpp	/^    void classify( const Mat& queryImage, vector<KeyPoint>& queryKeypoints );$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints )
classify	features2d/features2d.hpp	/^    void classify( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, const Mat& trainImage, vector<KeyPoint>& trainKeypoints ) const
clear	calib3d/calib3d.hpp	/^    void clear();$/;"	p	class:CvLevMarq	access:public	signature:()
clear	contrib/contrib.hpp	/^        virtual void clear();$/;"	p	class:cv::LevMarqSparse	access:public	signature:()
clear	contrib/contrib.hpp	/^    void clear();$/;"	p	class:CvFuzzyCurve	access:public	signature:()
clear	core/core.hpp	/^        void clear();$/;"	p	struct:cv::SparseMat::Hdr	access:public	signature:()
clear	core/core.hpp	/^    virtual void clear() const;$/;"	p	class:cv::_OutputArray	access:public	signature:() const
clear	core/core.hpp	/^    void clear();$/;"	p	class:cv::Seq	access:public	signature:()
clear	core/core.hpp	/^    void clear();$/;"	p	class:cv::SparseMat	access:public	signature:()
clear	core/operations.hpp	/^    void clear() { resize(0); }$/;"	f	class:cv::Vector	access:public	signature:()
clear	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::clear()$/;"	f	class:cv::Seq	signature:()
clear	features2d/features2d.hpp	/^        virtual void clear();$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:()
clear	features2d/features2d.hpp	/^        void clear();$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:()
clear	features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::BOWTrainer	access:public	signature:()
clear	features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::DescriptorMatcher	access:public	signature:()
clear	features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::FernClassifier	access:public	signature:()
clear	features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:()
clear	features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:()
clear	features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:()
clear	features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:()
clear	features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:()
clear	features2d/features2d.hpp	/^    void clear ();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
clear	flann/dynamic_bitset.h	/^    void clear()$/;"	f	class:DynamicBitset	access:public	signature:()
clear	flann/heap.h	/^    void clear()$/;"	f	class:cvflann::Heap	access:public	signature:()
clear	flann/result_set.h	/^    inline void clear()$/;"	f	class:cvflann::RadiusUniqueResultSet	access:public	signature:()
clear	flann/result_set.h	/^    virtual void clear() = 0;$/;"	p	class:cvflann::UniqueResultSet	access:public	signature:()
clear	flann/result_set.h	/^    void clear()$/;"	f	class:cvflann::KNNRadiusUniqueResultSet	access:public	signature:()
clear	flann/result_set.h	/^    void clear()$/;"	f	class:cvflann::KNNUniqueResultSet	access:public	signature:()
clear	gpu/NCV.hpp	/^    void clear()$/;"	f	class:NCVMatrix	access:public	signature:()
clear	gpu/NCV.hpp	/^    void clear()$/;"	f	class:NCVVector	access:public	signature:()
clear	gpu/NCV.hpp	/^    void clear();$/;"	p	struct:NCVMemPtr	access:public	signature:()
clear	gpu/NCV.hpp	/^    void clear();$/;"	p	struct:NCVMemSegment	access:public	signature:()
clear	gpu/gpu.hpp	/^            void clear();$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:()
clear	legacy/legacy.hpp	/^    void clear() { detach(); }$/;"	f	class:CvImage	access:public	signature:()
clear	legacy/legacy.hpp	/^    void clear()$/;"	f	class:CvMatrix	access:public	signature:()
clear	ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvANN_MLP	access:public	signature:()
clear	ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvBoost	access:public	signature:()
clear	ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvDTree	access:public	signature:()
clear	ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvEM	access:public	signature:()
clear	ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvGBTrees	access:public	signature:()
clear	ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvNormalBayesClassifier	access:public	signature:()
clear	ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvRTrees	access:public	signature:()
clear	ml/ml.hpp	/^    CV_WRAP virtual void clear();$/;"	p	class:CvSVM	access:public	signature:()
clear	ml/ml.hpp	/^    virtual void clear();$/;"	p	class:CvBoostTree	access:public	signature:()
clear	ml/ml.hpp	/^    virtual void clear();$/;"	p	class:CvKNearest	access:public	signature:()
clear	ml/ml.hpp	/^    virtual void clear();$/;"	p	class:CvMLData	access:protected	signature:()
clear	ml/ml.hpp	/^    virtual void clear();$/;"	p	class:CvSVMSolver	access:public	signature:()
clear	ml/ml.hpp	/^    virtual void clear();$/;"	p	class:CvStatModel	access:public	signature:()
clear	ml/ml.hpp	/^    virtual void clear();$/;"	p	struct:CvDTreeTrainData	access:public	signature:()
clear	ml/ml.hpp	/^    virtual void clear();$/;"	p	struct:CvSVMKernel	access:public	signature:()
clearBuffers	contrib/retina.hpp	/^        void clearBuffers();$/;"	p	class:cv::Retina	access:public	signature:()
clearOctree	contrib/contrib.hpp	/^        void clearOctree();$/;"	p	class:cv::Mesh3D	access:public	signature:()
clearSeq	core/operations.hpp	/^CV_EXPORTS void  clearSeq( CvSeq* seq );$/;"	p	namespace:cv	signature:( CvSeq* seq )
clearVoronoi	imgproc/imgproc.hpp	/^    void clearVoronoi();$/;"	p	class:cv::Subdiv2D	access:protected	signature:()
clipLine	core/core.hpp	/^CV_EXPORTS bool clipLine(Size imgSize, CV_IN_OUT Point& pt1, CV_IN_OUT Point& pt2);$/;"	p	namespace:cv	signature:(Size imgSize, CV_IN_OUT Point& pt1, CV_IN_OUT Point& pt2)
clipLine	core/core.hpp	/^CV_EXPORTS_W bool clipLine(Rect imgRect, CV_OUT CV_IN_OUT Point& pt1, CV_OUT CV_IN_OUT Point& pt2);$/;"	p	namespace:cv	signature:(Rect imgRect, CV_OUT CV_IN_OUT Point& pt1, CV_OUT CV_IN_OUT Point& pt2)
clone	core/core.hpp	/^    Mat clone() const;$/;"	p	class:cv::Mat	access:public	signature:() const
clone	core/core.hpp	/^    Mat_ clone() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
clone	core/core.hpp	/^    SparseMat clone() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
clone	core/core.hpp	/^    SparseMat_ clone() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
clone	core/mat.hpp	/^SparseMat_<_Tp>::clone() const$/;"	f	class:cv::SparseMat_	signature:() const
clone	core/mat.hpp	/^inline Mat Mat::clone() const$/;"	f	class:cv::Mat	signature:() const
clone	core/mat.hpp	/^inline SparseMat SparseMat::clone() const$/;"	f	class:cv::SparseMat	signature:() const
clone	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::clone() const$/;"	f	class:cv::Mat_	signature:() const
clone	core/operations.hpp	/^    Vector<_Tp> clone() const$/;"	f	class:cv::Vector	access:public	signature:() const
clone	core/operations.hpp	/^    static void* clone(const void* ptr)$/;"	f	struct:cv::RTTIImpl	access:public	signature:(const void* ptr)
clone	core/types_c.h	/^    CvCloneFunc clone;$/;"	m	struct:CvTypeInfo	access:public
clone	features2d/features2d.hpp	/^    virtual Ptr<AdjusterAdapter> clone() const = 0;$/;"	p	class:cv::AdjusterAdapter	access:public	signature:() const
clone	features2d/features2d.hpp	/^    virtual Ptr<AdjusterAdapter> clone() const;$/;"	p	class:cv::FastAdjuster	access:public	signature:() const
clone	features2d/features2d.hpp	/^    virtual Ptr<AdjusterAdapter> clone() const;$/;"	p	class:cv::StarAdjuster	access:public	signature:() const
clone	features2d/features2d.hpp	/^    virtual Ptr<AdjusterAdapter> clone() const;$/;"	p	class:cv::SurfAdjuster	access:public	signature:() const
clone	features2d/features2d.hpp	/^    virtual Ptr<DescriptorMatcher> clone( bool emptyTrainData=false ) const = 0;$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( bool emptyTrainData=false ) const
clone	features2d/features2d.hpp	/^    virtual Ptr<DescriptorMatcher> clone( bool emptyTrainData=false ) const;$/;"	p	class:cv::BruteForceMatcher	access:public	signature:( bool emptyTrainData=false ) const
clone	features2d/features2d.hpp	/^    virtual Ptr<DescriptorMatcher> clone( bool emptyTrainData=false ) const;$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:( bool emptyTrainData=false ) const
clone	features2d/features2d.hpp	/^    virtual Ptr<GenericDescriptorMatcher> clone( bool emptyTrainData=false ) const = 0;$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( bool emptyTrainData=false ) const
clone	features2d/features2d.hpp	/^    virtual Ptr<GenericDescriptorMatcher> clone( bool emptyTrainData=false ) const;$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:( bool emptyTrainData=false ) const
clone	features2d/features2d.hpp	/^    virtual Ptr<GenericDescriptorMatcher> clone( bool emptyTrainData=false ) const;$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:( bool emptyTrainData=false ) const
clone	features2d/features2d.hpp	/^    virtual Ptr<GenericDescriptorMatcher> clone( bool emptyTrainData=false ) const;$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:( bool emptyTrainData=false ) const
clone	features2d/features2d.hpp	/^Ptr<DescriptorMatcher> BruteForceMatcher<Distance>::clone( bool emptyTrainData ) const$/;"	f	class:cv::BruteForceMatcher	signature:( bool emptyTrainData ) const
clone	flann/any.h	/^    virtual void clone(void* const* src, void** dest) = 0;$/;"	p	struct:cdiggins::anyimpl::base_any_policy	access:public	signature:(void* const* src, void** dest)
clone	flann/any.h	/^    virtual void clone(void* const* src, void** dest) { *dest = *src; }$/;"	f	struct:cdiggins::anyimpl::small_any_policy	access:public	signature:(void* const* src, void** dest)
clone	flann/any.h	/^    virtual void clone(void* const* src, void** dest)$/;"	f	struct:cdiggins::anyimpl::big_any_policy	access:public	signature:(void* const* src, void** dest)
clone	gpu/gpu.hpp	/^            CudaMem clone() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
clone	gpu/gpumat.hpp	/^        GpuMat clone() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
clone	gpu/gpumat.hpp	/^    inline GpuMat GpuMat::clone() const$/;"	f	class:cv::gpu::GpuMat	signature:() const
clone	gpu/matrix_operations.hpp	/^inline CudaMem CudaMem::clone() const$/;"	f	class:cv::gpu::CudaMem	signature:() const
clone	legacy/legacy.hpp	/^    CvImage clone() { return CvImage(image ? cvCloneImage(image) : 0); }$/;"	f	class:CvImage	access:public	signature:()
clone	legacy/legacy.hpp	/^    CvMatrix clone() { return CvMatrix(matrix ? cvCloneMat(matrix) : 0); }$/;"	f	class:CvMatrix	access:public	signature:()
clone	objdetect/objdetect.hpp	/^    virtual Ptr<FeatureEvaluator> clone() const;$/;"	p	class:cv::FeatureEvaluator	access:public	signature:() const
clone_op	features2d/features2d.hpp	/^        static Mat clone_op( Mat m ) { return m.clone(); }$/;"	f	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:private	signature:( Mat m )
clone_op	features2d/features2d.hpp	/^    static Mat clone_op( Mat m ) { return m.clone(); }$/;"	f	class:cv::DescriptorMatcher	access:protected	signature:( Mat m )
cls_labels	ml/ml.hpp	/^    CvMat*  cls_labels;$/;"	m	class:CvNormalBayesClassifier	access:protected
cluster	features2d/features2d.hpp	/^    virtual Mat cluster( const Mat& descriptors ) const = 0;$/;"	p	class:cv::BOWTrainer	access:public	signature:( const Mat& descriptors ) const
cluster	features2d/features2d.hpp	/^    virtual Mat cluster( const Mat& descriptors ) const;$/;"	p	class:cv::BOWKMeansTrainer	access:public	signature:( const Mat& descriptors ) const
cluster	features2d/features2d.hpp	/^    virtual Mat cluster() const = 0;$/;"	p	class:cv::BOWTrainer	access:public	signature:() const
cluster	features2d/features2d.hpp	/^    virtual Mat cluster() const;$/;"	p	class:cv::BOWKMeansTrainer	access:public	signature:() const
clusterCount	features2d/features2d.hpp	/^    int clusterCount;$/;"	m	class:cv::BOWKMeansTrainer	access:protected
cluster_categories	ml/ml.hpp	/^    virtual void cluster_categories( const int* vectors, int vector_count,$/;"	p	class:CvDTree	access:protected	signature:( const int* vectors, int vector_count, int var_count, int* sums, int k, int* cluster_labels )
clusteringDistance	features2d/features2d.hpp	/^    double clusteringDistance;$/;"	m	class:cv::LDetector	access:public
code	core/core.hpp	/^    int code; \/\/\/< error code @see CVStatus$/;"	m	class:cv::Exception	access:public
code	imgproc/types_c.h	/^    char      code;$/;"	m	struct:CvChainPtReader	access:public
coef0	ml/ml.hpp	/^    CV_PROP_RW double      coef0;  \/\/ for poly\/sigmoid$/;"	m	struct:CvSVMParams	access:public
coeffs	legacy/legacy.hpp	/^    double coeffs[2][3][3];\/* coefficients for transformation *\/$/;"	m	struct:CvStereoCamera	access:public
coi	core/types_c.h	/^    int  coi; \/* 0 - no COI (all channels are selected), 1 - 0th channel is selected ...*\/$/;"	m	struct:_IplROI	access:public
coi	legacy/legacy.hpp	/^    int coi() const { return !image || !image->roi ? 0 : image->roi->coi; }$/;"	f	class:CvImage	access:public	signature:() const
col	core/core.hpp	/^    Mat col(int x) const;$/;"	p	class:cv::Mat	access:public	signature:(int x) const
col	core/core.hpp	/^    Mat_ col(int x) const;$/;"	p	class:cv::Mat_	access:public	signature:(int x) const
col	core/core.hpp	/^    Matx<_Tp, m, 1> col(int i) const;$/;"	p	class:cv::Matx	access:public	signature:(int i) const
col	core/mat.hpp	/^    MatExpr col(int x) const;$/;"	p	class:cv::MatExpr	access:public	signature:(int x) const
col	core/mat.hpp	/^inline Mat Mat::col(int x) const { return Mat(*this, Range::all(), Range(x, x+1)); }$/;"	f	class:cv::Mat	signature:(int x) const
col	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::col(int x) const$/;"	f	class:cv::Mat_	signature:(int x) const
col	core/operations.hpp	/^Matx<_Tp, m, 1> Matx<_Tp, m, n>::col(int j) const$/;"	f	class:cv::Matx	signature:(int j) const
col	gpu/gpumat.hpp	/^        GpuMat col(int x) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int x) const
colRange	core/core.hpp	/^    Mat colRange(const Range& r) const;$/;"	p	class:cv::Mat	access:public	signature:(const Range& r) const
colRange	core/core.hpp	/^    Mat colRange(int startcol, int endcol) const;$/;"	p	class:cv::Mat	access:public	signature:(int startcol, int endcol) const
colRange	core/mat.hpp	/^inline Mat Mat::colRange(const Range& r) const$/;"	f	class:cv::Mat	signature:(const Range& r) const
colRange	core/mat.hpp	/^inline Mat Mat::colRange(int startcol, int endcol) const$/;"	f	class:cv::Mat	signature:(int startcol, int endcol) const
colRange	gpu/gpumat.hpp	/^        GpuMat colRange(const Range& r) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Range& r) const
colRange	gpu/gpumat.hpp	/^        GpuMat colRange(int startcol, int endcol) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int startcol, int endcol) const
color	core/core_c.h	/^	CvScalar color;				\/\/Qt:ColorFont -> cvScalar(blue_component, green_component, red\\_component[, alpha_component])$/;"	m	struct:CvFont	access:public
color	legacy/blobtrack.hpp	/^    CvScalar color;$/;"	m	struct:CvDrawShape	access:public
colorModel	core/types_c.h	/^    char colorModel[4];     \/* Ignored by OpenCV *\/$/;"	m	struct:_IplImage	access:public
color_transform	legacy/legacy.hpp	/^    virtual void color_transform( const IplImage* img );$/;"	p	class:CvCamShiftTracker	access:protected	signature:( const IplImage* img )
cols	core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, rows = m, cols = n, channels = rows*cols,$/;"	e	enum:cv::Matx::__anon113
cols	core/core.hpp	/^    int rows, cols;$/;"	m	class:cv::Mat	access:public
cols	core/types_c.h	/^        int cols;$/;"	m	union:CvMat::__anon153	access:public
cols	core/types_c.h	/^    int cols;$/;"	m	struct:CvMat	access:public
cols	flann/matrix.h	/^    size_t cols;$/;"	m	class:cvflann::Matrix	access:public
cols	flann/matrix.h	/^    size_t cols;$/;"	m	class:cvflann::UntypedMatrix	access:public
cols	flann/saving.h	/^    size_t cols;$/;"	m	struct:cvflann::IndexHeader	access:public
cols	gpu/devmem2d.hpp	/^            int cols;$/;"	m	struct:cv::gpu::DevMem2D_	access:public
cols	gpu/gpu.hpp	/^            int rows, cols;$/;"	m	class:cv::gpu::CudaMem	access:public
cols	gpu/gpumat.hpp	/^        int rows, cols;$/;"	m	class:cv::gpu::GpuMat	access:public
cols	legacy/legacy.hpp	/^    int cols() const { return matrix ? matrix->cols : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
columnBorderType	imgproc/imgproc.hpp	/^    int rowBorderType, columnBorderType;$/;"	m	class:cv::FilterEngine	access:public
columnFilter	imgproc/imgproc.hpp	/^    Ptr<BaseColumnFilter> columnFilter;$/;"	m	class:cv::FilterEngine	access:public
columnSum	gpu/gpu.hpp	/^        CV_EXPORTS void columnSum(const GpuMat& src, GpuMat& sum);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& sum)
comLen	legacy/blobtrack.hpp	/^    int comLen; \/\/common length for two tracks$/;"	m	struct:CvTracksTimePos	access:public
commParams	features2d/features2d.hpp	/^    CommonParams commParams;$/;"	m	class:cv::SIFT	access:protected
commonKnnMatchImpl	features2d/features2d.hpp	/^    static void commonKnnMatchImpl( BruteForceMatcher<Distance>& matcher,$/;"	p	class:cv::BruteForceMatcher	access:private	signature:( BruteForceMatcher<Distance>& matcher, const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
commonKnnMatchImpl	features2d/features2d.hpp	/^inline void BruteForceMatcher<Distance>::commonKnnMatchImpl( BruteForceMatcher<Distance>& matcher,$/;"	f	class:cv::BruteForceMatcher	signature:( BruteForceMatcher<Distance>& matcher, const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int knn, const vector<Mat>& masks, bool compactResult )
commonRadiusMatchImpl	features2d/features2d.hpp	/^    static void commonRadiusMatchImpl( BruteForceMatcher<Distance>& matcher,$/;"	p	class:cv::BruteForceMatcher	access:private	signature:( BruteForceMatcher<Distance>& matcher, const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
commonRadiusMatchImpl	features2d/features2d.hpp	/^inline void BruteForceMatcher<Distance>::commonRadiusMatchImpl( BruteForceMatcher<Distance>& matcher,$/;"	f	class:cv::BruteForceMatcher	signature:( BruteForceMatcher<Distance>& matcher, const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
compare	core/core.hpp	/^CV_EXPORTS_W void compare(InputArray src1, InputArray src2, OutputArray dst, int cmpop);$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst, int cmpop)
compare	gpu/gpu.hpp	/^        CV_EXPORTS void compare(const GpuMat& a, const GpuMat& b, GpuMat& c, int cmpop, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c, int cmpop, Stream& stream = Stream::Null())
compareHist	imgproc/imgproc.hpp	/^CV_EXPORTS double compareHist( const SparseMat& H1, const SparseMat& H2, int method );$/;"	p	namespace:cv	signature:( const SparseMat& H1, const SparseMat& H2, int method )
compareHist	imgproc/imgproc.hpp	/^CV_EXPORTS_W double compareHist( InputArray H1, InputArray H2, int method );$/;"	p	namespace:cv	signature:( InputArray H1, InputArray H2, int method )
compatible	flann/any.h	/^    bool compatible(const any& x) const$/;"	f	struct:cdiggins::any	access:public	signature:(const any& x) const
completeSymm	core/core.hpp	/^CV_EXPORTS_W void completeSymm(InputOutputArray mtx, bool lowerToUpper=false);$/;"	p	namespace:cv	signature:(InputOutputArray mtx, bool lowerToUpper=false)
completeSymmFlag	calib3d/calib3d.hpp	/^    bool completeSymmFlag;$/;"	m	class:CvLevMarq	access:public
complete_node_dir	ml/ml.hpp	/^    virtual void complete_node_dir( CvDTreeNode* node );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* node )
complexity	ml/ml.hpp	/^    int complexity;$/;"	m	struct:CvDTreeNode	access:public
composeRT	calib3d/calib3d.hpp	/^CV_EXPORTS_W void composeRT( InputArray rvec1, InputArray tvec1,$/;"	p	namespace:cv	signature:( InputArray rvec1, InputArray tvec1, InputArray rvec2, InputArray tvec2, OutputArray rvec3, OutputArray tvec3, OutputArray dr3dr1=noArray(), OutputArray dr3dt1=noArray(), OutputArray dr3dr2=noArray(), OutputArray dr3dt2=noArray(), OutputArray dt3dr1=noArray(), OutputArray dt3dt1=noArray(), OutputArray dt3dr2=noArray(), OutputArray dt3dt2=noArray() )
compressLeaves	features2d/features2d.hpp	/^  void compressLeaves(size_t reduced_num_dim);$/;"	p	class:cv::RandomizedTree	access:private	signature:(size_t reduced_num_dim)
compressionMethod	features2d/features2d.hpp	/^        int compressionMethod;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
compressionMethod	features2d/features2d.hpp	/^    int compressionMethod;$/;"	m	class:cv::FernClassifier	access:protected
compute	contrib/contrib.hpp	/^        virtual void compute(const Mat& img, vector<float>& descriptors, Size winStride=Size(),$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(const Mat& img, vector<float>& descriptors, Size winStride=Size(), const vector<Point>& locations=vector<Point>()) const
compute	contrib/contrib.hpp	/^        void compute();$/;"	p	class:cv::SpinImageModel	access:public	signature:()
compute	core/core.hpp	/^    static void compute( InputArray src, OutputArray w, int flags=0 );$/;"	p	class:cv::SVD	access:public	signature:( InputArray src, OutputArray w, int flags=0 )
compute	core/core.hpp	/^    static void compute( InputArray src, OutputArray w,$/;"	p	class:cv::SVD	access:public	signature:( InputArray src, OutputArray w, OutputArray u, OutputArray vt, int flags=0 )
compute	core/core.hpp	/^    template<typename _Tp, int m, int n, int nm> static void compute( const Matx<_Tp, m, n>& a,$/;"	p	class:cv::SVD	access:public	signature:( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w )
compute	core/core.hpp	/^    template<typename _Tp, int m, int n, int nm> static void compute( const Matx<_Tp, m, n>& a,$/;"	p	class:cv::SVD	access:public	signature:( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w, Matx<_Tp, m, nm>& u, Matx<_Tp, n, nm>& vt )
compute	core/mat.hpp	/^    SVD::compute( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w, Matx<_Tp, m, nm>& u, Matx<_Tp, n, nm>& vt )$/;"	f	class:cv::SVD	signature:( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w, Matx<_Tp, m, nm>& u, Matx<_Tp, n, nm>& vt )
compute	core/mat.hpp	/^SVD::compute( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w )$/;"	f	class:cv::SVD	signature:( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w )
compute	features2d/features2d.hpp	/^    void compute( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;$/;"	p	class:cv::DescriptorExtractor	access:public	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
compute	features2d/features2d.hpp	/^    void compute( const Mat& image, vector<KeyPoint>& keypoints, Mat& imgDescriptor,$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& imgDescriptor, vector<vector<int> >* pointIdxsOfClusters=0, Mat* descriptors=0 )
compute	features2d/features2d.hpp	/^    void compute( const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints, vector<Mat>& descriptors ) const;$/;"	p	class:cv::DescriptorExtractor	access:public	signature:( const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints, vector<Mat>& descriptors ) const
compute	objdetect/objdetect.hpp	/^    CV_WRAP virtual void compute(const Mat& img,$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const Mat& img, CV_OUT vector<float>& descriptors, Size winStride=Size(), Size padding=Size(), const vector<Point>& locations=vector<Point>()) const
computeBlockHistograms	gpu/gpu.hpp	/^            void computeBlockHistograms(const GpuMat& img);$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:(const GpuMat& img)
computeBoundingBox	flann/kdtree_single_index.h	/^    void computeBoundingBox(BoundingBox& bbox)$/;"	f	class:cvflann::KDTreeSingleIndex	access:private	signature:(BoundingBox& bbox)
computeClustering	flann/hierarchical_clustering_index.h	/^    void computeClustering(NodePtr node, int* indices, int indices_length, int branching, int level)$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:private	signature:(NodePtr node, int* indices, int indices_length, int branching, int level)
computeClustering	flann/kmeans_index.h	/^    void computeClustering(KMeansNodePtr node, int* indices, int indices_length, int branching, int level)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNodePtr node, int* indices, int indices_length, int branching, int level)
computeCorrespondEpilines	calib3d/calib3d.hpp	/^CV_EXPORTS void computeCorrespondEpilines( InputArray points1,$/;"	p	namespace:cv	signature:( InputArray points1, int whichImage, InputArray F, OutputArray lines )
computeDescriptors	features2d/features2d.hpp	/^  computeDescriptors(const cv::Mat& image, const cv::Mat& integral_image, unsigned int level,$/;"	p	class:cv::ORB	access:private	signature:(const cv::Mat& image, const cv::Mat& integral_image, unsigned int level, std::vector<cv::KeyPoint>& keypoints, cv::Mat & descriptors) const
computeDistanceRaport	flann/index_testing.h	/^typename Distance::ResultType computeDistanceRaport(const Matrix<typename Distance::ElementType>& inputData, typename Distance::ElementType* target,$/;"	f	namespace:cvflann	signature:(const Matrix<typename Distance::ElementType>& inputData, typename Distance::ElementType* target, int* neighbors, int* groundTruth, int veclen, int n, const Distance& distance)
computeGradient	gpu/gpu.hpp	/^            void computeGradient(const GpuMat& img, GpuMat& grad, GpuMat& qangle);$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:(const GpuMat& img, GpuMat& grad, GpuMat& qangle)
computeGradient	objdetect/objdetect.hpp	/^    CV_WRAP virtual void computeGradient(const Mat& img, CV_OUT Mat& grad, CV_OUT Mat& angleOfs,$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const Mat& img, CV_OUT Mat& grad, CV_OUT Mat& angleOfs, Size paddingTL=Size(), Size paddingBR=Size()) const
computeImpl	features2d/features2d.hpp	/^	virtual void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
computeImpl	features2d/features2d.hpp	/^	virtual void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;$/;"	p	class:cv::SiftDescriptorExtractor	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
computeImpl	features2d/features2d.hpp	/^    virtual void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const = 0;$/;"	p	class:cv::DescriptorExtractor	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
computeImpl	features2d/features2d.hpp	/^    virtual void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;$/;"	p	class:cv::CalonderDescriptorExtractor	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
computeImpl	features2d/features2d.hpp	/^    virtual void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;$/;"	p	class:cv::SurfDescriptorExtractor	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
computeImpl	features2d/features2d.hpp	/^    virtual void computeImpl(const Mat& image, std::vector<KeyPoint>& keypoints, Mat& descriptors) const;$/;"	p	class:cv::BriefDescriptorExtractor	access:protected	signature:(const Mat& image, std::vector<KeyPoint>& keypoints, Mat& descriptors) const
computeImpl	features2d/features2d.hpp	/^  void computeImpl(const cv::Mat& image, std::vector<cv::KeyPoint>& keypoints, cv::Mat& descriptors) const;$/;"	p	class:cv::OrbDescriptorExtractor	access:protected	signature:(const cv::Mat& image, std::vector<cv::KeyPoint>& keypoints, cv::Mat& descriptors) const
computeImpl	features2d/features2d.hpp	/^void CalonderDescriptorExtractor<T>::computeImpl( const cv::Mat& image,$/;"	f	class:cv::CalonderDescriptorExtractor	signature:( const cv::Mat& image, std::vector<cv::KeyPoint>& keypoints, cv::Mat& descriptors) const
computeInitialDistances	flann/kdtree_single_index.h	/^    DistanceType computeInitialDistances(const ElementType* vec, std::vector<DistanceType>& dists)$/;"	f	class:cvflann::KDTreeSingleIndex	access:private	signature:(const ElementType* vec, std::vector<DistanceType>& dists)
computeIntegralImage	features2d/features2d.hpp	/^  void computeIntegralImage(const cv::Mat & image, unsigned int level, cv::Mat &integral_image);$/;"	p	class:cv::ORB	access:private	signature:(const cv::Mat & image, unsigned int level, cv::Mat &integral_image)
computeKeyPoints	features2d/features2d.hpp	/^  void computeKeyPoints(const std::vector<cv::Mat>& image_pyramid, const std::vector<cv::Mat>& mask_pyramid,$/;"	p	class:cv::ORB	access:private	signature:(const std::vector<cv::Mat>& image_pyramid, const std::vector<cv::Mat>& mask_pyramid, std::vector<std::vector<cv::KeyPoint> >& keypoints) const
computeLabels	flann/hierarchical_clustering_index.h	/^    void computeLabels(int* indices, int indices_length,  int* centers, int centers_length, int* labels, DistanceType& cost)$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:private	signature:(int* indices, int indices_length, int* centers, int centers_length, int* labels, DistanceType& cost)
computeLogPolarMapping	contrib/contrib.hpp	/^        virtual void computeLogPolarMapping(Mat& mappingMask) const;$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(Mat& mappingMask) const
computeMinMax	flann/kdtree_single_index.h	/^    void computeMinMax(int* ind, int count, int dim, ElementType& min_elem, ElementType& max_elem)$/;"	f	class:cvflann::KDTreeSingleIndex	access:private	signature:(int* ind, int count, int dim, ElementType& min_elem, ElementType& max_elem)
computeNodeStatistics	flann/kmeans_index.h	/^    void computeNodeStatistics(KMeansNodePtr node, int* indices, int indices_length)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNodePtr node, int* indices, int indices_length)
computeNormals	contrib/contrib.hpp	/^        void computeNormals(const vector<int>& subset, float normalRadius, int minNeighbors = 20);$/;"	p	class:cv::Mesh3D	access:public	signature:(const vector<int>& subset, float normalRadius, int minNeighbors = 20)
computeNormals	contrib/contrib.hpp	/^        void computeNormals(float normalRadius, int minNeighbors = 20);$/;"	p	class:cv::Mesh3D	access:public	signature:(float normalRadius, int minNeighbors = 20)
computeOrientation	features2d/features2d.hpp	/^  computeOrientation(const cv::Mat& image, const cv::Mat& integral_image, unsigned int level,$/;"	p	class:cv::ORB	access:private	signature:(const cv::Mat& image, const cv::Mat& integral_image, unsigned int level, std::vector<cv::KeyPoint>& keypoints) const
computeRecallPrecisionCurve	features2d/features2d.hpp	/^CV_EXPORTS void computeRecallPrecisionCurve( const vector<vector<DMatch> >& matches1to2,$/;"	p	namespace:cv	signature:( const vector<vector<DMatch> >& matches1to2, const vector<vector<uchar> >& correctMatches1to2Mask, vector<Point2f>& recallPrecisionCurve )
compute_ground_truth	flann/ground_truth.h	/^void compute_ground_truth(const Matrix<typename Distance::ElementType>& dataset, const Matrix<typename Distance::ElementType>& testset, Matrix<int>& matches,$/;"	f	namespace:cvflann	signature:(const Matrix<typename Distance::ElementType>& dataset, const Matrix<typename Distance::ElementType>& testset, Matrix<int>& matches, int skip=0, Distance d = Distance())
condens	legacy/legacy.hpp	/^CVAPI(void)  cvConDensUpdateByTime( CvConDensation* condens);$/;"	v
condens	legacy/legacy.hpp	/^CVAPI(void)  cvReleaseConDensation( CvConDensation** condens );$/;"	v
condensed_idx	ml/ml.hpp	/^    int condensed_idx;$/;"	m	struct:CvDTreeSplit	access:public
confidence	features2d/features2d.hpp	/^      double confidence;$/;"	m	struct:cv::SimpleBlobDetector::Center	access:public
conj	core/core.hpp	/^    Complex conj() const;$/;"	p	class:cv::Complex	access:public	signature:() const
conj	core/core.hpp	/^    Scalar_<_Tp> conj() const;$/;"	p	class:cv::Scalar_	access:public	signature:() const
conj	core/operations.hpp	/^template<typename _Tp> inline Complex<_Tp> Complex<_Tp>::conj() const$/;"	f	class:cv::Complex	signature:() const
conj	core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp> Scalar_<_Tp>::conj() const$/;"	f	class:cv::Scalar_	signature:() const
connectEdges	imgproc/imgproc.hpp	/^    int connectEdges( int edgeA, int edgeB );$/;"	p	class:cv::Subdiv2D	access:protected	signature:( int edgeA, int edgeB )
constBorderRow	imgproc/imgproc.hpp	/^    vector<uchar> constBorderRow;$/;"	m	class:cv::FilterEngine	access:public
constBorderValue	imgproc/imgproc.hpp	/^    vector<uchar> constBorderValue;$/;"	m	class:cv::FilterEngine	access:public
const_iterator	core/core.hpp	/^    typedef MatConstIterator_<_Tp> const_iterator;$/;"	t	class:cv::Mat_	access:public
const_iterator	core/core.hpp	/^    typedef SeqIterator<_Tp> const_iterator;$/;"	t	class:cv::Seq	access:public
const_iterator	core/core.hpp	/^    typedef SparseMatConstIterator const_iterator;$/;"	t	class:cv::SparseMat	access:public
const_iterator	core/core.hpp	/^    typedef SparseMatConstIterator_<_Tp> const_iterator;$/;"	t	class:cv::SparseMat_	access:public
const_iterator	core/operations.hpp	/^    typedef const _Tp* const_iterator;$/;"	t	class:cv::Vector	access:public
const_pointer	core/core.hpp	/^    typedef const value_type* const_pointer;$/;"	t	class:cv::Allocator	access:public
const_reference	core/core.hpp	/^    typedef const value_type& const_reference;$/;"	t	class:cv::Allocator	access:public
const_reference	core/operations.hpp	/^    typedef const _Tp& const_reference;$/;"	t	class:cv::Vector	access:public
construct	core/core.hpp	/^    void construct(pointer p, const _Tp& v) { new(static_cast<void*>(p)) _Tp(v); }$/;"	f	class:cv::Allocator	access:public	signature:(pointer p, const _Tp& v)
container	core/core.hpp	/^    const CvFileNode* container;$/;"	m	class:cv::FileNodeIterator	access:public
contains	core/core.hpp	/^    bool contains(const Point_<_Tp>& pt) const;$/;"	p	class:cv::Rect_	access:public	signature:(const Point_<_Tp>& pt) const
contains	core/operations.hpp	/^template<typename _Tp> inline bool Rect_<_Tp>::contains(const Point_<_Tp>& pt) const$/;"	f	class:cv::Rect_	signature:(const Point_<_Tp>& pt) const
contour	imgproc/imgproc_c.h	/^CVAPI(int)  cvCheckContourConvexity( const CvArr* contour );$/;"	v
contour	imgproc/types_c.h	/^    CvSeq* contour; \/* optional component boundary$/;"	m	struct:CvConnectedComp	access:public
contour	legacy/legacy.hpp	/^    CvContour* contour; $/;"	m	struct:CvLCMNode	access:public
contourArea	imgproc/imgproc.hpp	/^CV_EXPORTS_W double contourArea( InputArray contour, bool oriented=false );$/;"	p	namespace:cv	signature:( InputArray contour, bool oriented=false )
controlMatrix	video/tracking.hpp	/^    Mat controlMatrix;      \/\/!< control matrix (B) (not used if there is no control)$/;"	m	class:cv::KalmanFilter	access:public
control_matrix	video/tracking.hpp	/^    CvMat* control_matrix;      \/* control matrix (B)$/;"	m	struct:CvKalman	access:public
convert	features2d/features2d.hpp	/^    static void convert(const std::vector<KeyPoint>& keypoints,$/;"	p	class:cv::KeyPoint	access:public	signature:(const std::vector<KeyPoint>& keypoints, CV_OUT std::vector<Point2f>& points2f, const std::vector<int>& keypointIndexes=std::vector<int>())
convert	features2d/features2d.hpp	/^    static void convert(const std::vector<Point2f>& points2f,$/;"	p	class:cv::KeyPoint	access:public	signature:(const std::vector<Point2f>& points2f, CV_OUT std::vector<KeyPoint>& keypoints, float size=1, float response=1, int octave=0, int class_id=-1)
convertMaps	imgproc/imgproc.hpp	/^CV_EXPORTS_W void convertMaps( InputArray map1, InputArray map2,$/;"	p	namespace:cv	signature:( InputArray map1, InputArray map2, OutputArray dstmap1, OutputArray dstmap2, int dstmap1type, bool nninterpolation=false )
convertPointsFromHomogeneous	calib3d/calib3d.hpp	/^CV_EXPORTS_W void convertPointsFromHomogeneous( InputArray src, OutputArray dst );$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst )
convertPointsHomogeneous	calib3d/calib3d.hpp	/^CV_EXPORTS void convertPointsHomogeneous( InputArray src, OutputArray dst );$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst )
convertPointsToHomogeneous	calib3d/calib3d.hpp	/^CV_EXPORTS_W void convertPointsToHomogeneous( InputArray src, OutputArray dst );$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst )
convertPosteriorsToChar	features2d/features2d.hpp	/^  void convertPosteriorsToChar();$/;"	p	class:cv::RandomizedTree	access:private	signature:()
convertScaleAbs	core/core.hpp	/^CV_EXPORTS_W void convertScaleAbs(InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, double alpha=1, double beta=0)
convertTo	core/core.hpp	/^    void convertTo( Mat& m, int rtype, double alpha=1, double beta=0 ) const;$/;"	p	class:cv::SparseMat	access:public	signature:( Mat& m, int rtype, double alpha=1, double beta=0 ) const
convertTo	core/core.hpp	/^    void convertTo( OutputArray m, int rtype, double alpha=1, double beta=0 ) const;$/;"	p	class:cv::Mat	access:public	signature:( OutputArray m, int rtype, double alpha=1, double beta=0 ) const
convertTo	core/core.hpp	/^    void convertTo( SparseMat& m, int rtype, double alpha=1 ) const;$/;"	p	class:cv::SparseMat	access:public	signature:( SparseMat& m, int rtype, double alpha=1 ) const
convertTo	gpu/gpumat.hpp	/^        void convertTo( GpuMat& m, int rtype, double alpha=1, double beta=0 ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( GpuMat& m, int rtype, double alpha=1, double beta=0 ) const
convertToDMatches	features2d/features2d.hpp	/^    static void convertToDMatches( const DescriptorCollection& descriptors,$/;"	p	class:cv::FlannBasedMatcher	access:protected	signature:( const DescriptorCollection& descriptors, const Mat& indices, const Mat& distances, vector<vector<DMatch> >& matches )
convexHull	imgproc/imgproc.hpp	/^CV_EXPORTS_W void convexHull( InputArray points, OutputArray hull,$/;"	p	namespace:cv	signature:( InputArray points, OutputArray hull, bool clockwise=false, bool returnPoints=true )
convolve	gpu/gpu.hpp	/^            friend void convolve(const GpuMat&, const GpuMat&, GpuMat&, bool, ConvolveBuf&);$/;"	p	struct:cv::gpu::ConvolveBuf	access:friend	signature:(const GpuMat&, const GpuMat&, GpuMat&, bool, ConvolveBuf&)
convolve	gpu/gpu.hpp	/^        CV_EXPORTS void convolve(const GpuMat& image, const GpuMat& templ, GpuMat& result, $/;"	p	namespace:cv::gpu	signature:(const GpuMat& image, const GpuMat& templ, GpuMat& result, bool ccorr, ConvolveBuf& buf)
convolve	gpu/gpu.hpp	/^        CV_EXPORTS void convolve(const GpuMat& image, const GpuMat& templ, GpuMat& result, $/;"	p	namespace:cv::gpu	signature:(const GpuMat& image, const GpuMat& templ, GpuMat& result, bool ccorr=false)
copy	flann/result_set.h	/^    virtual void copy(int* indices, DistanceType* dist, int n_neighbors = -1) const$/;"	f	class:cvflann::UniqueResultSet	access:public	signature:(int* indices, DistanceType* dist, int n_neighbors = -1) const
copy2D	gpu/NCV.hpp	/^    NCVStatus copy2D(NCVMatrix<T> &dst, NcvSize32u roi, cudaStream_t cuStream) const$/;"	f	class:NCVMatrix	access:public	signature:(NCVMatrix<T> &dst, NcvSize32u roi, cudaStream_t cuStream) const
copyMakeBorder	gpu/gpu.hpp	/^        CV_EXPORTS void copyMakeBorder(const GpuMat& src, GpuMat& dst, int top, int bottom, int left, int right, const Scalar& value = Scalar(), Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int top, int bottom, int left, int right, const Scalar& value = Scalar(), Stream& stream = Stream::Null())
copyMakeBorder	imgproc/imgproc.hpp	/^CV_EXPORTS_W void copyMakeBorder( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar& value=Scalar() )
copySize	core/core.hpp	/^    void copySize(const Mat& m);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m)
copySolid	gpu/NCV.hpp	/^    NCVStatus copySolid(NCVMatrix<T> &dst, cudaStream_t cuStream, size_t howMuch=0) const$/;"	f	class:NCVMatrix	access:public	signature:(NCVMatrix<T> &dst, cudaStream_t cuStream, size_t howMuch=0) const
copySolid	gpu/NCV.hpp	/^    NCVStatus copySolid(NCVVector<T> &dst, cudaStream_t cuStream, size_t howMuch=0) const$/;"	f	class:NCVVector	access:public	signature:(NCVVector<T> &dst, cudaStream_t cuStream, size_t howMuch=0) const
copyTo	core/core.hpp	/^    void copyTo( Mat& m ) const;$/;"	p	class:cv::SparseMat	access:public	signature:( Mat& m ) const
copyTo	core/core.hpp	/^    void copyTo( OutputArray m ) const;$/;"	p	class:cv::Mat	access:public	signature:( OutputArray m ) const
copyTo	core/core.hpp	/^    void copyTo( OutputArray m, InputArray mask ) const;$/;"	p	class:cv::Mat	access:public	signature:( OutputArray m, InputArray mask ) const
copyTo	core/core.hpp	/^    void copyTo( SparseMat& m ) const;$/;"	p	class:cv::SparseMat	access:public	signature:( SparseMat& m ) const
copyTo	core/core.hpp	/^    void copyTo(vector<_Tp>& vec, const Range& range=Range::all()) const;$/;"	p	class:cv::Seq	access:public	signature:(vector<_Tp>& vec, const Range& range=Range::all()) const
copyTo	core/operations.hpp	/^    void copyTo(Vector<_Tp>& vec) const$/;"	f	class:cv::Vector	access:public	signature:(Vector<_Tp>& vec) const
copyTo	core/operations.hpp	/^    void copyTo(std::vector<_Tp>& vec) const$/;"	f	class:cv::Vector	access:public	signature:(std::vector<_Tp>& vec) const
copyTo	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::copyTo(vector<_Tp>& vec, const Range& range) const$/;"	f	class:cv::Seq	signature:(vector<_Tp>& vec, const Range& range) const
copyTo	gpu/gpumat.hpp	/^        void copyTo( GpuMat& m ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( GpuMat& m ) const
copyTo	gpu/gpumat.hpp	/^        void copyTo( GpuMat& m, const GpuMat& mask ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( GpuMat& m, const GpuMat& mask ) const
copyTo	objdetect/objdetect.hpp	/^    virtual void copyTo(HOGDescriptor& c) const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(HOGDescriptor& c) const
copy_from_value	flann/any.h	/^    virtual void copy_from_value(void const* src, void** dest) = 0;$/;"	p	struct:cdiggins::anyimpl::base_any_policy	access:public	signature:(void const* src, void** dest)
copy_from_value	flann/any.h	/^    virtual void copy_from_value(void const* src, void** dest)$/;"	f	struct:cdiggins::anyimpl::big_any_policy	access:public	signature:(void const* src, void** dest)
copy_from_value	flann/any.h	/^    virtual void copy_from_value(void const* src, void** dest)$/;"	f	struct:cdiggins::anyimpl::small_any_policy	access:public	signature:(void const* src, void** dest)
cornerEigenValsAndVecs	imgproc/imgproc.hpp	/^CV_EXPORTS_W void cornerEigenValsAndVecs( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int blockSize, int ksize, int borderType=BORDER_DEFAULT )
cornerHarris	gpu/gpu.hpp	/^        CV_EXPORTS void cornerHarris(const GpuMat& src, GpuMat& dst, GpuMat& Dx, GpuMat& Dy, int blockSize, int ksize, double k, int borderType=BORDER_REFLECT101);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, GpuMat& Dx, GpuMat& Dy, int blockSize, int ksize, double k, int borderType=BORDER_REFLECT101)
cornerHarris	gpu/gpu.hpp	/^        CV_EXPORTS void cornerHarris(const GpuMat& src, GpuMat& dst, int blockSize, int ksize, double k, int borderType=BORDER_REFLECT101);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int blockSize, int ksize, double k, int borderType=BORDER_REFLECT101)
cornerHarris	imgproc/imgproc.hpp	/^CV_EXPORTS_W void cornerHarris( InputArray src, OutputArray dst, int blockSize,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int blockSize, int ksize, double k, int borderType=BORDER_DEFAULT )
cornerMinEigenVal	gpu/gpu.hpp	/^        CV_EXPORTS void cornerMinEigenVal(const GpuMat& src, GpuMat& dst, GpuMat& Dx, GpuMat& Dy, int blockSize, int ksize, int borderType=BORDER_REFLECT101);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, GpuMat& Dx, GpuMat& Dy, int blockSize, int ksize, int borderType=BORDER_REFLECT101)
cornerMinEigenVal	gpu/gpu.hpp	/^        CV_EXPORTS void cornerMinEigenVal(const GpuMat& src, GpuMat& dst, int blockSize, int ksize, int borderType=BORDER_REFLECT101);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int blockSize, int ksize, int borderType=BORDER_REFLECT101)
cornerMinEigenVal	imgproc/imgproc.hpp	/^CV_EXPORTS_W void cornerMinEigenVal( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int blockSize, int ksize=3, int borderType=BORDER_DEFAULT )
cornerSubPix	imgproc/imgproc.hpp	/^CV_EXPORTS_W void cornerSubPix( InputArray image, InputOutputArray corners,$/;"	p	namespace:cv	signature:( InputArray image, InputOutputArray corners, Size winSize, Size zeroZone, TermCriteria criteria )
corners	objdetect/objdetect.hpp	/^  CvMat *corners;$/;"	m	struct:CvDataMatrixCode	access:public
corners	objdetect/objdetect.hpp	/^  Point corners[4]; \/\/TODO vector$/;"	m	struct:cv::DataMatrixCode	access:public
correct	video/tracking.hpp	/^    CV_WRAP const Mat& correct(const Mat& measurement);$/;"	p	class:cv::KalmanFilter	access:public	signature:(const Mat& measurement)
cost	calib3d/calib3d.hpp	/^    CvMat* cost;$/;"	m	struct:CvStereoBMState	access:public
count	core/core.hpp	/^    int err, count;$/;"	m	class:cv::LineIterator	access:public
count	core/core_c.h	/^    int count; \/* number of arrays *\/$/;"	m	struct:CvNArrayIterator	access:public
count	core/types_c.h	/^    int    count;             \/* Number of elements in the block.           *\/$/;"	m	struct:CvSeqBlock	access:public
count	flann/heap.h	/^    int count;$/;"	m	class:cvflann::Heap	access:private
count	flann/result_set.h	/^    int count;$/;"	m	class:cvflann::KNNResultSet	access:private
count	flann/result_set.h	/^    int count;$/;"	m	class:cvflann::KNNSimpleResultSet	access:private
count	flann/result_set.h	/^    size_t count;$/;"	m	class:cvflann::RadiusResultSet	access:private
count	ml/ml.hpp	/^        int count;$/;"	m	union:CvTrainTestSplit::__anon85	access:public
count	ml/ml.hpp	/^    CvMat** count;$/;"	m	class:CvNormalBayesClassifier	access:protected
count	ml/ml.hpp	/^    int dims, count;$/;"	m	struct:CvVectors	access:public
count	objdetect/objdetect.hpp	/^    int  count;$/;"	m	struct:CvHaarClassifierCascade	access:public
count	objdetect/objdetect.hpp	/^    int  count;$/;"	m	struct:CvHaarStageClassifier	access:public
count	objdetect/objdetect.hpp	/^    int count;$/;"	m	struct:CvHaarClassifier	access:public
countCorrectMatches	flann/index_testing.h	/^inline int countCorrectMatches(int* neighbors, int* groundTruth, int n)$/;"	f	namespace:cvflann	signature:(int* neighbors, int* groundTruth, int n)
countFrames	video/background_segm.hpp	/^    int                        countFrames;$/;"	m	struct:CvGaussBGModel	access:public
countNonZero	core/core.hpp	/^CV_EXPORTS_W int countNonZero( InputArray src );$/;"	p	namespace:cv	signature:( InputArray src )
countNonZero	gpu/gpu.hpp	/^        CV_EXPORTS int countNonZero(const GpuMat& src);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src)
countNonZero	gpu/gpu.hpp	/^        CV_EXPORTS int countNonZero(const GpuMat& src, GpuMat& buf);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& buf)
countNonZeroElements	features2d/features2d.hpp	/^  static int countNonZeroElements(float *vec, int n, double tol=1e-10);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(float *vec, int n, double tol=1e-10)
countZeroElements	features2d/features2d.hpp	/^  float countZeroElements();$/;"	p	class:cv::RTreeClassifier	access:public	signature:()
counter	contrib/contrib.hpp	/^        int64 counter;$/;"	m	class:cv::TickMeter	access:private
counter_	flann/random.h	/^    int counter_;$/;"	m	class:cvflann::UniqueRandom	access:private
counts	ml/ml.hpp	/^    CvMat* counts;$/;"	m	struct:CvDTreeTrainData	access:public
cov_mat_type	ml/ml.hpp	/^    CV_PROP_RW int cov_mat_type;$/;"	m	struct:CvEMParams	access:public
cov_rotate_mats	ml/ml.hpp	/^    CvMat** cov_rotate_mats;$/;"	m	class:CvEM	access:protected
cov_rotate_mats	ml/ml.hpp	/^    CvMat** cov_rotate_mats;$/;"	m	class:CvNormalBayesClassifier	access:protected
covs	ml/ml.hpp	/^    CvMat** covs;$/;"	m	class:CvEM	access:protected
covs	ml/ml.hpp	/^    const CvMat** covs;$/;"	m	struct:CvEMParams	access:public
create	core/core.hpp	/^    virtual void create(Size sz, int type, int i=-1, bool allocateVector=false, int fixedDepthMask=0) const;$/;"	p	class:cv::_OutputArray	access:public	signature:(Size sz, int type, int i=-1, bool allocateVector=false, int fixedDepthMask=0) const
create	core/core.hpp	/^    virtual void create(int dims, const int* size, int type, int i=-1, bool allowTransposed=false, int fixedDepthMask=0) const;$/;"	p	class:cv::_OutputArray	access:public	signature:(int dims, const int* size, int type, int i=-1, bool allowTransposed=false, int fixedDepthMask=0) const
create	core/core.hpp	/^    virtual void create(int rows, int cols, int type, int i=-1, bool allowTransposed=false, int fixedDepthMask=0) const;$/;"	p	class:cv::_OutputArray	access:public	signature:(int rows, int cols, int type, int i=-1, bool allowTransposed=false, int fixedDepthMask=0) const
create	core/core.hpp	/^    void create(Size _size);$/;"	p	class:cv::Mat_	access:public	signature:(Size _size)
create	core/core.hpp	/^    void create(Size _size, int _type);$/;"	p	class:cv::Mat	access:public	signature:(Size _size, int _type)
create	core/core.hpp	/^    void create(int _ndims, const int* _sizes);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes)
create	core/core.hpp	/^    void create(int _ndims, const int* _sizes, int _type);$/;"	p	class:cv::Mat	access:public	signature:(int _ndims, const int* _sizes, int _type)
create	core/core.hpp	/^    void create(int _rows, int _cols);$/;"	p	class:cv::Mat_	access:public	signature:(int _rows, int _cols)
create	core/core.hpp	/^    void create(int _rows, int _cols, int _type);$/;"	p	class:cv::Mat	access:public	signature:(int _rows, int _cols, int _type)
create	core/core.hpp	/^    void create(int dims, const int* _sizes);$/;"	p	class:cv::SparseMat_	access:public	signature:(int dims, const int* _sizes)
create	core/core.hpp	/^    void create(int dims, const int* _sizes, int _type);$/;"	p	class:cv::SparseMat	access:public	signature:(int dims, const int* _sizes, int _type)
create	core/mat.hpp	/^SparseMat_<_Tp>::create(int _dims, const int* _sizes)$/;"	f	class:cv::SparseMat_	signature:(int _dims, const int* _sizes)
create	core/mat.hpp	/^inline void Mat::create(Size _sz, int _type)$/;"	f	class:cv::Mat	signature:(Size _sz, int _type)
create	core/mat.hpp	/^inline void Mat::create(int _rows, int _cols, int _type)$/;"	f	class:cv::Mat	signature:(int _rows, int _cols, int _type)
create	core/mat.hpp	/^template<typename _Tp> inline void Mat_<_Tp>::create(Size _sz)$/;"	f	class:cv::Mat_	signature:(Size _sz)
create	core/mat.hpp	/^template<typename _Tp> inline void Mat_<_Tp>::create(int _dims, const int* _sz)$/;"	f	class:cv::Mat_	signature:(int _dims, const int* _sz)
create	core/mat.hpp	/^template<typename _Tp> inline void Mat_<_Tp>::create(int _rows, int _cols)$/;"	f	class:cv::Mat_	signature:(int _rows, int _cols)
create	features2d/features2d.hpp	/^    static Ptr<AdjusterAdapter> create( const string& detectorType );$/;"	p	class:cv::AdjusterAdapter	access:public	signature:( const string& detectorType )
create	features2d/features2d.hpp	/^    static Ptr<DescriptorExtractor> create( const string& descriptorExtractorType );$/;"	p	class:cv::DescriptorExtractor	access:public	signature:( const string& descriptorExtractorType )
create	features2d/features2d.hpp	/^    static Ptr<DescriptorMatcher> create( const string& descriptorMatcherType );$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const string& descriptorMatcherType )
create	features2d/features2d.hpp	/^    static Ptr<FeatureDetector> create( const string& detectorType );$/;"	p	class:cv::FeatureDetector	access:public	signature:( const string& detectorType )
create	features2d/features2d.hpp	/^    static Ptr<GenericDescriptorMatcher> create( const string& genericDescritptorMatcherType,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const string& genericDescritptorMatcherType, const string &paramsFilename=string() )
create	flann/all_indices.h	/^    static NNIndex<Distance>* create(const Matrix<typename Distance::ElementType>& dataset, const IndexParams& params, const Distance& distance)$/;"	f	struct:cvflann::index_creator	access:public	signature:(const Matrix<typename Distance::ElementType>& dataset, const IndexParams& params, const Distance& distance)
create	flann/object_factory.h	/^    ObjectCreator create(UniqueIdType id)$/;"	f	class:cvflann::ObjectFactory	access:public	signature:(UniqueIdType id)
create	gpu/gpu.hpp	/^            void create();$/;"	p	class:cv::gpu::Stream	access:private	signature:()
create	gpu/gpu.hpp	/^            void create(Size image_size, Size templ_size);$/;"	p	struct:cv::gpu::ConvolveBuf	access:public	signature:(Size image_size, Size templ_size)
create	gpu/gpu.hpp	/^            void create(Size image_size, int image_type_);$/;"	p	struct:cv::gpu::PyrDownBuf	access:public	signature:(Size image_size, int image_type_)
create	gpu/gpu.hpp	/^            void create(Size image_size, int image_type_);$/;"	p	struct:cv::gpu::PyrUpBuf	access:public	signature:(Size image_size, int image_type_)
create	gpu/gpu.hpp	/^            void create(Size size, int type, int alloc_type = ALLOC_PAGE_LOCKED);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(Size size, int type, int alloc_type = ALLOC_PAGE_LOCKED)
create	gpu/gpu.hpp	/^            void create(const Size& image_size, int apperture_size = 3);$/;"	p	struct:cv::gpu::CannyBuf	access:public	signature:(const Size& image_size, int apperture_size = 3)
create	gpu/gpu.hpp	/^            void create(int rows, int cols, int type, int alloc_type = ALLOC_PAGE_LOCKED);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(int rows, int cols, int type, int alloc_type = ALLOC_PAGE_LOCKED)
create	gpu/gpumat.hpp	/^        void create(Size size, int type);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(Size size, int type)
create	gpu/gpumat.hpp	/^        void create(int rows, int cols, int type);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int rows, int cols, int type)
create	gpu/matrix_operations.hpp	/^inline void CudaMem::create(Size _size, int _type, int _alloc_type) { create(_size.height, _size.width, _type, _alloc_type); }$/;"	f	class:cv::gpu::CudaMem	signature:(Size _size, int _type, int _alloc_type)
create	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackAnalysis* cvCreateBlobTrackAnalysisList(CvBlobTrackAnalysisOne* (*create)());$/;"	p	signature:()
create	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackPostProc* cvCreateBlobTrackPostProcList(CvBlobTrackPostProcOne* (*create)());$/;"	p	signature:()
create	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerList(CvBlobTrackerOne* (*create)());$/;"	p	signature:()
create	legacy/legacy.hpp	/^    void create( CvSize size, int depth, int channels )$/;"	f	class:CvImage	access:public	signature:( CvSize size, int depth, int channels )
create	legacy/legacy.hpp	/^    void create( int rows, int cols, int type )$/;"	f	class:CvMatrix	access:public	signature:( int rows, int cols, int type )
create	ml/ml.hpp	/^    CV_WRAP virtual void create( const cv::Mat& layerSizes,$/;"	p	class:CvANN_MLP	access:public	signature:( const cv::Mat& layerSizes, int activateFunc=CvANN_MLP::SIGMOID_SYM, double fparam1=0, double fparam2=0 )
create	ml/ml.hpp	/^    virtual bool create( const CvSVMParams* params, Calc _calc_func );$/;"	p	struct:CvSVMKernel	access:public	signature:( const CvSVMParams* params, Calc _calc_func )
create	ml/ml.hpp	/^    virtual bool create( int count, int var_count, const float** samples, schar* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, schar* y, int alpha_count, double* alpha, double Cp, double Cn, CvMemStorage* storage, CvSVMKernel* kernel, GetRow get_row, SelectWorkingSet select_working_set, CalcRho calc_rho )
create	ml/ml.hpp	/^    virtual void create( const CvMat* layerSizes,$/;"	p	class:CvANN_MLP	access:public	signature:( const CvMat* layerSizes, int activateFunc=CvANN_MLP::SIGMOID_SYM, double fparam1=0, double fparam2=0 )
create	objdetect/objdetect.hpp	/^    static Ptr<FeatureEvaluator> create(int type);$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(int type)
createBoxFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createBoxFilter( int srcType, int dstType, Size ksize,$/;"	p	namespace:cv	signature:( int srcType, int dstType, Size ksize, Point anchor=Point(-1,-1), bool normalize=true, int borderType=BORDER_DEFAULT)
createBoxFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createBoxFilter_GPU(int srcType, int dstType, const Size& ksize,$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Size& ksize, const Point& anchor = Point(-1,-1))
createButton	highgui/highgui.hpp	/^CV_EXPORTS int createButton( const string& bar_name, ButtonCallback on_change,$/;"	p	namespace:cv	signature:( const string& bar_name, ButtonCallback on_change, void* userdata=NULL, int type=CV_PUSH_BUTTON, bool initial_button_state=0)
createContinuous	gpu/gpumat.hpp	/^    CV_EXPORTS GpuMat createContinuous(Size size, int type);$/;"	p	namespace:cv::gpu	signature:(Size size, int type)
createContinuous	gpu/gpumat.hpp	/^    CV_EXPORTS GpuMat createContinuous(int rows, int cols, int type);$/;"	p	namespace:cv::gpu	signature:(int rows, int cols, int type)
createContinuous	gpu/gpumat.hpp	/^    CV_EXPORTS void createContinuous(Size size, int type, GpuMat& m);$/;"	p	namespace:cv::gpu	signature:(Size size, int type, GpuMat& m)
createContinuous	gpu/gpumat.hpp	/^    CV_EXPORTS void createContinuous(int rows, int cols, int type, GpuMat& m);$/;"	p	namespace:cv::gpu	signature:(int rows, int cols, int type, GpuMat& m)
createDerivFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createDerivFilter( int srcType, int dstType,$/;"	p	namespace:cv	signature:( int srcType, int dstType, int dx, int dy, int ksize, int borderType=BORDER_DEFAULT )
createDerivFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createDerivFilter_GPU(int srcType, int dstType, int dx, int dy, int ksize,$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, int dx, int dy, int ksize, int rowBorderType = BORDER_DEFAULT, int columnBorderType = -1)
createFilter2D_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createFilter2D_GPU(const Ptr<BaseFilter_GPU>& filter2D, int srcType, int dstType);$/;"	p	namespace:cv::gpu	signature:(const Ptr<BaseFilter_GPU>& filter2D, int srcType, int dstType)
createGaussianFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createGaussianFilter( int type, Size ksize,$/;"	p	namespace:cv	signature:( int type, Size ksize, double sigma1, double sigma2=0, int borderType=BORDER_DEFAULT)
createGaussianFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createGaussianFilter_GPU(int type, Size ksize, double sigma1, double sigma2 = 0,$/;"	p	namespace:cv::gpu	signature:(int type, Size ksize, double sigma1, double sigma2 = 0, int rowBorderType = BORDER_DEFAULT, int columnBorderType = -1)
createGpuMatHeader	gpu/gpu.hpp	/^            GpuMat createGpuMatHeader() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
createLinearFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createLinearFilter(int srcType, int dstType,$/;"	p	namespace:cv	signature:(int srcType, int dstType, InputArray kernel, Point _anchor=Point(-1,-1), double delta=0, int _rowBorderType=BORDER_DEFAULT, int _columnBorderType=-1, const Scalar& _borderValue=Scalar())
createLinearFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createLinearFilter_GPU(int srcType, int dstType, const Mat& kernel,$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Mat& kernel, const Point& anchor = Point(-1,-1))
createMatHeader	gpu/gpu.hpp	/^            Mat createMatHeader() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
createMatHeader	gpu/matrix_operations.hpp	/^inline Mat CudaMem::createMatHeader() const { return Mat(size(), type(), data); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
createMorphologyFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createMorphologyFilter(int op, int type, InputArray kernel,$/;"	p	namespace:cv	signature:(int op, int type, InputArray kernel, Point anchor=Point(-1,-1), int _rowBorderType=BORDER_CONSTANT, int _columnBorderType=-1, const Scalar& _borderValue=morphologyDefaultBorderValue())
createMorphologyFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createMorphologyFilter_GPU(int op, int type, const Mat& kernel,$/;"	p	namespace:cv::gpu	signature:(int op, int type, const Mat& kernel, const Point& anchor = Point(-1,-1), int iterations = 1)
createNodes	features2d/features2d.hpp	/^  void createNodes(int num_nodes, RNG &rng);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int num_nodes, RNG &rng)
createOpenGLCallback	highgui/highgui.hpp	/^CV_EXPORTS void createOpenGLCallback(const string& winname, CvOpenGLCallback callbackOpenGL, void* userdata=0);$/;"	p	namespace:cv	signature:(const string& winname, CvOpenGLCallback callbackOpenGL, void* userdata=0)
createSeparableFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createSeparableFilter_GPU(const Ptr<BaseRowFilter_GPU>& rowFilter,$/;"	p	namespace:cv::gpu	signature:(const Ptr<BaseRowFilter_GPU>& rowFilter, const Ptr<BaseColumnFilter_GPU>& columnFilter, int srcType, int bufType, int dstType)
createSeparableLinearFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createSeparableLinearFilter(int srcType, int dstType,$/;"	p	namespace:cv	signature:(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point _anchor=Point(-1,-1), double delta=0, int _rowBorderType=BORDER_DEFAULT, int _columnBorderType=-1, const Scalar& _borderValue=Scalar())
createSeparableLinearFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createSeparableLinearFilter_GPU(int srcType, int dstType, const Mat& rowKernel,$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Mat& rowKernel, const Mat& columnKernel, const Point& anchor = Point(-1,-1), int rowBorderType = BORDER_DEFAULT, int columnBorderType = -1)
createTrackbar	highgui/highgui.hpp	/^CV_EXPORTS int createTrackbar( const string& trackbarname, const string& winname,$/;"	p	namespace:cv	signature:( const string& trackbarname, const string& winname, int* value, int count, TrackbarCallback onChange=0, void* userdata=0)
create_index_by_type	flann/all_indices.h	/^NNIndex<Distance>* create_index_by_type(const Matrix<typename Distance::ElementType>& dataset, const IndexParams& params, const Distance& distance)$/;"	f	namespace:cvflann	signature:(const Matrix<typename Distance::ElementType>& dataset, const IndexParams& params, const Distance& distance)
create_index_by_type	flann/autotuned_index.h	/^NNIndex<Distance>* create_index_by_type(const Matrix<typename Distance::ElementType>& dataset, const IndexParams& params, const Distance& distance);$/;"	p	namespace:cvflann	signature:(const Matrix<typename Distance::ElementType>& dataset, const IndexParams& params, const Distance& distance)
create_kernel	ml/ml.hpp	/^    virtual void create_kernel();$/;"	p	class:CvSVM	access:protected	signature:()
create_solver	ml/ml.hpp	/^    virtual void create_solver();$/;"	p	class:CvSVM	access:protected	signature:()
criteria	calib3d/calib3d.hpp	/^    CvTermCriteria criteria;$/;"	m	class:CvLevMarq	access:public
criteria	contrib/contrib.hpp	/^        CvTermCriteria criteria;$/;"	m	class:cv::LevMarqSparse	access:public
cross	core/core.hpp	/^    Mat cross(InputArray m) const;$/;"	p	class:cv::Mat	access:public	signature:(InputArray m) const
cross	core/core.hpp	/^    Mat_ cross(const Mat_& m) const;$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m) const
cross	core/core.hpp	/^    Point3_ cross(const Point3_& pt) const;$/;"	p	class:cv::Point3_	access:public	signature:(const Point3_& pt) const
cross	core/core.hpp	/^    Vec cross(const Vec& v) const;$/;"	p	class:cv::Vec	access:public	signature:(const Vec& v) const
cross	core/mat.hpp	/^    Mat cross(const Mat& m) const;$/;"	p	class:cv::MatExpr	access:public	signature:(const Mat& m) const
cross	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::cross(const Mat_& m) const$/;"	f	class:cv::Mat_	signature:(const Mat_& m) const
cross	core/operations.hpp	/^template<> inline Vec<double, 3> Vec<double, 3>::cross(const Vec<double, 3>& v) const$/;"	f	class:cv::Vec	signature:(const Vec<double, 3>& v) const
cross	core/operations.hpp	/^template<> inline Vec<float, 3> Vec<float, 3>::cross(const Vec<float, 3>& v) const$/;"	f	class:cv::Vec	signature:(const Vec<float, 3>& v) const
cross	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn> Vec<_Tp, cn>::cross(const Vec<_Tp, cn>& v) const$/;"	f	class:cv::Vec	signature:(const Vec<_Tp, cn>& v) const
cross	core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp> Point3_<_Tp>::cross(const Point3_<_Tp>& pt) const$/;"	f	class:cv::Point3_	signature:(const Point3_<_Tp>& pt) const
ctable	video/background_segm.hpp	/^    CvBGPixelCStatTable*  ctable;$/;"	m	struct:CvBGPixelStat	access:public
cubeRoot	core/core.hpp	/^CV_EXPORTS_W float cubeRoot(float val);$/;"	p	namespace:cv	signature:(float val)
cur_weight	legacy/legacy.hpp	/^    float* cur_weight;$/;"	m	struct:CvCliqueFinder	access:public
curidx	core/types_c.h	/^    int curidx;$/;"	m	struct:CvSparseMatIterator	access:public
currentSize	gpu/NCV.hpp	/^    size_t currentSize;$/;"	m	class:NCVMemNativeAllocator	access:private
currentSize	gpu/NCV.hpp	/^    size_t currentSize;$/;"	m	class:NCVMemStackAllocator	access:private
current_comp	legacy/legacy.hpp	/^    int* current_comp;$/;"	m	struct:CvCliqueFinder	access:public
currline	legacy/compat.hpp	/^    float*  currline;$/;"	m	struct:_CvPixelPosition32f	access:public
currline	legacy/compat.hpp	/^    schar*  currline;$/;"	m	struct:_CvPixelPosition8s	access:public
currline	legacy/compat.hpp	/^    uchar*  currline;      \/* pointer to the start of the current pixel line   *\/$/;"	m	struct:_CvPixelPosition8u	access:public
curves	contrib/contrib.hpp	/^    std::vector<CvFuzzyCurve> curves;$/;"	m	class:CvFuzzyFunction	access:public
cut_tree	ml/ml.hpp	/^    virtual int cut_tree( int T, int fold, double min_alpha );$/;"	p	class:CvDTree	access:protected	signature:( int T, int fold, double min_alpha )
cv	calib3d/calib3d.hpp	/^namespace cv$/;"	n
cv	contrib/contrib.hpp	/^namespace cv$/;"	n
cv	contrib/retina.hpp	/^namespace cv$/;"	n
cv	core/core.hpp	/^namespace cv {$/;"	n
cv	core/eigen.hpp	/^namespace cv$/;"	n
cv	core/internal.hpp	/^    namespace cv$/;"	n
cv	core/mat.hpp	/^namespace cv$/;"	n
cv	core/operations.hpp	/^namespace cv$/;"	n
cv	core/wimage.hpp	/^namespace cv {$/;"	n
cv	features2d/features2d.hpp	/^namespace cv$/;"	n
cv	flann/flann.hpp	/^namespace cv$/;"	n
cv	flann/miniflann.hpp	/^namespace cv$/;"	n
cv	gpu/devmem2d.hpp	/^namespace cv$/;"	n
cv	gpu/gpu.hpp	/^namespace cv$/;"	n
cv	gpu/gpumat.hpp	/^namespace cv { namespace gpu$/;"	n
cv	gpu/matrix_operations.hpp	/^namespace cv$/;"	n
cv	gpu/stream_accessor.hpp	/^namespace cv$/;"	n
cv	highgui/highgui.hpp	/^namespace cv$/;"	n
cv	imgproc/imgproc.hpp	/^namespace cv$/;"	n
cv	ml/ml.hpp	/^namespace cv$/;"	n
cv	objdetect/objdetect.hpp	/^namespace cv$/;"	n
cv	video/background_segm.hpp	/^namespace cv$/;"	n
cv	video/tracking.hpp	/^namespace cv$/;"	n
cv2eigen	core/eigen.hpp	/^void cv2eigen( const Mat& src,$/;"	f	namespace:cv	signature:( const Mat& src, Eigen::Matrix<_Tp, 1, Eigen::Dynamic>& dst )
cv2eigen	core/eigen.hpp	/^void cv2eigen( const Mat& src,$/;"	f	namespace:cv	signature:( const Mat& src, Eigen::Matrix<_Tp, Eigen::Dynamic, 1>& dst )
cv2eigen	core/eigen.hpp	/^void cv2eigen( const Mat& src,$/;"	f	namespace:cv	signature:( const Mat& src, Eigen::Matrix<_Tp, Eigen::Dynamic, Eigen::Dynamic>& dst )
cv2eigen	core/eigen.hpp	/^void cv2eigen( const Mat& src,$/;"	f	namespace:cv	signature:( const Mat& src, Eigen::Matrix<_Tp, _rows, _cols, _options, _maxRows, _maxCols>& dst )
cv3dTracker2dTrackedObject	legacy/legacy.hpp	/^CV_INLINE Cv3dTracker2dTrackedObject cv3dTracker2dTrackedObject(int id, CvPoint2D32f p)$/;"	f	signature:(int id, CvPoint2D32f p)
cv3dTrackerTrackedObject	legacy/legacy.hpp	/^CV_INLINE Cv3dTrackerTrackedObject cv3dTrackerTrackedObject(int id, CvPoint3D32f p)$/;"	f	signature:(int id, CvPoint3D32f p)
cv::ADAPTIVE_THRESH_GAUSSIAN_C	imgproc/imgproc.hpp	/^enum { ADAPTIVE_THRESH_MEAN_C=0, ADAPTIVE_THRESH_GAUSSIAN_C=1 };$/;"	e	enum:cv::__anon17
cv::ADAPTIVE_THRESH_MEAN_C	imgproc/imgproc.hpp	/^enum { ADAPTIVE_THRESH_MEAN_C=0, ADAPTIVE_THRESH_GAUSSIAN_C=1 };$/;"	e	enum:cv::__anon17
cv::ANN_MLP_TrainParams	ml/ml.hpp	/^typedef CvANN_MLP_TrainParams ANN_MLP_TrainParams;$/;"	t	namespace:cv
cv::Accumulator	features2d/features2d.hpp	/^struct CV_EXPORTS Accumulator$/;"	s	namespace:cv
cv::Accumulator	features2d/features2d.hpp	/^template<> struct Accumulator<char>   { typedef float Type; };$/;"	s	namespace:cv
cv::Accumulator	features2d/features2d.hpp	/^template<> struct Accumulator<short>  { typedef float Type; };$/;"	s	namespace:cv
cv::Accumulator	features2d/features2d.hpp	/^template<> struct Accumulator<unsigned char>  { typedef float Type; };$/;"	s	namespace:cv
cv::Accumulator	features2d/features2d.hpp	/^template<> struct Accumulator<unsigned short> { typedef float Type; };$/;"	s	namespace:cv
cv::Accumulator::Type	features2d/features2d.hpp	/^    typedef T Type;$/;"	t	struct:cv::Accumulator	access:public
cv::Accumulator::Type	features2d/features2d.hpp	/^template<> struct Accumulator<char>   { typedef float Type; };$/;"	t	struct:cv::Accumulator	access:public
cv::Accumulator::Type	features2d/features2d.hpp	/^template<> struct Accumulator<short>  { typedef float Type; };$/;"	t	struct:cv::Accumulator	access:public
cv::Accumulator::Type	features2d/features2d.hpp	/^template<> struct Accumulator<unsigned char>  { typedef float Type; };$/;"	t	struct:cv::Accumulator	access:public
cv::Accumulator::Type	features2d/features2d.hpp	/^template<> struct Accumulator<unsigned short> { typedef float Type; };$/;"	t	struct:cv::Accumulator	access:public
cv::AdjusterAdapter	features2d/features2d.hpp	/^class CV_EXPORTS AdjusterAdapter: public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
cv::AdjusterAdapter::clone	features2d/features2d.hpp	/^    virtual Ptr<AdjusterAdapter> clone() const = 0;$/;"	p	class:cv::AdjusterAdapter	access:public	signature:() const
cv::AdjusterAdapter::create	features2d/features2d.hpp	/^    static Ptr<AdjusterAdapter> create( const string& detectorType );$/;"	p	class:cv::AdjusterAdapter	access:public	signature:( const string& detectorType )
cv::AdjusterAdapter::good	features2d/features2d.hpp	/^    virtual bool good() const = 0;$/;"	p	class:cv::AdjusterAdapter	access:public	signature:() const
cv::AdjusterAdapter::tooFew	features2d/features2d.hpp	/^    virtual void tooFew(int min, int n_detected) = 0;$/;"	p	class:cv::AdjusterAdapter	access:public	signature:(int min, int n_detected)
cv::AdjusterAdapter::tooMany	features2d/features2d.hpp	/^    virtual void tooMany(int max, int n_detected) = 0;$/;"	p	class:cv::AdjusterAdapter	access:public	signature:(int max, int n_detected)
cv::AdjusterAdapter::~AdjusterAdapter	features2d/features2d.hpp	/^    virtual ~AdjusterAdapter() {}$/;"	f	class:cv::AdjusterAdapter	access:public	signature:()
cv::Allocator	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Allocator$/;"	c	namespace:cv
cv::Allocator::Allocator	core/core.hpp	/^    explicit Allocator() {}$/;"	f	class:cv::Allocator	access:public	signature:()
cv::Allocator::Allocator	core/core.hpp	/^    explicit Allocator(Allocator const&) {}$/;"	f	class:cv::Allocator	access:public	signature:(Allocator const&)
cv::Allocator::Allocator	core/core.hpp	/^    explicit Allocator(Allocator<U> const&) {}$/;"	f	class:cv::Allocator	access:public	signature:(Allocator<U> const&)
cv::Allocator::address	core/core.hpp	/^    const_pointer address(const_reference r) { return &r; }$/;"	f	class:cv::Allocator	access:public	signature:(const_reference r)
cv::Allocator::address	core/core.hpp	/^    pointer address(reference r) { return &r; }$/;"	f	class:cv::Allocator	access:public	signature:(reference r)
cv::Allocator::allocate	core/core.hpp	/^    pointer allocate(size_type count, const void* =0)$/;"	f	class:cv::Allocator	access:public	signature:(size_type count, const void* =0)
cv::Allocator::const_pointer	core/core.hpp	/^    typedef const value_type* const_pointer;$/;"	t	class:cv::Allocator	access:public
cv::Allocator::const_reference	core/core.hpp	/^    typedef const value_type& const_reference;$/;"	t	class:cv::Allocator	access:public
cv::Allocator::construct	core/core.hpp	/^    void construct(pointer p, const _Tp& v) { new(static_cast<void*>(p)) _Tp(v); }$/;"	f	class:cv::Allocator	access:public	signature:(pointer p, const _Tp& v)
cv::Allocator::deallocate	core/core.hpp	/^    void deallocate(pointer p, size_type) {fastFree(p); }$/;"	f	class:cv::Allocator	access:public	signature:(pointer p, size_type)
cv::Allocator::destroy	core/core.hpp	/^    void destroy(pointer p) { p->~_Tp(); }$/;"	f	class:cv::Allocator	access:public	signature:(pointer p)
cv::Allocator::difference_type	core/core.hpp	/^    typedef ptrdiff_t difference_type;$/;"	t	class:cv::Allocator	access:public
cv::Allocator::max_size	core/core.hpp	/^    size_type max_size() const$/;"	f	class:cv::Allocator	access:public	signature:() const
cv::Allocator::pointer	core/core.hpp	/^    typedef value_type* pointer;$/;"	t	class:cv::Allocator	access:public
cv::Allocator::rebind	core/core.hpp	/^    template<typename U> class rebind { typedef Allocator<U> other; };$/;"	c	class:cv::Allocator	access:public
cv::Allocator::rebind::other	core/core.hpp	/^    template<typename U> class rebind { typedef Allocator<U> other; };$/;"	t	class:cv::Allocator::rebind	access:private
cv::Allocator::reference	core/core.hpp	/^    typedef value_type& reference;$/;"	t	class:cv::Allocator	access:public
cv::Allocator::size_type	core/core.hpp	/^    typedef size_t size_type;$/;"	t	class:cv::Allocator	access:public
cv::Allocator::value_type	core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Allocator	access:public
cv::Allocator::~Allocator	core/core.hpp	/^    ~Allocator() {}$/;"	f	class:cv::Allocator	access:public	signature:()
cv::AutoBuffer	core/core.hpp	/^template<typename _Tp, size_t fixed_size=4096\/sizeof(_Tp)+8> class CV_EXPORTS AutoBuffer$/;"	c	namespace:cv
cv::AutoBuffer::AutoBuffer	core/core.hpp	/^    AutoBuffer();$/;"	p	class:cv::AutoBuffer	access:public	signature:()
cv::AutoBuffer::AutoBuffer	core/core.hpp	/^    AutoBuffer(size_t _size);$/;"	p	class:cv::AutoBuffer	access:public	signature:(size_t _size)
cv::AutoBuffer::AutoBuffer	core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::AutoBuffer()$/;"	f	class:cv::AutoBuffer	signature:()
cv::AutoBuffer::AutoBuffer	core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::AutoBuffer(size_t _size)$/;"	f	class:cv::AutoBuffer	signature:(size_t _size)
cv::AutoBuffer::allocate	core/core.hpp	/^    void allocate(size_t _size);$/;"	p	class:cv::AutoBuffer	access:public	signature:(size_t _size)
cv::AutoBuffer::allocate	core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline void AutoBuffer<_Tp, fixed_size>::allocate(size_t _size)$/;"	f	class:cv::AutoBuffer	signature:(size_t _size)
cv::AutoBuffer::buf	core/core.hpp	/^    _Tp buf[fixed_size+buffer_padding];$/;"	m	class:cv::AutoBuffer	access:protected
cv::AutoBuffer::buffer_padding	core/core.hpp	/^    enum { buffer_padding = (int)((16 + sizeof(_Tp) - 1)\/sizeof(_Tp)) };$/;"	e	enum:cv::AutoBuffer::__anon145
cv::AutoBuffer::deallocate	core/core.hpp	/^    void deallocate();$/;"	p	class:cv::AutoBuffer	access:public	signature:()
cv::AutoBuffer::deallocate	core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline void AutoBuffer<_Tp, fixed_size>::deallocate()$/;"	f	class:cv::AutoBuffer	signature:()
cv::AutoBuffer::operator _Tp*	core/core.hpp	/^    operator _Tp* ();$/;"	p	class:cv::AutoBuffer	access:public	signature:()
cv::AutoBuffer::operator _Tp*	core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::operator _Tp* ()$/;"	f	class:cv::AutoBuffer	signature:()
cv::AutoBuffer::operator const _Tp*	core/core.hpp	/^    operator const _Tp* () const;$/;"	p	class:cv::AutoBuffer	access:public	signature:() const
cv::AutoBuffer::operator const _Tp*	core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::operator const _Tp* () const$/;"	f	class:cv::AutoBuffer	signature:() const
cv::AutoBuffer::ptr	core/core.hpp	/^    _Tp* ptr;$/;"	m	class:cv::AutoBuffer	access:protected
cv::AutoBuffer::size	core/core.hpp	/^    size_t size;$/;"	m	class:cv::AutoBuffer	access:protected
cv::AutoBuffer::value_type	core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::AutoBuffer	access:public
cv::AutoBuffer::~AutoBuffer	core/core.hpp	/^    ~AutoBuffer();$/;"	p	class:cv::AutoBuffer	access:public	signature:()
cv::AutoBuffer::~AutoBuffer	core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::~AutoBuffer()$/;"	f	class:cv::AutoBuffer	signature:()
cv::BORDER_CONSTANT	imgproc/imgproc.hpp	/^enum { BORDER_REPLICATE=IPL_BORDER_REPLICATE, BORDER_CONSTANT=IPL_BORDER_CONSTANT,$/;"	e	enum:cv::__anon10
cv::BORDER_DEFAULT	imgproc/imgproc.hpp	/^       BORDER_DEFAULT=BORDER_REFLECT_101, BORDER_ISOLATED=16 };$/;"	e	enum:cv::__anon10
cv::BORDER_ISOLATED	imgproc/imgproc.hpp	/^       BORDER_DEFAULT=BORDER_REFLECT_101, BORDER_ISOLATED=16 };$/;"	e	enum:cv::__anon10
cv::BORDER_REFLECT	imgproc/imgproc.hpp	/^       BORDER_REFLECT=IPL_BORDER_REFLECT, BORDER_WRAP=IPL_BORDER_WRAP, $/;"	e	enum:cv::__anon10
cv::BORDER_REFLECT101	imgproc/imgproc.hpp	/^       BORDER_REFLECT_101=IPL_BORDER_REFLECT_101, BORDER_REFLECT101=BORDER_REFLECT_101,$/;"	e	enum:cv::__anon10
cv::BORDER_REFLECT_101	imgproc/imgproc.hpp	/^       BORDER_REFLECT_101=IPL_BORDER_REFLECT_101, BORDER_REFLECT101=BORDER_REFLECT_101,$/;"	e	enum:cv::__anon10
cv::BORDER_REPLICATE	imgproc/imgproc.hpp	/^enum { BORDER_REPLICATE=IPL_BORDER_REPLICATE, BORDER_CONSTANT=IPL_BORDER_CONSTANT,$/;"	e	enum:cv::__anon10
cv::BORDER_TRANSPARENT	imgproc/imgproc.hpp	/^       BORDER_TRANSPARENT=IPL_BORDER_TRANSPARENT,$/;"	e	enum:cv::__anon10
cv::BORDER_WRAP	imgproc/imgproc.hpp	/^       BORDER_REFLECT=IPL_BORDER_REFLECT, BORDER_WRAP=IPL_BORDER_WRAP, $/;"	e	enum:cv::__anon10
cv::BOWImgDescriptorExtractor	features2d/features2d.hpp	/^class CV_EXPORTS BOWImgDescriptorExtractor$/;"	c	namespace:cv
cv::BOWImgDescriptorExtractor::BOWImgDescriptorExtractor	features2d/features2d.hpp	/^    BOWImgDescriptorExtractor( const Ptr<DescriptorExtractor>& dextractor,$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:( const Ptr<DescriptorExtractor>& dextractor, const Ptr<DescriptorMatcher>& dmatcher )
cv::BOWImgDescriptorExtractor::compute	features2d/features2d.hpp	/^    void compute( const Mat& image, vector<KeyPoint>& keypoints, Mat& imgDescriptor,$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& imgDescriptor, vector<vector<int> >* pointIdxsOfClusters=0, Mat* descriptors=0 )
cv::BOWImgDescriptorExtractor::descriptorSize	features2d/features2d.hpp	/^    int descriptorSize() const;$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:() const
cv::BOWImgDescriptorExtractor::descriptorType	features2d/features2d.hpp	/^    int descriptorType() const;$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:() const
cv::BOWImgDescriptorExtractor::dextractor	features2d/features2d.hpp	/^    Ptr<DescriptorExtractor> dextractor;$/;"	m	class:cv::BOWImgDescriptorExtractor	access:protected
cv::BOWImgDescriptorExtractor::dmatcher	features2d/features2d.hpp	/^    Ptr<DescriptorMatcher> dmatcher;$/;"	m	class:cv::BOWImgDescriptorExtractor	access:protected
cv::BOWImgDescriptorExtractor::getVocabulary	features2d/features2d.hpp	/^    const Mat& getVocabulary() const;$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:() const
cv::BOWImgDescriptorExtractor::setVocabulary	features2d/features2d.hpp	/^    void setVocabulary( const Mat& vocabulary );$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:( const Mat& vocabulary )
cv::BOWImgDescriptorExtractor::vocabulary	features2d/features2d.hpp	/^    Mat vocabulary;$/;"	m	class:cv::BOWImgDescriptorExtractor	access:protected
cv::BOWImgDescriptorExtractor::~BOWImgDescriptorExtractor	features2d/features2d.hpp	/^    virtual ~BOWImgDescriptorExtractor();$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:()
cv::BOWKMeansTrainer	features2d/features2d.hpp	/^class CV_EXPORTS BOWKMeansTrainer : public BOWTrainer$/;"	c	namespace:cv	inherits:BOWTrainer
cv::BOWKMeansTrainer::BOWKMeansTrainer	features2d/features2d.hpp	/^    BOWKMeansTrainer( int clusterCount, const TermCriteria& termcrit=TermCriteria(),$/;"	p	class:cv::BOWKMeansTrainer	access:public	signature:( int clusterCount, const TermCriteria& termcrit=TermCriteria(), int attempts=3, int flags=KMEANS_PP_CENTERS )
cv::BOWKMeansTrainer::attempts	features2d/features2d.hpp	/^    int attempts;$/;"	m	class:cv::BOWKMeansTrainer	access:protected
cv::BOWKMeansTrainer::cluster	features2d/features2d.hpp	/^    virtual Mat cluster( const Mat& descriptors ) const;$/;"	p	class:cv::BOWKMeansTrainer	access:public	signature:( const Mat& descriptors ) const
cv::BOWKMeansTrainer::cluster	features2d/features2d.hpp	/^    virtual Mat cluster() const;$/;"	p	class:cv::BOWKMeansTrainer	access:public	signature:() const
cv::BOWKMeansTrainer::clusterCount	features2d/features2d.hpp	/^    int clusterCount;$/;"	m	class:cv::BOWKMeansTrainer	access:protected
cv::BOWKMeansTrainer::flags	features2d/features2d.hpp	/^    int flags;$/;"	m	class:cv::BOWKMeansTrainer	access:protected
cv::BOWKMeansTrainer::termcrit	features2d/features2d.hpp	/^    TermCriteria termcrit;$/;"	m	class:cv::BOWKMeansTrainer	access:protected
cv::BOWKMeansTrainer::~BOWKMeansTrainer	features2d/features2d.hpp	/^    virtual ~BOWKMeansTrainer();$/;"	p	class:cv::BOWKMeansTrainer	access:public	signature:()
cv::BOWTrainer	features2d/features2d.hpp	/^class CV_EXPORTS BOWTrainer$/;"	c	namespace:cv
cv::BOWTrainer::BOWTrainer	features2d/features2d.hpp	/^    BOWTrainer();$/;"	p	class:cv::BOWTrainer	access:public	signature:()
cv::BOWTrainer::add	features2d/features2d.hpp	/^    void add( const Mat& descriptors );$/;"	p	class:cv::BOWTrainer	access:public	signature:( const Mat& descriptors )
cv::BOWTrainer::clear	features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::BOWTrainer	access:public	signature:()
cv::BOWTrainer::cluster	features2d/features2d.hpp	/^    virtual Mat cluster( const Mat& descriptors ) const = 0;$/;"	p	class:cv::BOWTrainer	access:public	signature:( const Mat& descriptors ) const
cv::BOWTrainer::cluster	features2d/features2d.hpp	/^    virtual Mat cluster() const = 0;$/;"	p	class:cv::BOWTrainer	access:public	signature:() const
cv::BOWTrainer::descripotorsCount	features2d/features2d.hpp	/^    int descripotorsCount() const;$/;"	p	class:cv::BOWTrainer	access:public	signature:() const
cv::BOWTrainer::descriptors	features2d/features2d.hpp	/^    vector<Mat> descriptors;$/;"	m	class:cv::BOWTrainer	access:protected
cv::BOWTrainer::getDescriptors	features2d/features2d.hpp	/^    const vector<Mat>& getDescriptors() const;$/;"	p	class:cv::BOWTrainer	access:public	signature:() const
cv::BOWTrainer::size	features2d/features2d.hpp	/^    int size;$/;"	m	class:cv::BOWTrainer	access:protected
cv::BOWTrainer::~BOWTrainer	features2d/features2d.hpp	/^    virtual ~BOWTrainer();$/;"	p	class:cv::BOWTrainer	access:public	signature:()
cv::BackgroundSubtractor	video/background_segm.hpp	/^class CV_EXPORTS_W BackgroundSubtractor$/;"	c	namespace:cv
cv::BackgroundSubtractor::getBackgroundImage	video/background_segm.hpp	/^    virtual void getBackgroundImage(OutputArray backgroundImage) const;$/;"	p	class:cv::BackgroundSubtractor	access:public	signature:(OutputArray backgroundImage) const
cv::BackgroundSubtractor::operator ()	video/background_segm.hpp	/^    CV_WRAP_AS(apply) virtual void operator()(InputArray image, OutputArray fgmask,$/;"	p	class:cv::BackgroundSubtractor	access:public	signature:(InputArray image, OutputArray fgmask, double learningRate=0)
cv::BackgroundSubtractor::~BackgroundSubtractor	video/background_segm.hpp	/^    virtual ~BackgroundSubtractor();$/;"	p	class:cv::BackgroundSubtractor	access:public	signature:()
cv::BackgroundSubtractorMOG	video/background_segm.hpp	/^class CV_EXPORTS_W BackgroundSubtractorMOG : public BackgroundSubtractor$/;"	c	namespace:cv	inherits:BackgroundSubtractor
cv::BackgroundSubtractorMOG2	video/background_segm.hpp	/^class CV_EXPORTS BackgroundSubtractorMOG2 : public BackgroundSubtractor$/;"	c	namespace:cv	inherits:BackgroundSubtractor
cv::BackgroundSubtractorMOG2::BackgroundSubtractorMOG2	video/background_segm.hpp	/^    BackgroundSubtractorMOG2();$/;"	p	class:cv::BackgroundSubtractorMOG2	access:public	signature:()
cv::BackgroundSubtractorMOG2::BackgroundSubtractorMOG2	video/background_segm.hpp	/^    BackgroundSubtractorMOG2(int history,  float varThreshold, bool bShadowDetection=1);$/;"	p	class:cv::BackgroundSubtractorMOG2	access:public	signature:(int history, float varThreshold, bool bShadowDetection=1)
cv::BackgroundSubtractorMOG2::bShadowDetection	video/background_segm.hpp	/^    bool bShadowDetection;\/\/default 1 - do shadow detection$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
cv::BackgroundSubtractorMOG2::backgroundRatio	video/background_segm.hpp	/^    float backgroundRatio;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
cv::BackgroundSubtractorMOG2::bgmodel	video/background_segm.hpp	/^    Mat bgmodel;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
cv::BackgroundSubtractorMOG2::bgmodelUsedModes	video/background_segm.hpp	/^    Mat bgmodelUsedModes;\/\/keep track of number of modes per pixel$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
cv::BackgroundSubtractorMOG2::fCT	video/background_segm.hpp	/^    float fCT;\/\/CT - complexity reduction prior$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
cv::BackgroundSubtractorMOG2::fTau	video/background_segm.hpp	/^    float fTau;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
cv::BackgroundSubtractorMOG2::fVarInit	video/background_segm.hpp	/^    float fVarInit;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
cv::BackgroundSubtractorMOG2::fVarMax	video/background_segm.hpp	/^    float fVarMax;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
cv::BackgroundSubtractorMOG2::fVarMin	video/background_segm.hpp	/^    float fVarMin;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
cv::BackgroundSubtractorMOG2::frameSize	video/background_segm.hpp	/^    Size frameSize;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
cv::BackgroundSubtractorMOG2::frameType	video/background_segm.hpp	/^    int frameType;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
cv::BackgroundSubtractorMOG2::getBackgroundImage	video/background_segm.hpp	/^    virtual void getBackgroundImage(OutputArray backgroundImage) const;$/;"	p	class:cv::BackgroundSubtractorMOG2	access:public	signature:(OutputArray backgroundImage) const
cv::BackgroundSubtractorMOG2::history	video/background_segm.hpp	/^    int history;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
cv::BackgroundSubtractorMOG2::initialize	video/background_segm.hpp	/^    virtual void initialize(Size frameSize, int frameType);$/;"	p	class:cv::BackgroundSubtractorMOG2	access:public	signature:(Size frameSize, int frameType)
cv::BackgroundSubtractorMOG2::nShadowDetection	video/background_segm.hpp	/^    unsigned char nShadowDetection;\/\/do shadow detection - insert this value as the detection result - 127 default value$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
cv::BackgroundSubtractorMOG2::nframes	video/background_segm.hpp	/^    int nframes;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
cv::BackgroundSubtractorMOG2::nmixtures	video/background_segm.hpp	/^    int nmixtures;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
cv::BackgroundSubtractorMOG2::operator ()	video/background_segm.hpp	/^    virtual void operator()(InputArray image, OutputArray fgmask, double learningRate=-1);$/;"	p	class:cv::BackgroundSubtractorMOG2	access:public	signature:(InputArray image, OutputArray fgmask, double learningRate=-1)
cv::BackgroundSubtractorMOG2::varThreshold	video/background_segm.hpp	/^    float varThreshold;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
cv::BackgroundSubtractorMOG2::varThresholdGen	video/background_segm.hpp	/^    float varThresholdGen;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
cv::BackgroundSubtractorMOG2::~BackgroundSubtractorMOG2	video/background_segm.hpp	/^    virtual ~BackgroundSubtractorMOG2();$/;"	p	class:cv::BackgroundSubtractorMOG2	access:public	signature:()
cv::BackgroundSubtractorMOG::BackgroundSubtractorMOG	video/background_segm.hpp	/^    CV_WRAP BackgroundSubtractorMOG();$/;"	p	class:cv::BackgroundSubtractorMOG	access:public	signature:()
cv::BackgroundSubtractorMOG::BackgroundSubtractorMOG	video/background_segm.hpp	/^    CV_WRAP BackgroundSubtractorMOG(int history, int nmixtures, double backgroundRatio, double noiseSigma=0);$/;"	p	class:cv::BackgroundSubtractorMOG	access:public	signature:(int history, int nmixtures, double backgroundRatio, double noiseSigma=0)
cv::BackgroundSubtractorMOG::backgroundRatio	video/background_segm.hpp	/^    double backgroundRatio;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
cv::BackgroundSubtractorMOG::bgmodel	video/background_segm.hpp	/^    Mat bgmodel;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
cv::BackgroundSubtractorMOG::frameSize	video/background_segm.hpp	/^    Size frameSize;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
cv::BackgroundSubtractorMOG::frameType	video/background_segm.hpp	/^    int frameType;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
cv::BackgroundSubtractorMOG::history	video/background_segm.hpp	/^    int history;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
cv::BackgroundSubtractorMOG::initialize	video/background_segm.hpp	/^    virtual void initialize(Size frameSize, int frameType);$/;"	p	class:cv::BackgroundSubtractorMOG	access:public	signature:(Size frameSize, int frameType)
cv::BackgroundSubtractorMOG::nframes	video/background_segm.hpp	/^    int nframes;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
cv::BackgroundSubtractorMOG::nmixtures	video/background_segm.hpp	/^    int nmixtures;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
cv::BackgroundSubtractorMOG::noiseSigma	video/background_segm.hpp	/^    double noiseSigma;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
cv::BackgroundSubtractorMOG::operator ()	video/background_segm.hpp	/^    virtual void operator()(InputArray image, OutputArray fgmask, double learningRate=0);$/;"	p	class:cv::BackgroundSubtractorMOG	access:public	signature:(InputArray image, OutputArray fgmask, double learningRate=0)
cv::BackgroundSubtractorMOG::varThreshold	video/background_segm.hpp	/^    double varThreshold;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
cv::BackgroundSubtractorMOG::~BackgroundSubtractorMOG	video/background_segm.hpp	/^    virtual ~BackgroundSubtractorMOG();$/;"	p	class:cv::BackgroundSubtractorMOG	access:public	signature:()
cv::BaseColumnFilter	imgproc/imgproc.hpp	/^class CV_EXPORTS BaseColumnFilter$/;"	c	namespace:cv
cv::BaseColumnFilter::BaseColumnFilter	imgproc/imgproc.hpp	/^    BaseColumnFilter();$/;"	p	class:cv::BaseColumnFilter	access:public	signature:()
cv::BaseColumnFilter::anchor	imgproc/imgproc.hpp	/^    int ksize, anchor;$/;"	m	class:cv::BaseColumnFilter	access:public
cv::BaseColumnFilter::ksize	imgproc/imgproc.hpp	/^    int ksize, anchor;$/;"	m	class:cv::BaseColumnFilter	access:public
cv::BaseColumnFilter::operator ()	imgproc/imgproc.hpp	/^    virtual void operator()(const uchar** src, uchar* dst, int dststep,$/;"	p	class:cv::BaseColumnFilter	access:public	signature:(const uchar** src, uchar* dst, int dststep, int dstcount, int width)
cv::BaseColumnFilter::reset	imgproc/imgproc.hpp	/^    virtual void reset();$/;"	p	class:cv::BaseColumnFilter	access:public	signature:()
cv::BaseColumnFilter::~BaseColumnFilter	imgproc/imgproc.hpp	/^    virtual ~BaseColumnFilter();$/;"	p	class:cv::BaseColumnFilter	access:public	signature:()
cv::BaseFilter	imgproc/imgproc.hpp	/^class CV_EXPORTS BaseFilter$/;"	c	namespace:cv
cv::BaseFilter::BaseFilter	imgproc/imgproc.hpp	/^    BaseFilter();$/;"	p	class:cv::BaseFilter	access:public	signature:()
cv::BaseFilter::anchor	imgproc/imgproc.hpp	/^    Point anchor;$/;"	m	class:cv::BaseFilter	access:public
cv::BaseFilter::ksize	imgproc/imgproc.hpp	/^    Size ksize;$/;"	m	class:cv::BaseFilter	access:public
cv::BaseFilter::operator ()	imgproc/imgproc.hpp	/^    virtual void operator()(const uchar** src, uchar* dst, int dststep,$/;"	p	class:cv::BaseFilter	access:public	signature:(const uchar** src, uchar* dst, int dststep, int dstcount, int width, int cn)
cv::BaseFilter::reset	imgproc/imgproc.hpp	/^    virtual void reset();$/;"	p	class:cv::BaseFilter	access:public	signature:()
cv::BaseFilter::~BaseFilter	imgproc/imgproc.hpp	/^    virtual ~BaseFilter();$/;"	p	class:cv::BaseFilter	access:public	signature:()
cv::BaseKeypoint	features2d/features2d.hpp	/^struct CV_EXPORTS BaseKeypoint$/;"	s	namespace:cv
cv::BaseKeypoint::BaseKeypoint	features2d/features2d.hpp	/^  BaseKeypoint()$/;"	f	struct:cv::BaseKeypoint	access:public	signature:()
cv::BaseKeypoint::BaseKeypoint	features2d/features2d.hpp	/^  BaseKeypoint(int x, int y, IplImage* image)$/;"	f	struct:cv::BaseKeypoint	access:public	signature:(int x, int y, IplImage* image)
cv::BaseKeypoint::image	features2d/features2d.hpp	/^  IplImage* image;$/;"	m	struct:cv::BaseKeypoint	access:public
cv::BaseKeypoint::x	features2d/features2d.hpp	/^  int x;$/;"	m	struct:cv::BaseKeypoint	access:public
cv::BaseKeypoint::y	features2d/features2d.hpp	/^  int y;$/;"	m	struct:cv::BaseKeypoint	access:public
cv::BaseRowFilter	imgproc/imgproc.hpp	/^class CV_EXPORTS BaseRowFilter$/;"	c	namespace:cv
cv::BaseRowFilter::BaseRowFilter	imgproc/imgproc.hpp	/^    BaseRowFilter();$/;"	p	class:cv::BaseRowFilter	access:public	signature:()
cv::BaseRowFilter::anchor	imgproc/imgproc.hpp	/^    int ksize, anchor;$/;"	m	class:cv::BaseRowFilter	access:public
cv::BaseRowFilter::ksize	imgproc/imgproc.hpp	/^    int ksize, anchor;$/;"	m	class:cv::BaseRowFilter	access:public
cv::BaseRowFilter::operator ()	imgproc/imgproc.hpp	/^    virtual void operator()(const uchar* src, uchar* dst,$/;"	p	class:cv::BaseRowFilter	access:public	signature:(const uchar* src, uchar* dst, int width, int cn)
cv::BaseRowFilter::~BaseRowFilter	imgproc/imgproc.hpp	/^    virtual ~BaseRowFilter();$/;"	p	class:cv::BaseRowFilter	access:public	signature:()
cv::BlockedRange	core/internal.hpp	/^        typedef tbb::blocked_range<int> BlockedRange;$/;"	t	namespace:cv
cv::Boost	ml/ml.hpp	/^typedef CvBoost Boost;$/;"	t	namespace:cv
cv::BoostParams	ml/ml.hpp	/^typedef CvBoostParams BoostParams;$/;"	t	namespace:cv
cv::BoostTree	ml/ml.hpp	/^typedef CvBoostTree BoostTree;$/;"	t	namespace:cv
cv::BriefDescriptorExtractor	features2d/features2d.hpp	/^class CV_EXPORTS BriefDescriptorExtractor : public DescriptorExtractor$/;"	c	namespace:cv	inherits:DescriptorExtractor
cv::BriefDescriptorExtractor::BriefDescriptorExtractor	features2d/features2d.hpp	/^    BriefDescriptorExtractor( int bytes = 32 );$/;"	p	class:cv::BriefDescriptorExtractor	access:public	signature:( int bytes = 32 )
cv::BriefDescriptorExtractor::KERNEL_SIZE	features2d/features2d.hpp	/^    static const int KERNEL_SIZE = 9;$/;"	m	class:cv::BriefDescriptorExtractor	access:public
cv::BriefDescriptorExtractor::PATCH_SIZE	features2d/features2d.hpp	/^    static const int PATCH_SIZE = 48;$/;"	m	class:cv::BriefDescriptorExtractor	access:public
cv::BriefDescriptorExtractor::PixelTestFn	features2d/features2d.hpp	/^    typedef void(*PixelTestFn)(const Mat&, const std::vector<KeyPoint>&, Mat&);$/;"	t	class:cv::BriefDescriptorExtractor	access:protected
cv::BriefDescriptorExtractor::bytes_	features2d/features2d.hpp	/^    int bytes_;$/;"	m	class:cv::BriefDescriptorExtractor	access:protected
cv::BriefDescriptorExtractor::computeImpl	features2d/features2d.hpp	/^    virtual void computeImpl(const Mat& image, std::vector<KeyPoint>& keypoints, Mat& descriptors) const;$/;"	p	class:cv::BriefDescriptorExtractor	access:protected	signature:(const Mat& image, std::vector<KeyPoint>& keypoints, Mat& descriptors) const
cv::BriefDescriptorExtractor::descriptorSize	features2d/features2d.hpp	/^    virtual int descriptorSize() const;$/;"	p	class:cv::BriefDescriptorExtractor	access:public	signature:() const
cv::BriefDescriptorExtractor::descriptorType	features2d/features2d.hpp	/^    virtual int descriptorType() const;$/;"	p	class:cv::BriefDescriptorExtractor	access:public	signature:() const
cv::BriefDescriptorExtractor::read	features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::BriefDescriptorExtractor	access:public	signature:( const FileNode& )
cv::BriefDescriptorExtractor::test_fn_	features2d/features2d.hpp	/^    PixelTestFn test_fn_;$/;"	m	class:cv::BriefDescriptorExtractor	access:protected
cv::BriefDescriptorExtractor::write	features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::BriefDescriptorExtractor	access:public	signature:( FileStorage& ) const
cv::BruteForceMatcher	features2d/features2d.hpp	/^class CV_EXPORTS BruteForceMatcher : public DescriptorMatcher$/;"	c	namespace:cv	inherits:DescriptorMatcher
cv::BruteForceMatcher::BruteForceMatcher	features2d/features2d.hpp	/^    BruteForceMatcher( Distance d = Distance() ) : distance(d) {}$/;"	f	class:cv::BruteForceMatcher	access:public	signature:( Distance d = Distance() )
cv::BruteForceMatcher::clone	features2d/features2d.hpp	/^    virtual Ptr<DescriptorMatcher> clone( bool emptyTrainData=false ) const;$/;"	p	class:cv::BruteForceMatcher	access:public	signature:( bool emptyTrainData=false ) const
cv::BruteForceMatcher::clone	features2d/features2d.hpp	/^Ptr<DescriptorMatcher> BruteForceMatcher<Distance>::clone( bool emptyTrainData ) const$/;"	f	class:cv::BruteForceMatcher	signature:( bool emptyTrainData ) const
cv::BruteForceMatcher::commonKnnMatchImpl	features2d/features2d.hpp	/^    static void commonKnnMatchImpl( BruteForceMatcher<Distance>& matcher,$/;"	p	class:cv::BruteForceMatcher	access:private	signature:( BruteForceMatcher<Distance>& matcher, const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
cv::BruteForceMatcher::commonKnnMatchImpl	features2d/features2d.hpp	/^inline void BruteForceMatcher<Distance>::commonKnnMatchImpl( BruteForceMatcher<Distance>& matcher,$/;"	f	class:cv::BruteForceMatcher	signature:( BruteForceMatcher<Distance>& matcher, const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int knn, const vector<Mat>& masks, bool compactResult )
cv::BruteForceMatcher::commonRadiusMatchImpl	features2d/features2d.hpp	/^    static void commonRadiusMatchImpl( BruteForceMatcher<Distance>& matcher,$/;"	p	class:cv::BruteForceMatcher	access:private	signature:( BruteForceMatcher<Distance>& matcher, const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
cv::BruteForceMatcher::commonRadiusMatchImpl	features2d/features2d.hpp	/^inline void BruteForceMatcher<Distance>::commonRadiusMatchImpl( BruteForceMatcher<Distance>& matcher,$/;"	f	class:cv::BruteForceMatcher	signature:( BruteForceMatcher<Distance>& matcher, const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
cv::BruteForceMatcher::distance	features2d/features2d.hpp	/^    Distance distance;$/;"	m	class:cv::BruteForceMatcher	access:protected
cv::BruteForceMatcher::isMaskSupported	features2d/features2d.hpp	/^    virtual bool isMaskSupported() const { return true; }$/;"	f	class:cv::BruteForceMatcher	access:public	signature:() const
cv::BruteForceMatcher::knnMatchImpl	features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	p	class:cv::BruteForceMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
cv::BruteForceMatcher::knnMatchImpl	features2d/features2d.hpp	/^void BruteForceMatcher<Distance>::knnMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	f	class:cv::BruteForceMatcher	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
cv::BruteForceMatcher::knnMatchImpl	features2d/features2d.hpp	/^void BruteForceMatcher<L2<float> >::knnMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	p	class:cv::BruteForceMatcher	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
cv::BruteForceMatcher::radiusMatchImpl	features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance,$/;"	p	class:cv::BruteForceMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
cv::BruteForceMatcher::radiusMatchImpl	features2d/features2d.hpp	/^void BruteForceMatcher<Distance>::radiusMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches,$/;"	f	class:cv::BruteForceMatcher	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
cv::BruteForceMatcher::radiusMatchImpl	features2d/features2d.hpp	/^void BruteForceMatcher<L2<float> >::radiusMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches,$/;"	p	class:cv::BruteForceMatcher	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
cv::BruteForceMatcher::~BruteForceMatcher	features2d/features2d.hpp	/^    virtual ~BruteForceMatcher() {}$/;"	f	class:cv::BruteForceMatcher	access:public	signature:()
cv::BundleAdjustCallback	contrib/contrib.hpp	/^    typedef bool (*BundleAdjustCallback)(int iteration, double norm_error, void* user_data);$/;"	t	namespace:cv
cv::ButtonCallback	highgui/highgui.hpp	/^typedef void (CV_CDECL *ButtonCallback)(int state, void* userdata);$/;"	t	namespace:cv
cv::CALIB_CB_ADAPTIVE_THRESH	calib3d/calib3d.hpp	/^enum { CALIB_CB_ADAPTIVE_THRESH = 1, CALIB_CB_NORMALIZE_IMAGE = 2,$/;"	e	enum:cv::__anon88
cv::CALIB_CB_ASYMMETRIC_GRID	calib3d/calib3d.hpp	/^enum { CALIB_CB_SYMMETRIC_GRID = 1, CALIB_CB_ASYMMETRIC_GRID = 2,$/;"	e	enum:cv::__anon89
cv::CALIB_CB_CLUSTERING	calib3d/calib3d.hpp	/^       CALIB_CB_CLUSTERING = 4 };$/;"	e	enum:cv::__anon89
cv::CALIB_CB_FAST_CHECK	calib3d/calib3d.hpp	/^       CALIB_CB_FILTER_QUADS = 4, CALIB_CB_FAST_CHECK = 8 };$/;"	e	enum:cv::__anon88
cv::CALIB_CB_FILTER_QUADS	calib3d/calib3d.hpp	/^       CALIB_CB_FILTER_QUADS = 4, CALIB_CB_FAST_CHECK = 8 };$/;"	e	enum:cv::__anon88
cv::CALIB_CB_NORMALIZE_IMAGE	calib3d/calib3d.hpp	/^enum { CALIB_CB_ADAPTIVE_THRESH = 1, CALIB_CB_NORMALIZE_IMAGE = 2,$/;"	e	enum:cv::__anon88
cv::CALIB_CB_SYMMETRIC_GRID	calib3d/calib3d.hpp	/^enum { CALIB_CB_SYMMETRIC_GRID = 1, CALIB_CB_ASYMMETRIC_GRID = 2,$/;"	e	enum:cv::__anon89
cv::CALIB_FIX_ASPECT_RATIO	calib3d/calib3d.hpp	/^    CALIB_FIX_ASPECT_RATIO = CV_CALIB_FIX_ASPECT_RATIO,$/;"	e	enum:cv::__anon90
cv::CALIB_FIX_FOCAL_LENGTH	calib3d/calib3d.hpp	/^    CALIB_FIX_FOCAL_LENGTH = CV_CALIB_FIX_FOCAL_LENGTH,$/;"	e	enum:cv::__anon90
cv::CALIB_FIX_INTRINSIC	calib3d/calib3d.hpp	/^    CALIB_FIX_INTRINSIC = CV_CALIB_FIX_INTRINSIC,$/;"	e	enum:cv::__anon90
cv::CALIB_FIX_K1	calib3d/calib3d.hpp	/^    CALIB_FIX_K1 = CV_CALIB_FIX_K1,$/;"	e	enum:cv::__anon90
cv::CALIB_FIX_K2	calib3d/calib3d.hpp	/^    CALIB_FIX_K2 = CV_CALIB_FIX_K2,$/;"	e	enum:cv::__anon90
cv::CALIB_FIX_K3	calib3d/calib3d.hpp	/^    CALIB_FIX_K3 = CV_CALIB_FIX_K3,$/;"	e	enum:cv::__anon90
cv::CALIB_FIX_K4	calib3d/calib3d.hpp	/^    CALIB_FIX_K4 = CV_CALIB_FIX_K4,$/;"	e	enum:cv::__anon90
cv::CALIB_FIX_K5	calib3d/calib3d.hpp	/^    CALIB_FIX_K5 = CV_CALIB_FIX_K5,$/;"	e	enum:cv::__anon90
cv::CALIB_FIX_K6	calib3d/calib3d.hpp	/^    CALIB_FIX_K6 = CV_CALIB_FIX_K6,$/;"	e	enum:cv::__anon90
cv::CALIB_FIX_PRINCIPAL_POINT	calib3d/calib3d.hpp	/^    CALIB_FIX_PRINCIPAL_POINT = CV_CALIB_FIX_PRINCIPAL_POINT,$/;"	e	enum:cv::__anon90
cv::CALIB_RATIONAL_MODEL	calib3d/calib3d.hpp	/^    CALIB_RATIONAL_MODEL = CV_CALIB_RATIONAL_MODEL,$/;"	e	enum:cv::__anon90
cv::CALIB_SAME_FOCAL_LENGTH	calib3d/calib3d.hpp	/^    CALIB_SAME_FOCAL_LENGTH = CV_CALIB_SAME_FOCAL_LENGTH,$/;"	e	enum:cv::__anon90
cv::CALIB_USE_INTRINSIC_GUESS	calib3d/calib3d.hpp	/^    CALIB_USE_INTRINSIC_GUESS = CV_CALIB_USE_INTRINSIC_GUESS,$/;"	e	enum:cv::__anon90
cv::CALIB_ZERO_DISPARITY	calib3d/calib3d.hpp	/^    CALIB_ZERO_DISPARITY = CV_CALIB_ZERO_DISPARITY$/;"	e	enum:cv::__anon90
cv::CALIB_ZERO_TANGENT_DIST	calib3d/calib3d.hpp	/^    CALIB_ZERO_TANGENT_DIST = CV_CALIB_ZERO_TANGENT_DIST,$/;"	e	enum:cv::__anon90
cv::CASCADE_DO_CANNY_PRUNING	objdetect/objdetect.hpp	/^	CASCADE_DO_CANNY_PRUNING=1,$/;"	e	enum:cv::__anon199
cv::CASCADE_DO_ROUGH_SEARCH	objdetect/objdetect.hpp	/^	CASCADE_DO_ROUGH_SEARCH=8$/;"	e	enum:cv::__anon199
cv::CASCADE_FIND_BIGGEST_OBJECT	objdetect/objdetect.hpp	/^	CASCADE_FIND_BIGGEST_OBJECT=4,$/;"	e	enum:cv::__anon199
cv::CASCADE_SCALE_IMAGE	objdetect/objdetect.hpp	/^	CASCADE_SCALE_IMAGE=2,$/;"	e	enum:cv::__anon199
cv::CHAIN_APPROX_NONE	imgproc/imgproc.hpp	/^    CHAIN_APPROX_NONE=CV_CHAIN_APPROX_NONE,$/;"	e	enum:cv::__anon26
cv::CHAIN_APPROX_SIMPLE	imgproc/imgproc.hpp	/^    CHAIN_APPROX_SIMPLE=CV_CHAIN_APPROX_SIMPLE,$/;"	e	enum:cv::__anon26
cv::CHAIN_APPROX_TC89_KCOS	imgproc/imgproc.hpp	/^    CHAIN_APPROX_TC89_KCOS=CV_CHAIN_APPROX_TC89_KCOS$/;"	e	enum:cv::__anon26
cv::CHAIN_APPROX_TC89_L1	imgproc/imgproc.hpp	/^    CHAIN_APPROX_TC89_L1=CV_CHAIN_APPROX_TC89_L1,$/;"	e	enum:cv::__anon26
cv::CMP_EQ	core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon99
cv::CMP_GE	core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon99
cv::CMP_GT	core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon99
cv::CMP_LE	core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon99
cv::CMP_LT	core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon99
cv::CMP_NE	core/core.hpp	/^enum { CMP_EQ=0, CMP_GT=1, CMP_GE=2, CMP_LT=3, CMP_LE=4, CMP_NE=5 };$/;"	e	enum:cv::__anon99
cv::COLOR_BGR2BGR555	imgproc/imgproc.hpp	/^    COLOR_BGR2BGR555  =22,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR2BGR565	imgproc/imgproc.hpp	/^    COLOR_BGR2BGR565  =12,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR2BGRA	imgproc/imgproc.hpp	/^    COLOR_BGR2BGRA    =0,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR2GRAY	imgproc/imgproc.hpp	/^    COLOR_BGR2GRAY    =6,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR2HLS	imgproc/imgproc.hpp	/^    COLOR_BGR2HLS     =52,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR2HLS_FULL	imgproc/imgproc.hpp	/^    COLOR_BGR2HLS_FULL = 68,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR2HSV	imgproc/imgproc.hpp	/^    COLOR_BGR2HSV     =40,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR2HSV_FULL	imgproc/imgproc.hpp	/^    COLOR_BGR2HSV_FULL = 66,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR2Lab	imgproc/imgproc.hpp	/^    COLOR_BGR2Lab     =44,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR2Luv	imgproc/imgproc.hpp	/^    COLOR_BGR2Luv     =50,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR2RGB	imgproc/imgproc.hpp	/^    COLOR_BGR2RGB     =4,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR2RGBA	imgproc/imgproc.hpp	/^    COLOR_BGR2RGBA    =2,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR2XYZ	imgproc/imgproc.hpp	/^    COLOR_BGR2XYZ     =32,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR2YCrCb	imgproc/imgproc.hpp	/^    COLOR_BGR2YCrCb   =36,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR2YUV	imgproc/imgproc.hpp	/^    COLOR_BGR2YUV      = 82,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR5552BGR	imgproc/imgproc.hpp	/^    COLOR_BGR5552BGR  =24,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR5552BGRA	imgproc/imgproc.hpp	/^    COLOR_BGR5552BGRA =28,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR5552GRAY	imgproc/imgproc.hpp	/^    COLOR_BGR5552GRAY =31,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR5552RGB	imgproc/imgproc.hpp	/^    COLOR_BGR5552RGB  =25,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR5552RGBA	imgproc/imgproc.hpp	/^    COLOR_BGR5552RGBA =29,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR5652BGR	imgproc/imgproc.hpp	/^    COLOR_BGR5652BGR  =14,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR5652BGRA	imgproc/imgproc.hpp	/^    COLOR_BGR5652BGRA =18,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR5652GRAY	imgproc/imgproc.hpp	/^    COLOR_BGR5652GRAY =21,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR5652RGB	imgproc/imgproc.hpp	/^    COLOR_BGR5652RGB  =15,$/;"	e	enum:cv::__anon23
cv::COLOR_BGR5652RGBA	imgproc/imgproc.hpp	/^    COLOR_BGR5652RGBA =19,$/;"	e	enum:cv::__anon23
cv::COLOR_BGRA2BGR	imgproc/imgproc.hpp	/^    COLOR_BGRA2BGR    =1,$/;"	e	enum:cv::__anon23
cv::COLOR_BGRA2BGR555	imgproc/imgproc.hpp	/^    COLOR_BGRA2BGR555 =26,$/;"	e	enum:cv::__anon23
cv::COLOR_BGRA2BGR565	imgproc/imgproc.hpp	/^    COLOR_BGRA2BGR565 =16,$/;"	e	enum:cv::__anon23
cv::COLOR_BGRA2GRAY	imgproc/imgproc.hpp	/^    COLOR_BGRA2GRAY   =10,$/;"	e	enum:cv::__anon23
cv::COLOR_BGRA2RGB	imgproc/imgproc.hpp	/^    COLOR_BGRA2RGB    =COLOR_RGBA2BGR,$/;"	e	enum:cv::__anon23
cv::COLOR_BGRA2RGBA	imgproc/imgproc.hpp	/^    COLOR_BGRA2RGBA   =5,$/;"	e	enum:cv::__anon23
cv::COLOR_BayerBG2BGR	imgproc/imgproc.hpp	/^    COLOR_BayerBG2BGR =46,$/;"	e	enum:cv::__anon23
cv::COLOR_BayerBG2BGR_VNG	imgproc/imgproc.hpp	/^    COLOR_BayerBG2BGR_VNG =62,$/;"	e	enum:cv::__anon23
cv::COLOR_BayerBG2GRAY	imgproc/imgproc.hpp	/^    COLOR_BayerBG2GRAY = 86,$/;"	e	enum:cv::__anon23
cv::COLOR_BayerBG2RGB	imgproc/imgproc.hpp	/^    COLOR_BayerBG2RGB =COLOR_BayerRG2BGR,$/;"	e	enum:cv::__anon23
cv::COLOR_BayerBG2RGB_VNG	imgproc/imgproc.hpp	/^    COLOR_BayerBG2RGB_VNG =COLOR_BayerRG2BGR_VNG,$/;"	e	enum:cv::__anon23
cv::COLOR_BayerGB2BGR	imgproc/imgproc.hpp	/^    COLOR_BayerGB2BGR =47,$/;"	e	enum:cv::__anon23
cv::COLOR_BayerGB2BGR_VNG	imgproc/imgproc.hpp	/^    COLOR_BayerGB2BGR_VNG =63,$/;"	e	enum:cv::__anon23
cv::COLOR_BayerGB2GRAY	imgproc/imgproc.hpp	/^    COLOR_BayerGB2GRAY = 87,$/;"	e	enum:cv::__anon23
cv::COLOR_BayerGB2RGB	imgproc/imgproc.hpp	/^    COLOR_BayerGB2RGB =COLOR_BayerGR2BGR,$/;"	e	enum:cv::__anon23
cv::COLOR_BayerGB2RGB_VNG	imgproc/imgproc.hpp	/^    COLOR_BayerGB2RGB_VNG =COLOR_BayerGR2BGR_VNG,$/;"	e	enum:cv::__anon23
cv::COLOR_BayerGR2BGR	imgproc/imgproc.hpp	/^    COLOR_BayerGR2BGR =49,$/;"	e	enum:cv::__anon23
cv::COLOR_BayerGR2BGR_VNG	imgproc/imgproc.hpp	/^    COLOR_BayerGR2BGR_VNG =65,$/;"	e	enum:cv::__anon23
cv::COLOR_BayerGR2GRAY	imgproc/imgproc.hpp	/^    COLOR_BayerGR2GRAY = 89,$/;"	e	enum:cv::__anon23
cv::COLOR_BayerGR2RGB	imgproc/imgproc.hpp	/^    COLOR_BayerGR2RGB =COLOR_BayerGB2BGR,$/;"	e	enum:cv::__anon23
cv::COLOR_BayerGR2RGB_VNG	imgproc/imgproc.hpp	/^    COLOR_BayerGR2RGB_VNG =COLOR_BayerGB2BGR_VNG,$/;"	e	enum:cv::__anon23
cv::COLOR_BayerRG2BGR	imgproc/imgproc.hpp	/^    COLOR_BayerRG2BGR =48,$/;"	e	enum:cv::__anon23
cv::COLOR_BayerRG2BGR_VNG	imgproc/imgproc.hpp	/^    COLOR_BayerRG2BGR_VNG =64,$/;"	e	enum:cv::__anon23
cv::COLOR_BayerRG2GRAY	imgproc/imgproc.hpp	/^    COLOR_BayerRG2GRAY = 88,$/;"	e	enum:cv::__anon23
cv::COLOR_BayerRG2RGB	imgproc/imgproc.hpp	/^    COLOR_BayerRG2RGB =COLOR_BayerBG2BGR,$/;"	e	enum:cv::__anon23
cv::COLOR_BayerRG2RGB_VNG	imgproc/imgproc.hpp	/^    COLOR_BayerRG2RGB_VNG =COLOR_BayerBG2BGR_VNG,$/;"	e	enum:cv::__anon23
cv::COLOR_COLORCVT_MAX	imgproc/imgproc.hpp	/^    COLOR_COLORCVT_MAX  =100$/;"	e	enum:cv::__anon23
cv::COLOR_GRAY2BGR	imgproc/imgproc.hpp	/^    COLOR_GRAY2BGR    =8,$/;"	e	enum:cv::__anon23
cv::COLOR_GRAY2BGR555	imgproc/imgproc.hpp	/^    COLOR_GRAY2BGR555 =30,$/;"	e	enum:cv::__anon23
cv::COLOR_GRAY2BGR565	imgproc/imgproc.hpp	/^    COLOR_GRAY2BGR565 =20,$/;"	e	enum:cv::__anon23
cv::COLOR_GRAY2BGRA	imgproc/imgproc.hpp	/^    COLOR_GRAY2BGRA   =9,$/;"	e	enum:cv::__anon23
cv::COLOR_GRAY2RGB	imgproc/imgproc.hpp	/^    COLOR_GRAY2RGB    =COLOR_GRAY2BGR,$/;"	e	enum:cv::__anon23
cv::COLOR_GRAY2RGBA	imgproc/imgproc.hpp	/^    COLOR_GRAY2RGBA   =COLOR_GRAY2BGRA,$/;"	e	enum:cv::__anon23
cv::COLOR_HLS2BGR	imgproc/imgproc.hpp	/^    COLOR_HLS2BGR     =60,$/;"	e	enum:cv::__anon23
cv::COLOR_HLS2BGR_FULL	imgproc/imgproc.hpp	/^    COLOR_HLS2BGR_FULL = 72,$/;"	e	enum:cv::__anon23
cv::COLOR_HLS2RGB	imgproc/imgproc.hpp	/^    COLOR_HLS2RGB     =61,$/;"	e	enum:cv::__anon23
cv::COLOR_HLS2RGB_FULL	imgproc/imgproc.hpp	/^    COLOR_HLS2RGB_FULL = 73,$/;"	e	enum:cv::__anon23
cv::COLOR_HSV2BGR	imgproc/imgproc.hpp	/^    COLOR_HSV2BGR     =54,$/;"	e	enum:cv::__anon23
cv::COLOR_HSV2BGR_FULL	imgproc/imgproc.hpp	/^    COLOR_HSV2BGR_FULL = 70,$/;"	e	enum:cv::__anon23
cv::COLOR_HSV2RGB	imgproc/imgproc.hpp	/^    COLOR_HSV2RGB     =55,$/;"	e	enum:cv::__anon23
cv::COLOR_HSV2RGB_FULL	imgproc/imgproc.hpp	/^    COLOR_HSV2RGB_FULL = 71,$/;"	e	enum:cv::__anon23
cv::COLOR_LBGR2Lab	imgproc/imgproc.hpp	/^    COLOR_LBGR2Lab     = 74,$/;"	e	enum:cv::__anon23
cv::COLOR_LBGR2Luv	imgproc/imgproc.hpp	/^    COLOR_LBGR2Luv     = 76,$/;"	e	enum:cv::__anon23
cv::COLOR_LRGB2Lab	imgproc/imgproc.hpp	/^    COLOR_LRGB2Lab     = 75,$/;"	e	enum:cv::__anon23
cv::COLOR_LRGB2Luv	imgproc/imgproc.hpp	/^    COLOR_LRGB2Luv     = 77,$/;"	e	enum:cv::__anon23
cv::COLOR_Lab2BGR	imgproc/imgproc.hpp	/^    COLOR_Lab2BGR     =56,$/;"	e	enum:cv::__anon23
cv::COLOR_Lab2LBGR	imgproc/imgproc.hpp	/^    COLOR_Lab2LBGR     = 78,$/;"	e	enum:cv::__anon23
cv::COLOR_Lab2LRGB	imgproc/imgproc.hpp	/^    COLOR_Lab2LRGB     = 79,$/;"	e	enum:cv::__anon23
cv::COLOR_Lab2RGB	imgproc/imgproc.hpp	/^    COLOR_Lab2RGB     =57,$/;"	e	enum:cv::__anon23
cv::COLOR_Luv2BGR	imgproc/imgproc.hpp	/^    COLOR_Luv2BGR     =58,$/;"	e	enum:cv::__anon23
cv::COLOR_Luv2LBGR	imgproc/imgproc.hpp	/^    COLOR_Luv2LBGR     = 80,$/;"	e	enum:cv::__anon23
cv::COLOR_Luv2LRGB	imgproc/imgproc.hpp	/^    COLOR_Luv2LRGB     = 81,$/;"	e	enum:cv::__anon23
cv::COLOR_Luv2RGB	imgproc/imgproc.hpp	/^    COLOR_Luv2RGB     =59,$/;"	e	enum:cv::__anon23
cv::COLOR_RGB2BGR	imgproc/imgproc.hpp	/^    COLOR_RGB2BGR     =COLOR_BGR2RGB,$/;"	e	enum:cv::__anon23
cv::COLOR_RGB2BGR555	imgproc/imgproc.hpp	/^    COLOR_RGB2BGR555  =23,$/;"	e	enum:cv::__anon23
cv::COLOR_RGB2BGR565	imgproc/imgproc.hpp	/^    COLOR_RGB2BGR565  =13,$/;"	e	enum:cv::__anon23
cv::COLOR_RGB2BGRA	imgproc/imgproc.hpp	/^    COLOR_RGB2BGRA    =COLOR_BGR2RGBA,$/;"	e	enum:cv::__anon23
cv::COLOR_RGB2GRAY	imgproc/imgproc.hpp	/^    COLOR_RGB2GRAY    =7,$/;"	e	enum:cv::__anon23
cv::COLOR_RGB2HLS	imgproc/imgproc.hpp	/^    COLOR_RGB2HLS     =53,$/;"	e	enum:cv::__anon23
cv::COLOR_RGB2HLS_FULL	imgproc/imgproc.hpp	/^    COLOR_RGB2HLS_FULL = 69,$/;"	e	enum:cv::__anon23
cv::COLOR_RGB2HSV	imgproc/imgproc.hpp	/^    COLOR_RGB2HSV     =41,$/;"	e	enum:cv::__anon23
cv::COLOR_RGB2HSV_FULL	imgproc/imgproc.hpp	/^    COLOR_RGB2HSV_FULL = 67,$/;"	e	enum:cv::__anon23
cv::COLOR_RGB2Lab	imgproc/imgproc.hpp	/^    COLOR_RGB2Lab     =45,$/;"	e	enum:cv::__anon23
cv::COLOR_RGB2Luv	imgproc/imgproc.hpp	/^    COLOR_RGB2Luv     =51,$/;"	e	enum:cv::__anon23
cv::COLOR_RGB2RGBA	imgproc/imgproc.hpp	/^    COLOR_RGB2RGBA    =COLOR_BGR2BGRA,$/;"	e	enum:cv::__anon23
cv::COLOR_RGB2XYZ	imgproc/imgproc.hpp	/^    COLOR_RGB2XYZ     =33,$/;"	e	enum:cv::__anon23
cv::COLOR_RGB2YCrCb	imgproc/imgproc.hpp	/^    COLOR_RGB2YCrCb   =37,$/;"	e	enum:cv::__anon23
cv::COLOR_RGB2YUV	imgproc/imgproc.hpp	/^    COLOR_RGB2YUV      = 83,$/;"	e	enum:cv::__anon23
cv::COLOR_RGBA2BGR	imgproc/imgproc.hpp	/^    COLOR_RGBA2BGR    =3,$/;"	e	enum:cv::__anon23
cv::COLOR_RGBA2BGR555	imgproc/imgproc.hpp	/^    COLOR_RGBA2BGR555 =27,$/;"	e	enum:cv::__anon23
cv::COLOR_RGBA2BGR565	imgproc/imgproc.hpp	/^    COLOR_RGBA2BGR565 =17,$/;"	e	enum:cv::__anon23
cv::COLOR_RGBA2BGRA	imgproc/imgproc.hpp	/^    COLOR_RGBA2BGRA   =COLOR_BGRA2RGBA,$/;"	e	enum:cv::__anon23
cv::COLOR_RGBA2GRAY	imgproc/imgproc.hpp	/^    COLOR_RGBA2GRAY   =11,$/;"	e	enum:cv::__anon23
cv::COLOR_RGBA2RGB	imgproc/imgproc.hpp	/^    COLOR_RGBA2RGB    =COLOR_BGRA2BGR,$/;"	e	enum:cv::__anon23
cv::COLOR_XYZ2BGR	imgproc/imgproc.hpp	/^    COLOR_XYZ2BGR     =34,$/;"	e	enum:cv::__anon23
cv::COLOR_XYZ2RGB	imgproc/imgproc.hpp	/^    COLOR_XYZ2RGB     =35,$/;"	e	enum:cv::__anon23
cv::COLOR_YCrCb2BGR	imgproc/imgproc.hpp	/^    COLOR_YCrCb2BGR   =38,$/;"	e	enum:cv::__anon23
cv::COLOR_YCrCb2RGB	imgproc/imgproc.hpp	/^    COLOR_YCrCb2RGB   =39,$/;"	e	enum:cv::__anon23
cv::COLOR_YUV2BGR	imgproc/imgproc.hpp	/^    COLOR_YUV2BGR      = 84,$/;"	e	enum:cv::__anon23
cv::COLOR_YUV2RGB	imgproc/imgproc.hpp	/^    COLOR_YUV2RGB      = 85,$/;"	e	enum:cv::__anon23
cv::COLOR_YUV420i2BGR	imgproc/imgproc.hpp	/^    COLOR_YUV420i2BGR  = 91,$/;"	e	enum:cv::__anon23
cv::COLOR_YUV420i2RGB	imgproc/imgproc.hpp	/^    COLOR_YUV420i2RGB  = 90,$/;"	e	enum:cv::__anon23
cv::COLOR_YUV420sp2BGR	imgproc/imgproc.hpp	/^    COLOR_YUV420sp2BGR = 93,$/;"	e	enum:cv::__anon23
cv::COLOR_YUV420sp2RGB	imgproc/imgproc.hpp	/^    COLOR_YUV420sp2RGB = 92,$/;"	e	enum:cv::__anon23
cv::COVAR_COLS	core/core.hpp	/^	COVAR_COLS=16$/;"	e	enum:cv::__anon141
cv::COVAR_NORMAL	core/core.hpp	/^	COVAR_NORMAL=1,$/;"	e	enum:cv::__anon141
cv::COVAR_ROWS	core/core.hpp	/^	COVAR_ROWS=8,$/;"	e	enum:cv::__anon141
cv::COVAR_SCALE	core/core.hpp	/^	COVAR_SCALE=4,$/;"	e	enum:cv::__anon141
cv::COVAR_SCRAMBLED	core/core.hpp	/^	COVAR_SCRAMBLED=0,$/;"	e	enum:cv::__anon141
cv::COVAR_USE_AVG	core/core.hpp	/^	COVAR_USE_AVG=2,$/;"	e	enum:cv::__anon141
cv::CalonderDescriptorExtractor	features2d/features2d.hpp	/^class CV_EXPORTS CalonderDescriptorExtractor : public DescriptorExtractor$/;"	c	namespace:cv	inherits:DescriptorExtractor
cv::CalonderDescriptorExtractor::BORDER_SIZE	features2d/features2d.hpp	/^    static const int BORDER_SIZE = 16;$/;"	m	class:cv::CalonderDescriptorExtractor	access:protected
cv::CalonderDescriptorExtractor::CalonderDescriptorExtractor	features2d/features2d.hpp	/^    CalonderDescriptorExtractor( const string& classifierFile );$/;"	p	class:cv::CalonderDescriptorExtractor	access:public	signature:( const string& classifierFile )
cv::CalonderDescriptorExtractor::CalonderDescriptorExtractor	features2d/features2d.hpp	/^CalonderDescriptorExtractor<T>::CalonderDescriptorExtractor(const std::string& classifier_file)$/;"	f	class:cv::CalonderDescriptorExtractor	signature:(const std::string& classifier_file)
cv::CalonderDescriptorExtractor::classifier_	features2d/features2d.hpp	/^    RTreeClassifier classifier_;$/;"	m	class:cv::CalonderDescriptorExtractor	access:protected
cv::CalonderDescriptorExtractor::computeImpl	features2d/features2d.hpp	/^    virtual void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;$/;"	p	class:cv::CalonderDescriptorExtractor	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
cv::CalonderDescriptorExtractor::computeImpl	features2d/features2d.hpp	/^void CalonderDescriptorExtractor<T>::computeImpl( const cv::Mat& image,$/;"	f	class:cv::CalonderDescriptorExtractor	signature:( const cv::Mat& image, std::vector<cv::KeyPoint>& keypoints, cv::Mat& descriptors) const
cv::CalonderDescriptorExtractor::descriptorSize	features2d/features2d.hpp	/^    virtual int descriptorSize() const { return classifier_.classes(); }$/;"	f	class:cv::CalonderDescriptorExtractor	access:public	signature:() const
cv::CalonderDescriptorExtractor::descriptorType	features2d/features2d.hpp	/^    virtual int descriptorType() const { return DataType<T>::type; }$/;"	f	class:cv::CalonderDescriptorExtractor	access:public	signature:() const
cv::CalonderDescriptorExtractor::empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::CalonderDescriptorExtractor	access:public	signature:() const
cv::CalonderDescriptorExtractor::empty	features2d/features2d.hpp	/^bool CalonderDescriptorExtractor<T>::empty() const$/;"	f	class:cv::CalonderDescriptorExtractor	signature:() const
cv::CalonderDescriptorExtractor::read	features2d/features2d.hpp	/^    virtual void read( const FileNode &fn );$/;"	p	class:cv::CalonderDescriptorExtractor	access:public	signature:( const FileNode &fn )
cv::CalonderDescriptorExtractor::read	features2d/features2d.hpp	/^void CalonderDescriptorExtractor<T>::read( const FileNode& )$/;"	f	class:cv::CalonderDescriptorExtractor	signature:( const FileNode& )
cv::CalonderDescriptorExtractor::write	features2d/features2d.hpp	/^    virtual void write( FileStorage &fs ) const;$/;"	p	class:cv::CalonderDescriptorExtractor	access:public	signature:( FileStorage &fs ) const
cv::CalonderDescriptorExtractor::write	features2d/features2d.hpp	/^void CalonderDescriptorExtractor<T>::write( FileStorage& ) const$/;"	f	class:cv::CalonderDescriptorExtractor	signature:( FileStorage& ) const
cv::CamShift	video/tracking.hpp	/^CV_EXPORTS_W RotatedRect CamShift( InputArray probImage, CV_OUT CV_IN_OUT Rect& window,$/;"	p	namespace:cv	signature:( InputArray probImage, CV_OUT CV_IN_OUT Rect& window, TermCriteria criteria )
cv::Canny	imgproc/imgproc.hpp	/^CV_EXPORTS_W void Canny( InputArray image, OutputArray edges,$/;"	p	namespace:cv	signature:( InputArray image, OutputArray edges, double threshold1, double threshold2, int apertureSize=3, bool L2gradient=false )
cv::CascadeClassifier	objdetect/objdetect.hpp	/^class CV_EXPORTS_W CascadeClassifier$/;"	c	namespace:cv
cv::CascadeClassifier::BOOST	objdetect/objdetect.hpp	/^    enum { BOOST = 0 };$/;"	e	enum:cv::CascadeClassifier::__anon200
cv::CascadeClassifier::CascadeClassifier	objdetect/objdetect.hpp	/^    CV_WRAP CascadeClassifier( const string& filename );$/;"	p	class:cv::CascadeClassifier	access:public	signature:( const string& filename )
cv::CascadeClassifier::CascadeClassifier	objdetect/objdetect.hpp	/^    CV_WRAP CascadeClassifier();$/;"	p	class:cv::CascadeClassifier	access:public	signature:()
cv::CascadeClassifier::DO_CANNY_PRUNING	objdetect/objdetect.hpp	/^    enum { DO_CANNY_PRUNING = 1, SCALE_IMAGE = 2,$/;"	e	enum:cv::CascadeClassifier::__anon201
cv::CascadeClassifier::DO_ROUGH_SEARCH	objdetect/objdetect.hpp	/^           FIND_BIGGEST_OBJECT = 4, DO_ROUGH_SEARCH = 8 };$/;"	e	enum:cv::CascadeClassifier::__anon201
cv::CascadeClassifier::Data	objdetect/objdetect.hpp	/^    class Data$/;"	c	class:cv::CascadeClassifier	access:protected
cv::CascadeClassifier::Data::DTree	objdetect/objdetect.hpp	/^        struct CV_EXPORTS DTree$/;"	s	class:cv::CascadeClassifier::Data	access:public
cv::CascadeClassifier::Data::DTree::nodeCount	objdetect/objdetect.hpp	/^            int nodeCount;$/;"	m	struct:cv::CascadeClassifier::Data::DTree	access:public
cv::CascadeClassifier::Data::DTreeNode	objdetect/objdetect.hpp	/^        struct CV_EXPORTS DTreeNode$/;"	s	class:cv::CascadeClassifier::Data	access:public
cv::CascadeClassifier::Data::DTreeNode::featureIdx	objdetect/objdetect.hpp	/^            int featureIdx;$/;"	m	struct:cv::CascadeClassifier::Data::DTreeNode	access:public
cv::CascadeClassifier::Data::DTreeNode::left	objdetect/objdetect.hpp	/^            int left;$/;"	m	struct:cv::CascadeClassifier::Data::DTreeNode	access:public
cv::CascadeClassifier::Data::DTreeNode::right	objdetect/objdetect.hpp	/^            int right;$/;"	m	struct:cv::CascadeClassifier::Data::DTreeNode	access:public
cv::CascadeClassifier::Data::DTreeNode::threshold	objdetect/objdetect.hpp	/^            float threshold; \/\/ for ordered features only$/;"	m	struct:cv::CascadeClassifier::Data::DTreeNode	access:public
cv::CascadeClassifier::Data::Stage	objdetect/objdetect.hpp	/^        struct CV_EXPORTS Stage$/;"	s	class:cv::CascadeClassifier::Data	access:public
cv::CascadeClassifier::Data::Stage::first	objdetect/objdetect.hpp	/^            int first;$/;"	m	struct:cv::CascadeClassifier::Data::Stage	access:public
cv::CascadeClassifier::Data::Stage::ntrees	objdetect/objdetect.hpp	/^            int ntrees;$/;"	m	struct:cv::CascadeClassifier::Data::Stage	access:public
cv::CascadeClassifier::Data::Stage::threshold	objdetect/objdetect.hpp	/^            float threshold;$/;"	m	struct:cv::CascadeClassifier::Data::Stage	access:public
cv::CascadeClassifier::Data::classifiers	objdetect/objdetect.hpp	/^        vector<DTree> classifiers;$/;"	m	class:cv::CascadeClassifier::Data	access:public
cv::CascadeClassifier::Data::featureType	objdetect/objdetect.hpp	/^        int featureType;$/;"	m	class:cv::CascadeClassifier::Data	access:public
cv::CascadeClassifier::Data::isStumpBased	objdetect/objdetect.hpp	/^        bool isStumpBased;$/;"	m	class:cv::CascadeClassifier::Data	access:public
cv::CascadeClassifier::Data::leaves	objdetect/objdetect.hpp	/^        vector<float> leaves;$/;"	m	class:cv::CascadeClassifier::Data	access:public
cv::CascadeClassifier::Data::ncategories	objdetect/objdetect.hpp	/^        int ncategories;$/;"	m	class:cv::CascadeClassifier::Data	access:public
cv::CascadeClassifier::Data::nodes	objdetect/objdetect.hpp	/^        vector<DTreeNode> nodes;$/;"	m	class:cv::CascadeClassifier::Data	access:public
cv::CascadeClassifier::Data::origWinSize	objdetect/objdetect.hpp	/^        Size origWinSize;$/;"	m	class:cv::CascadeClassifier::Data	access:public
cv::CascadeClassifier::Data::read	objdetect/objdetect.hpp	/^        bool read(const FileNode &node);$/;"	p	class:cv::CascadeClassifier::Data	access:public	signature:(const FileNode &node)
cv::CascadeClassifier::Data::stageType	objdetect/objdetect.hpp	/^        int stageType;$/;"	m	class:cv::CascadeClassifier::Data	access:public
cv::CascadeClassifier::Data::stages	objdetect/objdetect.hpp	/^        vector<Stage> stages;$/;"	m	class:cv::CascadeClassifier::Data	access:public
cv::CascadeClassifier::Data::subsets	objdetect/objdetect.hpp	/^        vector<int> subsets;$/;"	m	class:cv::CascadeClassifier::Data	access:public
cv::CascadeClassifier::FIND_BIGGEST_OBJECT	objdetect/objdetect.hpp	/^           FIND_BIGGEST_OBJECT = 4, DO_ROUGH_SEARCH = 8 };$/;"	e	enum:cv::CascadeClassifier::__anon201
cv::CascadeClassifier::SCALE_IMAGE	objdetect/objdetect.hpp	/^    enum { DO_CANNY_PRUNING = 1, SCALE_IMAGE = 2,$/;"	e	enum:cv::CascadeClassifier::__anon201
cv::CascadeClassifier::data	objdetect/objdetect.hpp	/^    Data data;$/;"	m	class:cv::CascadeClassifier	access:protected
cv::CascadeClassifier::detectMultiScale	objdetect/objdetect.hpp	/^    CV_WRAP virtual void detectMultiScale( const Mat& image,$/;"	p	class:cv::CascadeClassifier	access:public	signature:( const Mat& image, CV_OUT vector<Rect>& objects, double scaleFactor=1.1, int minNeighbors=3, int flags=0, Size minSize=Size(), Size maxSize=Size() )
cv::CascadeClassifier::detectMultiScale	objdetect/objdetect.hpp	/^    CV_WRAP virtual void detectMultiScale( const Mat& image,$/;"	p	class:cv::CascadeClassifier	access:public	signature:( const Mat& image, CV_OUT vector<Rect>& objects, vector<int>& rejectLevels, vector<double>& levelWeights, double scaleFactor=1.1, int minNeighbors=3, int flags=0, Size minSize=Size(), Size maxSize=Size(), bool outputRejectLevels=false )
cv::CascadeClassifier::detectSingleScale	objdetect/objdetect.hpp	/^    virtual bool detectSingleScale( const Mat& image, int stripCount, Size processingRectSize,$/;"	p	class:cv::CascadeClassifier	access:protected	signature:( const Mat& image, int stripCount, Size processingRectSize, int stripSize, int yStep, double factor, vector<Rect>& candidates, vector<int>& rejectLevels, vector<double>& levelWeights, bool outputRejectLevels=false)
cv::CascadeClassifier::empty	objdetect/objdetect.hpp	/^    CV_WRAP virtual bool empty() const;$/;"	p	class:cv::CascadeClassifier	access:public	signature:() const
cv::CascadeClassifier::featureEvaluator	objdetect/objdetect.hpp	/^    Ptr<FeatureEvaluator> featureEvaluator;$/;"	m	class:cv::CascadeClassifier	access:protected
cv::CascadeClassifier::getFeatureType	objdetect/objdetect.hpp	/^    int getFeatureType() const;$/;"	p	class:cv::CascadeClassifier	access:public	signature:() const
cv::CascadeClassifier::getOriginalWindowSize	objdetect/objdetect.hpp	/^    virtual Size getOriginalWindowSize() const;$/;"	p	class:cv::CascadeClassifier	access:public	signature:() const
cv::CascadeClassifier::isOldFormatCascade	objdetect/objdetect.hpp	/^    bool isOldFormatCascade() const;$/;"	p	class:cv::CascadeClassifier	access:public	signature:() const
cv::CascadeClassifier::load	objdetect/objdetect.hpp	/^    CV_WRAP bool load( const string& filename );$/;"	p	class:cv::CascadeClassifier	access:public	signature:( const string& filename )
cv::CascadeClassifier::oldCascade	objdetect/objdetect.hpp	/^    Ptr<CvHaarClassifierCascade> oldCascade;$/;"	m	class:cv::CascadeClassifier	access:protected
cv::CascadeClassifier::predictCategorical	objdetect/objdetect.hpp	/^    friend int predictCategorical( CascadeClassifier& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight);$/;"	p	class:cv::CascadeClassifier	access:friend	signature:( CascadeClassifier& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight)
cv::CascadeClassifier::predictCategoricalStump	objdetect/objdetect.hpp	/^    friend int predictCategoricalStump( CascadeClassifier& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight);$/;"	p	class:cv::CascadeClassifier	access:friend	signature:( CascadeClassifier& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight)
cv::CascadeClassifier::predictOrdered	objdetect/objdetect.hpp	/^    friend int predictOrdered( CascadeClassifier& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight);$/;"	p	class:cv::CascadeClassifier	access:friend	signature:( CascadeClassifier& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight)
cv::CascadeClassifier::predictOrderedStump	objdetect/objdetect.hpp	/^    friend int predictOrderedStump( CascadeClassifier& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight);$/;"	p	class:cv::CascadeClassifier	access:friend	signature:( CascadeClassifier& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight)
cv::CascadeClassifier::read	objdetect/objdetect.hpp	/^    virtual bool read( const FileNode& node );$/;"	p	class:cv::CascadeClassifier	access:public	signature:( const FileNode& node )
cv::CascadeClassifier::runAt	objdetect/objdetect.hpp	/^    virtual int runAt( Ptr<FeatureEvaluator>&, Point, double& weight );$/;"	p	class:cv::CascadeClassifier	access:protected	signature:( Ptr<FeatureEvaluator>&, Point, double& weight )
cv::CascadeClassifier::setImage	objdetect/objdetect.hpp	/^    bool setImage( Ptr<FeatureEvaluator>&, const Mat& );$/;"	p	class:cv::CascadeClassifier	access:protected	signature:( Ptr<FeatureEvaluator>&, const Mat& )
cv::CascadeClassifier::setImage	objdetect/objdetect.hpp	/^    bool setImage( const Mat& );$/;"	p	class:cv::CascadeClassifier	access:public	signature:( const Mat& )
cv::CascadeClassifier::~CascadeClassifier	objdetect/objdetect.hpp	/^    virtual ~CascadeClassifier();$/;"	p	class:cv::CascadeClassifier	access:public	signature:()
cv::Cholesky	core/operations.hpp	/^CV_EXPORTS bool Cholesky(double* A, size_t astep, int m, double* b, size_t bstep, int n);    $/;"	p	namespace:cv	signature:(double* A, size_t astep, int m, double* b, size_t bstep, int n)
cv::Cholesky	core/operations.hpp	/^CV_EXPORTS bool Cholesky(float* A, size_t astep, int m, float* b, size_t bstep, int n);$/;"	p	namespace:cv	signature:(float* A, size_t astep, int m, float* b, size_t bstep, int n)
cv::CommandLineParser	core/core.hpp	/^class CV_EXPORTS CommandLineParser$/;"	c	namespace:cv
cv::CommandLineParser::CommandLineParser	core/core.hpp	/^      CommandLineParser(int argc, const char* argv[], const char* key_map);$/;"	p	class:cv::CommandLineParser	access:public	signature:(int argc, const char* argv[], const char* key_map)
cv::CommandLineParser::analizeValue	core/core.hpp	/^    _Tp analizeValue(const std::string& str, bool space_delete=false);$/;"	p	class:cv::CommandLineParser	access:protected	signature:(const std::string& str, bool space_delete=false)
cv::CommandLineParser::analizeValue	core/core.hpp	/^double CommandLineParser::analizeValue<double>(const std::string& str, bool space_delete);$/;"	p	class:cv::CommandLineParser	signature:(const std::string& str, bool space_delete)
cv::CommandLineParser::analizeValue	core/core.hpp	/^float CommandLineParser::analizeValue<float>(const std::string& str, bool space_delete);$/;"	p	class:cv::CommandLineParser	signature:(const std::string& str, bool space_delete)
cv::CommandLineParser::analizeValue	core/core.hpp	/^int CommandLineParser::analizeValue<int>(const std::string& str, bool space_delete);$/;"	p	class:cv::CommandLineParser	signature:(const std::string& str, bool space_delete)
cv::CommandLineParser::analizeValue	core/core.hpp	/^std::string CommandLineParser::analizeValue<std::string>(const std::string& str, bool space_delete);$/;"	p	class:cv::CommandLineParser	signature:(const std::string& str, bool space_delete)
cv::CommandLineParser::analizeValue	core/core.hpp	/^unsigned CommandLineParser::analizeValue<unsigned int>(const std::string& str, bool space_delete);$/;"	p	class:cv::CommandLineParser	signature:(const std::string& str, bool space_delete)
cv::CommandLineParser::data	core/core.hpp	/^    std::map<std::string, std::vector<std::string> > data;$/;"	m	class:cv::CommandLineParser	access:protected
cv::CommandLineParser::fromStringNumber	core/core.hpp	/^     _Tp fromStringNumber(const std::string& str);\/\/the default conversion function for numbers$/;"	p	class:cv::CommandLineParser	access:protected	signature:(const std::string& str)
cv::CommandLineParser::get	core/core.hpp	/^    _Tp get(const std::string& name, bool space_delete=true)$/;"	f	class:cv::CommandLineParser	access:public	signature:(const std::string& name, bool space_delete=true)
cv::CommandLineParser::get	core/core.hpp	/^bool CommandLineParser::get<bool>(const std::string& name, bool space_delete);$/;"	p	class:cv::CommandLineParser	signature:(const std::string& name, bool space_delete)
cv::CommandLineParser::getData	core/core.hpp	/^    static _Tp getData(const std::string& str)$/;"	f	class:cv::CommandLineParser	access:protected	signature:(const std::string& str)
cv::CommandLineParser::getString	core/core.hpp	/^    std::string getString(const std::string& name);$/;"	p	class:cv::CommandLineParser	access:protected	signature:(const std::string& name)
cv::CommandLineParser::has	core/core.hpp	/^    bool has(const std::string& keys);$/;"	p	class:cv::CommandLineParser	access:protected	signature:(const std::string& keys)
cv::CommandLineParser::printParams	core/core.hpp	/^    void printParams();$/;"	p	class:cv::CommandLineParser	access:public	signature:()
cv::Complex	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Complex$/;"	c	namespace:cv
cv::Complex::Complex	core/core.hpp	/^    Complex( _Tp _re, _Tp _im=0 );$/;"	p	class:cv::Complex	access:public	signature:( _Tp _re, _Tp _im=0 )
cv::Complex::Complex	core/core.hpp	/^    Complex( const std::complex<_Tp>& c );$/;"	p	class:cv::Complex	access:public	signature:( const std::complex<_Tp>& c )
cv::Complex::Complex	core/core.hpp	/^    Complex();$/;"	p	class:cv::Complex	access:public	signature:()
cv::Complex::Complex	core/operations.hpp	/^template<typename _Tp> inline Complex<_Tp>::Complex( _Tp _re, _Tp _im ) : re(_re), im(_im) {}$/;"	f	class:cv::Complex	signature:( _Tp _re, _Tp _im )
cv::Complex::Complex	core/operations.hpp	/^template<typename _Tp> inline Complex<_Tp>::Complex() : re(0), im(0) {}$/;"	f	class:cv::Complex	signature:()
cv::Complex::conj	core/core.hpp	/^    Complex conj() const;$/;"	p	class:cv::Complex	access:public	signature:() const
cv::Complex::conj	core/operations.hpp	/^template<typename _Tp> inline Complex<_Tp> Complex<_Tp>::conj() const$/;"	f	class:cv::Complex	signature:() const
cv::Complex::im	core/core.hpp	/^    _Tp re, im; \/\/< the real and the imaginary parts$/;"	m	class:cv::Complex	access:public
cv::Complex::operator Complex<T2>	core/core.hpp	/^    template<typename T2> operator Complex<T2>() const;$/;"	p	class:cv::Complex	access:public	signature:() const
cv::Complex::operator Complex<T2>	core/operations.hpp	/^template<typename _Tp> template<typename T2> inline Complex<_Tp>::operator Complex<T2>() const$/;"	f	class:cv::Complex	signature:() const
cv::Complex::operator std::complex<_Tp>	core/core.hpp	/^    operator std::complex<_Tp>() const;$/;"	p	class:cv::Complex	access:public	signature:() const
cv::Complex::re	core/core.hpp	/^    _Tp re, im; \/\/< the real and the imaginary parts$/;"	m	class:cv::Complex	access:public
cv::Complexd	core/core.hpp	/^typedef Complex<double> Complexd;$/;"	t	namespace:cv
cv::Complexf	core/core.hpp	/^typedef Complex<float> Complexf;$/;"	t	namespace:cv
cv::ConcurrentDoubleVector	core/internal.hpp	/^        typedef tbb::concurrent_vector<double> ConcurrentDoubleVector;$/;"	t	namespace:cv
cv::ConcurrentRectVector	core/internal.hpp	/^        typedef tbb::concurrent_vector<Rect> ConcurrentRectVector;$/;"	t	namespace:cv
cv::ConvertData	core/core.hpp	/^typedef void (*ConvertData)(const void* from, void* to, int cn);$/;"	t	namespace:cv
cv::ConvertScaleData	core/core.hpp	/^typedef void (*ConvertScaleData)(const void* from, void* to, int cn, double alpha, double beta);$/;"	t	namespace:cv
cv::CvAffinePose	features2d/features2d.hpp	/^class CV_EXPORTS CvAffinePose$/;"	c	namespace:cv
cv::CvAffinePose::lambda1	features2d/features2d.hpp	/^    float lambda1;$/;"	m	class:cv::CvAffinePose	access:public
cv::CvAffinePose::lambda2	features2d/features2d.hpp	/^    float lambda2;$/;"	m	class:cv::CvAffinePose	access:public
cv::CvAffinePose::phi	features2d/features2d.hpp	/^    float phi;$/;"	m	class:cv::CvAffinePose	access:public
cv::CvAffinePose::theta	features2d/features2d.hpp	/^    float theta;$/;"	m	class:cv::CvAffinePose	access:public
cv::DCT_INVERSE	core/core.hpp	/^    DCT_INVERSE = DFT_INVERSE, DCT_ROWS=DFT_ROWS };$/;"	e	enum:cv::__anon101
cv::DCT_ROWS	core/core.hpp	/^    DCT_INVERSE = DFT_INVERSE, DCT_ROWS=DFT_ROWS };$/;"	e	enum:cv::__anon101
cv::DECOMP_CHOLESKY	core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon97
cv::DECOMP_EIG	core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon97
cv::DECOMP_LU	core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon97
cv::DECOMP_NORMAL	core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon97
cv::DECOMP_QR	core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon97
cv::DECOMP_SVD	core/core.hpp	/^enum { DECOMP_LU=0, DECOMP_SVD=1, DECOMP_EIG=2, DECOMP_CHOLESKY=3, DECOMP_QR=4, DECOMP_NORMAL=16 };$/;"	e	enum:cv::__anon97
cv::DEPTH_MASK	core/core.hpp	/^enum { MAGIC_MASK=0xFFFF0000, TYPE_MASK=0x00000FFF, DEPTH_MASK=7 };$/;"	e	enum:cv::__anon136
cv::DEPTH_MASK_16S	core/core.hpp	/^    DEPTH_MASK_16S = 1 << CV_16S,$/;"	e	enum:cv::__anon135
cv::DEPTH_MASK_16U	core/core.hpp	/^    DEPTH_MASK_16U = 1 << CV_16U,$/;"	e	enum:cv::__anon135
cv::DEPTH_MASK_32F	core/core.hpp	/^    DEPTH_MASK_32F = 1 << CV_32F,$/;"	e	enum:cv::__anon135
cv::DEPTH_MASK_32S	core/core.hpp	/^    DEPTH_MASK_32S = 1 << CV_32S,$/;"	e	enum:cv::__anon135
cv::DEPTH_MASK_64F	core/core.hpp	/^    DEPTH_MASK_64F = 1 << CV_64F,$/;"	e	enum:cv::__anon135
cv::DEPTH_MASK_8S	core/core.hpp	/^    DEPTH_MASK_8S = 1 << CV_8S,$/;"	e	enum:cv::__anon135
cv::DEPTH_MASK_8U	core/core.hpp	/^    DEPTH_MASK_8U = 1 << CV_8U,$/;"	e	enum:cv::__anon135
cv::DEPTH_MASK_ALL	core/core.hpp	/^    DEPTH_MASK_ALL = (DEPTH_MASK_64F<<1)-1,$/;"	e	enum:cv::__anon135
cv::DEPTH_MASK_ALL_BUT_8S	core/core.hpp	/^    DEPTH_MASK_ALL_BUT_8S = DEPTH_MASK_ALL & ~DEPTH_MASK_8S,$/;"	e	enum:cv::__anon135
cv::DEPTH_MASK_FLT	core/core.hpp	/^    DEPTH_MASK_FLT = DEPTH_MASK_32F + DEPTH_MASK_64F$/;"	e	enum:cv::__anon135
cv::DFT_COMPLEX_OUTPUT	core/core.hpp	/^enum { DFT_INVERSE=1, DFT_SCALE=2, DFT_ROWS=4, DFT_COMPLEX_OUTPUT=16, DFT_REAL_OUTPUT=32,$/;"	e	enum:cv::__anon101
cv::DFT_INVERSE	core/core.hpp	/^enum { DFT_INVERSE=1, DFT_SCALE=2, DFT_ROWS=4, DFT_COMPLEX_OUTPUT=16, DFT_REAL_OUTPUT=32,$/;"	e	enum:cv::__anon101
cv::DFT_REAL_OUTPUT	core/core.hpp	/^enum { DFT_INVERSE=1, DFT_SCALE=2, DFT_ROWS=4, DFT_COMPLEX_OUTPUT=16, DFT_REAL_OUTPUT=32,$/;"	e	enum:cv::__anon101
cv::DFT_ROWS	core/core.hpp	/^enum { DFT_INVERSE=1, DFT_SCALE=2, DFT_ROWS=4, DFT_COMPLEX_OUTPUT=16, DFT_REAL_OUTPUT=32,$/;"	e	enum:cv::__anon101
cv::DFT_SCALE	core/core.hpp	/^enum { DFT_INVERSE=1, DFT_SCALE=2, DFT_ROWS=4, DFT_COMPLEX_OUTPUT=16, DFT_REAL_OUTPUT=32,$/;"	e	enum:cv::__anon101
cv::DMatch	features2d/features2d.hpp	/^struct CV_EXPORTS DMatch$/;"	s	namespace:cv
cv::DMatch::DMatch	features2d/features2d.hpp	/^    DMatch( int _queryIdx, int _trainIdx, float _distance ) :$/;"	f	struct:cv::DMatch	access:public	signature:( int _queryIdx, int _trainIdx, float _distance )
cv::DMatch::DMatch	features2d/features2d.hpp	/^    DMatch( int _queryIdx, int _trainIdx, int _imgIdx, float _distance ) :$/;"	f	struct:cv::DMatch	access:public	signature:( int _queryIdx, int _trainIdx, int _imgIdx, float _distance )
cv::DMatch::DMatch	features2d/features2d.hpp	/^    DMatch() : queryIdx(-1), trainIdx(-1), imgIdx(-1), distance(std::numeric_limits<float>::max()) {}$/;"	f	struct:cv::DMatch	access:public	signature:()
cv::DMatch::distance	features2d/features2d.hpp	/^    float distance;$/;"	m	struct:cv::DMatch	access:public
cv::DMatch::imgIdx	features2d/features2d.hpp	/^    int imgIdx;   \/\/ train image index$/;"	m	struct:cv::DMatch	access:public
cv::DMatch::operator <	features2d/features2d.hpp	/^    bool operator<( const DMatch &m ) const$/;"	f	struct:cv::DMatch	access:public	signature:( const DMatch &m ) const
cv::DMatch::queryIdx	features2d/features2d.hpp	/^    int queryIdx; \/\/ query descriptor index$/;"	m	struct:cv::DMatch	access:public
cv::DMatch::trainIdx	features2d/features2d.hpp	/^    int trainIdx; \/\/ train descriptor index$/;"	m	struct:cv::DMatch	access:public
cv::DTreeParams	ml/ml.hpp	/^typedef CvDTreeParams DTreeParams;$/;"	t	namespace:cv
cv::DataDepth	core/core.hpp	/^template<> class DataDepth<bool> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	c	namespace:cv
cv::DataDepth	core/core.hpp	/^template<> class DataDepth<char> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	c	namespace:cv
cv::DataDepth	core/core.hpp	/^template<> class DataDepth<double> { public: enum { value = CV_64F, fmt=(int)'d' }; };$/;"	c	namespace:cv
cv::DataDepth	core/core.hpp	/^template<> class DataDepth<float> { public: enum { value = CV_32F, fmt=(int)'f' }; };$/;"	c	namespace:cv
cv::DataDepth	core/core.hpp	/^template<> class DataDepth<int> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	c	namespace:cv
cv::DataDepth	core/core.hpp	/^template<> class DataDepth<schar> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	c	namespace:cv
cv::DataDepth	core/core.hpp	/^template<> class DataDepth<short> { public: enum { value = CV_16S, fmt=(int)'s' }; };$/;"	c	namespace:cv
cv::DataDepth	core/core.hpp	/^template<> class DataDepth<uchar> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	c	namespace:cv
cv::DataDepth	core/core.hpp	/^template<> class DataDepth<unsigned> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	c	namespace:cv
cv::DataDepth	core/core.hpp	/^template<> class DataDepth<ushort> { public: enum { value = CV_16U, fmt=(int)'w' }; };$/;"	c	namespace:cv
cv::DataDepth	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS DataDepth {};$/;"	c	namespace:cv
cv::DataDepth	core/core.hpp	/^template<typename _Tp> class DataDepth<_Tp*> { public: enum { value = CV_USRTYPE1, fmt=(int)'r' }; };$/;"	c	namespace:cv
cv::DataDepth::fmt	core/core.hpp	/^template<> class DataDepth<bool> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	e	enum:cv::DataDepth::__anon102
cv::DataDepth::fmt	core/core.hpp	/^template<> class DataDepth<char> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	e	enum:cv::DataDepth::__anon105
cv::DataDepth::fmt	core/core.hpp	/^template<> class DataDepth<double> { public: enum { value = CV_64F, fmt=(int)'d' }; };$/;"	e	enum:cv::DataDepth::__anon111
cv::DataDepth::fmt	core/core.hpp	/^template<> class DataDepth<float> { public: enum { value = CV_32F, fmt=(int)'f' }; };$/;"	e	enum:cv::DataDepth::__anon110
cv::DataDepth::fmt	core/core.hpp	/^template<> class DataDepth<int> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	e	enum:cv::DataDepth::__anon108
cv::DataDepth::fmt	core/core.hpp	/^template<> class DataDepth<schar> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	e	enum:cv::DataDepth::__anon104
cv::DataDepth::fmt	core/core.hpp	/^template<> class DataDepth<short> { public: enum { value = CV_16S, fmt=(int)'s' }; };$/;"	e	enum:cv::DataDepth::__anon107
cv::DataDepth::fmt	core/core.hpp	/^template<> class DataDepth<uchar> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	e	enum:cv::DataDepth::__anon103
cv::DataDepth::fmt	core/core.hpp	/^template<> class DataDepth<unsigned> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	e	enum:cv::DataDepth::__anon109
cv::DataDepth::fmt	core/core.hpp	/^template<> class DataDepth<ushort> { public: enum { value = CV_16U, fmt=(int)'w' }; };$/;"	e	enum:cv::DataDepth::__anon106
cv::DataDepth::fmt	core/core.hpp	/^template<typename _Tp> class DataDepth<_Tp*> { public: enum { value = CV_USRTYPE1, fmt=(int)'r' }; };$/;"	e	enum:cv::DataDepth::__anon112
cv::DataDepth::value	core/core.hpp	/^template<> class DataDepth<bool> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	e	enum:cv::DataDepth::__anon102
cv::DataDepth::value	core/core.hpp	/^template<> class DataDepth<char> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	e	enum:cv::DataDepth::__anon105
cv::DataDepth::value	core/core.hpp	/^template<> class DataDepth<double> { public: enum { value = CV_64F, fmt=(int)'d' }; };$/;"	e	enum:cv::DataDepth::__anon111
cv::DataDepth::value	core/core.hpp	/^template<> class DataDepth<float> { public: enum { value = CV_32F, fmt=(int)'f' }; };$/;"	e	enum:cv::DataDepth::__anon110
cv::DataDepth::value	core/core.hpp	/^template<> class DataDepth<int> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	e	enum:cv::DataDepth::__anon108
cv::DataDepth::value	core/core.hpp	/^template<> class DataDepth<schar> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	e	enum:cv::DataDepth::__anon104
cv::DataDepth::value	core/core.hpp	/^template<> class DataDepth<short> { public: enum { value = CV_16S, fmt=(int)'s' }; };$/;"	e	enum:cv::DataDepth::__anon107
cv::DataDepth::value	core/core.hpp	/^template<> class DataDepth<uchar> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	e	enum:cv::DataDepth::__anon103
cv::DataDepth::value	core/core.hpp	/^template<> class DataDepth<unsigned> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	e	enum:cv::DataDepth::__anon109
cv::DataDepth::value	core/core.hpp	/^template<> class DataDepth<ushort> { public: enum { value = CV_16U, fmt=(int)'w' }; };$/;"	e	enum:cv::DataDepth::__anon106
cv::DataDepth::value	core/core.hpp	/^template<typename _Tp> class DataDepth<_Tp*> { public: enum { value = CV_USRTYPE1, fmt=(int)'r' }; };$/;"	e	enum:cv::DataDepth::__anon112
cv::DataMatrixCode	objdetect/objdetect.hpp	/^struct CV_EXPORTS DataMatrixCode {$/;"	s	namespace:cv
cv::DataMatrixCode::corners	objdetect/objdetect.hpp	/^  Point corners[4]; \/\/TODO vector$/;"	m	struct:cv::DataMatrixCode	access:public
cv::DataMatrixCode::msg	objdetect/objdetect.hpp	/^  char msg[4]; \/\/TODO std::string$/;"	m	struct:cv::DataMatrixCode	access:public
cv::DataMatrixCode::original	objdetect/objdetect.hpp	/^  Mat original;$/;"	m	struct:cv::DataMatrixCode	access:public
cv::DataType	core/core.hpp	/^template<> class DataType<Range>$/;"	c	namespace:cv
cv::DataType	core/core.hpp	/^template<> class DataType<bool>$/;"	c	namespace:cv
cv::DataType	core/core.hpp	/^template<> class DataType<char>$/;"	c	namespace:cv
cv::DataType	core/core.hpp	/^template<> class DataType<double>$/;"	c	namespace:cv
cv::DataType	core/core.hpp	/^template<> class DataType<float>$/;"	c	namespace:cv
cv::DataType	core/core.hpp	/^template<> class DataType<int>$/;"	c	namespace:cv
cv::DataType	core/core.hpp	/^template<> class DataType<schar>$/;"	c	namespace:cv
cv::DataType	core/core.hpp	/^template<> class DataType<short>$/;"	c	namespace:cv
cv::DataType	core/core.hpp	/^template<> class DataType<uchar>$/;"	c	namespace:cv
cv::DataType	core/core.hpp	/^template<> class DataType<ushort>$/;"	c	namespace:cv
cv::DataType	core/core.hpp	/^template<typename _Tp, int cn> class DataType<Vec<_Tp, cn> >$/;"	c	namespace:cv
cv::DataType	core/core.hpp	/^template<typename _Tp> class DataType$/;"	c	namespace:cv
cv::DataType	core/core.hpp	/^template<typename _Tp> class DataType<Complex<_Tp> >$/;"	c	namespace:cv
cv::DataType	core/core.hpp	/^template<typename _Tp> class DataType<Point3_<_Tp> >$/;"	c	namespace:cv
cv::DataType	core/core.hpp	/^template<typename _Tp> class DataType<Point_<_Tp> >$/;"	c	namespace:cv
cv::DataType	core/core.hpp	/^template<typename _Tp> class DataType<Rect_<_Tp> >$/;"	c	namespace:cv
cv::DataType	core/core.hpp	/^template<typename _Tp> class DataType<Scalar_<_Tp> >$/;"	c	namespace:cv
cv::DataType	core/core.hpp	/^template<typename _Tp> class DataType<Size_<_Tp> >$/;"	c	namespace:cv
cv::DataType	core/core.hpp	/^template<typename _Tp> class DataType<std::complex<_Tp> >$/;"	c	namespace:cv
cv::DataType::channel_type	core/core.hpp	/^    typedef _Tp channel_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::channel_type	core/core.hpp	/^    typedef int channel_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::channel_type	core/core.hpp	/^    typedef value_type channel_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon116
cv::DataType::channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon117
cv::DataType::channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon118
cv::DataType::channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon119
cv::DataType::channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon120
cv::DataType::channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon121
cv::DataType::channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon122
cv::DataType::channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon123
cv::DataType::channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon124
cv::DataType::channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon126
cv::DataType::channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon127
cv::DataType::channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon128
cv::DataType::channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon130
cv::DataType::channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon133
cv::DataType::channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 3,$/;"	e	enum:cv::DataType::__anon129
cv::DataType::channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon131
cv::DataType::channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon132
cv::DataType::channels	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = cn,$/;"	e	enum:cv::DataType::__anon125
cv::DataType::channels	core/core.hpp	/^    enum { generic_type = 1, depth = -1, channels = 1, fmt=0,$/;"	e	enum:cv::DataType::__anon115
cv::DataType::depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon116
cv::DataType::depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon117
cv::DataType::depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon118
cv::DataType::depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon119
cv::DataType::depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon120
cv::DataType::depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon121
cv::DataType::depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon122
cv::DataType::depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon123
cv::DataType::depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon124
cv::DataType::depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon126
cv::DataType::depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon127
cv::DataType::depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon128
cv::DataType::depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon130
cv::DataType::depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon133
cv::DataType::depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 3,$/;"	e	enum:cv::DataType::__anon129
cv::DataType::depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon131
cv::DataType::depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon132
cv::DataType::depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = cn,$/;"	e	enum:cv::DataType::__anon125
cv::DataType::depth	core/core.hpp	/^    enum { generic_type = 1, depth = -1, channels = 1, fmt=0,$/;"	e	enum:cv::DataType::__anon115
cv::DataType::fmt	core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon125
cv::DataType::fmt	core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon126
cv::DataType::fmt	core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon127
cv::DataType::fmt	core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon128
cv::DataType::fmt	core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon129
cv::DataType::fmt	core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon130
cv::DataType::fmt	core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon131
cv::DataType::fmt	core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon132
cv::DataType::fmt	core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon133
cv::DataType::fmt	core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon116
cv::DataType::fmt	core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon117
cv::DataType::fmt	core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon118
cv::DataType::fmt	core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon119
cv::DataType::fmt	core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon120
cv::DataType::fmt	core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon121
cv::DataType::fmt	core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon122
cv::DataType::fmt	core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon123
cv::DataType::fmt	core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon124
cv::DataType::fmt	core/core.hpp	/^    enum { generic_type = 1, depth = -1, channels = 1, fmt=0,$/;"	e	enum:cv::DataType::__anon115
cv::DataType::generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon116
cv::DataType::generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon117
cv::DataType::generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon118
cv::DataType::generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon119
cv::DataType::generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon120
cv::DataType::generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon121
cv::DataType::generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon122
cv::DataType::generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon123
cv::DataType::generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon124
cv::DataType::generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon126
cv::DataType::generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon127
cv::DataType::generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon128
cv::DataType::generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon130
cv::DataType::generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon133
cv::DataType::generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 3,$/;"	e	enum:cv::DataType::__anon129
cv::DataType::generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon131
cv::DataType::generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon132
cv::DataType::generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = cn,$/;"	e	enum:cv::DataType::__anon125
cv::DataType::generic_type	core/core.hpp	/^    enum { generic_type = 1, depth = -1, channels = 1, fmt=0,$/;"	e	enum:cv::DataType::__anon115
cv::DataType::type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon116
cv::DataType::type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon117
cv::DataType::type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon118
cv::DataType::type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon119
cv::DataType::type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon120
cv::DataType::type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon121
cv::DataType::type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon122
cv::DataType::type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon123
cv::DataType::type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon124
cv::DataType::type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon125
cv::DataType::type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon126
cv::DataType::type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon127
cv::DataType::type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon128
cv::DataType::type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon129
cv::DataType::type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon130
cv::DataType::type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon131
cv::DataType::type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon132
cv::DataType::type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon133
cv::DataType::type	core/core.hpp	/^        type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon115
cv::DataType::value_type	core/core.hpp	/^    typedef Complex<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	core/core.hpp	/^    typedef Point3_<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	core/core.hpp	/^    typedef Point_<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	core/core.hpp	/^    typedef Range value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	core/core.hpp	/^    typedef Rect_<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	core/core.hpp	/^    typedef Scalar_<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	core/core.hpp	/^    typedef Size_<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	core/core.hpp	/^    typedef Vec<_Tp, cn> value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	core/core.hpp	/^    typedef bool value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	core/core.hpp	/^    typedef double value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	core/core.hpp	/^    typedef float value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	core/core.hpp	/^    typedef int value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	core/core.hpp	/^    typedef schar value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	core/core.hpp	/^    typedef short value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	core/core.hpp	/^    typedef std::complex<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	core/core.hpp	/^    typedef uchar value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::value_type	core/core.hpp	/^    typedef ushort value_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::vec_type	core/core.hpp	/^    typedef Vec<channel_type, channels> vec_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::vec_type	core/core.hpp	/^    typedef value_type vec_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::work_type	core/core.hpp	/^    typedef Point3_<typename DataType<_Tp>::work_type> work_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::work_type	core/core.hpp	/^    typedef Point_<typename DataType<_Tp>::work_type> work_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::work_type	core/core.hpp	/^    typedef Rect_<typename DataType<_Tp>::work_type> work_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::work_type	core/core.hpp	/^    typedef Scalar_<typename DataType<_Tp>::work_type> work_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::work_type	core/core.hpp	/^    typedef Size_<typename DataType<_Tp>::work_type> work_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::work_type	core/core.hpp	/^    typedef Vec<typename DataType<_Tp>::work_type, cn> work_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::work_type	core/core.hpp	/^    typedef int work_type;$/;"	t	class:cv::DataType	access:public
cv::DataType::work_type	core/core.hpp	/^    typedef value_type work_type;$/;"	t	class:cv::DataType	access:public
cv::DecisionTree	ml/ml.hpp	/^typedef CvDTree DecisionTree;$/;"	t	namespace:cv
cv::DefaultRngAuto	features2d/features2d.hpp	/^    struct CV_EXPORTS DefaultRngAuto$/;"	s	namespace:cv
cv::DefaultRngAuto::DefaultRngAuto	features2d/features2d.hpp	/^        DefaultRngAuto() : old_state(theRNG().state) { theRNG().state = (uint64)-1; }$/;"	f	struct:cv::DefaultRngAuto	access:public	signature:()
cv::DefaultRngAuto::old_state	features2d/features2d.hpp	/^        const uint64 old_state;$/;"	m	struct:cv::DefaultRngAuto	access:public
cv::DefaultRngAuto::operator =	features2d/features2d.hpp	/^        DefaultRngAuto& operator=(const DefaultRngAuto&);$/;"	p	struct:cv::DefaultRngAuto	access:public	signature:(const DefaultRngAuto&)
cv::DefaultRngAuto::~DefaultRngAuto	features2d/features2d.hpp	/^        ~DefaultRngAuto() { theRNG().state = old_state; }$/;"	f	struct:cv::DefaultRngAuto	access:public	signature:()
cv::DenseFeatureDetector	features2d/features2d.hpp	/^class CV_EXPORTS DenseFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
cv::DenseFeatureDetector::DenseFeatureDetector	features2d/features2d.hpp	/^    DenseFeatureDetector( const DenseFeatureDetector::Params& params=DenseFeatureDetector::Params() );$/;"	p	class:cv::DenseFeatureDetector	access:public	signature:( const DenseFeatureDetector::Params& params=DenseFeatureDetector::Params() )
cv::DenseFeatureDetector::Params	features2d/features2d.hpp	/^    class CV_EXPORTS Params$/;"	c	class:cv::DenseFeatureDetector	access:public
cv::DenseFeatureDetector::Params::Params	features2d/features2d.hpp	/^        Params( float initFeatureScale=1.f, int featureScaleLevels=1, float featureScaleMul=0.1f,$/;"	p	class:cv::DenseFeatureDetector::Params	access:public	signature:( float initFeatureScale=1.f, int featureScaleLevels=1, float featureScaleMul=0.1f, int initXyStep=6, int initImgBound=0, bool varyXyStepWithScale=true, bool varyImgBoundWithScale=false )
cv::DenseFeatureDetector::Params::featureScaleLevels	features2d/features2d.hpp	/^        int featureScaleLevels;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
cv::DenseFeatureDetector::Params::featureScaleMul	features2d/features2d.hpp	/^        float featureScaleMul;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
cv::DenseFeatureDetector::Params::initFeatureScale	features2d/features2d.hpp	/^        float initFeatureScale;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
cv::DenseFeatureDetector::Params::initImgBound	features2d/features2d.hpp	/^        int initImgBound;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
cv::DenseFeatureDetector::Params::initXyStep	features2d/features2d.hpp	/^        int initXyStep;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
cv::DenseFeatureDetector::Params::read	features2d/features2d.hpp	/^        void read( const FileNode& fn );$/;"	p	class:cv::DenseFeatureDetector::Params	access:public	signature:( const FileNode& fn )
cv::DenseFeatureDetector::Params::varyImgBoundWithScale	features2d/features2d.hpp	/^        bool varyImgBoundWithScale;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
cv::DenseFeatureDetector::Params::varyXyStepWithScale	features2d/features2d.hpp	/^        bool varyXyStepWithScale;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
cv::DenseFeatureDetector::Params::write	features2d/features2d.hpp	/^        void write( FileStorage& fs ) const;$/;"	p	class:cv::DenseFeatureDetector::Params	access:public	signature:( FileStorage& fs ) const
cv::DenseFeatureDetector::detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::DenseFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::DenseFeatureDetector::params	features2d/features2d.hpp	/^    Params params;$/;"	m	class:cv::DenseFeatureDetector	access:protected
cv::DenseFeatureDetector::read	features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::DenseFeatureDetector	access:public	signature:( const FileNode& fn )
cv::DenseFeatureDetector::write	features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::DenseFeatureDetector	access:public	signature:( FileStorage& fs ) const
cv::DescriptorExtractor	features2d/features2d.hpp	/^class CV_EXPORTS DescriptorExtractor$/;"	c	namespace:cv
cv::DescriptorExtractor::compute	features2d/features2d.hpp	/^    void compute( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;$/;"	p	class:cv::DescriptorExtractor	access:public	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
cv::DescriptorExtractor::compute	features2d/features2d.hpp	/^    void compute( const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints, vector<Mat>& descriptors ) const;$/;"	p	class:cv::DescriptorExtractor	access:public	signature:( const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints, vector<Mat>& descriptors ) const
cv::DescriptorExtractor::computeImpl	features2d/features2d.hpp	/^    virtual void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const = 0;$/;"	p	class:cv::DescriptorExtractor	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
cv::DescriptorExtractor::create	features2d/features2d.hpp	/^    static Ptr<DescriptorExtractor> create( const string& descriptorExtractorType );$/;"	p	class:cv::DescriptorExtractor	access:public	signature:( const string& descriptorExtractorType )
cv::DescriptorExtractor::descriptorSize	features2d/features2d.hpp	/^    virtual int descriptorSize() const = 0;$/;"	p	class:cv::DescriptorExtractor	access:public	signature:() const
cv::DescriptorExtractor::descriptorType	features2d/features2d.hpp	/^    virtual int descriptorType() const = 0;$/;"	p	class:cv::DescriptorExtractor	access:public	signature:() const
cv::DescriptorExtractor::empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::DescriptorExtractor	access:public	signature:() const
cv::DescriptorExtractor::read	features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::DescriptorExtractor	access:public	signature:( const FileNode& )
cv::DescriptorExtractor::removeBorderKeypoints	features2d/features2d.hpp	/^    static void removeBorderKeypoints( vector<KeyPoint>& keypoints,$/;"	p	class:cv::DescriptorExtractor	access:protected	signature:( vector<KeyPoint>& keypoints, Size imageSize, int borderSize )
cv::DescriptorExtractor::write	features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::DescriptorExtractor	access:public	signature:( FileStorage& ) const
cv::DescriptorExtractor::~DescriptorExtractor	features2d/features2d.hpp	/^    virtual ~DescriptorExtractor();$/;"	p	class:cv::DescriptorExtractor	access:public	signature:()
cv::DescriptorMatcher	features2d/features2d.hpp	/^class CV_EXPORTS DescriptorMatcher$/;"	c	namespace:cv
cv::DescriptorMatcher::DescriptorCollection	features2d/features2d.hpp	/^    class CV_EXPORTS DescriptorCollection$/;"	c	class:cv::DescriptorMatcher	access:protected
cv::DescriptorMatcher::DescriptorCollection::DescriptorCollection	features2d/features2d.hpp	/^        DescriptorCollection( const DescriptorCollection& collection );$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:( const DescriptorCollection& collection )
cv::DescriptorMatcher::DescriptorCollection::DescriptorCollection	features2d/features2d.hpp	/^        DescriptorCollection();$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:()
cv::DescriptorMatcher::DescriptorCollection::clear	features2d/features2d.hpp	/^        virtual void clear();$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:()
cv::DescriptorMatcher::DescriptorCollection::getDescriptor	features2d/features2d.hpp	/^        const Mat getDescriptor( int globalDescIdx ) const;$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:( int globalDescIdx ) const
cv::DescriptorMatcher::DescriptorCollection::getDescriptor	features2d/features2d.hpp	/^        const Mat getDescriptor( int imgIdx, int localDescIdx ) const;$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:( int imgIdx, int localDescIdx ) const
cv::DescriptorMatcher::DescriptorCollection::getDescriptors	features2d/features2d.hpp	/^        const Mat& getDescriptors() const;$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:() const
cv::DescriptorMatcher::DescriptorCollection::getLocalIdx	features2d/features2d.hpp	/^        void getLocalIdx( int globalDescIdx, int& imgIdx, int& localDescIdx ) const;$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:( int globalDescIdx, int& imgIdx, int& localDescIdx ) const
cv::DescriptorMatcher::DescriptorCollection::mergedDescriptors	features2d/features2d.hpp	/^        Mat mergedDescriptors;$/;"	m	class:cv::DescriptorMatcher::DescriptorCollection	access:protected
cv::DescriptorMatcher::DescriptorCollection::set	features2d/features2d.hpp	/^        void set( const vector<Mat>& descriptors );$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:( const vector<Mat>& descriptors )
cv::DescriptorMatcher::DescriptorCollection::size	features2d/features2d.hpp	/^        int size() const;$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:() const
cv::DescriptorMatcher::DescriptorCollection::startIdxs	features2d/features2d.hpp	/^        vector<int> startIdxs;$/;"	m	class:cv::DescriptorMatcher::DescriptorCollection	access:protected
cv::DescriptorMatcher::DescriptorCollection::~DescriptorCollection	features2d/features2d.hpp	/^        virtual ~DescriptorCollection();$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:()
cv::DescriptorMatcher::add	features2d/features2d.hpp	/^    virtual void add( const vector<Mat>& descriptors );$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const vector<Mat>& descriptors )
cv::DescriptorMatcher::checkMasks	features2d/features2d.hpp	/^	void checkMasks( const vector<Mat>& masks, int queryDescriptorsCount ) const;$/;"	p	class:cv::DescriptorMatcher	access:protected	signature:( const vector<Mat>& masks, int queryDescriptorsCount ) const
cv::DescriptorMatcher::clear	features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::DescriptorMatcher	access:public	signature:()
cv::DescriptorMatcher::clone	features2d/features2d.hpp	/^    virtual Ptr<DescriptorMatcher> clone( bool emptyTrainData=false ) const = 0;$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( bool emptyTrainData=false ) const
cv::DescriptorMatcher::clone_op	features2d/features2d.hpp	/^    static Mat clone_op( Mat m ) { return m.clone(); }$/;"	f	class:cv::DescriptorMatcher	access:protected	signature:( Mat m )
cv::DescriptorMatcher::create	features2d/features2d.hpp	/^    static Ptr<DescriptorMatcher> create( const string& descriptorMatcherType );$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const string& descriptorMatcherType )
cv::DescriptorMatcher::empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::DescriptorMatcher	access:public	signature:() const
cv::DescriptorMatcher::getTrainDescriptors	features2d/features2d.hpp	/^    const vector<Mat>& getTrainDescriptors() const;$/;"	p	class:cv::DescriptorMatcher	access:public	signature:() const
cv::DescriptorMatcher::isMaskSupported	features2d/features2d.hpp	/^    virtual bool isMaskSupported() const = 0;$/;"	p	class:cv::DescriptorMatcher	access:public	signature:() const
cv::DescriptorMatcher::isMaskedOut	features2d/features2d.hpp	/^    static bool isMaskedOut( const vector<Mat>& masks, int queryIdx );$/;"	p	class:cv::DescriptorMatcher	access:protected	signature:( const vector<Mat>& masks, int queryIdx )
cv::DescriptorMatcher::isPossibleMatch	features2d/features2d.hpp	/^    static bool isPossibleMatch( const Mat& mask, int queryIdx, int trainIdx );$/;"	p	class:cv::DescriptorMatcher	access:protected	signature:( const Mat& mask, int queryIdx, int trainIdx )
cv::DescriptorMatcher::knnMatch	features2d/features2d.hpp	/^    void knnMatch( const Mat& queryDescriptors, const Mat& trainDescriptors,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, const Mat& trainDescriptors, vector<vector<DMatch> >& matches, int k, const Mat& mask=Mat(), bool compactResult=false ) const
cv::DescriptorMatcher::knnMatch	features2d/features2d.hpp	/^    void knnMatch( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
cv::DescriptorMatcher::knnMatchImpl	features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	p	class:cv::DescriptorMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
cv::DescriptorMatcher::match	features2d/features2d.hpp	/^    void match( const Mat& queryDescriptors, const Mat& trainDescriptors,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, const Mat& trainDescriptors, vector<DMatch>& matches, const Mat& mask=Mat() ) const
cv::DescriptorMatcher::match	features2d/features2d.hpp	/^    void match( const Mat& queryDescriptors, vector<DMatch>& matches,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, vector<DMatch>& matches, const vector<Mat>& masks=vector<Mat>() )
cv::DescriptorMatcher::radiusMatch	features2d/features2d.hpp	/^    void radiusMatch( const Mat& queryDescriptors, const Mat& trainDescriptors,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, const Mat& trainDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const Mat& mask=Mat(), bool compactResult=false ) const
cv::DescriptorMatcher::radiusMatch	features2d/features2d.hpp	/^    void radiusMatch( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
cv::DescriptorMatcher::radiusMatchImpl	features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance,$/;"	p	class:cv::DescriptorMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
cv::DescriptorMatcher::read	features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const FileNode& )
cv::DescriptorMatcher::train	features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::DescriptorMatcher	access:public	signature:()
cv::DescriptorMatcher::trainDescCollection	features2d/features2d.hpp	/^    vector<Mat> trainDescCollection;$/;"	m	class:cv::DescriptorMatcher	access:protected
cv::DescriptorMatcher::write	features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( FileStorage& ) const
cv::DescriptorMatcher::~DescriptorMatcher	features2d/features2d.hpp	/^    virtual ~DescriptorMatcher();$/;"	p	class:cv::DescriptorMatcher	access:public	signature:()
cv::DrawMatchesFlags	features2d/features2d.hpp	/^struct CV_EXPORTS DrawMatchesFlags$/;"	s	namespace:cv
cv::DrawMatchesFlags::DEFAULT	features2d/features2d.hpp	/^    enum{ DEFAULT = 0, \/\/ Output image matrix will be created (Mat::create),$/;"	e	enum:cv::DrawMatchesFlags::__anon194
cv::DrawMatchesFlags::DRAW_OVER_OUTIMG	features2d/features2d.hpp	/^          DRAW_OVER_OUTIMG = 1, \/\/ Output image matrix will not be created (Mat::create).$/;"	e	enum:cv::DrawMatchesFlags::__anon194
cv::DrawMatchesFlags::DRAW_RICH_KEYPOINTS	features2d/features2d.hpp	/^          DRAW_RICH_KEYPOINTS = 4 \/\/ For each keypoint the circle around keypoint with keypoint size and$/;"	e	enum:cv::DrawMatchesFlags::__anon194
cv::DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS	features2d/features2d.hpp	/^          NOT_DRAW_SINGLE_POINTS = 2, \/\/ Single keypoints will not be drawn.$/;"	e	enum:cv::DrawMatchesFlags::__anon194
cv::DynamicAdaptedFeatureDetector	features2d/features2d.hpp	/^class CV_EXPORTS DynamicAdaptedFeatureDetector: public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
cv::DynamicAdaptedFeatureDetector::DynamicAdaptedFeatureDetector	features2d/features2d.hpp	/^	DynamicAdaptedFeatureDetector(const DynamicAdaptedFeatureDetector&);$/;"	p	class:cv::DynamicAdaptedFeatureDetector	access:private	signature:(const DynamicAdaptedFeatureDetector&)
cv::DynamicAdaptedFeatureDetector::DynamicAdaptedFeatureDetector	features2d/features2d.hpp	/^    DynamicAdaptedFeatureDetector( const Ptr<AdjusterAdapter>& adjaster, int min_features=400, int max_features=500, int max_iters=5 );$/;"	p	class:cv::DynamicAdaptedFeatureDetector	access:public	signature:( const Ptr<AdjusterAdapter>& adjaster, int min_features=400, int max_features=500, int max_iters=5 )
cv::DynamicAdaptedFeatureDetector::adjuster_	features2d/features2d.hpp	/^    const Ptr<AdjusterAdapter> adjuster_;$/;"	m	class:cv::DynamicAdaptedFeatureDetector	access:private
cv::DynamicAdaptedFeatureDetector::detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::DynamicAdaptedFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::DynamicAdaptedFeatureDetector::empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::DynamicAdaptedFeatureDetector	access:public	signature:() const
cv::DynamicAdaptedFeatureDetector::escape_iters_	features2d/features2d.hpp	/^    int escape_iters_;$/;"	m	class:cv::DynamicAdaptedFeatureDetector	access:private
cv::DynamicAdaptedFeatureDetector::max_features_	features2d/features2d.hpp	/^    int min_features_, max_features_;$/;"	m	class:cv::DynamicAdaptedFeatureDetector	access:private
cv::DynamicAdaptedFeatureDetector::min_features_	features2d/features2d.hpp	/^    int min_features_, max_features_;$/;"	m	class:cv::DynamicAdaptedFeatureDetector	access:private
cv::DynamicAdaptedFeatureDetector::operator =	features2d/features2d.hpp	/^	DynamicAdaptedFeatureDetector& operator=(const DynamicAdaptedFeatureDetector&);$/;"	p	class:cv::DynamicAdaptedFeatureDetector	access:private	signature:(const DynamicAdaptedFeatureDetector&)
cv::EMD	imgproc/imgproc.hpp	/^CV_EXPORTS float EMD( InputArray signature1, InputArray signature2,$/;"	p	namespace:cv	signature:( InputArray signature1, InputArray signature2, int distType, InputArray cost=noArray(), float* lowerBound=0, OutputArray flow=noArray() )
cv::EMParams	ml/ml.hpp	/^typedef CvEMParams EMParams;$/;"	t	namespace:cv
cv::ERTree	ml/ml.hpp	/^typedef CvForestERTree ERTree;$/;"	t	namespace:cv
cv::ERTreeTRainData	ml/ml.hpp	/^typedef CvERTreeTrainData ERTreeTRainData;$/;"	t	namespace:cv
cv::ERTrees	ml/ml.hpp	/^typedef CvERTrees ERTrees;$/;"	t	namespace:cv
cv::EVENT_FLAG_ALTKEY	highgui/highgui.hpp	/^    EVENT_FLAG_ALTKEY    =32$/;"	e	enum:cv::__anon161
cv::EVENT_FLAG_CTRLKEY	highgui/highgui.hpp	/^    EVENT_FLAG_CTRLKEY   =8,$/;"	e	enum:cv::__anon161
cv::EVENT_FLAG_LBUTTON	highgui/highgui.hpp	/^    EVENT_FLAG_LBUTTON   =1,$/;"	e	enum:cv::__anon161
cv::EVENT_FLAG_MBUTTON	highgui/highgui.hpp	/^    EVENT_FLAG_MBUTTON   =4,$/;"	e	enum:cv::__anon161
cv::EVENT_FLAG_RBUTTON	highgui/highgui.hpp	/^    EVENT_FLAG_RBUTTON   =2,$/;"	e	enum:cv::__anon161
cv::EVENT_FLAG_SHIFTKEY	highgui/highgui.hpp	/^    EVENT_FLAG_SHIFTKEY  =16,$/;"	e	enum:cv::__anon161
cv::EVENT_LBUTTONDBLCLK	highgui/highgui.hpp	/^    EVENT_LBUTTONDBLCLK  =7,$/;"	e	enum:cv::__anon160
cv::EVENT_LBUTTONDOWN	highgui/highgui.hpp	/^    EVENT_LBUTTONDOWN    =1,$/;"	e	enum:cv::__anon160
cv::EVENT_LBUTTONUP	highgui/highgui.hpp	/^    EVENT_LBUTTONUP      =4,$/;"	e	enum:cv::__anon160
cv::EVENT_MBUTTONDBLCLK	highgui/highgui.hpp	/^    EVENT_MBUTTONDBLCLK  =9$/;"	e	enum:cv::__anon160
cv::EVENT_MBUTTONDOWN	highgui/highgui.hpp	/^    EVENT_MBUTTONDOWN    =3,$/;"	e	enum:cv::__anon160
cv::EVENT_MBUTTONUP	highgui/highgui.hpp	/^    EVENT_MBUTTONUP      =6,$/;"	e	enum:cv::__anon160
cv::EVENT_MOUSEMOVE	highgui/highgui.hpp	/^    EVENT_MOUSEMOVE      =0,$/;"	e	enum:cv::__anon160
cv::EVENT_RBUTTONDBLCLK	highgui/highgui.hpp	/^    EVENT_RBUTTONDBLCLK  =8,$/;"	e	enum:cv::__anon160
cv::EVENT_RBUTTONDOWN	highgui/highgui.hpp	/^    EVENT_RBUTTONDOWN    =2,$/;"	e	enum:cv::__anon160
cv::EVENT_RBUTTONUP	highgui/highgui.hpp	/^    EVENT_RBUTTONUP      =5,$/;"	e	enum:cv::__anon160
cv::ErrorCallback	core/core.hpp	/^typedef int (CV_CDECL *ErrorCallback)( int status, const char* func_name,$/;"	t	namespace:cv
cv::Exception	core/core.hpp	/^class CV_EXPORTS Exception : public std::exception$/;"	c	namespace:cv	inherits:std::exception
cv::Exception::Exception	core/core.hpp	/^    Exception();$/;"	p	class:cv::Exception	access:public	signature:()
cv::Exception::Exception	core/core.hpp	/^    Exception(int _code, const string& _err, const string& _func, const string& _file, int _line);$/;"	p	class:cv::Exception	access:public	signature:(int _code, const string& _err, const string& _func, const string& _file, int _line)
cv::Exception::code	core/core.hpp	/^    int code; \/\/\/< error code @see CVStatus$/;"	m	class:cv::Exception	access:public
cv::Exception::err	core/core.hpp	/^    string err; \/\/\/< error description$/;"	m	class:cv::Exception	access:public
cv::Exception::file	core/core.hpp	/^    string file; \/\/\/< source file name where the error has occured$/;"	m	class:cv::Exception	access:public
cv::Exception::formatMessage	core/core.hpp	/^    void formatMessage();$/;"	p	class:cv::Exception	access:public	signature:()
cv::Exception::func	core/core.hpp	/^    string func; \/\/\/< function name. Available only when the compiler supports __func__ macro$/;"	m	class:cv::Exception	access:public
cv::Exception::line	core/core.hpp	/^    int line; \/\/\/< line number in the source file where the error has occured $/;"	m	class:cv::Exception	access:public
cv::Exception::msg	core/core.hpp	/^    string msg; \/\/\/< the formatted error message$/;"	m	class:cv::Exception	access:public
cv::Exception::what	core/core.hpp	/^    virtual const char *what() const throw();$/;"	p	class:cv::Exception	access:public	signature:() const
cv::Exception::~Exception	core/core.hpp	/^    virtual ~Exception() throw();$/;"	p	class:cv::Exception	access:public	signature:()
cv::ExpectationMaximization	ml/ml.hpp	/^typedef CvEM ExpectationMaximization;$/;"	t	namespace:cv
cv::FAST	features2d/features2d.hpp	/^CV_EXPORTS void FAST( const Mat& image, CV_OUT vector<KeyPoint>& keypoints,$/;"	p	namespace:cv	signature:( const Mat& image, CV_OUT vector<KeyPoint>& keypoints, int threshold, bool nonmaxSupression=true )
cv::FLOODFILL_FIXED_RANGE	imgproc/imgproc.hpp	/^enum { FLOODFILL_FIXED_RANGE = 1 << 16, FLOODFILL_MASK_ONLY = 1 << 17 };$/;"	e	enum:cv::__anon22
cv::FLOODFILL_MASK_ONLY	imgproc/imgproc.hpp	/^enum { FLOODFILL_FIXED_RANGE = 1 << 16, FLOODFILL_MASK_ONLY = 1 << 17 };$/;"	e	enum:cv::__anon22
cv::FM_7POINT	calib3d/calib3d.hpp	/^    FM_7POINT = CV_FM_7POINT, \/\/!< 7-point algorithm$/;"	e	enum:cv::__anon91
cv::FM_8POINT	calib3d/calib3d.hpp	/^    FM_8POINT = CV_FM_8POINT, \/\/!< 8-point algorithm$/;"	e	enum:cv::__anon91
cv::FM_LMEDS	calib3d/calib3d.hpp	/^    FM_LMEDS = CV_FM_LMEDS,  \/\/!< least-median algorithm$/;"	e	enum:cv::__anon91
cv::FM_RANSAC	calib3d/calib3d.hpp	/^    FM_RANSAC = CV_FM_RANSAC  \/\/!< RANSAC algorithm$/;"	e	enum:cv::__anon91
cv::FONT_HERSHEY_COMPLEX	core/core.hpp	/^    FONT_HERSHEY_COMPLEX = 3,$/;"	e	enum:cv::__anon144
cv::FONT_HERSHEY_COMPLEX_SMALL	core/core.hpp	/^    FONT_HERSHEY_COMPLEX_SMALL = 5,$/;"	e	enum:cv::__anon144
cv::FONT_HERSHEY_DUPLEX	core/core.hpp	/^    FONT_HERSHEY_DUPLEX = 2,$/;"	e	enum:cv::__anon144
cv::FONT_HERSHEY_PLAIN	core/core.hpp	/^    FONT_HERSHEY_PLAIN = 1,$/;"	e	enum:cv::__anon144
cv::FONT_HERSHEY_SCRIPT_COMPLEX	core/core.hpp	/^    FONT_HERSHEY_SCRIPT_COMPLEX = 7,$/;"	e	enum:cv::__anon144
cv::FONT_HERSHEY_SCRIPT_SIMPLEX	core/core.hpp	/^    FONT_HERSHEY_SCRIPT_SIMPLEX = 6,$/;"	e	enum:cv::__anon144
cv::FONT_HERSHEY_SIMPLEX	core/core.hpp	/^    FONT_HERSHEY_SIMPLEX = 0,$/;"	e	enum:cv::__anon144
cv::FONT_HERSHEY_TRIPLEX	core/core.hpp	/^    FONT_HERSHEY_TRIPLEX = 4,$/;"	e	enum:cv::__anon144
cv::FONT_ITALIC	core/core.hpp	/^    FONT_ITALIC = 16$/;"	e	enum:cv::__anon144
cv::FastAdjuster	features2d/features2d.hpp	/^class CV_EXPORTS FastAdjuster: public AdjusterAdapter$/;"	c	namespace:cv	inherits:AdjusterAdapter
cv::FastAdjuster::FastAdjuster	features2d/features2d.hpp	/^    FastAdjuster(int init_thresh=20, bool nonmax=true, int min_thresh=1, int max_thresh=200);$/;"	p	class:cv::FastAdjuster	access:public	signature:(int init_thresh=20, bool nonmax=true, int min_thresh=1, int max_thresh=200)
cv::FastAdjuster::clone	features2d/features2d.hpp	/^    virtual Ptr<AdjusterAdapter> clone() const;$/;"	p	class:cv::FastAdjuster	access:public	signature:() const
cv::FastAdjuster::detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::FastAdjuster	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::FastAdjuster::good	features2d/features2d.hpp	/^    virtual bool good() const;$/;"	p	class:cv::FastAdjuster	access:public	signature:() const
cv::FastAdjuster::init_thresh_	features2d/features2d.hpp	/^    int init_thresh_, min_thresh_, max_thresh_;$/;"	m	class:cv::FastAdjuster	access:protected
cv::FastAdjuster::max_thresh_	features2d/features2d.hpp	/^    int init_thresh_, min_thresh_, max_thresh_;$/;"	m	class:cv::FastAdjuster	access:protected
cv::FastAdjuster::min_thresh_	features2d/features2d.hpp	/^    int init_thresh_, min_thresh_, max_thresh_;$/;"	m	class:cv::FastAdjuster	access:protected
cv::FastAdjuster::nonmax_	features2d/features2d.hpp	/^    bool nonmax_;$/;"	m	class:cv::FastAdjuster	access:protected
cv::FastAdjuster::thresh_	features2d/features2d.hpp	/^    int thresh_;$/;"	m	class:cv::FastAdjuster	access:protected
cv::FastAdjuster::tooFew	features2d/features2d.hpp	/^    virtual void tooFew(int min, int n_detected);$/;"	p	class:cv::FastAdjuster	access:public	signature:(int min, int n_detected)
cv::FastAdjuster::tooMany	features2d/features2d.hpp	/^    virtual void tooMany(int max, int n_detected);$/;"	p	class:cv::FastAdjuster	access:public	signature:(int max, int n_detected)
cv::FastFeatureDetector	features2d/features2d.hpp	/^class CV_EXPORTS FastFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
cv::FastFeatureDetector::FastFeatureDetector	features2d/features2d.hpp	/^    FastFeatureDetector( int threshold=10, bool nonmaxSuppression=true );$/;"	p	class:cv::FastFeatureDetector	access:public	signature:( int threshold=10, bool nonmaxSuppression=true )
cv::FastFeatureDetector::detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::FastFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::FastFeatureDetector::nonmaxSuppression	features2d/features2d.hpp	/^    bool nonmaxSuppression;$/;"	m	class:cv::FastFeatureDetector	access:protected
cv::FastFeatureDetector::read	features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::FastFeatureDetector	access:public	signature:( const FileNode& fn )
cv::FastFeatureDetector::threshold	features2d/features2d.hpp	/^    int threshold;$/;"	m	class:cv::FastFeatureDetector	access:protected
cv::FastFeatureDetector::write	features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::FastFeatureDetector	access:public	signature:( FileStorage& fs ) const
cv::FeatureDetector	features2d/features2d.hpp	/^class CV_EXPORTS FeatureDetector$/;"	c	namespace:cv
cv::FeatureDetector::create	features2d/features2d.hpp	/^    static Ptr<FeatureDetector> create( const string& detectorType );$/;"	p	class:cv::FeatureDetector	access:public	signature:( const string& detectorType )
cv::FeatureDetector::detect	features2d/features2d.hpp	/^    void detect( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::FeatureDetector	access:public	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::FeatureDetector::detect	features2d/features2d.hpp	/^    void detect( const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints, const vector<Mat>& masks=vector<Mat>() ) const;$/;"	p	class:cv::FeatureDetector	access:public	signature:( const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints, const vector<Mat>& masks=vector<Mat>() ) const
cv::FeatureDetector::detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const = 0;$/;"	p	class:cv::FeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::FeatureDetector::empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::FeatureDetector	access:public	signature:() const
cv::FeatureDetector::read	features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::FeatureDetector	access:public	signature:( const FileNode& )
cv::FeatureDetector::removeInvalidPoints	features2d/features2d.hpp	/^    static void removeInvalidPoints( const Mat& mask, vector<KeyPoint>& keypoints );$/;"	p	class:cv::FeatureDetector	access:protected	signature:( const Mat& mask, vector<KeyPoint>& keypoints )
cv::FeatureDetector::write	features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::FeatureDetector	access:public	signature:( FileStorage& ) const
cv::FeatureDetector::~FeatureDetector	features2d/features2d.hpp	/^    virtual ~FeatureDetector();$/;"	p	class:cv::FeatureDetector	access:public	signature:()
cv::FeatureEvaluator	objdetect/objdetect.hpp	/^class CV_EXPORTS FeatureEvaluator$/;"	c	namespace:cv
cv::FeatureEvaluator::HAAR	objdetect/objdetect.hpp	/^    enum { HAAR = 0, LBP = 1 };$/;"	e	enum:cv::FeatureEvaluator::__anon198
cv::FeatureEvaluator::LBP	objdetect/objdetect.hpp	/^    enum { HAAR = 0, LBP = 1 };$/;"	e	enum:cv::FeatureEvaluator::__anon198
cv::FeatureEvaluator::calcCat	objdetect/objdetect.hpp	/^    virtual int calcCat(int featureIdx) const;$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(int featureIdx) const
cv::FeatureEvaluator::calcOrd	objdetect/objdetect.hpp	/^    virtual double calcOrd(int featureIdx) const;$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(int featureIdx) const
cv::FeatureEvaluator::clone	objdetect/objdetect.hpp	/^    virtual Ptr<FeatureEvaluator> clone() const;$/;"	p	class:cv::FeatureEvaluator	access:public	signature:() const
cv::FeatureEvaluator::create	objdetect/objdetect.hpp	/^    static Ptr<FeatureEvaluator> create(int type);$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(int type)
cv::FeatureEvaluator::getFeatureType	objdetect/objdetect.hpp	/^    virtual int getFeatureType() const;$/;"	p	class:cv::FeatureEvaluator	access:public	signature:() const
cv::FeatureEvaluator::read	objdetect/objdetect.hpp	/^    virtual bool read(const FileNode& node);$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(const FileNode& node)
cv::FeatureEvaluator::setImage	objdetect/objdetect.hpp	/^    virtual bool setImage(const Mat&, Size origWinSize);$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(const Mat&, Size origWinSize)
cv::FeatureEvaluator::setWindow	objdetect/objdetect.hpp	/^    virtual bool setWindow(Point p);$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(Point p)
cv::FeatureEvaluator::~FeatureEvaluator	objdetect/objdetect.hpp	/^    virtual ~FeatureEvaluator();$/;"	p	class:cv::FeatureEvaluator	access:public	signature:()
cv::FernClassifier	features2d/features2d.hpp	/^class CV_EXPORTS FernClassifier$/;"	c	namespace:cv
cv::FernClassifier::COMPRESSION_NONE	features2d/features2d.hpp	/^        COMPRESSION_NONE = 0,$/;"	e	enum:cv::FernClassifier::__anon193
cv::FernClassifier::COMPRESSION_PCA	features2d/features2d.hpp	/^        COMPRESSION_PCA = 2,$/;"	e	enum:cv::FernClassifier::__anon193
cv::FernClassifier::COMPRESSION_RANDOM_PROJ	features2d/features2d.hpp	/^        COMPRESSION_RANDOM_PROJ = 1,$/;"	e	enum:cv::FernClassifier::__anon193
cv::FernClassifier::DEFAULT_COMPRESSION_METHOD	features2d/features2d.hpp	/^        DEFAULT_COMPRESSION_METHOD = COMPRESSION_NONE$/;"	e	enum:cv::FernClassifier::__anon193
cv::FernClassifier::DEFAULT_SIGNATURE_SIZE	features2d/features2d.hpp	/^        DEFAULT_SIGNATURE_SIZE = 176,$/;"	e	enum:cv::FernClassifier::__anon193
cv::FernClassifier::DEFAULT_STRUCTS	features2d/features2d.hpp	/^        DEFAULT_STRUCTS = 50,$/;"	e	enum:cv::FernClassifier::__anon193
cv::FernClassifier::DEFAULT_STRUCT_SIZE	features2d/features2d.hpp	/^        DEFAULT_STRUCT_SIZE = 9,$/;"	e	enum:cv::FernClassifier::__anon193
cv::FernClassifier::DEFAULT_VIEWS	features2d/features2d.hpp	/^        DEFAULT_VIEWS = 5000,$/;"	e	enum:cv::FernClassifier::__anon193
cv::FernClassifier::Feature	features2d/features2d.hpp	/^    struct Feature$/;"	s	class:cv::FernClassifier	access:public
cv::FernClassifier::Feature::Feature	features2d/features2d.hpp	/^        Feature() : x1(0), y1(0), x2(0), y2(0) {}$/;"	f	struct:cv::FernClassifier::Feature	access:public	signature:()
cv::FernClassifier::Feature::Feature	features2d/features2d.hpp	/^        Feature(int _x1, int _y1, int _x2, int _y2)$/;"	f	struct:cv::FernClassifier::Feature	access:public	signature:(int _x1, int _y1, int _x2, int _y2)
cv::FernClassifier::Feature::operator ()	features2d/features2d.hpp	/^        template<typename _Tp> bool operator ()(const Mat_<_Tp>& patch) const$/;"	f	struct:cv::FernClassifier::Feature	access:public	signature:(const Mat_<_Tp>& patch) const
cv::FernClassifier::Feature::x1	features2d/features2d.hpp	/^        uchar x1, y1, x2, y2;$/;"	m	struct:cv::FernClassifier::Feature	access:public
cv::FernClassifier::Feature::x2	features2d/features2d.hpp	/^        uchar x1, y1, x2, y2;$/;"	m	struct:cv::FernClassifier::Feature	access:public
cv::FernClassifier::Feature::y1	features2d/features2d.hpp	/^        uchar x1, y1, x2, y2;$/;"	m	struct:cv::FernClassifier::Feature	access:public
cv::FernClassifier::Feature::y2	features2d/features2d.hpp	/^        uchar x1, y1, x2, y2;$/;"	m	struct:cv::FernClassifier::Feature	access:public
cv::FernClassifier::FernClassifier	features2d/features2d.hpp	/^    FernClassifier();$/;"	p	class:cv::FernClassifier	access:public	signature:()
cv::FernClassifier::FernClassifier	features2d/features2d.hpp	/^    FernClassifier(const FileNode& node);$/;"	p	class:cv::FernClassifier	access:public	signature:(const FileNode& node)
cv::FernClassifier::FernClassifier	features2d/features2d.hpp	/^    FernClassifier(const vector<vector<Point2f> >& points,$/;"	p	class:cv::FernClassifier	access:public	signature:(const vector<vector<Point2f> >& points, const vector<Mat>& refimgs, const vector<vector<int> >& labels=vector<vector<int> >(), int _nclasses=0, int _patchSize=PATCH_SIZE, int _signatureSize=DEFAULT_SIGNATURE_SIZE, int _nstructs=DEFAULT_STRUCTS, int _structSize=DEFAULT_STRUCT_SIZE, int _nviews=DEFAULT_VIEWS, int _compressionMethod=COMPRESSION_NONE, const PatchGenerator& patchGenerator=PatchGenerator())
cv::FernClassifier::PATCH_SIZE	features2d/features2d.hpp	/^        PATCH_SIZE = 31,$/;"	e	enum:cv::FernClassifier::__anon193
cv::FernClassifier::classCounters	features2d/features2d.hpp	/^    vector<int> classCounters;$/;"	m	class:cv::FernClassifier	access:protected
cv::FernClassifier::clear	features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::FernClassifier	access:public	signature:()
cv::FernClassifier::compressionMethod	features2d/features2d.hpp	/^    int compressionMethod;$/;"	m	class:cv::FernClassifier	access:protected
cv::FernClassifier::empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
cv::FernClassifier::features	features2d/features2d.hpp	/^    vector<Feature> features;$/;"	m	class:cv::FernClassifier	access:protected
cv::FernClassifier::finalize	features2d/features2d.hpp	/^    virtual void finalize(RNG& rng);$/;"	p	class:cv::FernClassifier	access:protected	signature:(RNG& rng)
cv::FernClassifier::getClassCount	features2d/features2d.hpp	/^    int getClassCount() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
cv::FernClassifier::getCompressionMethod	features2d/features2d.hpp	/^    int getCompressionMethod() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
cv::FernClassifier::getLeaf	features2d/features2d.hpp	/^    virtual int getLeaf(int fidx, const Mat& patch) const;$/;"	p	class:cv::FernClassifier	access:protected	signature:(int fidx, const Mat& patch) const
cv::FernClassifier::getPatchSize	features2d/features2d.hpp	/^    Size getPatchSize() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
cv::FernClassifier::getSignatureSize	features2d/features2d.hpp	/^    int getSignatureSize() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
cv::FernClassifier::getStructCount	features2d/features2d.hpp	/^    int getStructCount() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
cv::FernClassifier::getStructSize	features2d/features2d.hpp	/^    int getStructSize() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
cv::FernClassifier::leavesPerStruct	features2d/features2d.hpp	/^    int leavesPerStruct;$/;"	m	class:cv::FernClassifier	access:protected
cv::FernClassifier::nclasses	features2d/features2d.hpp	/^    int nclasses;$/;"	m	class:cv::FernClassifier	access:protected
cv::FernClassifier::nstructs	features2d/features2d.hpp	/^    int nstructs;$/;"	m	class:cv::FernClassifier	access:protected
cv::FernClassifier::operator ()	features2d/features2d.hpp	/^    virtual int operator()(const Mat& img, Point2f kpt, vector<float>& signature) const;$/;"	p	class:cv::FernClassifier	access:public	signature:(const Mat& img, Point2f kpt, vector<float>& signature) const
cv::FernClassifier::operator ()	features2d/features2d.hpp	/^    virtual int operator()(const Mat& patch, vector<float>& signature) const;$/;"	p	class:cv::FernClassifier	access:public	signature:(const Mat& patch, vector<float>& signature) const
cv::FernClassifier::patchSize	features2d/features2d.hpp	/^    Size patchSize;$/;"	m	class:cv::FernClassifier	access:protected
cv::FernClassifier::posteriors	features2d/features2d.hpp	/^    vector<float> posteriors;$/;"	m	class:cv::FernClassifier	access:protected
cv::FernClassifier::prepare	features2d/features2d.hpp	/^    virtual void prepare(int _nclasses, int _patchSize, int _signatureSize,$/;"	p	class:cv::FernClassifier	access:protected	signature:(int _nclasses, int _patchSize, int _signatureSize, int _nstructs, int _structSize, int _nviews, int _compressionMethod)
cv::FernClassifier::read	features2d/features2d.hpp	/^    virtual void read(const FileNode& n);$/;"	p	class:cv::FernClassifier	access:public	signature:(const FileNode& n)
cv::FernClassifier::setVerbose	features2d/features2d.hpp	/^    void setVerbose(bool verbose);$/;"	p	class:cv::FernClassifier	access:public	signature:(bool verbose)
cv::FernClassifier::signatureSize	features2d/features2d.hpp	/^    int signatureSize;$/;"	m	class:cv::FernClassifier	access:protected
cv::FernClassifier::structSize	features2d/features2d.hpp	/^    int structSize;$/;"	m	class:cv::FernClassifier	access:protected
cv::FernClassifier::train	features2d/features2d.hpp	/^    virtual void train(const vector<vector<Point2f> >& points,$/;"	p	class:cv::FernClassifier	access:public	signature:(const vector<vector<Point2f> >& points, const vector<Mat>& refimgs, const vector<vector<int> >& labels=vector<vector<int> >(), int _nclasses=0, int _patchSize=PATCH_SIZE, int _signatureSize=DEFAULT_SIGNATURE_SIZE, int _nstructs=DEFAULT_STRUCTS, int _structSize=DEFAULT_STRUCT_SIZE, int _nviews=DEFAULT_VIEWS, int _compressionMethod=COMPRESSION_NONE, const PatchGenerator& patchGenerator=PatchGenerator())
cv::FernClassifier::trainFromSingleView	features2d/features2d.hpp	/^    virtual void trainFromSingleView(const Mat& image,$/;"	p	class:cv::FernClassifier	access:public	signature:(const Mat& image, const vector<KeyPoint>& keypoints, int _patchSize=PATCH_SIZE, int _signatureSize=DEFAULT_SIGNATURE_SIZE, int _nstructs=DEFAULT_STRUCTS, int _structSize=DEFAULT_STRUCT_SIZE, int _nviews=DEFAULT_VIEWS, int _compressionMethod=COMPRESSION_NONE, const PatchGenerator& patchGenerator=PatchGenerator())
cv::FernClassifier::verbose	features2d/features2d.hpp	/^    bool verbose;$/;"	m	class:cv::FernClassifier	access:protected
cv::FernClassifier::write	features2d/features2d.hpp	/^    virtual void write(FileStorage& fs, const String& name=String()) const;$/;"	p	class:cv::FernClassifier	access:public	signature:(FileStorage& fs, const String& name=String()) const
cv::FernClassifier::~FernClassifier	features2d/features2d.hpp	/^    virtual ~FernClassifier();$/;"	p	class:cv::FernClassifier	access:public	signature:()
cv::FernDescriptorMatch	features2d/features2d.hpp	/^typedef FernDescriptorMatcher FernDescriptorMatch;$/;"	t	namespace:cv
cv::FernDescriptorMatcher	features2d/features2d.hpp	/^class CV_EXPORTS FernDescriptorMatcher : public GenericDescriptorMatcher$/;"	c	namespace:cv	inherits:GenericDescriptorMatcher
cv::FernDescriptorMatcher::FernDescriptorMatcher	features2d/features2d.hpp	/^    FernDescriptorMatcher( const Params& params=Params() );$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:( const Params& params=Params() )
cv::FernDescriptorMatcher::Params	features2d/features2d.hpp	/^    class CV_EXPORTS Params$/;"	c	class:cv::FernDescriptorMatcher	access:public
cv::FernDescriptorMatcher::Params::Params	features2d/features2d.hpp	/^        Params( const string& filename );$/;"	p	class:cv::FernDescriptorMatcher::Params	access:public	signature:( const string& filename )
cv::FernDescriptorMatcher::Params::Params	features2d/features2d.hpp	/^        Params( int nclasses=0,$/;"	p	class:cv::FernDescriptorMatcher::Params	access:public	signature:( int nclasses=0, int patchSize=FernClassifier::PATCH_SIZE, int signatureSize=FernClassifier::DEFAULT_SIGNATURE_SIZE, int nstructs=FernClassifier::DEFAULT_STRUCTS, int structSize=FernClassifier::DEFAULT_STRUCT_SIZE, int nviews=FernClassifier::DEFAULT_VIEWS, int compressionMethod=FernClassifier::COMPRESSION_NONE, const PatchGenerator& patchGenerator=PatchGenerator() )
cv::FernDescriptorMatcher::Params::compressionMethod	features2d/features2d.hpp	/^        int compressionMethod;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
cv::FernDescriptorMatcher::Params::filename	features2d/features2d.hpp	/^        string filename;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
cv::FernDescriptorMatcher::Params::nclasses	features2d/features2d.hpp	/^        int nclasses;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
cv::FernDescriptorMatcher::Params::nstructs	features2d/features2d.hpp	/^        int nstructs;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
cv::FernDescriptorMatcher::Params::nviews	features2d/features2d.hpp	/^        int nviews;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
cv::FernDescriptorMatcher::Params::patchGenerator	features2d/features2d.hpp	/^        PatchGenerator patchGenerator;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
cv::FernDescriptorMatcher::Params::patchSize	features2d/features2d.hpp	/^        int patchSize;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
cv::FernDescriptorMatcher::Params::signatureSize	features2d/features2d.hpp	/^        int signatureSize;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
cv::FernDescriptorMatcher::Params::structSize	features2d/features2d.hpp	/^        int structSize;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
cv::FernDescriptorMatcher::calcBestProbAndMatchIdx	features2d/features2d.hpp	/^    void calcBestProbAndMatchIdx( const Mat& image, const Point2f& pt,$/;"	p	class:cv::FernDescriptorMatcher	access:protected	signature:( const Mat& image, const Point2f& pt, float& bestProb, int& bestMatchIdx, vector<float>& signature )
cv::FernDescriptorMatcher::classifier	features2d/features2d.hpp	/^    Ptr<FernClassifier> classifier;$/;"	m	class:cv::FernDescriptorMatcher	access:protected
cv::FernDescriptorMatcher::clear	features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:()
cv::FernDescriptorMatcher::clone	features2d/features2d.hpp	/^    virtual Ptr<GenericDescriptorMatcher> clone( bool emptyTrainData=false ) const;$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:( bool emptyTrainData=false ) const
cv::FernDescriptorMatcher::empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:() const
cv::FernDescriptorMatcher::isMaskSupported	features2d/features2d.hpp	/^    virtual bool isMaskSupported();$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:()
cv::FernDescriptorMatcher::knnMatchImpl	features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::FernDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
cv::FernDescriptorMatcher::params	features2d/features2d.hpp	/^    Params params;$/;"	m	class:cv::FernDescriptorMatcher	access:protected
cv::FernDescriptorMatcher::prevTrainCount	features2d/features2d.hpp	/^    int prevTrainCount;$/;"	m	class:cv::FernDescriptorMatcher	access:protected
cv::FernDescriptorMatcher::radiusMatchImpl	features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::FernDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
cv::FernDescriptorMatcher::read	features2d/features2d.hpp	/^    virtual void read( const FileNode &fn );$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:( const FileNode &fn )
cv::FernDescriptorMatcher::train	features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:()
cv::FernDescriptorMatcher::trainFernClassifier	features2d/features2d.hpp	/^    void trainFernClassifier();$/;"	p	class:cv::FernDescriptorMatcher	access:protected	signature:()
cv::FernDescriptorMatcher::write	features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:( FileStorage& fs ) const
cv::FernDescriptorMatcher::~FernDescriptorMatcher	features2d/features2d.hpp	/^    virtual ~FernDescriptorMatcher();$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:()
cv::FileNode	core/core.hpp	/^class CV_EXPORTS FileNode;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::FileNode	core/core.hpp	/^class CV_EXPORTS_W_SIMPLE FileNode$/;"	c	namespace:cv
cv::FileNode::EMPTY	core/core.hpp	/^        EMPTY=32, \/\/!< empty structure (sequence or mapping)$/;"	e	enum:cv::FileNode::__anon149
cv::FileNode::FLOAT	core/core.hpp	/^        FLOAT=REAL, \/\/!< synonym or REAL$/;"	e	enum:cv::FileNode::__anon149
cv::FileNode::FLOW	core/core.hpp	/^        FLOW=8, \/\/!< compact representation of a sequence or mapping. Used only by YAML writer$/;"	e	enum:cv::FileNode::__anon149
cv::FileNode::FileNode	core/core.hpp	/^    CV_WRAP FileNode();$/;"	p	class:cv::FileNode	access:public	signature:()
cv::FileNode::FileNode	core/core.hpp	/^    FileNode(const CvFileStorage* fs, const CvFileNode* node);$/;"	p	class:cv::FileNode	access:public	signature:(const CvFileStorage* fs, const CvFileNode* node)
cv::FileNode::FileNode	core/core.hpp	/^    FileNode(const FileNode& node);$/;"	p	class:cv::FileNode	access:public	signature:(const FileNode& node)
cv::FileNode::FileNode	core/operations.hpp	/^inline FileNode::FileNode() : fs(0), node(0) {}$/;"	f	class:cv::FileNode	signature:()
cv::FileNode::FileNode	core/operations.hpp	/^inline FileNode::FileNode(const CvFileStorage* _fs, const CvFileNode* _node)$/;"	f	class:cv::FileNode	signature:(const CvFileStorage* _fs, const CvFileNode* _node)
cv::FileNode::FileNode	core/operations.hpp	/^inline FileNode::FileNode(const FileNode& _node) : fs(_node.fs), node(_node.node) {}$/;"	f	class:cv::FileNode	signature:(const FileNode& _node)
cv::FileNode::INT	core/core.hpp	/^        INT=1, \/\/!< an integer$/;"	e	enum:cv::FileNode::__anon149
cv::FileNode::MAP	core/core.hpp	/^        MAP=6, \/\/!< mapping$/;"	e	enum:cv::FileNode::__anon149
cv::FileNode::NAMED	core/core.hpp	/^        NAMED=64 \/\/!< the node has a name (i.e. it is element of a mapping)$/;"	e	enum:cv::FileNode::__anon149
cv::FileNode::NONE	core/core.hpp	/^        NONE=0, \/\/!< empty node$/;"	e	enum:cv::FileNode::__anon149
cv::FileNode::REAL	core/core.hpp	/^        REAL=2, \/\/!< floating-point number$/;"	e	enum:cv::FileNode::__anon149
cv::FileNode::REF	core/core.hpp	/^        REF=4, \/\/!< integer of size size_t. Typically used for storing complex dynamic structures where some elements reference the others $/;"	e	enum:cv::FileNode::__anon149
cv::FileNode::SEQ	core/core.hpp	/^        SEQ=5, \/\/!< sequence$/;"	e	enum:cv::FileNode::__anon149
cv::FileNode::STR	core/core.hpp	/^        STR=3, \/\/!< text string in UTF-8 encoding$/;"	e	enum:cv::FileNode::__anon149
cv::FileNode::STRING	core/core.hpp	/^        STRING=STR, \/\/!< synonym for STR$/;"	e	enum:cv::FileNode::__anon149
cv::FileNode::TYPE_MASK	core/core.hpp	/^        TYPE_MASK=7,$/;"	e	enum:cv::FileNode::__anon149
cv::FileNode::USER	core/core.hpp	/^        USER=16, \/\/!< a registered object (e.g. a matrix)$/;"	e	enum:cv::FileNode::__anon149
cv::FileNode::begin	core/core.hpp	/^    FileNodeIterator begin() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::begin	core/operations.hpp	/^inline FileNodeIterator FileNode::begin() const$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::empty	core/core.hpp	/^    CV_WRAP bool empty() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::empty	core/operations.hpp	/^inline bool FileNode::empty() const { return node == 0; }$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::end	core/core.hpp	/^    FileNodeIterator end() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::end	core/operations.hpp	/^inline FileNodeIterator FileNode::end() const$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::fs	core/core.hpp	/^    const CvFileStorage* fs;$/;"	m	class:cv::FileNode	access:public
cv::FileNode::isInt	core/core.hpp	/^    CV_WRAP bool isInt() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::isInt	core/operations.hpp	/^inline bool FileNode::isInt() const { return type() == INT; }$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::isMap	core/core.hpp	/^    CV_WRAP bool isMap() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::isMap	core/operations.hpp	/^inline bool FileNode::isMap() const { return type() == MAP; }$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::isNamed	core/core.hpp	/^    CV_WRAP bool isNamed() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::isNamed	core/operations.hpp	/^inline bool FileNode::isNamed() const { return !node ? false : (node->tag & NAMED) != 0; }$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::isNone	core/core.hpp	/^    CV_WRAP bool isNone() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::isNone	core/operations.hpp	/^inline bool FileNode::isNone() const { return type() == NONE; }$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::isReal	core/core.hpp	/^    CV_WRAP bool isReal() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::isReal	core/operations.hpp	/^inline bool FileNode::isReal() const { return type() == REAL; }$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::isSeq	core/core.hpp	/^    CV_WRAP bool isSeq() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::isSeq	core/operations.hpp	/^inline bool FileNode::isSeq() const { return type() == SEQ; }$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::isString	core/core.hpp	/^    CV_WRAP bool isString() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::isString	core/operations.hpp	/^inline bool FileNode::isString() const { return type() == STR; }$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::name	core/core.hpp	/^    CV_WRAP string name() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::node	core/core.hpp	/^    const CvFileNode* node;$/;"	m	class:cv::FileNode	access:public
cv::FileNode::operator *	core/core.hpp	/^    CvFileNode* operator *();$/;"	p	class:cv::FileNode	access:public	signature:()
cv::FileNode::operator *	core/core.hpp	/^    const CvFileNode* operator* () const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::operator *	core/operations.hpp	/^inline CvFileNode* FileNode::operator *() { return (CvFileNode*)node; }$/;"	f	class:cv::FileNode	signature:()
cv::FileNode::operator *	core/operations.hpp	/^inline const CvFileNode* FileNode::operator* () const { return node; }$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::operator []	core/core.hpp	/^    CV_WRAP FileNode operator[](const char* nodename) const;$/;"	p	class:cv::FileNode	access:public	signature:(const char* nodename) const
cv::FileNode::operator []	core/core.hpp	/^    CV_WRAP FileNode operator[](int i) const;$/;"	p	class:cv::FileNode	access:public	signature:(int i) const
cv::FileNode::operator []	core/core.hpp	/^    FileNode operator[](const string& nodename) const;$/;"	p	class:cv::FileNode	access:public	signature:(const string& nodename) const
cv::FileNode::operator double	core/core.hpp	/^    operator double() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::operator double	core/operations.hpp	/^inline FileNode::operator double() const$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::operator float	core/core.hpp	/^    operator float() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::operator float	core/operations.hpp	/^inline FileNode::operator float() const$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::operator int	core/core.hpp	/^    operator int() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::operator int	core/operations.hpp	/^inline FileNode::operator int() const$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::operator string	core/core.hpp	/^    operator string() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::operator string	core/operations.hpp	/^inline FileNode::operator string() const$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::readObj	core/core.hpp	/^    void* readObj() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::readRaw	core/core.hpp	/^    void readRaw( const string& fmt, uchar* vec, size_t len ) const;$/;"	p	class:cv::FileNode	access:public	signature:( const string& fmt, uchar* vec, size_t len ) const
cv::FileNode::readRaw	core/operations.hpp	/^inline void FileNode::readRaw( const string& fmt, uchar* vec, size_t len ) const$/;"	f	class:cv::FileNode	signature:( const string& fmt, uchar* vec, size_t len ) const
cv::FileNode::size	core/core.hpp	/^    CV_WRAP size_t size() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::size	core/operations.hpp	/^inline size_t FileNode::size() const$/;"	f	class:cv::FileNode	signature:() const
cv::FileNode::type	core/core.hpp	/^    CV_WRAP int type() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
cv::FileNode::type	core/operations.hpp	/^inline int FileNode::type() const { return !node ? NONE : (node->tag & TYPE_MASK); }$/;"	f	class:cv::FileNode	signature:() const
cv::FileNodeIterator	core/core.hpp	/^class CV_EXPORTS FileNodeIterator$/;"	c	namespace:cv
cv::FileNodeIterator	core/core.hpp	/^class CV_EXPORTS FileNodeIterator;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::FileNodeIterator::FileNodeIterator	core/core.hpp	/^    FileNodeIterator();$/;"	p	class:cv::FileNodeIterator	access:public	signature:()
cv::FileNodeIterator::FileNodeIterator	core/core.hpp	/^    FileNodeIterator(const CvFileStorage* fs, const CvFileNode* node, size_t ofs=0);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(const CvFileStorage* fs, const CvFileNode* node, size_t ofs=0)
cv::FileNodeIterator::FileNodeIterator	core/core.hpp	/^    FileNodeIterator(const FileNodeIterator& it);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(const FileNodeIterator& it)
cv::FileNodeIterator::container	core/core.hpp	/^    const CvFileNode* container;$/;"	m	class:cv::FileNodeIterator	access:public
cv::FileNodeIterator::fs	core/core.hpp	/^    const CvFileStorage* fs;$/;"	m	class:cv::FileNodeIterator	access:public
cv::FileNodeIterator::operator *	core/core.hpp	/^    FileNode operator *() const;$/;"	p	class:cv::FileNodeIterator	access:public	signature:() const
cv::FileNodeIterator::operator *	core/operations.hpp	/^inline FileNode FileNodeIterator::operator *() const$/;"	f	class:cv::FileNodeIterator	signature:() const
cv::FileNodeIterator::operator ++	core/core.hpp	/^    FileNodeIterator operator ++ (int);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(int)
cv::FileNodeIterator::operator ++	core/core.hpp	/^    FileNodeIterator& operator ++ ();$/;"	p	class:cv::FileNodeIterator	access:public	signature:()
cv::FileNodeIterator::operator +=	core/core.hpp	/^    FileNodeIterator& operator += (int);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(int)
cv::FileNodeIterator::operator --	core/core.hpp	/^    FileNodeIterator operator -- (int);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(int)
cv::FileNodeIterator::operator --	core/core.hpp	/^    FileNodeIterator& operator -- ();$/;"	p	class:cv::FileNodeIterator	access:public	signature:()
cv::FileNodeIterator::operator -=	core/core.hpp	/^    FileNodeIterator& operator -= (int);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(int)
cv::FileNodeIterator::operator ->	core/core.hpp	/^    FileNode operator ->() const;$/;"	p	class:cv::FileNodeIterator	access:public	signature:() const
cv::FileNodeIterator::operator ->	core/operations.hpp	/^inline FileNode FileNodeIterator::operator ->() const$/;"	f	class:cv::FileNodeIterator	signature:() const
cv::FileNodeIterator::readRaw	core/core.hpp	/^    FileNodeIterator& readRaw( const string& fmt, uchar* vec,$/;"	p	class:cv::FileNodeIterator	access:public	signature:( const string& fmt, uchar* vec, size_t maxCount=(size_t)INT_MAX )
cv::FileNodeIterator::reader	core/core.hpp	/^    CvSeqReader reader;$/;"	m	class:cv::FileNodeIterator	access:public
cv::FileNodeIterator::remaining	core/core.hpp	/^    size_t remaining;$/;"	m	class:cv::FileNodeIterator	access:public
cv::FileStorage	core/core.hpp	/^class CV_EXPORTS_W FileStorage$/;"	c	namespace:cv
cv::FileStorage::APPEND	core/core.hpp	/^        APPEND=2 \/\/! append mode$/;"	e	enum:cv::FileStorage::__anon147
cv::FileStorage::FileStorage	core/core.hpp	/^    CV_WRAP FileStorage();$/;"	p	class:cv::FileStorage	access:public	signature:()
cv::FileStorage::FileStorage	core/core.hpp	/^    CV_WRAP FileStorage(const string& filename, int flags, const string& encoding=string());$/;"	p	class:cv::FileStorage	access:public	signature:(const string& filename, int flags, const string& encoding=string())
cv::FileStorage::FileStorage	core/core.hpp	/^    FileStorage(CvFileStorage* fs);$/;"	p	class:cv::FileStorage	access:public	signature:(CvFileStorage* fs)
cv::FileStorage::INSIDE_MAP	core/core.hpp	/^        INSIDE_MAP=4$/;"	e	enum:cv::FileStorage::__anon148
cv::FileStorage::NAME_EXPECTED	core/core.hpp	/^        NAME_EXPECTED=2,$/;"	e	enum:cv::FileStorage::__anon148
cv::FileStorage::READ	core/core.hpp	/^        READ=0, \/\/! read mode$/;"	e	enum:cv::FileStorage::__anon147
cv::FileStorage::UNDEFINED	core/core.hpp	/^        UNDEFINED=0, $/;"	e	enum:cv::FileStorage::__anon148
cv::FileStorage::VALUE_EXPECTED	core/core.hpp	/^        VALUE_EXPECTED=1,$/;"	e	enum:cv::FileStorage::__anon148
cv::FileStorage::WRITE	core/core.hpp	/^        WRITE=1, \/\/! write mode$/;"	e	enum:cv::FileStorage::__anon147
cv::FileStorage::elname	core/core.hpp	/^    string elname; \/\/!< the currently written element$/;"	m	class:cv::FileStorage	access:public
cv::FileStorage::fs	core/core.hpp	/^    Ptr<CvFileStorage> fs; \/\/!< the underlying C FileStorage structure$/;"	m	class:cv::FileStorage	access:public
cv::FileStorage::getDefaultObjectName	core/core.hpp	/^    static string getDefaultObjectName(const string& filename);$/;"	p	class:cv::FileStorage	access:public	signature:(const string& filename)
cv::FileStorage::getFirstTopLevelNode	core/core.hpp	/^    CV_WRAP FileNode getFirstTopLevelNode() const;$/;"	p	class:cv::FileStorage	access:public	signature:() const
cv::FileStorage::getFirstTopLevelNode	core/operations.hpp	/^inline FileNode FileStorage::getFirstTopLevelNode() const$/;"	f	class:cv::FileStorage	signature:() const
cv::FileStorage::isOpened	core/core.hpp	/^    CV_WRAP virtual bool isOpened() const;$/;"	p	class:cv::FileStorage	access:public	signature:() const
cv::FileStorage::open	core/core.hpp	/^    CV_WRAP virtual bool open(const string& filename, int flags, const string& encoding=string());$/;"	p	class:cv::FileStorage	access:public	signature:(const string& filename, int flags, const string& encoding=string())
cv::FileStorage::operator *	core/core.hpp	/^    CvFileStorage* operator *() { return fs; }$/;"	f	class:cv::FileStorage	access:public	signature:()
cv::FileStorage::operator *	core/core.hpp	/^    const CvFileStorage* operator *() const { return fs; }$/;"	f	class:cv::FileStorage	access:public	signature:() const
cv::FileStorage::operator []	core/core.hpp	/^    CV_WRAP FileNode operator[](const char* nodename) const;$/;"	p	class:cv::FileStorage	access:public	signature:(const char* nodename) const
cv::FileStorage::operator []	core/core.hpp	/^    FileNode operator[](const string& nodename) const;$/;"	p	class:cv::FileStorage	access:public	signature:(const string& nodename) const
cv::FileStorage::release	core/core.hpp	/^    CV_WRAP virtual void release();$/;"	p	class:cv::FileStorage	access:public	signature:()
cv::FileStorage::root	core/core.hpp	/^    CV_WRAP FileNode root(int streamidx=0) const;$/;"	p	class:cv::FileStorage	access:public	signature:(int streamidx=0) const
cv::FileStorage::state	core/core.hpp	/^    int state; \/\/!< the writer state$/;"	m	class:cv::FileStorage	access:public
cv::FileStorage::structs	core/core.hpp	/^    vector<char> structs; \/\/!< the stack of written structures$/;"	m	class:cv::FileStorage	access:public
cv::FileStorage::writeObj	core/core.hpp	/^    void writeObj( const string& name, const void* obj );$/;"	p	class:cv::FileStorage	access:public	signature:( const string& name, const void* obj )
cv::FileStorage::writeRaw	core/core.hpp	/^    void writeRaw( const string& fmt, const uchar* vec, size_t len );$/;"	p	class:cv::FileStorage	access:public	signature:( const string& fmt, const uchar* vec, size_t len )
cv::FileStorage::~FileStorage	core/core.hpp	/^    virtual ~FileStorage();$/;"	p	class:cv::FileStorage	access:public	signature:()
cv::FilterEngine	imgproc/imgproc.hpp	/^class CV_EXPORTS FilterEngine$/;"	c	namespace:cv
cv::FilterEngine::FilterEngine	imgproc/imgproc.hpp	/^    FilterEngine();$/;"	p	class:cv::FilterEngine	access:public	signature:()
cv::FilterEngine::FilterEngine	imgproc/imgproc.hpp	/^    FilterEngine(const Ptr<BaseFilter>& _filter2D,$/;"	p	class:cv::FilterEngine	access:public	signature:(const Ptr<BaseFilter>& _filter2D, const Ptr<BaseRowFilter>& _rowFilter, const Ptr<BaseColumnFilter>& _columnFilter, int srcType, int dstType, int bufType, int _rowBorderType=BORDER_REPLICATE, int _columnBorderType=-1, const Scalar& _borderValue=Scalar())
cv::FilterEngine::anchor	imgproc/imgproc.hpp	/^    Point anchor;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::apply	imgproc/imgproc.hpp	/^    virtual void apply( const Mat& src, Mat& dst,$/;"	p	class:cv::FilterEngine	access:public	signature:( const Mat& src, Mat& dst, const Rect& srcRoi=Rect(0,0,-1,-1), Point dstOfs=Point(0,0), bool isolated=false)
cv::FilterEngine::borderElemSize	imgproc/imgproc.hpp	/^    int borderElemSize;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::borderTab	imgproc/imgproc.hpp	/^    vector<int> borderTab;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::bufStep	imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::bufType	imgproc/imgproc.hpp	/^    int srcType, dstType, bufType;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::columnBorderType	imgproc/imgproc.hpp	/^    int rowBorderType, columnBorderType;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::columnFilter	imgproc/imgproc.hpp	/^    Ptr<BaseColumnFilter> columnFilter;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::constBorderRow	imgproc/imgproc.hpp	/^    vector<uchar> constBorderRow;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::constBorderValue	imgproc/imgproc.hpp	/^    vector<uchar> constBorderValue;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::dstType	imgproc/imgproc.hpp	/^    int srcType, dstType, bufType;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::dstY	imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::dx1	imgproc/imgproc.hpp	/^    int dx1, dx2;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::dx2	imgproc/imgproc.hpp	/^    int dx1, dx2;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::endY	imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::filter2D	imgproc/imgproc.hpp	/^    Ptr<BaseFilter> filter2D;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::init	imgproc/imgproc.hpp	/^    void init(const Ptr<BaseFilter>& _filter2D,$/;"	p	class:cv::FilterEngine	access:public	signature:(const Ptr<BaseFilter>& _filter2D, const Ptr<BaseRowFilter>& _rowFilter, const Ptr<BaseColumnFilter>& _columnFilter, int srcType, int dstType, int bufType, int _rowBorderType=BORDER_REPLICATE, int _columnBorderType=-1, const Scalar& _borderValue=Scalar())
cv::FilterEngine::isSeparable	imgproc/imgproc.hpp	/^    bool isSeparable() const { return (const BaseFilter*)filter2D == 0; }$/;"	f	class:cv::FilterEngine	access:public	signature:() const
cv::FilterEngine::ksize	imgproc/imgproc.hpp	/^    Size ksize;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::maxWidth	imgproc/imgproc.hpp	/^    int maxWidth;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::proceed	imgproc/imgproc.hpp	/^    virtual int proceed(const uchar* src, int srcStep, int srcCount,$/;"	p	class:cv::FilterEngine	access:public	signature:(const uchar* src, int srcStep, int srcCount, uchar* dst, int dstStep)
cv::FilterEngine::remainingInputRows	imgproc/imgproc.hpp	/^    int remainingInputRows() const;$/;"	p	class:cv::FilterEngine	access:public	signature:() const
cv::FilterEngine::remainingOutputRows	imgproc/imgproc.hpp	/^    int remainingOutputRows() const;$/;"	p	class:cv::FilterEngine	access:public	signature:() const
cv::FilterEngine::ringBuf	imgproc/imgproc.hpp	/^    vector<uchar> ringBuf;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::roi	imgproc/imgproc.hpp	/^    Rect roi;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::rowBorderType	imgproc/imgproc.hpp	/^    int rowBorderType, columnBorderType;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::rowCount	imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::rowFilter	imgproc/imgproc.hpp	/^    Ptr<BaseRowFilter> rowFilter;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::rows	imgproc/imgproc.hpp	/^    vector<uchar*> rows;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::srcRow	imgproc/imgproc.hpp	/^    vector<uchar> srcRow;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::srcType	imgproc/imgproc.hpp	/^    int srcType, dstType, bufType;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::start	imgproc/imgproc.hpp	/^    virtual int start(Size wholeSize, Rect roi, int maxBufRows=-1);$/;"	p	class:cv::FilterEngine	access:public	signature:(Size wholeSize, Rect roi, int maxBufRows=-1)
cv::FilterEngine::start	imgproc/imgproc.hpp	/^    virtual int start(const Mat& src, const Rect& srcRoi=Rect(0,0,-1,-1),$/;"	p	class:cv::FilterEngine	access:public	signature:(const Mat& src, const Rect& srcRoi=Rect(0,0,-1,-1), bool isolated=false, int maxBufRows=-1)
cv::FilterEngine::startY	imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::startY0	imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::wholeSize	imgproc/imgproc.hpp	/^    Size wholeSize;$/;"	m	class:cv::FilterEngine	access:public
cv::FilterEngine::~FilterEngine	imgproc/imgproc.hpp	/^    virtual ~FilterEngine();$/;"	p	class:cv::FilterEngine	access:public	signature:()
cv::FlannBasedMatcher	features2d/features2d.hpp	/^class CV_EXPORTS FlannBasedMatcher : public DescriptorMatcher$/;"	c	namespace:cv	inherits:DescriptorMatcher
cv::FlannBasedMatcher::FlannBasedMatcher	features2d/features2d.hpp	/^    FlannBasedMatcher( const Ptr<flann::IndexParams>& indexParams=new flann::KDTreeIndexParams(),$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:( const Ptr<flann::IndexParams>& indexParams=new flann::KDTreeIndexParams(), const Ptr<flann::SearchParams>& searchParams=new flann::SearchParams() )
cv::FlannBasedMatcher::add	features2d/features2d.hpp	/^    virtual void add( const vector<Mat>& descriptors );$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:( const vector<Mat>& descriptors )
cv::FlannBasedMatcher::addedDescCount	features2d/features2d.hpp	/^    int addedDescCount;$/;"	m	class:cv::FlannBasedMatcher	access:protected
cv::FlannBasedMatcher::clear	features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:()
cv::FlannBasedMatcher::clone	features2d/features2d.hpp	/^    virtual Ptr<DescriptorMatcher> clone( bool emptyTrainData=false ) const;$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:( bool emptyTrainData=false ) const
cv::FlannBasedMatcher::convertToDMatches	features2d/features2d.hpp	/^    static void convertToDMatches( const DescriptorCollection& descriptors,$/;"	p	class:cv::FlannBasedMatcher	access:protected	signature:( const DescriptorCollection& descriptors, const Mat& indices, const Mat& distances, vector<vector<DMatch> >& matches )
cv::FlannBasedMatcher::flannIndex	features2d/features2d.hpp	/^    Ptr<flann::Index> flannIndex;$/;"	m	class:cv::FlannBasedMatcher	access:protected
cv::FlannBasedMatcher::indexParams	features2d/features2d.hpp	/^    Ptr<flann::IndexParams> indexParams;$/;"	m	class:cv::FlannBasedMatcher	access:protected
cv::FlannBasedMatcher::isMaskSupported	features2d/features2d.hpp	/^    virtual bool isMaskSupported() const;$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:() const
cv::FlannBasedMatcher::knnMatchImpl	features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	p	class:cv::FlannBasedMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
cv::FlannBasedMatcher::mergedDescriptors	features2d/features2d.hpp	/^    DescriptorCollection mergedDescriptors;$/;"	m	class:cv::FlannBasedMatcher	access:protected
cv::FlannBasedMatcher::radiusMatchImpl	features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance,$/;"	p	class:cv::FlannBasedMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
cv::FlannBasedMatcher::read	features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:( const FileNode& )
cv::FlannBasedMatcher::searchParams	features2d/features2d.hpp	/^    Ptr<flann::SearchParams> searchParams;$/;"	m	class:cv::FlannBasedMatcher	access:protected
cv::FlannBasedMatcher::train	features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:()
cv::FlannBasedMatcher::write	features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:( FileStorage& ) const
cv::ForestTree	ml/ml.hpp	/^typedef CvForestTree ForestTree;$/;"	t	namespace:cv
cv::Formatted	core/operations.hpp	/^struct CV_EXPORTS Formatted$/;"	s	namespace:cv
cv::Formatted::Formatted	core/operations.hpp	/^    Formatted(const Mat& m, const Formatter* fmt,$/;"	p	struct:cv::Formatted	access:public	signature:(const Mat& m, const Formatter* fmt, const int* params=0)
cv::Formatted::Formatted	core/operations.hpp	/^    Formatted(const Mat& m, const Formatter* fmt,$/;"	p	struct:cv::Formatted	access:public	signature:(const Mat& m, const Formatter* fmt, const vector<int>& params)
cv::Formatted::fmt	core/operations.hpp	/^    const Formatter* fmt;$/;"	m	struct:cv::Formatted	access:public
cv::Formatted::mtx	core/operations.hpp	/^    Mat mtx;$/;"	m	struct:cv::Formatted	access:public
cv::Formatted::params	core/operations.hpp	/^    vector<int> params;$/;"	m	struct:cv::Formatted	access:public
cv::Formatter	core/operations.hpp	/^class CV_EXPORTS Formatter$/;"	c	namespace:cv
cv::Formatter::get	core/operations.hpp	/^    static const Formatter* get(const char* fmt="");$/;"	p	class:cv::Formatter	access:public	signature:(const char* fmt=)
cv::Formatter::setDefault	core/operations.hpp	/^    static const Formatter* setDefault(const Formatter* fmt);$/;"	p	class:cv::Formatter	access:public	signature:(const Formatter* fmt)
cv::Formatter::write	core/operations.hpp	/^    virtual void write(std::ostream& out, const Mat& m, const int* params=0, int nparams=0) const = 0;$/;"	p	class:cv::Formatter	access:public	signature:(std::ostream& out, const Mat& m, const int* params=0, int nparams=0) const
cv::Formatter::write	core/operations.hpp	/^    virtual void write(std::ostream& out, const void* data, int nelems, int type,$/;"	p	class:cv::Formatter	access:public	signature:(std::ostream& out, const void* data, int nelems, int type, const int* params=0, int nparams=0) const
cv::Formatter::~Formatter	core/operations.hpp	/^    virtual ~Formatter() {}$/;"	f	class:cv::Formatter	access:public	signature:()
cv::GC_BGD	imgproc/imgproc.hpp	/^    GC_BGD    = 0,  \/\/!< background$/;"	e	enum:cv::__anon19
cv::GC_EVAL	imgproc/imgproc.hpp	/^    GC_EVAL            = 2$/;"	e	enum:cv::__anon20
cv::GC_FGD	imgproc/imgproc.hpp	/^    GC_FGD    = 1,  \/\/!< foreground$/;"	e	enum:cv::__anon19
cv::GC_INIT_WITH_MASK	imgproc/imgproc.hpp	/^    GC_INIT_WITH_MASK  = 1,$/;"	e	enum:cv::__anon20
cv::GC_INIT_WITH_RECT	imgproc/imgproc.hpp	/^    GC_INIT_WITH_RECT  = 0,$/;"	e	enum:cv::__anon20
cv::GC_PR_BGD	imgproc/imgproc.hpp	/^    GC_PR_BGD = 2,  \/\/!< most probably background$/;"	e	enum:cv::__anon19
cv::GC_PR_FGD	imgproc/imgproc.hpp	/^    GC_PR_FGD = 3   \/\/!< most probably foreground $/;"	e	enum:cv::__anon19
cv::GEMM_1_T	core/core.hpp	/^enum { GEMM_1_T=1, GEMM_2_T=2, GEMM_3_T=4 };$/;"	e	enum:cv::__anon100
cv::GEMM_2_T	core/core.hpp	/^enum { GEMM_1_T=1, GEMM_2_T=2, GEMM_3_T=4 };$/;"	e	enum:cv::__anon100
cv::GEMM_3_T	core/core.hpp	/^enum { GEMM_1_T=1, GEMM_2_T=2, GEMM_3_T=4 };$/;"	e	enum:cv::__anon100
cv::GaussianBlur	imgproc/imgproc.hpp	/^CV_EXPORTS_W void GaussianBlur( InputArray src,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, Size ksize, double sigma1, double sigma2=0, int borderType=BORDER_DEFAULT )
cv::GenericDescriptorMatch	features2d/features2d.hpp	/^typedef GenericDescriptorMatcher GenericDescriptorMatch;$/;"	t	namespace:cv
cv::GenericDescriptorMatcher	features2d/features2d.hpp	/^class CV_EXPORTS GenericDescriptorMatcher$/;"	c	namespace:cv
cv::GenericDescriptorMatcher::GenericDescriptorMatcher	features2d/features2d.hpp	/^    GenericDescriptorMatcher();$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:()
cv::GenericDescriptorMatcher::KeyPointCollection	features2d/features2d.hpp	/^    class CV_EXPORTS KeyPointCollection$/;"	c	class:cv::GenericDescriptorMatcher	access:protected
cv::GenericDescriptorMatcher::KeyPointCollection::KeyPointCollection	features2d/features2d.hpp	/^        KeyPointCollection( const KeyPointCollection& collection );$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( const KeyPointCollection& collection )
cv::GenericDescriptorMatcher::KeyPointCollection::KeyPointCollection	features2d/features2d.hpp	/^        KeyPointCollection();$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:()
cv::GenericDescriptorMatcher::KeyPointCollection::add	features2d/features2d.hpp	/^        void add( const vector<Mat>& images, const vector<vector<KeyPoint> >& keypoints );$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( const vector<Mat>& images, const vector<vector<KeyPoint> >& keypoints )
cv::GenericDescriptorMatcher::KeyPointCollection::clear	features2d/features2d.hpp	/^        void clear();$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:()
cv::GenericDescriptorMatcher::KeyPointCollection::clone_op	features2d/features2d.hpp	/^        static Mat clone_op( Mat m ) { return m.clone(); }$/;"	f	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:private	signature:( Mat m )
cv::GenericDescriptorMatcher::KeyPointCollection::getImage	features2d/features2d.hpp	/^        const Mat& getImage( int imgIdx ) const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( int imgIdx ) const
cv::GenericDescriptorMatcher::KeyPointCollection::getImages	features2d/features2d.hpp	/^        const vector<Mat>& getImages() const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:() const
cv::GenericDescriptorMatcher::KeyPointCollection::getKeyPoint	features2d/features2d.hpp	/^        const KeyPoint& getKeyPoint( int globalPointIdx ) const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( int globalPointIdx ) const
cv::GenericDescriptorMatcher::KeyPointCollection::getKeyPoint	features2d/features2d.hpp	/^        const KeyPoint& getKeyPoint( int imgIdx, int localPointIdx ) const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( int imgIdx, int localPointIdx ) const
cv::GenericDescriptorMatcher::KeyPointCollection::getKeypoints	features2d/features2d.hpp	/^        const vector<KeyPoint>& getKeypoints( int imgIdx ) const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( int imgIdx ) const
cv::GenericDescriptorMatcher::KeyPointCollection::getKeypoints	features2d/features2d.hpp	/^        const vector<vector<KeyPoint> >& getKeypoints() const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:() const
cv::GenericDescriptorMatcher::KeyPointCollection::getLocalIdx	features2d/features2d.hpp	/^        void getLocalIdx( int globalPointIdx, int& imgIdx, int& localPointIdx ) const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( int globalPointIdx, int& imgIdx, int& localPointIdx ) const
cv::GenericDescriptorMatcher::KeyPointCollection::imageCount	features2d/features2d.hpp	/^        size_t imageCount() const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:() const
cv::GenericDescriptorMatcher::KeyPointCollection::images	features2d/features2d.hpp	/^        vector<Mat> images;$/;"	m	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:protected
cv::GenericDescriptorMatcher::KeyPointCollection::keypointCount	features2d/features2d.hpp	/^        size_t keypointCount() const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:() const
cv::GenericDescriptorMatcher::KeyPointCollection::keypoints	features2d/features2d.hpp	/^        vector<vector<KeyPoint> > keypoints;$/;"	m	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:protected
cv::GenericDescriptorMatcher::KeyPointCollection::pointCount	features2d/features2d.hpp	/^        int pointCount;$/;"	m	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:protected
cv::GenericDescriptorMatcher::KeyPointCollection::startIndices	features2d/features2d.hpp	/^        vector<int> startIndices;$/;"	m	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:protected
cv::GenericDescriptorMatcher::add	features2d/features2d.hpp	/^    virtual void add( const vector<Mat>& images,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints )
cv::GenericDescriptorMatcher::classify	features2d/features2d.hpp	/^    void classify( const Mat& queryImage, vector<KeyPoint>& queryKeypoints );$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints )
cv::GenericDescriptorMatcher::classify	features2d/features2d.hpp	/^    void classify( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, const Mat& trainImage, vector<KeyPoint>& trainKeypoints ) const
cv::GenericDescriptorMatcher::clear	features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:()
cv::GenericDescriptorMatcher::clone	features2d/features2d.hpp	/^    virtual Ptr<GenericDescriptorMatcher> clone( bool emptyTrainData=false ) const = 0;$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( bool emptyTrainData=false ) const
cv::GenericDescriptorMatcher::create	features2d/features2d.hpp	/^    static Ptr<GenericDescriptorMatcher> create( const string& genericDescritptorMatcherType,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const string& genericDescritptorMatcherType, const string &paramsFilename=string() )
cv::GenericDescriptorMatcher::empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:() const
cv::GenericDescriptorMatcher::getTrainImages	features2d/features2d.hpp	/^    const vector<Mat>& getTrainImages() const;$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:() const
cv::GenericDescriptorMatcher::getTrainKeypoints	features2d/features2d.hpp	/^    const vector<vector<KeyPoint> >& getTrainKeypoints() const;$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:() const
cv::GenericDescriptorMatcher::isMaskSupported	features2d/features2d.hpp	/^    virtual bool isMaskSupported() = 0;$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:()
cv::GenericDescriptorMatcher::knnMatch	features2d/features2d.hpp	/^    void knnMatch( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, const Mat& trainImage, vector<KeyPoint>& trainKeypoints, vector<vector<DMatch> >& matches, int k, const Mat& mask=Mat(), bool compactResult=false ) const
cv::GenericDescriptorMatcher::knnMatch	features2d/features2d.hpp	/^    void knnMatch( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
cv::GenericDescriptorMatcher::knnMatchImpl	features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
cv::GenericDescriptorMatcher::match	features2d/features2d.hpp	/^    void match( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, const Mat& trainImage, vector<KeyPoint>& trainKeypoints, vector<DMatch>& matches, const Mat& mask=Mat() ) const
cv::GenericDescriptorMatcher::match	features2d/features2d.hpp	/^    void match( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<DMatch>& matches, const vector<Mat>& masks=vector<Mat>() )
cv::GenericDescriptorMatcher::radiusMatch	features2d/features2d.hpp	/^    void radiusMatch( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, const Mat& trainImage, vector<KeyPoint>& trainKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const Mat& mask=Mat(), bool compactResult=false ) const
cv::GenericDescriptorMatcher::radiusMatch	features2d/features2d.hpp	/^    void radiusMatch( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
cv::GenericDescriptorMatcher::radiusMatchImpl	features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
cv::GenericDescriptorMatcher::read	features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const FileNode& )
cv::GenericDescriptorMatcher::train	features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:()
cv::GenericDescriptorMatcher::trainPointCollection	features2d/features2d.hpp	/^    KeyPointCollection trainPointCollection;$/;"	m	class:cv::GenericDescriptorMatcher	access:protected
cv::GenericDescriptorMatcher::write	features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( FileStorage& ) const
cv::GenericDescriptorMatcher::~GenericDescriptorMatcher	features2d/features2d.hpp	/^    virtual ~GenericDescriptorMatcher();$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:()
cv::GoodFeaturesToTrackDetector	features2d/features2d.hpp	/^class CV_EXPORTS GoodFeaturesToTrackDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
cv::GoodFeaturesToTrackDetector::GoodFeaturesToTrackDetector	features2d/features2d.hpp	/^    GoodFeaturesToTrackDetector( const GoodFeaturesToTrackDetector::Params& params=GoodFeaturesToTrackDetector::Params() );$/;"	p	class:cv::GoodFeaturesToTrackDetector	access:public	signature:( const GoodFeaturesToTrackDetector::Params& params=GoodFeaturesToTrackDetector::Params() )
cv::GoodFeaturesToTrackDetector::GoodFeaturesToTrackDetector	features2d/features2d.hpp	/^    GoodFeaturesToTrackDetector( int maxCorners, double qualityLevel, double minDistance,$/;"	p	class:cv::GoodFeaturesToTrackDetector	access:public	signature:( int maxCorners, double qualityLevel, double minDistance, int blockSize=3, bool useHarrisDetector=false, double k=0.04 )
cv::GoodFeaturesToTrackDetector::Params	features2d/features2d.hpp	/^    class CV_EXPORTS Params$/;"	c	class:cv::GoodFeaturesToTrackDetector	access:public
cv::GoodFeaturesToTrackDetector::Params::Params	features2d/features2d.hpp	/^        Params( int maxCorners=1000, double qualityLevel=0.01, double minDistance=1.,$/;"	p	class:cv::GoodFeaturesToTrackDetector::Params	access:public	signature:( int maxCorners=1000, double qualityLevel=0.01, double minDistance=1., int blockSize=3, bool useHarrisDetector=false, double k=0.04 )
cv::GoodFeaturesToTrackDetector::Params::blockSize	features2d/features2d.hpp	/^        int blockSize;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
cv::GoodFeaturesToTrackDetector::Params::k	features2d/features2d.hpp	/^        double k;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
cv::GoodFeaturesToTrackDetector::Params::maxCorners	features2d/features2d.hpp	/^        int maxCorners;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
cv::GoodFeaturesToTrackDetector::Params::minDistance	features2d/features2d.hpp	/^        double minDistance;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
cv::GoodFeaturesToTrackDetector::Params::qualityLevel	features2d/features2d.hpp	/^        double qualityLevel;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
cv::GoodFeaturesToTrackDetector::Params::read	features2d/features2d.hpp	/^        void read( const FileNode& fn );$/;"	p	class:cv::GoodFeaturesToTrackDetector::Params	access:public	signature:( const FileNode& fn )
cv::GoodFeaturesToTrackDetector::Params::useHarrisDetector	features2d/features2d.hpp	/^        bool useHarrisDetector;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
cv::GoodFeaturesToTrackDetector::Params::write	features2d/features2d.hpp	/^        void write( FileStorage& fs ) const;$/;"	p	class:cv::GoodFeaturesToTrackDetector::Params	access:public	signature:( FileStorage& fs ) const
cv::GoodFeaturesToTrackDetector::detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::GoodFeaturesToTrackDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::GoodFeaturesToTrackDetector::params	features2d/features2d.hpp	/^    Params params;$/;"	m	class:cv::GoodFeaturesToTrackDetector	access:protected
cv::GoodFeaturesToTrackDetector::read	features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::GoodFeaturesToTrackDetector	access:public	signature:( const FileNode& fn )
cv::GoodFeaturesToTrackDetector::write	features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::GoodFeaturesToTrackDetector	access:public	signature:( FileStorage& fs ) const
cv::GradientBoostingTreeParams	ml/ml.hpp	/^typedef CvGBTreesParams GradientBoostingTreeParams;$/;"	t	namespace:cv
cv::GradientBoostingTrees	ml/ml.hpp	/^typedef CvGBTrees GradientBoostingTrees;$/;"	t	namespace:cv
cv::GreaterEq	core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS GreaterEq$/;"	c	namespace:cv
cv::GreaterEq::operator ()	core/operations.hpp	/^    bool operator()(const _Tp& a, const _Tp& b) const { return a >= b; }$/;"	f	class:cv::GreaterEq	access:public	signature:(const _Tp& a, const _Tp& b) const
cv::GreaterEqIdx	core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS GreaterEqIdx$/;"	c	namespace:cv
cv::GreaterEqIdx::GreaterEqIdx	core/operations.hpp	/^    GreaterEqIdx( const _Tp* _arr ) : arr(_arr) {}$/;"	f	class:cv::GreaterEqIdx	access:public	signature:( const _Tp* _arr )
cv::GreaterEqIdx::arr	core/operations.hpp	/^    const _Tp* arr;$/;"	m	class:cv::GreaterEqIdx	access:public
cv::GreaterEqIdx::operator ()	core/operations.hpp	/^    bool operator()(int a, int b) const { return arr[a] >= arr[b]; }$/;"	f	class:cv::GreaterEqIdx	access:public	signature:(int a, int b) const
cv::GridAdaptedFeatureDetector	features2d/features2d.hpp	/^class CV_EXPORTS GridAdaptedFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
cv::GridAdaptedFeatureDetector::GridAdaptedFeatureDetector	features2d/features2d.hpp	/^    GridAdaptedFeatureDetector( const Ptr<FeatureDetector>& detector, int maxTotalKeypoints=1000,$/;"	p	class:cv::GridAdaptedFeatureDetector	access:public	signature:( const Ptr<FeatureDetector>& detector, int maxTotalKeypoints=1000, int gridRows=4, int gridCols=4 )
cv::GridAdaptedFeatureDetector::detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::GridAdaptedFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::GridAdaptedFeatureDetector::detector	features2d/features2d.hpp	/^    Ptr<FeatureDetector> detector;$/;"	m	class:cv::GridAdaptedFeatureDetector	access:protected
cv::GridAdaptedFeatureDetector::empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::GridAdaptedFeatureDetector	access:public	signature:() const
cv::GridAdaptedFeatureDetector::gridCols	features2d/features2d.hpp	/^    int gridCols;$/;"	m	class:cv::GridAdaptedFeatureDetector	access:protected
cv::GridAdaptedFeatureDetector::gridRows	features2d/features2d.hpp	/^    int gridRows;$/;"	m	class:cv::GridAdaptedFeatureDetector	access:protected
cv::GridAdaptedFeatureDetector::maxTotalKeypoints	features2d/features2d.hpp	/^    int maxTotalKeypoints;$/;"	m	class:cv::GridAdaptedFeatureDetector	access:protected
cv::HOGDescriptor	objdetect/objdetect.hpp	/^struct CV_EXPORTS_W HOGDescriptor$/;"	s	namespace:cv
cv::HOGDescriptor::DEFAULT_NLEVELS	objdetect/objdetect.hpp	/^    enum { DEFAULT_NLEVELS=64 };$/;"	e	enum:cv::HOGDescriptor::__anon203
cv::HOGDescriptor::HOGDescriptor	objdetect/objdetect.hpp	/^    CV_WRAP HOGDescriptor() : winSize(64,128), blockSize(16,16), blockStride(8,8),$/;"	f	struct:cv::HOGDescriptor	access:public	signature:()
cv::HOGDescriptor::HOGDescriptor	objdetect/objdetect.hpp	/^    CV_WRAP HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride,$/;"	f	struct:cv::HOGDescriptor	access:public	signature:(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture=1, double _winSigma=-1, int _histogramNormType=HOGDescriptor::L2Hys, double _L2HysThreshold=0.2, bool _gammaCorrection=false, int _nlevels=HOGDescriptor::DEFAULT_NLEVELS)
cv::HOGDescriptor::HOGDescriptor	objdetect/objdetect.hpp	/^    CV_WRAP HOGDescriptor(const String& filename)$/;"	f	struct:cv::HOGDescriptor	access:public	signature:(const String& filename)
cv::HOGDescriptor::HOGDescriptor	objdetect/objdetect.hpp	/^    HOGDescriptor(const HOGDescriptor& d)$/;"	f	struct:cv::HOGDescriptor	access:public	signature:(const HOGDescriptor& d)
cv::HOGDescriptor::L2Hys	objdetect/objdetect.hpp	/^    enum { L2Hys=0 };$/;"	e	enum:cv::HOGDescriptor::__anon202
cv::HOGDescriptor::L2HysThreshold	objdetect/objdetect.hpp	/^    CV_PROP double L2HysThreshold;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::blockSize	objdetect/objdetect.hpp	/^    CV_PROP Size blockSize;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::blockStride	objdetect/objdetect.hpp	/^    CV_PROP Size blockStride;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::cellSize	objdetect/objdetect.hpp	/^    CV_PROP Size cellSize;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::checkDetectorSize	objdetect/objdetect.hpp	/^    CV_WRAP bool checkDetectorSize() const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:() const
cv::HOGDescriptor::compute	objdetect/objdetect.hpp	/^    CV_WRAP virtual void compute(const Mat& img,$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const Mat& img, CV_OUT vector<float>& descriptors, Size winStride=Size(), Size padding=Size(), const vector<Point>& locations=vector<Point>()) const
cv::HOGDescriptor::computeGradient	objdetect/objdetect.hpp	/^    CV_WRAP virtual void computeGradient(const Mat& img, CV_OUT Mat& grad, CV_OUT Mat& angleOfs,$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const Mat& img, CV_OUT Mat& grad, CV_OUT Mat& angleOfs, Size paddingTL=Size(), Size paddingBR=Size()) const
cv::HOGDescriptor::copyTo	objdetect/objdetect.hpp	/^    virtual void copyTo(HOGDescriptor& c) const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(HOGDescriptor& c) const
cv::HOGDescriptor::derivAperture	objdetect/objdetect.hpp	/^    CV_PROP int derivAperture;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::detect	objdetect/objdetect.hpp	/^    CV_WRAP virtual void detect(const Mat& img, CV_OUT vector<Point>& foundLocations, $/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const Mat& img, CV_OUT vector<Point>& foundLocations, vector<double>& weights, double hitThreshold=0, Size winStride=Size(), Size padding=Size(), const vector<Point>& searchLocations=vector<Point>()) const
cv::HOGDescriptor::detect	objdetect/objdetect.hpp	/^    CV_WRAP virtual void detect(const Mat& img, CV_OUT vector<Point>& foundLocations,$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const Mat& img, CV_OUT vector<Point>& foundLocations, double hitThreshold=0, Size winStride=Size(), Size padding=Size(), const vector<Point>& searchLocations=vector<Point>()) const
cv::HOGDescriptor::detectMultiScale	objdetect/objdetect.hpp	/^	CV_WRAP virtual void detectMultiScale(const Mat& img, CV_OUT vector<Rect>& foundLocations, $/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const Mat& img, CV_OUT vector<Rect>& foundLocations, double hitThreshold=0, Size winStride=Size(), Size padding=Size(), double scale=1.05, double finalThreshold=2.0, bool useMeanshiftGrouping = false) const
cv::HOGDescriptor::detectMultiScale	objdetect/objdetect.hpp	/^    CV_WRAP virtual void detectMultiScale(const Mat& img, CV_OUT vector<Rect>& foundLocations, $/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const Mat& img, CV_OUT vector<Rect>& foundLocations, vector<double>& foundWeights, double hitThreshold=0, Size winStride=Size(), Size padding=Size(), double scale=1.05, double finalThreshold=2.0,bool useMeanshiftGrouping = false) const
cv::HOGDescriptor::gammaCorrection	objdetect/objdetect.hpp	/^    CV_PROP bool gammaCorrection;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::getDaimlerPeopleDetector	objdetect/objdetect.hpp	/^	CV_WRAP static vector<float> getDaimlerPeopleDetector();$/;"	p	struct:cv::HOGDescriptor	access:public	signature:()
cv::HOGDescriptor::getDefaultPeopleDetector	objdetect/objdetect.hpp	/^    CV_WRAP static vector<float> getDefaultPeopleDetector();$/;"	p	struct:cv::HOGDescriptor	access:public	signature:()
cv::HOGDescriptor::getDescriptorSize	objdetect/objdetect.hpp	/^    CV_WRAP size_t getDescriptorSize() const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:() const
cv::HOGDescriptor::getWinSigma	objdetect/objdetect.hpp	/^    CV_WRAP double getWinSigma() const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:() const
cv::HOGDescriptor::histogramNormType	objdetect/objdetect.hpp	/^    CV_PROP int histogramNormType;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::load	objdetect/objdetect.hpp	/^    CV_WRAP virtual bool load(const String& filename, const String& objname=String());$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const String& filename, const String& objname=String())
cv::HOGDescriptor::nbins	objdetect/objdetect.hpp	/^    CV_PROP int nbins;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::nlevels	objdetect/objdetect.hpp	/^    CV_PROP int nlevels;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::read	objdetect/objdetect.hpp	/^    virtual bool read(FileNode& fn);$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(FileNode& fn)
cv::HOGDescriptor::save	objdetect/objdetect.hpp	/^    CV_WRAP virtual void save(const String& filename, const String& objname=String()) const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const String& filename, const String& objname=String()) const
cv::HOGDescriptor::setSVMDetector	objdetect/objdetect.hpp	/^    CV_WRAP virtual void setSVMDetector(InputArray _svmdetector);$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(InputArray _svmdetector)
cv::HOGDescriptor::svmDetector	objdetect/objdetect.hpp	/^    CV_PROP vector<float> svmDetector;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::winSigma	objdetect/objdetect.hpp	/^    CV_PROP double winSigma;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::winSize	objdetect/objdetect.hpp	/^    CV_PROP Size winSize;$/;"	m	struct:cv::HOGDescriptor	access:public
cv::HOGDescriptor::write	objdetect/objdetect.hpp	/^    virtual void write(FileStorage& fs, const String& objname) const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(FileStorage& fs, const String& objname) const
cv::HOGDescriptor::~HOGDescriptor	objdetect/objdetect.hpp	/^    virtual ~HOGDescriptor() {}$/;"	f	struct:cv::HOGDescriptor	access:public	signature:()
cv::Hamming	features2d/features2d.hpp	/^struct CV_EXPORTS Hamming$/;"	s	namespace:cv
cv::Hamming::ResultType	features2d/features2d.hpp	/^    typedef int ResultType;$/;"	t	struct:cv::Hamming	access:public
cv::Hamming::ValueType	features2d/features2d.hpp	/^    typedef unsigned char ValueType;$/;"	t	struct:cv::Hamming	access:public
cv::Hamming::operator ()	features2d/features2d.hpp	/^    ResultType operator()(const unsigned char* a, const unsigned char* b, int size) const;$/;"	p	struct:cv::Hamming	access:public	signature:(const unsigned char* a, const unsigned char* b, int size) const
cv::HammingLUT	features2d/features2d.hpp	/^struct CV_EXPORTS HammingLUT$/;"	s	namespace:cv
cv::HammingLUT::ResultType	features2d/features2d.hpp	/^    typedef int ResultType;$/;"	t	struct:cv::HammingLUT	access:public
cv::HammingLUT::ValueType	features2d/features2d.hpp	/^    typedef unsigned char ValueType;$/;"	t	struct:cv::HammingLUT	access:public
cv::HammingLUT::byteBitsLookUp	features2d/features2d.hpp	/^    static unsigned char byteBitsLookUp(unsigned char b);$/;"	p	struct:cv::HammingLUT	access:public	signature:(unsigned char b)
cv::HammingLUT::operator ()	features2d/features2d.hpp	/^    ResultType operator()( const unsigned char* a, const unsigned char* b, int size ) const;$/;"	p	struct:cv::HammingLUT	access:public	signature:( const unsigned char* a, const unsigned char* b, int size ) const
cv::HoughCircles	imgproc/imgproc.hpp	/^CV_EXPORTS_W void HoughCircles( InputArray image, OutputArray circles,$/;"	p	namespace:cv	signature:( InputArray image, OutputArray circles, int method, double dp, double minDist, double param1=100, double param2=100, int minRadius=0, int maxRadius=0 )
cv::HoughLines	imgproc/imgproc.hpp	/^CV_EXPORTS_W void HoughLines( InputArray image, OutputArray lines,$/;"	p	namespace:cv	signature:( InputArray image, OutputArray lines, double rho, double theta, int threshold, double srn=0, double stn=0 )
cv::HoughLinesP	imgproc/imgproc.hpp	/^CV_EXPORTS_W void HoughLinesP( InputArray image, OutputArray lines,$/;"	p	namespace:cv	signature:( InputArray image, OutputArray lines, double rho, double theta, int threshold, double minLineLength=0, double maxLineGap=0 )
cv::HuMoments	imgproc/imgproc.hpp	/^CV_EXPORTS void HuMoments( const Moments& moments, double hu[7] );$/;"	p	namespace:cv	signature:( const Moments& moments, double hu[7] )
cv::HuMoments	imgproc/imgproc.hpp	/^CV_EXPORTS_W void HuMoments( const Moments& m, CV_OUT OutputArray hu );$/;"	p	namespace:cv	signature:( const Moments& m, CV_OUT OutputArray hu )
cv::INPAINT_NS	imgproc/imgproc.hpp	/^    INPAINT_NS=CV_INPAINT_NS, \/\/ Navier-Stokes algorithm$/;"	e	enum:cv::__anon21
cv::INPAINT_TELEA	imgproc/imgproc.hpp	/^    INPAINT_TELEA=CV_INPAINT_TELEA \/\/ A. Telea algorithm$/;"	e	enum:cv::__anon21
cv::INTER_AREA	imgproc/imgproc.hpp	/^    INTER_AREA=CV_INTER_AREA, \/\/!< area-based (or super) interpolation$/;"	e	enum:cv::__anon14
cv::INTER_BITS	imgproc/imgproc.hpp	/^    INTER_BITS=5, INTER_BITS2=INTER_BITS*2,$/;"	e	enum:cv::__anon15
cv::INTER_BITS2	imgproc/imgproc.hpp	/^    INTER_BITS=5, INTER_BITS2=INTER_BITS*2,$/;"	e	enum:cv::__anon15
cv::INTER_CUBIC	imgproc/imgproc.hpp	/^    INTER_CUBIC=CV_INTER_CUBIC, \/\/!< bicubic interpolation$/;"	e	enum:cv::__anon14
cv::INTER_LANCZOS4	imgproc/imgproc.hpp	/^    INTER_LANCZOS4=CV_INTER_LANCZOS4, \/\/!< Lanczos interpolation over 8x8 neighborhood$/;"	e	enum:cv::__anon14
cv::INTER_LINEAR	imgproc/imgproc.hpp	/^    INTER_LINEAR=CV_INTER_LINEAR, \/\/!< bilinear interpolation$/;"	e	enum:cv::__anon14
cv::INTER_MAX	imgproc/imgproc.hpp	/^    INTER_MAX=7,$/;"	e	enum:cv::__anon14
cv::INTER_NEAREST	imgproc/imgproc.hpp	/^    INTER_NEAREST=CV_INTER_NN, \/\/!< nearest neighbor interpolation$/;"	e	enum:cv::__anon14
cv::INTER_TAB_SIZE	imgproc/imgproc.hpp	/^    INTER_TAB_SIZE=(1<<INTER_BITS),$/;"	e	enum:cv::__anon15
cv::INTER_TAB_SIZE2	imgproc/imgproc.hpp	/^    INTER_TAB_SIZE2=INTER_TAB_SIZE*INTER_TAB_SIZE$/;"	e	enum:cv::__anon15
cv::InputArray	core/core.hpp	/^typedef const _InputArray& InputArray;$/;"	t	namespace:cv
cv::InputArrayOfArrays	core/core.hpp	/^typedef InputArray InputArrayOfArrays;$/;"	t	namespace:cv
cv::InputOutputArray	core/core.hpp	/^typedef OutputArray InputOutputArray;$/;"	t	namespace:cv
cv::InputOutputArrayOfArrays	core/core.hpp	/^typedef OutputArray InputOutputArrayOfArrays;$/;"	t	namespace:cv
cv::KDTree	core/core.hpp	/^class CV_EXPORTS_W KDTree$/;"	c	namespace:cv
cv::KDTree::KDTree	core/core.hpp	/^    CV_WRAP KDTree();$/;"	p	class:cv::KDTree	access:public	signature:()
cv::KDTree::KDTree	core/core.hpp	/^    CV_WRAP KDTree(InputArray points, InputArray _labels,$/;"	p	class:cv::KDTree	access:public	signature:(InputArray points, InputArray _labels, bool copyAndReorderPoints=false)
cv::KDTree::KDTree	core/core.hpp	/^    CV_WRAP KDTree(InputArray points, bool copyAndReorderPoints=false);$/;"	p	class:cv::KDTree	access:public	signature:(InputArray points, bool copyAndReorderPoints=false)
cv::KDTree::Node	core/core.hpp	/^    struct Node$/;"	s	class:cv::KDTree	access:public
cv::KDTree::Node::Node	core/core.hpp	/^        Node() : idx(-1), left(-1), right(-1), boundary(0.f) {}$/;"	f	struct:cv::KDTree::Node	access:public	signature:()
cv::KDTree::Node::Node	core/core.hpp	/^        Node(int _idx, int _left, int _right, float _boundary)$/;"	f	struct:cv::KDTree::Node	access:public	signature:(int _idx, int _left, int _right, float _boundary)
cv::KDTree::Node::boundary	core/core.hpp	/^        float boundary;$/;"	m	struct:cv::KDTree::Node	access:public
cv::KDTree::Node::idx	core/core.hpp	/^        int idx;$/;"	m	struct:cv::KDTree::Node	access:public
cv::KDTree::Node::left	core/core.hpp	/^        int left, right;$/;"	m	struct:cv::KDTree::Node	access:public
cv::KDTree::Node::right	core/core.hpp	/^        int left, right;$/;"	m	struct:cv::KDTree::Node	access:public
cv::KDTree::build	core/core.hpp	/^    CV_WRAP void build(InputArray points, InputArray labels,$/;"	p	class:cv::KDTree	access:public	signature:(InputArray points, InputArray labels, bool copyAndReorderPoints=false)
cv::KDTree::build	core/core.hpp	/^    CV_WRAP void build(InputArray points, bool copyAndReorderPoints=false);$/;"	p	class:cv::KDTree	access:public	signature:(InputArray points, bool copyAndReorderPoints=false)
cv::KDTree::dims	core/core.hpp	/^    CV_WRAP int dims() const;$/;"	p	class:cv::KDTree	access:public	signature:() const
cv::KDTree::findNearest	core/core.hpp	/^    CV_WRAP int findNearest(InputArray vec, int K, int Emax,$/;"	p	class:cv::KDTree	access:public	signature:(InputArray vec, int K, int Emax, OutputArray neighborsIdx, OutputArray neighbors=noArray(), OutputArray dist=noArray(), OutputArray labels=noArray()) const
cv::KDTree::findOrthoRange	core/core.hpp	/^    CV_WRAP void findOrthoRange(InputArray minBounds,$/;"	p	class:cv::KDTree	access:public	signature:(InputArray minBounds, InputArray maxBounds, OutputArray neighborsIdx, OutputArray neighbors=noArray(), OutputArray labels=noArray()) const
cv::KDTree::getPoint	core/core.hpp	/^    const float* getPoint(int ptidx, int* label=0) const;$/;"	p	class:cv::KDTree	access:public	signature:(int ptidx, int* label=0) const
cv::KDTree::getPoints	core/core.hpp	/^    CV_WRAP void getPoints(InputArray idx, OutputArray pts,$/;"	p	class:cv::KDTree	access:public	signature:(InputArray idx, OutputArray pts, OutputArray labels=noArray()) const
cv::KDTree::labels	core/core.hpp	/^    CV_PROP vector<int> labels; \/\/!< the parallel array of labels.$/;"	m	class:cv::KDTree	access:public
cv::KDTree::maxDepth	core/core.hpp	/^    CV_PROP int maxDepth; \/\/!< maximum depth of the search tree. Do not modify it$/;"	m	class:cv::KDTree	access:public
cv::KDTree::nodes	core/core.hpp	/^    vector<Node> nodes; \/\/!< all the tree nodes$/;"	m	class:cv::KDTree	access:public
cv::KDTree::normType	core/core.hpp	/^    CV_PROP_RW int normType; \/\/!< type of the distance (cv::NORM_L1 or cv::NORM_L2) used for search. Initially set to cv::NORM_L2, but you can modify it$/;"	m	class:cv::KDTree	access:public
cv::KDTree::points	core/core.hpp	/^    CV_PROP Mat points; \/\/!< all the points. It can be a reordered copy of the input vector set or the original vector set.$/;"	m	class:cv::KDTree	access:public
cv::KERNEL_ASYMMETRICAL	imgproc/imgproc.hpp	/^enum { KERNEL_GENERAL=0, KERNEL_SYMMETRICAL=1, KERNEL_ASYMMETRICAL=2,$/;"	e	enum:cv::__anon11
cv::KERNEL_GENERAL	imgproc/imgproc.hpp	/^enum { KERNEL_GENERAL=0, KERNEL_SYMMETRICAL=1, KERNEL_ASYMMETRICAL=2,$/;"	e	enum:cv::__anon11
cv::KERNEL_INTEGER	imgproc/imgproc.hpp	/^       KERNEL_SMOOTH=4, KERNEL_INTEGER=8 };$/;"	e	enum:cv::__anon11
cv::KERNEL_SMOOTH	imgproc/imgproc.hpp	/^       KERNEL_SMOOTH=4, KERNEL_INTEGER=8 };$/;"	e	enum:cv::__anon11
cv::KERNEL_SYMMETRICAL	imgproc/imgproc.hpp	/^enum { KERNEL_GENERAL=0, KERNEL_SYMMETRICAL=1, KERNEL_ASYMMETRICAL=2,$/;"	e	enum:cv::__anon11
cv::KMEANS_PP_CENTERS	core/core.hpp	/^    KMEANS_PP_CENTERS=2,     \/\/ Uses k-Means++ algorithm for initialization$/;"	e	enum:cv::__anon143
cv::KMEANS_RANDOM_CENTERS	core/core.hpp	/^    KMEANS_RANDOM_CENTERS=0, \/\/ Chooses random centers for k-Means initialization$/;"	e	enum:cv::__anon143
cv::KMEANS_USE_INITIAL_LABELS	core/core.hpp	/^    KMEANS_USE_INITIAL_LABELS=1 \/\/ Uses the user-provided labels for K-Means initialization$/;"	e	enum:cv::__anon143
cv::KNearest	ml/ml.hpp	/^typedef CvKNearest KNearest;$/;"	t	namespace:cv
cv::KalmanFilter	video/tracking.hpp	/^class CV_EXPORTS_W KalmanFilter$/;"	c	namespace:cv
cv::KalmanFilter::KalmanFilter	video/tracking.hpp	/^    CV_WRAP KalmanFilter();$/;"	p	class:cv::KalmanFilter	access:public	signature:()
cv::KalmanFilter::KalmanFilter	video/tracking.hpp	/^    CV_WRAP KalmanFilter(int dynamParams, int measureParams, int controlParams=0, int type=CV_32F);$/;"	p	class:cv::KalmanFilter	access:public	signature:(int dynamParams, int measureParams, int controlParams=0, int type=CV_32F)
cv::KalmanFilter::controlMatrix	video/tracking.hpp	/^    Mat controlMatrix;      \/\/!< control matrix (B) (not used if there is no control)$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::correct	video/tracking.hpp	/^    CV_WRAP const Mat& correct(const Mat& measurement);$/;"	p	class:cv::KalmanFilter	access:public	signature:(const Mat& measurement)
cv::KalmanFilter::errorCovPost	video/tracking.hpp	/^    Mat errorCovPost;       \/\/!< posteriori error estimate covariance matrix (P(k)): P(k)=(I-K(k)*H)*P'(k)$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::errorCovPre	video/tracking.hpp	/^    Mat errorCovPre;        \/\/!< priori error estimate covariance matrix (P'(k)): P'(k)=A*P(k-1)*At + Q)*\/$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::gain	video/tracking.hpp	/^    Mat gain;               \/\/!< Kalman gain matrix (K(k)): K(k)=P'(k)*Ht*inv(H*P'(k)*Ht+R)$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::init	video/tracking.hpp	/^    void init(int dynamParams, int measureParams, int controlParams=0, int type=CV_32F);$/;"	p	class:cv::KalmanFilter	access:public	signature:(int dynamParams, int measureParams, int controlParams=0, int type=CV_32F)
cv::KalmanFilter::measurementMatrix	video/tracking.hpp	/^    Mat measurementMatrix;  \/\/!< measurement matrix (H)$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::measurementNoiseCov	video/tracking.hpp	/^    Mat measurementNoiseCov;\/\/!< measurement noise covariance matrix (R)$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::predict	video/tracking.hpp	/^    CV_WRAP const Mat& predict(const Mat& control=Mat());$/;"	p	class:cv::KalmanFilter	access:public	signature:(const Mat& control=Mat())
cv::KalmanFilter::processNoiseCov	video/tracking.hpp	/^    Mat processNoiseCov;    \/\/!< process noise covariance matrix (Q)$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::statePost	video/tracking.hpp	/^    Mat statePost;          \/\/!< corrected state (x(k)): x(k)=x'(k)+K(k)*(z(k)-H*x'(k))$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::statePre	video/tracking.hpp	/^    Mat statePre;           \/\/!< predicted state (x'(k)): x(k)=A*x(k-1)+B*u(k)$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::temp1	video/tracking.hpp	/^    Mat temp1;$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::temp2	video/tracking.hpp	/^    Mat temp2;$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::temp3	video/tracking.hpp	/^    Mat temp3;$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::temp4	video/tracking.hpp	/^    Mat temp4;$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::temp5	video/tracking.hpp	/^    Mat temp5;$/;"	m	class:cv::KalmanFilter	access:public
cv::KalmanFilter::transitionMatrix	video/tracking.hpp	/^    Mat transitionMatrix;   \/\/!< state transition matrix (A)$/;"	m	class:cv::KalmanFilter	access:public
cv::KeyPoint	features2d/features2d.hpp	/^class CV_EXPORTS_W_SIMPLE KeyPoint$/;"	c	namespace:cv
cv::KeyPoint::KeyPoint	features2d/features2d.hpp	/^    CV_WRAP KeyPoint() : pt(0,0), size(0), angle(-1), response(0), octave(0), class_id(-1) {}$/;"	f	class:cv::KeyPoint	access:public	signature:()
cv::KeyPoint::KeyPoint	features2d/features2d.hpp	/^    CV_WRAP KeyPoint(float x, float y, float _size, float _angle=-1,$/;"	f	class:cv::KeyPoint	access:public	signature:(float x, float y, float _size, float _angle=-1, float _response=0, int _octave=0, int _class_id=-1)
cv::KeyPoint::KeyPoint	features2d/features2d.hpp	/^    KeyPoint(Point2f _pt, float _size, float _angle=-1,$/;"	f	class:cv::KeyPoint	access:public	signature:(Point2f _pt, float _size, float _angle=-1, float _response=0, int _octave=0, int _class_id=-1)
cv::KeyPoint::angle	features2d/features2d.hpp	/^    CV_PROP_RW float angle; \/\/!< computed orientation of the keypoint (-1 if not applicable)$/;"	m	class:cv::KeyPoint	access:public
cv::KeyPoint::class_id	features2d/features2d.hpp	/^    CV_PROP_RW int class_id; \/\/!< object class (if the keypoints need to be clustered by an object they belong to) $/;"	m	class:cv::KeyPoint	access:public
cv::KeyPoint::convert	features2d/features2d.hpp	/^    static void convert(const std::vector<KeyPoint>& keypoints,$/;"	p	class:cv::KeyPoint	access:public	signature:(const std::vector<KeyPoint>& keypoints, CV_OUT std::vector<Point2f>& points2f, const std::vector<int>& keypointIndexes=std::vector<int>())
cv::KeyPoint::convert	features2d/features2d.hpp	/^    static void convert(const std::vector<Point2f>& points2f,$/;"	p	class:cv::KeyPoint	access:public	signature:(const std::vector<Point2f>& points2f, CV_OUT std::vector<KeyPoint>& keypoints, float size=1, float response=1, int octave=0, int class_id=-1)
cv::KeyPoint::hash	features2d/features2d.hpp	/^    size_t hash() const;$/;"	p	class:cv::KeyPoint	access:public	signature:() const
cv::KeyPoint::octave	features2d/features2d.hpp	/^    CV_PROP_RW int octave; \/\/!< octave (pyramid layer) from which the keypoint has been extracted$/;"	m	class:cv::KeyPoint	access:public
cv::KeyPoint::overlap	features2d/features2d.hpp	/^    static float overlap(const KeyPoint& kp1, const KeyPoint& kp2);$/;"	p	class:cv::KeyPoint	access:public	signature:(const KeyPoint& kp1, const KeyPoint& kp2)
cv::KeyPoint::pt	features2d/features2d.hpp	/^    CV_PROP_RW Point2f pt; \/\/!< coordinates of the keypoints$/;"	m	class:cv::KeyPoint	access:public
cv::KeyPoint::response	features2d/features2d.hpp	/^    CV_PROP_RW float response; \/\/!< the response by which the most strong keypoints have been selected. Can be used for the further sorting or subsampling$/;"	m	class:cv::KeyPoint	access:public
cv::KeyPoint::size	features2d/features2d.hpp	/^    CV_PROP_RW float size; \/\/!< diameter of the meaningful keypoint neighborhood$/;"	m	class:cv::KeyPoint	access:public
cv::KeyPointsFilter	features2d/features2d.hpp	/^class CV_EXPORTS KeyPointsFilter$/;"	c	namespace:cv
cv::KeyPointsFilter::KeyPointsFilter	features2d/features2d.hpp	/^    KeyPointsFilter(){}$/;"	f	class:cv::KeyPointsFilter	access:public	signature:()
cv::KeyPointsFilter::removeDuplicated	features2d/features2d.hpp	/^    static void removeDuplicated( vector<KeyPoint>& keypoints );$/;"	p	class:cv::KeyPointsFilter	access:public	signature:( vector<KeyPoint>& keypoints )
cv::KeyPointsFilter::runByImageBorder	features2d/features2d.hpp	/^    static void runByImageBorder( vector<KeyPoint>& keypoints, Size imageSize, int borderSize );$/;"	p	class:cv::KeyPointsFilter	access:public	signature:( vector<KeyPoint>& keypoints, Size imageSize, int borderSize )
cv::KeyPointsFilter::runByKeypointSize	features2d/features2d.hpp	/^    static void runByKeypointSize( vector<KeyPoint>& keypoints, float minSize, float maxSize=std::numeric_limits<float>::max() );$/;"	p	class:cv::KeyPointsFilter	access:public	signature:( vector<KeyPoint>& keypoints, float minSize, float maxSize=std::numeric_limits<float>::max() )
cv::KeyPointsFilter::runByPixelsMask	features2d/features2d.hpp	/^    static void runByPixelsMask( vector<KeyPoint>& keypoints, const Mat& mask );$/;"	p	class:cv::KeyPointsFilter	access:public	signature:( vector<KeyPoint>& keypoints, const Mat& mask )
cv::L1	features2d/features2d.hpp	/^struct CV_EXPORTS L1$/;"	s	namespace:cv
cv::L1::ResultType	features2d/features2d.hpp	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cv::L1	access:public
cv::L1::ValueType	features2d/features2d.hpp	/^    typedef T ValueType;$/;"	t	struct:cv::L1	access:public
cv::L1::operator ()	features2d/features2d.hpp	/^    ResultType operator()( const T* a, const T* b, int size ) const$/;"	f	struct:cv::L1	access:public	signature:( const T* a, const T* b, int size ) const
cv::L2	features2d/features2d.hpp	/^struct CV_EXPORTS L2$/;"	s	namespace:cv
cv::L2::ResultType	features2d/features2d.hpp	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cv::L2	access:public
cv::L2::ValueType	features2d/features2d.hpp	/^    typedef T ValueType;$/;"	t	struct:cv::L2	access:public
cv::L2::operator ()	features2d/features2d.hpp	/^    ResultType operator()( const T* a, const T* b, int size ) const$/;"	f	struct:cv::L2	access:public	signature:( const T* a, const T* b, int size ) const
cv::LDetector	features2d/features2d.hpp	/^class CV_EXPORTS LDetector$/;"	c	namespace:cv
cv::LDetector::LDetector	features2d/features2d.hpp	/^    LDetector();$/;"	p	class:cv::LDetector	access:public	signature:()
cv::LDetector::LDetector	features2d/features2d.hpp	/^    LDetector(int _radius, int _threshold, int _nOctaves,$/;"	p	class:cv::LDetector	access:public	signature:(int _radius, int _threshold, int _nOctaves, int _nViews, double _baseFeatureSize, double _clusteringDistance)
cv::LDetector::baseFeatureSize	features2d/features2d.hpp	/^    double baseFeatureSize;$/;"	m	class:cv::LDetector	access:public
cv::LDetector::clusteringDistance	features2d/features2d.hpp	/^    double clusteringDistance;$/;"	m	class:cv::LDetector	access:public
cv::LDetector::getMostStable2D	features2d/features2d.hpp	/^    void getMostStable2D(const Mat& image, CV_OUT vector<KeyPoint>& keypoints,$/;"	p	class:cv::LDetector	access:public	signature:(const Mat& image, CV_OUT vector<KeyPoint>& keypoints, int maxCount, const PatchGenerator& patchGenerator) const
cv::LDetector::nOctaves	features2d/features2d.hpp	/^    int nOctaves;$/;"	m	class:cv::LDetector	access:public
cv::LDetector::nViews	features2d/features2d.hpp	/^    int nViews;$/;"	m	class:cv::LDetector	access:public
cv::LDetector::operator ()	features2d/features2d.hpp	/^    void operator()(const Mat& image,$/;"	p	class:cv::LDetector	access:public	signature:(const Mat& image, CV_OUT vector<KeyPoint>& keypoints, int maxCount=0, bool scaleCoords=true) const
cv::LDetector::operator ()	features2d/features2d.hpp	/^    void operator()(const vector<Mat>& pyr,$/;"	p	class:cv::LDetector	access:public	signature:(const vector<Mat>& pyr, CV_OUT vector<KeyPoint>& keypoints, int maxCount=0, bool scaleCoords=true) const
cv::LDetector::radius	features2d/features2d.hpp	/^    int radius;$/;"	m	class:cv::LDetector	access:public
cv::LDetector::read	features2d/features2d.hpp	/^    void read(const FileNode& node);$/;"	p	class:cv::LDetector	access:public	signature:(const FileNode& node)
cv::LDetector::setVerbose	features2d/features2d.hpp	/^    void setVerbose(bool verbose);$/;"	p	class:cv::LDetector	access:public	signature:(bool verbose)
cv::LDetector::threshold	features2d/features2d.hpp	/^    int threshold;$/;"	m	class:cv::LDetector	access:public
cv::LDetector::verbose	features2d/features2d.hpp	/^    bool verbose;$/;"	m	class:cv::LDetector	access:public
cv::LDetector::write	features2d/features2d.hpp	/^    void write(FileStorage& fs, const String& name=String()) const;$/;"	p	class:cv::LDetector	access:public	signature:(FileStorage& fs, const String& name=String()) const
cv::LMEDS	calib3d/calib3d.hpp	/^    LMEDS=CV_LMEDS, \/\/!< least-median algorithm$/;"	e	enum:cv::__anon87
cv::LU	core/operations.hpp	/^CV_EXPORTS int LU(double* A, size_t astep, int m, double* b, size_t bstep, int n);$/;"	p	namespace:cv	signature:(double* A, size_t astep, int m, double* b, size_t bstep, int n)
cv::LU	core/operations.hpp	/^CV_EXPORTS int LU(float* A, size_t astep, int m, float* b, size_t bstep, int n);$/;"	p	namespace:cv	signature:(float* A, size_t astep, int m, float* b, size_t bstep, int n)
cv::LUT	core/core.hpp	/^CV_EXPORTS_W void LUT(InputArray src, InputArray lut, OutputArray dst,$/;"	p	namespace:cv	signature:(InputArray src, InputArray lut, OutputArray dst, int interpolation=0)
cv::Laplacian	imgproc/imgproc.hpp	/^CV_EXPORTS_W void Laplacian( InputArray src, OutputArray dst, int ddepth,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int ddepth, int ksize=1, double scale=1, double delta=0, int borderType=BORDER_DEFAULT )
cv::LessThan	core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS LessThan$/;"	c	namespace:cv
cv::LessThan::operator ()	core/operations.hpp	/^    bool operator()(const _Tp& a, const _Tp& b) const { return a < b; }$/;"	f	class:cv::LessThan	access:public	signature:(const _Tp& a, const _Tp& b) const
cv::LessThanIdx	core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS LessThanIdx$/;"	c	namespace:cv
cv::LessThanIdx::LessThanIdx	core/operations.hpp	/^    LessThanIdx( const _Tp* _arr ) : arr(_arr) {}$/;"	f	class:cv::LessThanIdx	access:public	signature:( const _Tp* _arr )
cv::LessThanIdx::arr	core/operations.hpp	/^    const _Tp* arr;$/;"	m	class:cv::LessThanIdx	access:public
cv::LessThanIdx::operator ()	core/operations.hpp	/^    bool operator()(int a, int b) const { return arr[a] < arr[b]; }$/;"	f	class:cv::LessThanIdx	access:public	signature:(int a, int b) const
cv::LevMarqSparse	contrib/contrib.hpp	/^    class LevMarqSparse {$/;"	c	namespace:cv
cv::LevMarqSparse::A	contrib/contrib.hpp	/^        CvMat** A;$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::B	contrib/contrib.hpp	/^        CvMat** B;$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::JtJ_diag	contrib/contrib.hpp	/^        CvMat* JtJ_diag; \/\/diagonal of JtJ,  used to backup diagonal elements before augmentation$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::LevMarqSparse	contrib/contrib.hpp	/^        LevMarqSparse();$/;"	p	class:cv::LevMarqSparse	access:public	signature:()
cv::LevMarqSparse::LevMarqSparse	contrib/contrib.hpp	/^        LevMarqSparse(int npoints, \/\/ number of points$/;"	p	class:cv::LevMarqSparse	access:public	signature:(int npoints, int ncameras, int nPointParams, int nCameraParams, int nErrParams, Mat& visibility, Mat& P0, Mat& X, TermCriteria criteria, void (CV_CDECL * fjac)(int i, int j, Mat& point_params, Mat& cam_params, Mat& A, Mat& B, void* data), void (CV_CDECL * func)(int i, int j, Mat& point_params, Mat& cam_params, Mat& estim, void* data), void* data, BundleAdjustCallback cb, void* user_data )
cv::LevMarqSparse::P	contrib/contrib.hpp	/^        CvMat* P; \/\/ parameters used to evaluate function with new params$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::S	contrib/contrib.hpp	/^        CvMat* S; \/\/big matrix of block Sjk  , each block has size num_cam_params x num_cam_params $/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::U	contrib/contrib.hpp	/^        CvMat** U; \/\/size of array is equal to number of cameras$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::V	contrib/contrib.hpp	/^        CvMat** V; \/\/size of array is equal to number of points$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::Vis_index	contrib/contrib.hpp	/^        CvMat* Vis_index; \/\/ matrix which element is index of measurement for point i and camera j$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::W	contrib/contrib.hpp	/^        CvMat** W;$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::X	contrib/contrib.hpp	/^        CvMat* X; \/\/measurement $/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::Yj	contrib/contrib.hpp	/^        CvMat** Yj; \/\/length of array is i = num_points$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::ask_for_proj	contrib/contrib.hpp	/^        void ask_for_proj(CvMat &_vis,bool once=false);$/;"	p	class:cv::LevMarqSparse	access:public	signature:(CvMat &_vis,bool once=false)
cv::LevMarqSparse::ask_for_projac	contrib/contrib.hpp	/^        void ask_for_projac(CvMat &_vis);$/;"	p	class:cv::LevMarqSparse	access:public	signature:(CvMat &_vis)
cv::LevMarqSparse::bundleAdjust	contrib/contrib.hpp	/^        static void bundleAdjust(vector<Point3d>& points, \/\/ positions of points in global coordinate system (input and output)$/;"	p	class:cv::LevMarqSparse	access:public	signature:(vector<Point3d>& points, const vector<vector<Point2d> >& imagePoints, const vector<vector<int> >& visibility, vector<Mat>& cameraMatrix, vector<Mat>& R, vector<Mat>& T, vector<Mat>& distCoeffs, const TermCriteria& criteria= TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, DBL_EPSILON), BundleAdjustCallback cb = 0, void* user_data = 0)
cv::LevMarqSparse::cb	contrib/contrib.hpp	/^        BundleAdjustCallback cb;$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::clear	contrib/contrib.hpp	/^        virtual void clear();$/;"	p	class:cv::LevMarqSparse	access:public	signature:()
cv::LevMarqSparse::criteria	contrib/contrib.hpp	/^        CvTermCriteria criteria;$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::data	contrib/contrib.hpp	/^        void* data;$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::deltaP	contrib/contrib.hpp	/^        CvMat* deltaP; \/\/computed increase of parameters (result of normal system solution )$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::ea	contrib/contrib.hpp	/^        CvMat** ea; \/\/ sum_i  AijT * e_ij , used as right part of normal equation$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::eb	contrib/contrib.hpp	/^        CvMat** eb; \/\/ sum_j  BijT * e_ij , used as right part of normal equation$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::err	contrib/contrib.hpp	/^        CvMat* err; \/\/error X-hX$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::errNorm	contrib/contrib.hpp	/^        double prevErrNorm, errNorm;$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::fjac	contrib/contrib.hpp	/^        void (*fjac)(int i, int j, Mat& point_params, Mat& cam_params, Mat& A, Mat& B, void* data);$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::func	contrib/contrib.hpp	/^        void (*func)(int i, int j, Mat& point_params, Mat& cam_params, Mat& estim, void* data);$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::hX	contrib/contrib.hpp	/^        CvMat* hX; \/\/current measurement extimation given new parameter vector $/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::inv_V_star	contrib/contrib.hpp	/^        CvMat** inv_V_star; \/\/inverse of V*$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::iters	contrib/contrib.hpp	/^        int iters;$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::lambda	contrib/contrib.hpp	/^        double lambda;$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::num_cam_param	contrib/contrib.hpp	/^        int num_cam_param;$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::num_cams	contrib/contrib.hpp	/^        int num_cams;$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::num_err_param	contrib/contrib.hpp	/^        int num_err_param;$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::num_point_param	contrib/contrib.hpp	/^        int num_point_param;$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::num_points	contrib/contrib.hpp	/^        int num_points;$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::optimize	contrib/contrib.hpp	/^        virtual void optimize(CvMat &_vis); \/\/main function that runs minimization$/;"	p	class:cv::LevMarqSparse	access:public	signature:(CvMat &_vis)
cv::LevMarqSparse::prevErrNorm	contrib/contrib.hpp	/^        double prevErrNorm, errNorm;$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::prevP	contrib/contrib.hpp	/^        CvMat* prevP; \/\/current already accepted parameter. $/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::run	contrib/contrib.hpp	/^        virtual void run( int npoints, \/\/ number of points$/;"	p	class:cv::LevMarqSparse	access:public	signature:( int npoints, int ncameras, int nPointParams, int nCameraParams, int nErrParams, Mat& visibility, Mat& P0, Mat& X, TermCriteria criteria, void (CV_CDECL * fjac)(int i, int j, Mat& point_params, Mat& cam_params, Mat& A, Mat& B, void* data), void (CV_CDECL * func)(int i, int j, Mat& point_params, Mat& cam_params, Mat& estim, void* data), void* data )
cv::LevMarqSparse::user_data	contrib/contrib.hpp	/^        void* user_data;$/;"	m	class:cv::LevMarqSparse	access:public
cv::LevMarqSparse::~LevMarqSparse	contrib/contrib.hpp	/^        virtual ~LevMarqSparse();$/;"	p	class:cv::LevMarqSparse	access:public	signature:()
cv::LineIterator	core/core.hpp	/^class CV_EXPORTS LineIterator$/;"	c	namespace:cv
cv::LineIterator::LineIterator	core/core.hpp	/^    LineIterator( const Mat& img, Point pt1, Point pt2,$/;"	p	class:cv::LineIterator	access:public	signature:( const Mat& img, Point pt1, Point pt2, int connectivity=8, bool leftToRight=false )
cv::LineIterator::count	core/core.hpp	/^    int err, count;$/;"	m	class:cv::LineIterator	access:public
cv::LineIterator::elemSize	core/core.hpp	/^    int step, elemSize;$/;"	m	class:cv::LineIterator	access:public
cv::LineIterator::err	core/core.hpp	/^    int err, count;$/;"	m	class:cv::LineIterator	access:public
cv::LineIterator::minusDelta	core/core.hpp	/^    int minusDelta, plusDelta;$/;"	m	class:cv::LineIterator	access:public
cv::LineIterator::minusStep	core/core.hpp	/^    int minusStep, plusStep;$/;"	m	class:cv::LineIterator	access:public
cv::LineIterator::operator *	core/core.hpp	/^    uchar* operator *();$/;"	p	class:cv::LineIterator	access:public	signature:()
cv::LineIterator::operator *	core/operations.hpp	/^inline uchar* LineIterator::operator *() { return ptr; }$/;"	f	class:cv::LineIterator	signature:()
cv::LineIterator::operator ++	core/core.hpp	/^    LineIterator operator ++(int);$/;"	p	class:cv::LineIterator	access:public	signature:(int)
cv::LineIterator::operator ++	core/core.hpp	/^    LineIterator& operator ++();$/;"	p	class:cv::LineIterator	access:public	signature:()
cv::LineIterator::operator ++	core/operations.hpp	/^inline LineIterator LineIterator::operator ++(int)$/;"	f	class:cv::LineIterator	signature:(int)
cv::LineIterator::operator ++	core/operations.hpp	/^inline LineIterator& LineIterator::operator ++()$/;"	f	class:cv::LineIterator	signature:()
cv::LineIterator::plusDelta	core/core.hpp	/^    int minusDelta, plusDelta;$/;"	m	class:cv::LineIterator	access:public
cv::LineIterator::plusStep	core/core.hpp	/^    int minusStep, plusStep;$/;"	m	class:cv::LineIterator	access:public
cv::LineIterator::pos	core/core.hpp	/^    Point pos() const;$/;"	p	class:cv::LineIterator	access:public	signature:() const
cv::LineIterator::pos	core/operations.hpp	/^inline Point LineIterator::pos() const$/;"	f	class:cv::LineIterator	signature:() const
cv::LineIterator::ptr	core/core.hpp	/^    uchar* ptr;$/;"	m	class:cv::LineIterator	access:public
cv::LineIterator::ptr0	core/core.hpp	/^    const uchar* ptr0;$/;"	m	class:cv::LineIterator	access:public
cv::LineIterator::step	core/core.hpp	/^    int step, elemSize;$/;"	m	class:cv::LineIterator	access:public
cv::MAGIC_MASK	core/core.hpp	/^enum { MAGIC_MASK=0xFFFF0000, TYPE_MASK=0x00000FFF, DEPTH_MASK=7 };$/;"	e	enum:cv::__anon136
cv::MORPH_BLACKHAT	imgproc/imgproc.hpp	/^       MORPH_BLACKHAT=CV_MOP_BLACKHAT };$/;"	e	enum:cv::__anon12
cv::MORPH_CLOSE	imgproc/imgproc.hpp	/^       MORPH_OPEN=CV_MOP_OPEN, MORPH_CLOSE=CV_MOP_CLOSE,$/;"	e	enum:cv::__anon12
cv::MORPH_CROSS	imgproc/imgproc.hpp	/^enum { MORPH_RECT=0, MORPH_CROSS=1, MORPH_ELLIPSE=2 };$/;"	e	enum:cv::__anon13
cv::MORPH_DILATE	imgproc/imgproc.hpp	/^enum { MORPH_ERODE=CV_MOP_ERODE, MORPH_DILATE=CV_MOP_DILATE,$/;"	e	enum:cv::__anon12
cv::MORPH_ELLIPSE	imgproc/imgproc.hpp	/^enum { MORPH_RECT=0, MORPH_CROSS=1, MORPH_ELLIPSE=2 };$/;"	e	enum:cv::__anon13
cv::MORPH_ERODE	imgproc/imgproc.hpp	/^enum { MORPH_ERODE=CV_MOP_ERODE, MORPH_DILATE=CV_MOP_DILATE,$/;"	e	enum:cv::__anon12
cv::MORPH_GRADIENT	imgproc/imgproc.hpp	/^       MORPH_GRADIENT=CV_MOP_GRADIENT, MORPH_TOPHAT=CV_MOP_TOPHAT,$/;"	e	enum:cv::__anon12
cv::MORPH_OPEN	imgproc/imgproc.hpp	/^       MORPH_OPEN=CV_MOP_OPEN, MORPH_CLOSE=CV_MOP_CLOSE,$/;"	e	enum:cv::__anon12
cv::MORPH_RECT	imgproc/imgproc.hpp	/^enum { MORPH_RECT=0, MORPH_CROSS=1, MORPH_ELLIPSE=2 };$/;"	e	enum:cv::__anon13
cv::MORPH_TOPHAT	imgproc/imgproc.hpp	/^       MORPH_GRADIENT=CV_MOP_GRADIENT, MORPH_TOPHAT=CV_MOP_TOPHAT,$/;"	e	enum:cv::__anon12
cv::MSER	features2d/features2d.hpp	/^class CV_EXPORTS_W MSER : public CvMSERParams$/;"	c	namespace:cv	inherits:CvMSERParams
cv::MSER::MSER	features2d/features2d.hpp	/^    CV_WRAP MSER( int _delta, int _min_area, int _max_area,$/;"	p	class:cv::MSER	access:public	signature:( int _delta, int _min_area, int _max_area, double _max_variation, double _min_diversity, int _max_evolution, double _area_threshold, double _min_margin, int _edge_blur_size )
cv::MSER::MSER	features2d/features2d.hpp	/^    CV_WRAP MSER();$/;"	p	class:cv::MSER	access:public	signature:()
cv::MSER::operator ()	features2d/features2d.hpp	/^    CV_WRAP_AS(detect) void operator()( const Mat& image,$/;"	p	class:cv::MSER	access:public	signature:( const Mat& image, CV_OUT vector<vector<Point> >& msers, const Mat& mask ) const
cv::Mahalanobis	core/core.hpp	/^CV_EXPORTS_W double Mahalanobis(InputArray v1, InputArray v2, InputArray icovar);$/;"	p	namespace:cv	signature:(InputArray v1, InputArray v2, InputArray icovar)
cv::Mahalonobis	core/core.hpp	/^CV_EXPORTS double Mahalonobis(InputArray v1, InputArray v2, InputArray icovar);$/;"	p	namespace:cv	signature:(InputArray v1, InputArray v2, InputArray icovar)
cv::Mat	core/core.hpp	/^class CV_EXPORTS Mat$/;"	c	namespace:cv
cv::Mat1b	core/core.hpp	/^typedef Mat_<uchar> Mat1b;$/;"	t	namespace:cv
cv::Mat1d	core/core.hpp	/^typedef Mat_<double> Mat1d;$/;"	t	namespace:cv
cv::Mat1f	core/core.hpp	/^typedef Mat_<float> Mat1f;$/;"	t	namespace:cv
cv::Mat1i	core/core.hpp	/^typedef Mat_<int>   Mat1i;$/;"	t	namespace:cv
cv::Mat1s	core/core.hpp	/^typedef Mat_<short> Mat1s;$/;"	t	namespace:cv
cv::Mat1w	core/core.hpp	/^typedef Mat_<ushort> Mat1w;$/;"	t	namespace:cv
cv::Mat2b	core/core.hpp	/^typedef Mat_<Vec2b> Mat2b;$/;"	t	namespace:cv
cv::Mat2d	core/core.hpp	/^typedef Mat_<Vec2d> Mat2d;$/;"	t	namespace:cv
cv::Mat2f	core/core.hpp	/^typedef Mat_<Vec2f> Mat2f;$/;"	t	namespace:cv
cv::Mat2i	core/core.hpp	/^typedef Mat_<Vec2i> Mat2i;$/;"	t	namespace:cv
cv::Mat2s	core/core.hpp	/^typedef Mat_<Vec2s> Mat2s;$/;"	t	namespace:cv
cv::Mat2w	core/core.hpp	/^typedef Mat_<Vec2w> Mat2w;$/;"	t	namespace:cv
cv::Mat3b	core/core.hpp	/^typedef Mat_<Vec3b> Mat3b;$/;"	t	namespace:cv
cv::Mat3d	core/core.hpp	/^typedef Mat_<Vec3d> Mat3d;$/;"	t	namespace:cv
cv::Mat3f	core/core.hpp	/^typedef Mat_<Vec3f> Mat3f;$/;"	t	namespace:cv
cv::Mat3i	core/core.hpp	/^typedef Mat_<Vec3i> Mat3i;$/;"	t	namespace:cv
cv::Mat3s	core/core.hpp	/^typedef Mat_<Vec3s> Mat3s;$/;"	t	namespace:cv
cv::Mat3w	core/core.hpp	/^typedef Mat_<Vec3w> Mat3w;$/;"	t	namespace:cv
cv::Mat4b	core/core.hpp	/^typedef Mat_<Vec4b> Mat4b;$/;"	t	namespace:cv
cv::Mat4d	core/core.hpp	/^typedef Mat_<Vec4d> Mat4d;$/;"	t	namespace:cv
cv::Mat4f	core/core.hpp	/^typedef Mat_<Vec4f> Mat4f;$/;"	t	namespace:cv
cv::Mat4i	core/core.hpp	/^typedef Mat_<Vec4i> Mat4i;$/;"	t	namespace:cv
cv::Mat4s	core/core.hpp	/^typedef Mat_<Vec4s> Mat4s;$/;"	t	namespace:cv
cv::Mat4w	core/core.hpp	/^typedef Mat_<Vec4w> Mat4w;$/;"	t	namespace:cv
cv::Mat::AUTO_STEP	core/core.hpp	/^    enum { MAGIC_VAL=0x42FF0000, AUTO_STEP=0, CONTINUOUS_FLAG=CV_MAT_CONT_FLAG, SUBMATRIX_FLAG=CV_SUBMAT_FLAG };$/;"	e	enum:cv::Mat::__anon137
cv::Mat::CONTINUOUS_FLAG	core/core.hpp	/^    enum { MAGIC_VAL=0x42FF0000, AUTO_STEP=0, CONTINUOUS_FLAG=CV_MAT_CONT_FLAG, SUBMATRIX_FLAG=CV_SUBMAT_FLAG };$/;"	e	enum:cv::Mat::__anon137
cv::Mat::MAGIC_VAL	core/core.hpp	/^    enum { MAGIC_VAL=0x42FF0000, AUTO_STEP=0, CONTINUOUS_FLAG=CV_MAT_CONT_FLAG, SUBMATRIX_FLAG=CV_SUBMAT_FLAG };$/;"	e	enum:cv::Mat::__anon137
cv::Mat::MSize	core/core.hpp	/^    struct CV_EXPORTS MSize$/;"	s	class:cv::Mat	access:public
cv::Mat::MSize::MSize	core/core.hpp	/^        MSize(int* _p);$/;"	p	struct:cv::Mat::MSize	access:public	signature:(int* _p)
cv::Mat::MSize::MSize	core/mat.hpp	/^inline Mat::MSize::MSize(int* _p) : p(_p) {}$/;"	f	class:cv::Mat::MSize	signature:(int* _p)
cv::Mat::MSize::operator !=	core/core.hpp	/^        bool operator != (const MSize& sz) const;$/;"	p	struct:cv::Mat::MSize	access:public	signature:(const MSize& sz) const
cv::Mat::MSize::operator !=	core/mat.hpp	/^inline bool Mat::MSize::operator != (const MSize& sz) const$/;"	f	class:cv::Mat::MSize	signature:(const MSize& sz) const
cv::Mat::MSize::operator ()	core/core.hpp	/^        Size operator()() const;$/;"	p	struct:cv::Mat::MSize	access:public	signature:() const
cv::Mat::MSize::operator ()	core/mat.hpp	/^inline Size Mat::MSize::operator()() const$/;"	f	class:cv::Mat::MSize	signature:() const
cv::Mat::MSize::operator ==	core/core.hpp	/^        bool operator == (const MSize& sz) const;$/;"	p	struct:cv::Mat::MSize	access:public	signature:(const MSize& sz) const
cv::Mat::MSize::operator ==	core/mat.hpp	/^inline bool Mat::MSize::operator == (const MSize& sz) const$/;"	f	class:cv::Mat::MSize	signature:(const MSize& sz) const
cv::Mat::MSize::operator []	core/core.hpp	/^        const int& operator[](int i) const;$/;"	p	struct:cv::Mat::MSize	access:public	signature:(int i) const
cv::Mat::MSize::operator []	core/core.hpp	/^        int& operator[](int i);$/;"	p	struct:cv::Mat::MSize	access:public	signature:(int i)
cv::Mat::MSize::operator []	core/mat.hpp	/^inline const int& Mat::MSize::operator[](int i) const { return p[i]; }$/;"	f	class:cv::Mat::MSize	signature:(int i) const
cv::Mat::MSize::operator []	core/mat.hpp	/^inline int& Mat::MSize::operator[](int i) { return p[i]; }$/;"	f	class:cv::Mat::MSize	signature:(int i)
cv::Mat::MSize::operator const int*	core/core.hpp	/^        operator const int*() const;$/;"	p	struct:cv::Mat::MSize	access:public	signature:() const
cv::Mat::MSize::operator const int*	core/mat.hpp	/^inline Mat::MSize::operator const int*() const { return p; }$/;"	f	class:cv::Mat::MSize	signature:() const
cv::Mat::MSize::p	core/core.hpp	/^        int* p;$/;"	m	struct:cv::Mat::MSize	access:public
cv::Mat::MStep	core/core.hpp	/^    struct CV_EXPORTS MStep$/;"	s	class:cv::Mat	access:public
cv::Mat::MStep::MStep	core/core.hpp	/^        MStep();$/;"	p	struct:cv::Mat::MStep	access:public	signature:()
cv::Mat::MStep::MStep	core/core.hpp	/^        MStep(size_t s);$/;"	p	struct:cv::Mat::MStep	access:public	signature:(size_t s)
cv::Mat::MStep::MStep	core/mat.hpp	/^inline Mat::MStep::MStep() { p = buf; p[0] = p[1] = 0; }$/;"	f	class:cv::Mat::MStep	signature:()
cv::Mat::MStep::MStep	core/mat.hpp	/^inline Mat::MStep::MStep(size_t s) { p = buf; p[0] = s; p[1] = 0; }$/;"	f	class:cv::Mat::MStep	signature:(size_t s)
cv::Mat::MStep::buf	core/core.hpp	/^        size_t buf[2];$/;"	m	struct:cv::Mat::MStep	access:public
cv::Mat::MStep::operator =	core/core.hpp	/^        MStep& operator = (const MStep&);$/;"	p	struct:cv::Mat::MStep	access:protected	signature:(const MStep&)
cv::Mat::MStep::operator =	core/core.hpp	/^        MStep& operator = (size_t s);$/;"	p	struct:cv::Mat::MStep	access:public	signature:(size_t s)
cv::Mat::MStep::operator =	core/mat.hpp	/^inline Mat::MStep& Mat::MStep::operator = (size_t s)$/;"	f	class:cv::Mat::MStep	signature:(size_t s)
cv::Mat::MStep::operator []	core/core.hpp	/^        const size_t& operator[](int i) const;$/;"	p	struct:cv::Mat::MStep	access:public	signature:(int i) const
cv::Mat::MStep::operator []	core/core.hpp	/^        size_t& operator[](int i);$/;"	p	struct:cv::Mat::MStep	access:public	signature:(int i)
cv::Mat::MStep::operator []	core/mat.hpp	/^inline const size_t& Mat::MStep::operator[](int i) const { return p[i]; }$/;"	f	class:cv::Mat::MStep	signature:(int i) const
cv::Mat::MStep::operator []	core/mat.hpp	/^inline size_t& Mat::MStep::operator[](int i) { return p[i]; }$/;"	f	class:cv::Mat::MStep	signature:(int i)
cv::Mat::MStep::operator size_t	core/core.hpp	/^        operator size_t() const;$/;"	p	struct:cv::Mat::MStep	access:public	signature:() const
cv::Mat::MStep::operator size_t	core/mat.hpp	/^inline Mat::MStep::operator size_t() const$/;"	f	class:cv::Mat::MStep	signature:() const
cv::Mat::MStep::p	core/core.hpp	/^        size_t* p;$/;"	m	struct:cv::Mat::MStep	access:public
cv::Mat::Mat	core/core.hpp	/^    Mat();$/;"	p	class:cv::Mat	access:public	signature:()
cv::Mat::Mat	core/core.hpp	/^    Mat(Size _size, int _type);$/;"	p	class:cv::Mat	access:public	signature:(Size _size, int _type)
cv::Mat::Mat	core/core.hpp	/^    Mat(Size _size, int _type, const Scalar& _s);$/;"	p	class:cv::Mat	access:public	signature:(Size _size, int _type, const Scalar& _s)
cv::Mat::Mat	core/core.hpp	/^    Mat(Size _size, int _type, void* _data, size_t _step=AUTO_STEP);$/;"	p	class:cv::Mat	access:public	signature:(Size _size, int _type, void* _data, size_t _step=AUTO_STEP)
cv::Mat::Mat	core/core.hpp	/^    Mat(const CvMat* m, bool copyData=false);$/;"	p	class:cv::Mat	access:public	signature:(const CvMat* m, bool copyData=false)
cv::Mat::Mat	core/core.hpp	/^    Mat(const CvMatND* m, bool copyData=false);$/;"	p	class:cv::Mat	access:public	signature:(const CvMatND* m, bool copyData=false)
cv::Mat::Mat	core/core.hpp	/^    Mat(const IplImage* img, bool copyData=false);$/;"	p	class:cv::Mat	access:public	signature:(const IplImage* img, bool copyData=false)
cv::Mat::Mat	core/core.hpp	/^    Mat(const Mat& m);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m)
cv::Mat::Mat	core/core.hpp	/^    Mat(const Mat& m, const Range& rowRange, const Range& colRange=Range::all());$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m, const Range& rowRange, const Range& colRange=Range::all())
cv::Mat::Mat	core/core.hpp	/^    Mat(const Mat& m, const Range* ranges);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m, const Range* ranges)
cv::Mat::Mat	core/core.hpp	/^    Mat(const Mat& m, const Rect& roi);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m, const Rect& roi)
cv::Mat::Mat	core/core.hpp	/^    Mat(int _ndims, const int* _sizes, int _type);$/;"	p	class:cv::Mat	access:public	signature:(int _ndims, const int* _sizes, int _type)
cv::Mat::Mat	core/core.hpp	/^    Mat(int _ndims, const int* _sizes, int _type, const Scalar& _s);$/;"	p	class:cv::Mat	access:public	signature:(int _ndims, const int* _sizes, int _type, const Scalar& _s)
cv::Mat::Mat	core/core.hpp	/^    Mat(int _ndims, const int* _sizes, int _type, void* _data, const size_t* _steps=0);$/;"	p	class:cv::Mat	access:public	signature:(int _ndims, const int* _sizes, int _type, void* _data, const size_t* _steps=0)
cv::Mat::Mat	core/core.hpp	/^    Mat(int _rows, int _cols, int _type);$/;"	p	class:cv::Mat	access:public	signature:(int _rows, int _cols, int _type)
cv::Mat::Mat	core/core.hpp	/^    Mat(int _rows, int _cols, int _type, const Scalar& _s);$/;"	p	class:cv::Mat	access:public	signature:(int _rows, int _cols, int _type, const Scalar& _s)
cv::Mat::Mat	core/core.hpp	/^    Mat(int _rows, int _cols, int _type, void* _data, size_t _step=AUTO_STEP);$/;"	p	class:cv::Mat	access:public	signature:(int _rows, int _cols, int _type, void* _data, size_t _step=AUTO_STEP)
cv::Mat::Mat	core/core.hpp	/^    template<typename _Tp, int m, int n> explicit Mat(const Matx<_Tp, m, n>& mtx,$/;"	p	class:cv::Mat	access:public	signature:(const Matx<_Tp, m, n>& mtx, bool copyData=true)
cv::Mat::Mat	core/core.hpp	/^    template<typename _Tp, int n> explicit Mat(const Vec<_Tp, n>& vec,$/;"	p	class:cv::Mat	access:public	signature:(const Vec<_Tp, n>& vec, bool copyData=true)
cv::Mat::Mat	core/core.hpp	/^    template<typename _Tp> explicit Mat(const MatCommaInitializer_<_Tp>& commaInitializer);$/;"	p	class:cv::Mat	access:public	signature:(const MatCommaInitializer_<_Tp>& commaInitializer)
cv::Mat::Mat	core/core.hpp	/^    template<typename _Tp> explicit Mat(const Point3_<_Tp>& pt, bool copyData=true);$/;"	p	class:cv::Mat	access:public	signature:(const Point3_<_Tp>& pt, bool copyData=true)
cv::Mat::Mat	core/core.hpp	/^    template<typename _Tp> explicit Mat(const Point_<_Tp>& pt, bool copyData=true);$/;"	p	class:cv::Mat	access:public	signature:(const Point_<_Tp>& pt, bool copyData=true)
cv::Mat::Mat	core/core.hpp	/^    template<typename _Tp> explicit Mat(const vector<_Tp>& vec, bool copyData=false);$/;"	p	class:cv::Mat	access:public	signature:(const vector<_Tp>& vec, bool copyData=false)
cv::Mat::Mat	core/mat.hpp	/^inline Mat::Mat()$/;"	f	class:cv::Mat	signature:()
cv::Mat::Mat	core/mat.hpp	/^inline Mat::Mat(Size _sz, int _type)$/;"	f	class:cv::Mat	signature:(Size _sz, int _type)
cv::Mat::Mat	core/mat.hpp	/^inline Mat::Mat(Size _sz, int _type, const Scalar& _s)$/;"	f	class:cv::Mat	signature:(Size _sz, int _type, const Scalar& _s)
cv::Mat::Mat	core/mat.hpp	/^inline Mat::Mat(Size _sz, int _type, void* _data, size_t _step)$/;"	f	class:cv::Mat	signature:(Size _sz, int _type, void* _data, size_t _step)
cv::Mat::Mat	core/mat.hpp	/^inline Mat::Mat(const CvMat* m, bool copyData)$/;"	f	class:cv::Mat	signature:(const CvMat* m, bool copyData)
cv::Mat::Mat	core/mat.hpp	/^inline Mat::Mat(const Mat& m)$/;"	f	class:cv::Mat	signature:(const Mat& m)
cv::Mat::Mat	core/mat.hpp	/^inline Mat::Mat(int _dims, const int* _sz, int _type)$/;"	f	class:cv::Mat	signature:(int _dims, const int* _sz, int _type)
cv::Mat::Mat	core/mat.hpp	/^inline Mat::Mat(int _dims, const int* _sz, int _type, const Scalar& _s)$/;"	f	class:cv::Mat	signature:(int _dims, const int* _sz, int _type, const Scalar& _s)
cv::Mat::Mat	core/mat.hpp	/^inline Mat::Mat(int _rows, int _cols, int _type)$/;"	f	class:cv::Mat	signature:(int _rows, int _cols, int _type)
cv::Mat::Mat	core/mat.hpp	/^inline Mat::Mat(int _rows, int _cols, int _type, const Scalar& _s)$/;"	f	class:cv::Mat	signature:(int _rows, int _cols, int _type, const Scalar& _s)
cv::Mat::Mat	core/mat.hpp	/^inline Mat::Mat(int _rows, int _cols, int _type, void* _data, size_t _step)$/;"	f	class:cv::Mat	signature:(int _rows, int _cols, int _type, void* _data, size_t _step)
cv::Mat::Mat	core/mat.hpp	/^template<typename _Tp, int m, int n> inline Mat::Mat(const Matx<_Tp,m,n>& M, bool copyData)$/;"	f	class:cv::Mat	signature:(const Matx<_Tp,m,n>& M, bool copyData)
cv::Mat::Mat	core/mat.hpp	/^template<typename _Tp, int n> inline Mat::Mat(const Vec<_Tp, n>& vec, bool copyData)$/;"	f	class:cv::Mat	signature:(const Vec<_Tp, n>& vec, bool copyData)
cv::Mat::Mat	core/mat.hpp	/^template<typename _Tp> inline Mat::Mat(const MatCommaInitializer_<_Tp>& commaInitializer)$/;"	f	class:cv::Mat	signature:(const MatCommaInitializer_<_Tp>& commaInitializer)
cv::Mat::Mat	core/mat.hpp	/^template<typename _Tp> inline Mat::Mat(const Point3_<_Tp>& pt, bool copyData)$/;"	f	class:cv::Mat	signature:(const Point3_<_Tp>& pt, bool copyData)
cv::Mat::Mat	core/mat.hpp	/^template<typename _Tp> inline Mat::Mat(const Point_<_Tp>& pt, bool copyData)$/;"	f	class:cv::Mat	signature:(const Point_<_Tp>& pt, bool copyData)
cv::Mat::Mat	core/mat.hpp	/^template<typename _Tp> inline Mat::Mat(const vector<_Tp>& vec, bool copyData)$/;"	f	class:cv::Mat	signature:(const vector<_Tp>& vec, bool copyData)
cv::Mat::SUBMATRIX_FLAG	core/core.hpp	/^    enum { MAGIC_VAL=0x42FF0000, AUTO_STEP=0, CONTINUOUS_FLAG=CV_MAT_CONT_FLAG, SUBMATRIX_FLAG=CV_SUBMAT_FLAG };$/;"	e	enum:cv::Mat::__anon137
cv::Mat::addref	core/core.hpp	/^    void addref();$/;"	p	class:cv::Mat	access:public	signature:()
cv::Mat::addref	core/mat.hpp	/^inline void Mat::addref()$/;"	f	class:cv::Mat	signature:()
cv::Mat::adjustROI	core/core.hpp	/^    Mat& adjustROI( int dtop, int dbottom, int dleft, int dright );$/;"	p	class:cv::Mat	access:public	signature:( int dtop, int dbottom, int dleft, int dright )
cv::Mat::allocator	core/core.hpp	/^    MatAllocator* allocator;$/;"	m	class:cv::Mat	access:public
cv::Mat::assignTo	core/core.hpp	/^    void assignTo( Mat& m, int type=-1 ) const;$/;"	p	class:cv::Mat	access:public	signature:( Mat& m, int type=-1 ) const
cv::Mat::assignTo	core/mat.hpp	/^inline void Mat::assignTo( Mat& m, int type ) const$/;"	f	class:cv::Mat	signature:( Mat& m, int type ) const
cv::Mat::at	core/core.hpp	/^    template<typename _Tp, int n> _Tp& at(const Vec<int, n>& idx);$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx)
cv::Mat::at	core/core.hpp	/^    template<typename _Tp, int n> const _Tp& at(const Vec<int, n>& idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx) const
cv::Mat::at	core/core.hpp	/^    template<typename _Tp> _Tp& at(Point pt);$/;"	p	class:cv::Mat	access:public	signature:(Point pt)
cv::Mat::at	core/core.hpp	/^    template<typename _Tp> _Tp& at(const int* idx);$/;"	p	class:cv::Mat	access:public	signature:(const int* idx)
cv::Mat::at	core/core.hpp	/^    template<typename _Tp> _Tp& at(int i0, int i1);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1)
cv::Mat::at	core/core.hpp	/^    template<typename _Tp> _Tp& at(int i0, int i1, int i2);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2)
cv::Mat::at	core/core.hpp	/^    template<typename _Tp> _Tp& at(int i0=0);$/;"	p	class:cv::Mat	access:public	signature:(int i0=0)
cv::Mat::at	core/core.hpp	/^    template<typename _Tp> const _Tp& at(Point pt) const;$/;"	p	class:cv::Mat	access:public	signature:(Point pt) const
cv::Mat::at	core/core.hpp	/^    template<typename _Tp> const _Tp& at(const int* idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const int* idx) const
cv::Mat::at	core/core.hpp	/^    template<typename _Tp> const _Tp& at(int i0, int i1) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1) const
cv::Mat::at	core/core.hpp	/^    template<typename _Tp> const _Tp& at(int i0, int i1, int i2) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2) const
cv::Mat::at	core/core.hpp	/^    template<typename _Tp> const _Tp& at(int i0=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0=0) const
cv::Mat::at	core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat::at(Point pt)$/;"	f	class:cv::Mat	signature:(Point pt)
cv::Mat::at	core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat::at(const int* idx)$/;"	f	class:cv::Mat	signature:(const int* idx)
cv::Mat::at	core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat::at(int i0)$/;"	f	class:cv::Mat	signature:(int i0)
cv::Mat::at	core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat::at(int i0, int i1)$/;"	f	class:cv::Mat	signature:(int i0, int i1)
cv::Mat::at	core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat::at(int i0, int i1, int i2)$/;"	f	class:cv::Mat	signature:(int i0, int i1, int i2)
cv::Mat::at	core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat::at(Point pt) const$/;"	f	class:cv::Mat	signature:(Point pt) const
cv::Mat::at	core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat::at(const int* idx) const$/;"	f	class:cv::Mat	signature:(const int* idx) const
cv::Mat::at	core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat::at(int i0) const$/;"	f	class:cv::Mat	signature:(int i0) const
cv::Mat::at	core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat::at(int i0, int i1) const$/;"	f	class:cv::Mat	signature:(int i0, int i1) const
cv::Mat::at	core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat::at(int i0, int i1, int i2) const$/;"	f	class:cv::Mat	signature:(int i0, int i1, int i2) const
cv::Mat::begin	core/core.hpp	/^    template<typename _Tp> MatConstIterator_<_Tp> begin() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::begin	core/core.hpp	/^    template<typename _Tp> MatIterator_<_Tp> begin();$/;"	p	class:cv::Mat	access:public	signature:()
cv::Mat::begin	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> Mat::begin() const$/;"	f	class:cv::Mat	signature:() const
cv::Mat::begin	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> Mat::begin()$/;"	f	class:cv::Mat	signature:()
cv::Mat::channels	core/core.hpp	/^    int channels() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::channels	core/mat.hpp	/^inline int Mat::channels() const { return CV_MAT_CN(flags); }$/;"	f	class:cv::Mat	signature:() const
cv::Mat::checkVector	core/core.hpp	/^    int checkVector(int elemChannels, int depth=-1, bool requireContinuous=true) const;$/;"	p	class:cv::Mat	access:public	signature:(int elemChannels, int depth=-1, bool requireContinuous=true) const
cv::Mat::clone	core/core.hpp	/^    Mat clone() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::clone	core/mat.hpp	/^inline Mat Mat::clone() const$/;"	f	class:cv::Mat	signature:() const
cv::Mat::col	core/core.hpp	/^    Mat col(int x) const;$/;"	p	class:cv::Mat	access:public	signature:(int x) const
cv::Mat::col	core/mat.hpp	/^inline Mat Mat::col(int x) const { return Mat(*this, Range::all(), Range(x, x+1)); }$/;"	f	class:cv::Mat	signature:(int x) const
cv::Mat::colRange	core/core.hpp	/^    Mat colRange(const Range& r) const;$/;"	p	class:cv::Mat	access:public	signature:(const Range& r) const
cv::Mat::colRange	core/core.hpp	/^    Mat colRange(int startcol, int endcol) const;$/;"	p	class:cv::Mat	access:public	signature:(int startcol, int endcol) const
cv::Mat::colRange	core/mat.hpp	/^inline Mat Mat::colRange(const Range& r) const$/;"	f	class:cv::Mat	signature:(const Range& r) const
cv::Mat::colRange	core/mat.hpp	/^inline Mat Mat::colRange(int startcol, int endcol) const$/;"	f	class:cv::Mat	signature:(int startcol, int endcol) const
cv::Mat::cols	core/core.hpp	/^    int rows, cols;$/;"	m	class:cv::Mat	access:public
cv::Mat::convertTo	core/core.hpp	/^    void convertTo( OutputArray m, int rtype, double alpha=1, double beta=0 ) const;$/;"	p	class:cv::Mat	access:public	signature:( OutputArray m, int rtype, double alpha=1, double beta=0 ) const
cv::Mat::copySize	core/core.hpp	/^    void copySize(const Mat& m);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m)
cv::Mat::copyTo	core/core.hpp	/^    void copyTo( OutputArray m ) const;$/;"	p	class:cv::Mat	access:public	signature:( OutputArray m ) const
cv::Mat::copyTo	core/core.hpp	/^    void copyTo( OutputArray m, InputArray mask ) const;$/;"	p	class:cv::Mat	access:public	signature:( OutputArray m, InputArray mask ) const
cv::Mat::create	core/core.hpp	/^    void create(Size _size, int _type);$/;"	p	class:cv::Mat	access:public	signature:(Size _size, int _type)
cv::Mat::create	core/core.hpp	/^    void create(int _ndims, const int* _sizes, int _type);$/;"	p	class:cv::Mat	access:public	signature:(int _ndims, const int* _sizes, int _type)
cv::Mat::create	core/core.hpp	/^    void create(int _rows, int _cols, int _type);$/;"	p	class:cv::Mat	access:public	signature:(int _rows, int _cols, int _type)
cv::Mat::create	core/mat.hpp	/^inline void Mat::create(Size _sz, int _type)$/;"	f	class:cv::Mat	signature:(Size _sz, int _type)
cv::Mat::create	core/mat.hpp	/^inline void Mat::create(int _rows, int _cols, int _type)$/;"	f	class:cv::Mat	signature:(int _rows, int _cols, int _type)
cv::Mat::cross	core/core.hpp	/^    Mat cross(InputArray m) const;$/;"	p	class:cv::Mat	access:public	signature:(InputArray m) const
cv::Mat::data	core/core.hpp	/^    uchar* data;$/;"	m	class:cv::Mat	access:public
cv::Mat::dataend	core/core.hpp	/^    uchar* dataend;$/;"	m	class:cv::Mat	access:public
cv::Mat::datalimit	core/core.hpp	/^    uchar* datalimit;$/;"	m	class:cv::Mat	access:public
cv::Mat::datastart	core/core.hpp	/^    uchar* datastart;$/;"	m	class:cv::Mat	access:public
cv::Mat::deallocate	core/core.hpp	/^    void deallocate();$/;"	p	class:cv::Mat	access:public	signature:()
cv::Mat::depth	core/core.hpp	/^    int depth() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::depth	core/mat.hpp	/^inline int Mat::depth() const { return CV_MAT_DEPTH(flags); }$/;"	f	class:cv::Mat	signature:() const
cv::Mat::diag	core/core.hpp	/^    Mat diag(int d=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int d=0) const
cv::Mat::diag	core/core.hpp	/^    static Mat diag(const Mat& d);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& d)
cv::Mat::diag	core/mat.hpp	/^inline Mat Mat::diag(const Mat& d)$/;"	f	class:cv::Mat	signature:(const Mat& d)
cv::Mat::dims	core/core.hpp	/^    int dims;$/;"	m	class:cv::Mat	access:public
cv::Mat::dot	core/core.hpp	/^    double dot(InputArray m) const;$/;"	p	class:cv::Mat	access:public	signature:(InputArray m) const
cv::Mat::elemSize	core/core.hpp	/^    size_t elemSize() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::elemSize	core/mat.hpp	/^inline size_t Mat::elemSize() const { return dims > 0 ? step.p[dims-1] : 0; }$/;"	f	class:cv::Mat	signature:() const
cv::Mat::elemSize1	core/core.hpp	/^    size_t elemSize1() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::elemSize1	core/mat.hpp	/^inline size_t Mat::elemSize1() const { return CV_ELEM_SIZE1(flags); }$/;"	f	class:cv::Mat	signature:() const
cv::Mat::empty	core/core.hpp	/^    bool empty() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::empty	core/mat.hpp	/^inline bool Mat::empty() const { return data == 0 || total() == 0; }$/;"	f	class:cv::Mat	signature:() const
cv::Mat::end	core/core.hpp	/^    template<typename _Tp> MatConstIterator_<_Tp> end() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::end	core/core.hpp	/^    template<typename _Tp> MatIterator_<_Tp> end();$/;"	p	class:cv::Mat	access:public	signature:()
cv::Mat::end	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> Mat::end() const$/;"	f	class:cv::Mat	signature:() const
cv::Mat::end	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> Mat::end()$/;"	f	class:cv::Mat	signature:()
cv::Mat::eye	core/core.hpp	/^    static MatExpr eye(Size size, int type);$/;"	p	class:cv::Mat	access:public	signature:(Size size, int type)
cv::Mat::eye	core/core.hpp	/^    static MatExpr eye(int rows, int cols, int type);$/;"	p	class:cv::Mat	access:public	signature:(int rows, int cols, int type)
cv::Mat::flags	core/core.hpp	/^    int flags;$/;"	m	class:cv::Mat	access:public
cv::Mat::inv	core/core.hpp	/^    MatExpr inv(int method=DECOMP_LU) const;$/;"	p	class:cv::Mat	access:public	signature:(int method=DECOMP_LU) const
cv::Mat::isContinuous	core/core.hpp	/^    bool isContinuous() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::isContinuous	core/mat.hpp	/^inline bool Mat::isContinuous() const { return (flags & CONTINUOUS_FLAG) != 0; }$/;"	f	class:cv::Mat	signature:() const
cv::Mat::isSubmatrix	core/core.hpp	/^    bool isSubmatrix() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::isSubmatrix	core/mat.hpp	/^inline bool Mat::isSubmatrix() const { return (flags & SUBMATRIX_FLAG) != 0; }$/;"	f	class:cv::Mat	signature:() const
cv::Mat::locateROI	core/core.hpp	/^    void locateROI( Size& wholeSize, Point& ofs ) const;$/;"	p	class:cv::Mat	access:public	signature:( Size& wholeSize, Point& ofs ) const
cv::Mat::mul	core/core.hpp	/^    MatExpr mul(InputArray m, double scale=1) const;$/;"	p	class:cv::Mat	access:public	signature:(InputArray m, double scale=1) const
cv::Mat::ones	core/core.hpp	/^    static MatExpr ones(Size size, int type);$/;"	p	class:cv::Mat	access:public	signature:(Size size, int type)
cv::Mat::ones	core/core.hpp	/^    static MatExpr ones(int ndims, const int* sz, int type);$/;"	p	class:cv::Mat	access:public	signature:(int ndims, const int* sz, int type)
cv::Mat::ones	core/core.hpp	/^    static MatExpr ones(int rows, int cols, int type);$/;"	p	class:cv::Mat	access:public	signature:(int rows, int cols, int type)
cv::Mat::operator ()	core/core.hpp	/^    Mat operator()( Range rowRange, Range colRange ) const;$/;"	p	class:cv::Mat	access:public	signature:( Range rowRange, Range colRange ) const
cv::Mat::operator ()	core/core.hpp	/^    Mat operator()( const Range* ranges ) const;$/;"	p	class:cv::Mat	access:public	signature:( const Range* ranges ) const
cv::Mat::operator ()	core/core.hpp	/^    Mat operator()( const Rect& roi ) const;$/;"	p	class:cv::Mat	access:public	signature:( const Rect& roi ) const
cv::Mat::operator ()	core/mat.hpp	/^inline Mat Mat::operator()( Range rowRange, Range colRange ) const$/;"	f	class:cv::Mat	signature:( Range rowRange, Range colRange ) const
cv::Mat::operator ()	core/mat.hpp	/^inline Mat Mat::operator()( const Rect& roi ) const$/;"	f	class:cv::Mat	signature:( const Rect& roi ) const
cv::Mat::operator ()	core/mat.hpp	/^inline Mat Mat::operator()(const Range* ranges) const$/;"	f	class:cv::Mat	signature:(const Range* ranges) const
cv::Mat::operator =	core/core.hpp	/^    Mat& operator = (const Mat& m);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m)
cv::Mat::operator =	core/core.hpp	/^    Mat& operator = (const MatExpr& expr);$/;"	p	class:cv::Mat	access:public	signature:(const MatExpr& expr)
cv::Mat::operator =	core/core.hpp	/^    Mat& operator = (const Scalar& s);$/;"	p	class:cv::Mat	access:public	signature:(const Scalar& s)
cv::Mat::operator =	core/mat.hpp	/^inline Mat& Mat::operator = (const Mat& m)$/;"	f	class:cv::Mat	signature:(const Mat& m)
cv::Mat::operator =	core/mat.hpp	/^inline Mat& Mat::operator = (const MatExpr& e)$/;"	f	class:cv::Mat	signature:(const MatExpr& e)
cv::Mat::operator CvMat	core/core.hpp	/^    operator CvMat() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::operator CvMat	core/mat.hpp	/^inline Mat::operator CvMat() const$/;"	f	class:cv::Mat	signature:() const
cv::Mat::operator CvMatND	core/core.hpp	/^    operator CvMatND() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::operator IplImage	core/core.hpp	/^    operator IplImage() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::operator Matx<_Tp, m, n>	core/core.hpp	/^    template<typename _Tp, int m, int n> operator Matx<_Tp, m, n>() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::operator Matx<_Tp, m, n>	core/mat.hpp	/^template<typename _Tp, int m, int n> inline Mat::operator Matx<_Tp, m, n>() const$/;"	f	class:cv::Mat	signature:() const
cv::Mat::operator Vec<_Tp, n>	core/core.hpp	/^    template<typename _Tp, int n> operator Vec<_Tp, n>() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::operator Vec<_Tp, n>	core/mat.hpp	/^template<typename _Tp, int n> inline Mat::operator Vec<_Tp, n>() const$/;"	f	class:cv::Mat	signature:() const
cv::Mat::operator vector<_Tp>	core/core.hpp	/^    template<typename _Tp> operator vector<_Tp>() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::operator vector<_Tp>	core/mat.hpp	/^template<typename _Tp> inline Mat::operator vector<_Tp>() const$/;"	f	class:cv::Mat	signature:() const
cv::Mat::pop_back	core/core.hpp	/^    void pop_back(size_t nelems=1);$/;"	p	class:cv::Mat	access:public	signature:(size_t nelems=1)
cv::Mat::ptr	core/core.hpp	/^    const uchar* ptr(const int* idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const int* idx) const
cv::Mat::ptr	core/core.hpp	/^    const uchar* ptr(int i0, int i1) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1) const
cv::Mat::ptr	core/core.hpp	/^    const uchar* ptr(int i0, int i1, int i2) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2) const
cv::Mat::ptr	core/core.hpp	/^    const uchar* ptr(int i0=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0=0) const
cv::Mat::ptr	core/core.hpp	/^    template<int n> const uchar* ptr(const Vec<int, n>& idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx) const
cv::Mat::ptr	core/core.hpp	/^    template<int n> uchar* ptr(const Vec<int, n>& idx);$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx)
cv::Mat::ptr	core/core.hpp	/^    template<typename _Tp, int n> _Tp* ptr(const Vec<int, n>& idx);$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx)
cv::Mat::ptr	core/core.hpp	/^    template<typename _Tp, int n> const _Tp* ptr(const Vec<int, n>& idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx) const
cv::Mat::ptr	core/core.hpp	/^    template<typename _Tp> _Tp* ptr(const int* idx);$/;"	p	class:cv::Mat	access:public	signature:(const int* idx)
cv::Mat::ptr	core/core.hpp	/^    template<typename _Tp> _Tp* ptr(int i0, int i1);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1)
cv::Mat::ptr	core/core.hpp	/^    template<typename _Tp> _Tp* ptr(int i0, int i1, int i2);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2)
cv::Mat::ptr	core/core.hpp	/^    template<typename _Tp> _Tp* ptr(int i0=0);$/;"	p	class:cv::Mat	access:public	signature:(int i0=0)
cv::Mat::ptr	core/core.hpp	/^    template<typename _Tp> const _Tp* ptr(const int* idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const int* idx) const
cv::Mat::ptr	core/core.hpp	/^    template<typename _Tp> const _Tp* ptr(int i0, int i1) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1) const
cv::Mat::ptr	core/core.hpp	/^    template<typename _Tp> const _Tp* ptr(int i0, int i1, int i2) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2) const
cv::Mat::ptr	core/core.hpp	/^    template<typename _Tp> const _Tp* ptr(int i0=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0=0) const
cv::Mat::ptr	core/core.hpp	/^    uchar* ptr(const int* idx);$/;"	p	class:cv::Mat	access:public	signature:(const int* idx)
cv::Mat::ptr	core/core.hpp	/^    uchar* ptr(int i0, int i1);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1)
cv::Mat::ptr	core/core.hpp	/^    uchar* ptr(int i0, int i1, int i2);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2)
cv::Mat::ptr	core/core.hpp	/^    uchar* ptr(int i0=0);$/;"	p	class:cv::Mat	access:public	signature:(int i0=0)
cv::Mat::ptr	core/mat.hpp	/^inline const uchar* Mat::ptr(const int* idx) const$/;"	f	class:cv::Mat	signature:(const int* idx) const
cv::Mat::ptr	core/mat.hpp	/^inline const uchar* Mat::ptr(int i0, int i1) const$/;"	f	class:cv::Mat	signature:(int i0, int i1) const
cv::Mat::ptr	core/mat.hpp	/^inline const uchar* Mat::ptr(int i0, int i1, int i2) const$/;"	f	class:cv::Mat	signature:(int i0, int i1, int i2) const
cv::Mat::ptr	core/mat.hpp	/^inline const uchar* Mat::ptr(int y) const$/;"	f	class:cv::Mat	signature:(int y) const
cv::Mat::ptr	core/mat.hpp	/^inline uchar* Mat::ptr(const int* idx)$/;"	f	class:cv::Mat	signature:(const int* idx)
cv::Mat::ptr	core/mat.hpp	/^inline uchar* Mat::ptr(int i0, int i1)$/;"	f	class:cv::Mat	signature:(int i0, int i1)
cv::Mat::ptr	core/mat.hpp	/^inline uchar* Mat::ptr(int i0, int i1, int i2)$/;"	f	class:cv::Mat	signature:(int i0, int i1, int i2)
cv::Mat::ptr	core/mat.hpp	/^inline uchar* Mat::ptr(int y)$/;"	f	class:cv::Mat	signature:(int y)
cv::Mat::ptr	core/mat.hpp	/^template<typename _Tp> inline _Tp* Mat::ptr(int i0, int i1)$/;"	f	class:cv::Mat	signature:(int i0, int i1)
cv::Mat::ptr	core/mat.hpp	/^template<typename _Tp> inline _Tp* Mat::ptr(int i0, int i1, int i2)$/;"	f	class:cv::Mat	signature:(int i0, int i1, int i2)
cv::Mat::ptr	core/mat.hpp	/^template<typename _Tp> inline _Tp* Mat::ptr(int y)$/;"	f	class:cv::Mat	signature:(int y)
cv::Mat::ptr	core/mat.hpp	/^template<typename _Tp> inline const _Tp* Mat::ptr(int i0, int i1) const$/;"	f	class:cv::Mat	signature:(int i0, int i1) const
cv::Mat::ptr	core/mat.hpp	/^template<typename _Tp> inline const _Tp* Mat::ptr(int i0, int i1, int i2) const$/;"	f	class:cv::Mat	signature:(int i0, int i1, int i2) const
cv::Mat::ptr	core/mat.hpp	/^template<typename _Tp> inline const _Tp* Mat::ptr(int y) const$/;"	f	class:cv::Mat	signature:(int y) const
cv::Mat::push_back	core/core.hpp	/^    template<typename _Tp> void push_back(const Mat_<_Tp>& elem);$/;"	p	class:cv::Mat	access:public	signature:(const Mat_<_Tp>& elem)
cv::Mat::push_back	core/core.hpp	/^    template<typename _Tp> void push_back(const _Tp& elem);$/;"	p	class:cv::Mat	access:public	signature:(const _Tp& elem)
cv::Mat::push_back	core/core.hpp	/^    void push_back(const Mat& m);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m)
cv::Mat::push_back	core/mat.hpp	/^template<typename _Tp> inline void Mat::push_back(const Mat_<_Tp>& m)$/;"	f	class:cv::Mat	signature:(const Mat_<_Tp>& m)
cv::Mat::push_back	core/mat.hpp	/^template<typename _Tp> inline void Mat::push_back(const _Tp& elem)$/;"	f	class:cv::Mat	signature:(const _Tp& elem)
cv::Mat::push_back_	core/core.hpp	/^    void push_back_(const void* elem);$/;"	p	class:cv::Mat	access:public	signature:(const void* elem)
cv::Mat::refcount	core/core.hpp	/^    int* refcount;$/;"	m	class:cv::Mat	access:public
cv::Mat::release	core/core.hpp	/^    void release();$/;"	p	class:cv::Mat	access:public	signature:()
cv::Mat::release	core/mat.hpp	/^inline void Mat::release()$/;"	f	class:cv::Mat	signature:()
cv::Mat::reserve	core/core.hpp	/^    void reserve(size_t sz);$/;"	p	class:cv::Mat	access:public	signature:(size_t sz)
cv::Mat::reshape	core/core.hpp	/^    Mat reshape(int _cn, int _newndims, const int* _newsz) const;$/;"	p	class:cv::Mat	access:public	signature:(int _cn, int _newndims, const int* _newsz) const
cv::Mat::reshape	core/core.hpp	/^    Mat reshape(int _cn, int _rows=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int _cn, int _rows=0) const
cv::Mat::resize	core/core.hpp	/^    void resize(size_t sz);$/;"	p	class:cv::Mat	access:public	signature:(size_t sz)
cv::Mat::resize	core/core.hpp	/^    void resize(size_t sz, const Scalar& s);$/;"	p	class:cv::Mat	access:public	signature:(size_t sz, const Scalar& s)
cv::Mat::row	core/core.hpp	/^    Mat row(int y) const;$/;"	p	class:cv::Mat	access:public	signature:(int y) const
cv::Mat::row	core/mat.hpp	/^inline Mat Mat::row(int y) const { return Mat(*this, Range(y, y+1), Range::all()); }$/;"	f	class:cv::Mat	signature:(int y) const
cv::Mat::rowRange	core/core.hpp	/^    Mat rowRange(const Range& r) const;$/;"	p	class:cv::Mat	access:public	signature:(const Range& r) const
cv::Mat::rowRange	core/core.hpp	/^    Mat rowRange(int startrow, int endrow) const;$/;"	p	class:cv::Mat	access:public	signature:(int startrow, int endrow) const
cv::Mat::rowRange	core/mat.hpp	/^inline Mat Mat::rowRange(const Range& r) const$/;"	f	class:cv::Mat	signature:(const Range& r) const
cv::Mat::rowRange	core/mat.hpp	/^inline Mat Mat::rowRange(int startrow, int endrow) const$/;"	f	class:cv::Mat	signature:(int startrow, int endrow) const
cv::Mat::rows	core/core.hpp	/^    int rows, cols;$/;"	m	class:cv::Mat	access:public
cv::Mat::setTo	core/core.hpp	/^    Mat& setTo(InputArray value, InputArray mask=noArray());$/;"	p	class:cv::Mat	access:public	signature:(InputArray value, InputArray mask=noArray())
cv::Mat::size	core/core.hpp	/^    MSize size;$/;"	m	class:cv::Mat	access:public
cv::Mat::step	core/core.hpp	/^    MStep step;$/;"	m	class:cv::Mat	access:public
cv::Mat::step1	core/core.hpp	/^    size_t step1(int i=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int i=0) const
cv::Mat::step1	core/mat.hpp	/^inline size_t Mat::step1(int i) const { return step.p[i]\/elemSize1(); }$/;"	f	class:cv::Mat	signature:(int i) const
cv::Mat::t	core/core.hpp	/^    MatExpr t() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::total	core/core.hpp	/^    size_t total() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::total	core/mat.hpp	/^inline size_t Mat::total() const$/;"	f	class:cv::Mat	signature:() const
cv::Mat::type	core/core.hpp	/^    int type() const;$/;"	p	class:cv::Mat	access:public	signature:() const
cv::Mat::type	core/mat.hpp	/^inline int Mat::type() const { return CV_MAT_TYPE(flags); }$/;"	f	class:cv::Mat	signature:() const
cv::Mat::zeros	core/core.hpp	/^    static MatExpr zeros(Size size, int type);$/;"	p	class:cv::Mat	access:public	signature:(Size size, int type)
cv::Mat::zeros	core/core.hpp	/^    static MatExpr zeros(int ndims, const int* sz, int type);$/;"	p	class:cv::Mat	access:public	signature:(int ndims, const int* sz, int type)
cv::Mat::zeros	core/core.hpp	/^    static MatExpr zeros(int rows, int cols, int type);$/;"	p	class:cv::Mat	access:public	signature:(int rows, int cols, int type)
cv::Mat::~Mat	core/core.hpp	/^    ~Mat();$/;"	p	class:cv::Mat	access:public	signature:()
cv::Mat::~Mat	core/mat.hpp	/^inline Mat::~Mat()$/;"	f	class:cv::Mat	signature:()
cv::MatAllocator	core/core.hpp	/^class CV_EXPORTS MatAllocator$/;"	c	namespace:cv
cv::MatAllocator::MatAllocator	core/core.hpp	/^    MatAllocator() {}$/;"	f	class:cv::MatAllocator	access:public	signature:()
cv::MatAllocator::allocate	core/core.hpp	/^    virtual void allocate(int dims, const int* sizes, int type, int*& refcount,$/;"	p	class:cv::MatAllocator	access:public	signature:(int dims, const int* sizes, int type, int*& refcount, uchar*& datastart, uchar*& data, size_t* step)
cv::MatAllocator::deallocate	core/core.hpp	/^    virtual void deallocate(int* refcount, uchar* datastart, uchar* data) = 0;$/;"	p	class:cv::MatAllocator	access:public	signature:(int* refcount, uchar* datastart, uchar* data)
cv::MatAllocator::~MatAllocator	core/core.hpp	/^    virtual ~MatAllocator() {}$/;"	f	class:cv::MatAllocator	access:public	signature:()
cv::MatArg	core/core.hpp	/^class CV_EXPORTS MatArg;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::MatCommaInitializer_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS MatCommaInitializer_$/;"	c	namespace:cv
cv::MatCommaInitializer_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS MatCommaInitializer_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::MatCommaInitializer_::MatCommaInitializer_	core/core.hpp	/^    MatCommaInitializer_(Mat_<_Tp>* _m);$/;"	p	class:cv::MatCommaInitializer_	access:public	signature:(Mat_<_Tp>* _m)
cv::MatCommaInitializer_::MatCommaInitializer_	core/mat.hpp	/^template<typename _Tp> inline MatCommaInitializer_<_Tp>::MatCommaInitializer_(Mat_<_Tp>* _m) : it(_m) {}$/;"	f	class:cv::MatCommaInitializer_	signature:(Mat_<_Tp>* _m)
cv::MatCommaInitializer_::it	core/core.hpp	/^    MatIterator_<_Tp> it;$/;"	m	class:cv::MatCommaInitializer_	access:protected
cv::MatCommaInitializer_::operator *	core/core.hpp	/^    Mat_<_Tp> operator *() const;$/;"	p	class:cv::MatCommaInitializer_	access:public	signature:() const
cv::MatCommaInitializer_::operator *	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> MatCommaInitializer_<_Tp>::operator *() const$/;"	f	class:cv::MatCommaInitializer_	signature:() const
cv::MatCommaInitializer_::operator ,	core/core.hpp	/^    template<typename T2> MatCommaInitializer_<_Tp>& operator , (T2 v);$/;"	p	class:cv::MatCommaInitializer_	access:public	signature:(T2 v)
cv::MatCommaInitializer_::operator ,	core/mat.hpp	/^MatCommaInitializer_<_Tp>::operator , (T2 v)$/;"	f	class:cv::MatCommaInitializer_	signature:(T2 v)
cv::MatCommaInitializer_::operator Mat_<_Tp>	core/core.hpp	/^    operator Mat_<_Tp>() const;$/;"	p	class:cv::MatCommaInitializer_	access:public	signature:() const
cv::MatCommaInitializer_::operator Mat_<_Tp>	core/mat.hpp	/^template<typename _Tp> inline MatCommaInitializer_<_Tp>::operator Mat_<_Tp>() const$/;"	f	class:cv::MatCommaInitializer_	signature:() const
cv::MatConstIterator	core/core.hpp	/^class CV_EXPORTS MatConstIterator$/;"	c	namespace:cv
cv::MatConstIterator	core/core.hpp	/^class CV_EXPORTS MatConstIterator;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::MatConstIterator::MatConstIterator	core/core.hpp	/^    MatConstIterator();$/;"	p	class:cv::MatConstIterator	access:public	signature:()
cv::MatConstIterator::MatConstIterator	core/core.hpp	/^    MatConstIterator(const Mat* _m);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const Mat* _m)
cv::MatConstIterator::MatConstIterator	core/core.hpp	/^    MatConstIterator(const Mat* _m, Point _pt);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const Mat* _m, Point _pt)
cv::MatConstIterator::MatConstIterator	core/core.hpp	/^    MatConstIterator(const Mat* _m, const int* _idx);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const Mat* _m, const int* _idx)
cv::MatConstIterator::MatConstIterator	core/core.hpp	/^    MatConstIterator(const Mat* _m, int _row, int _col=0);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const Mat* _m, int _row, int _col=0)
cv::MatConstIterator::MatConstIterator	core/core.hpp	/^    MatConstIterator(const MatConstIterator& it);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const MatConstIterator& it)
cv::MatConstIterator::MatConstIterator	core/mat.hpp	/^inline MatConstIterator::MatConstIterator()$/;"	f	class:cv::MatConstIterator	signature:()
cv::MatConstIterator::MatConstIterator	core/mat.hpp	/^inline MatConstIterator::MatConstIterator(const Mat* _m)$/;"	f	class:cv::MatConstIterator	signature:(const Mat* _m)
cv::MatConstIterator::MatConstIterator	core/mat.hpp	/^inline MatConstIterator::MatConstIterator(const Mat* _m, Point _pt)$/;"	f	class:cv::MatConstIterator	signature:(const Mat* _m, Point _pt)
cv::MatConstIterator::MatConstIterator	core/mat.hpp	/^inline MatConstIterator::MatConstIterator(const Mat* _m, int _row, int _col)$/;"	f	class:cv::MatConstIterator	signature:(const Mat* _m, int _row, int _col)
cv::MatConstIterator::MatConstIterator	core/mat.hpp	/^inline MatConstIterator::MatConstIterator(const MatConstIterator& it)$/;"	f	class:cv::MatConstIterator	signature:(const MatConstIterator& it)
cv::MatConstIterator::difference_type	core/core.hpp	/^    typedef ptrdiff_t difference_type;$/;"	t	class:cv::MatConstIterator	access:public
cv::MatConstIterator::elemSize	core/core.hpp	/^    size_t elemSize;$/;"	m	class:cv::MatConstIterator	access:public
cv::MatConstIterator::iterator_category	core/core.hpp	/^    typedef std::random_access_iterator_tag iterator_category;$/;"	t	class:cv::MatConstIterator	access:public
cv::MatConstIterator::lpos	core/core.hpp	/^    ptrdiff_t lpos() const;$/;"	p	class:cv::MatConstIterator	access:public	signature:() const
cv::MatConstIterator::m	core/core.hpp	/^    const Mat* m;$/;"	m	class:cv::MatConstIterator	access:public
cv::MatConstIterator::operator *	core/core.hpp	/^    uchar* operator *() const;$/;"	p	class:cv::MatConstIterator	access:public	signature:() const
cv::MatConstIterator::operator *	core/mat.hpp	/^inline uchar* MatConstIterator::operator *() const { return ptr; }$/;"	f	class:cv::MatConstIterator	signature:() const
cv::MatConstIterator::operator ++	core/core.hpp	/^    MatConstIterator operator ++(int);$/;"	p	class:cv::MatConstIterator	access:public	signature:(int)
cv::MatConstIterator::operator ++	core/core.hpp	/^    MatConstIterator& operator ++();$/;"	p	class:cv::MatConstIterator	access:public	signature:()
cv::MatConstIterator::operator ++	core/mat.hpp	/^inline MatConstIterator MatConstIterator::operator ++(int)$/;"	f	class:cv::MatConstIterator	signature:(int)
cv::MatConstIterator::operator ++	core/mat.hpp	/^inline MatConstIterator& MatConstIterator::operator ++()$/;"	f	class:cv::MatConstIterator	signature:()
cv::MatConstIterator::operator +=	core/core.hpp	/^    MatConstIterator& operator += (ptrdiff_t ofs);$/;"	p	class:cv::MatConstIterator	access:public	signature:(ptrdiff_t ofs)
cv::MatConstIterator::operator +=	core/mat.hpp	/^inline MatConstIterator& MatConstIterator::operator += (ptrdiff_t ofs)$/;"	f	class:cv::MatConstIterator	signature:(ptrdiff_t ofs)
cv::MatConstIterator::operator --	core/core.hpp	/^    MatConstIterator operator --(int);$/;"	p	class:cv::MatConstIterator	access:public	signature:(int)
cv::MatConstIterator::operator --	core/core.hpp	/^    MatConstIterator& operator --();$/;"	p	class:cv::MatConstIterator	access:public	signature:()
cv::MatConstIterator::operator --	core/mat.hpp	/^inline MatConstIterator MatConstIterator::operator --(int)$/;"	f	class:cv::MatConstIterator	signature:(int)
cv::MatConstIterator::operator --	core/mat.hpp	/^inline MatConstIterator& MatConstIterator::operator --()$/;"	f	class:cv::MatConstIterator	signature:()
cv::MatConstIterator::operator -=	core/core.hpp	/^    MatConstIterator& operator -= (ptrdiff_t ofs);$/;"	p	class:cv::MatConstIterator	access:public	signature:(ptrdiff_t ofs)
cv::MatConstIterator::operator -=	core/mat.hpp	/^inline MatConstIterator& MatConstIterator::operator -= (ptrdiff_t ofs)$/;"	f	class:cv::MatConstIterator	signature:(ptrdiff_t ofs)
cv::MatConstIterator::operator =	core/core.hpp	/^    MatConstIterator& operator = (const MatConstIterator& it);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const MatConstIterator& it)
cv::MatConstIterator::operator =	core/mat.hpp	/^inline MatConstIterator& MatConstIterator::operator = (const MatConstIterator& it )$/;"	f	class:cv::MatConstIterator	signature:(const MatConstIterator& it )
cv::MatConstIterator::operator []	core/core.hpp	/^    uchar* operator [](ptrdiff_t i) const;$/;"	p	class:cv::MatConstIterator	access:public	signature:(ptrdiff_t i) const
cv::MatConstIterator::operator []	core/mat.hpp	/^inline uchar* MatConstIterator::operator [](ptrdiff_t i) const$/;"	f	class:cv::MatConstIterator	signature:(ptrdiff_t i) const
cv::MatConstIterator::pointer	core/core.hpp	/^    typedef const uchar** pointer;$/;"	t	class:cv::MatConstIterator	access:public
cv::MatConstIterator::pos	core/core.hpp	/^    Point pos() const;$/;"	p	class:cv::MatConstIterator	access:public	signature:() const
cv::MatConstIterator::pos	core/core.hpp	/^    void pos(int* _idx) const;$/;"	p	class:cv::MatConstIterator	access:public	signature:(int* _idx) const
cv::MatConstIterator::ptr	core/core.hpp	/^    uchar* ptr;$/;"	m	class:cv::MatConstIterator	access:public
cv::MatConstIterator::reference	core/core.hpp	/^    typedef uchar* reference;$/;"	t	class:cv::MatConstIterator	access:public
cv::MatConstIterator::seek	core/core.hpp	/^    void seek(const int* _idx, bool relative=false);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const int* _idx, bool relative=false)
cv::MatConstIterator::seek	core/core.hpp	/^    void seek(ptrdiff_t ofs, bool relative=false);$/;"	p	class:cv::MatConstIterator	access:public	signature:(ptrdiff_t ofs, bool relative=false)
cv::MatConstIterator::sliceEnd	core/core.hpp	/^    uchar* sliceEnd;$/;"	m	class:cv::MatConstIterator	access:public
cv::MatConstIterator::sliceStart	core/core.hpp	/^    uchar* sliceStart;$/;"	m	class:cv::MatConstIterator	access:public
cv::MatConstIterator::value_type	core/core.hpp	/^    typedef uchar* value_type;$/;"	t	class:cv::MatConstIterator	access:public
cv::MatConstIterator_	core/core.hpp	/^class CV_EXPORTS MatConstIterator_ : public MatConstIterator$/;"	c	namespace:cv	inherits:MatConstIterator
cv::MatConstIterator_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS MatConstIterator_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::MatConstIterator_::MatConstIterator_	core/core.hpp	/^    MatConstIterator_();$/;"	p	class:cv::MatConstIterator_	access:public	signature:()
cv::MatConstIterator_::MatConstIterator_	core/core.hpp	/^    MatConstIterator_(const MatConstIterator_& it);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const MatConstIterator_& it)
cv::MatConstIterator_::MatConstIterator_	core/core.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const Mat_<_Tp>* _m)
cv::MatConstIterator_::MatConstIterator_	core/core.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m, Point _pt);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const Mat_<_Tp>* _m, Point _pt)
cv::MatConstIterator_::MatConstIterator_	core/core.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m, const int* _idx);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const Mat_<_Tp>* _m, const int* _idx)
cv::MatConstIterator_::MatConstIterator_	core/core.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m, int _row, int _col=0);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const Mat_<_Tp>* _m, int _row, int _col=0)
cv::MatConstIterator_::MatConstIterator_	core/mat.hpp	/^    MatConstIterator_(const MatConstIterator_& it)$/;"	f	class:cv::MatConstIterator_	signature:(const MatConstIterator_& it)
cv::MatConstIterator_::MatConstIterator_	core/mat.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m, Point _pt)$/;"	f	class:cv::MatConstIterator_	signature:(const Mat_<_Tp>* _m, Point _pt)
cv::MatConstIterator_::MatConstIterator_	core/mat.hpp	/^    MatConstIterator_(const Mat_<_Tp>* _m, int _row, int _col)$/;"	f	class:cv::MatConstIterator_	signature:(const Mat_<_Tp>* _m, int _row, int _col)
cv::MatConstIterator_::MatConstIterator_	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>::MatConstIterator_() {}$/;"	f	class:cv::MatConstIterator_	signature:()
cv::MatConstIterator_::MatConstIterator_	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>::MatConstIterator_(const Mat_<_Tp>* _m)$/;"	f	class:cv::MatConstIterator_	signature:(const Mat_<_Tp>* _m)
cv::MatConstIterator_::difference_type	core/core.hpp	/^    typedef ptrdiff_t difference_type;$/;"	t	class:cv::MatConstIterator_	access:public
cv::MatConstIterator_::iterator_category	core/core.hpp	/^    typedef std::random_access_iterator_tag iterator_category;$/;"	t	class:cv::MatConstIterator_	access:public
cv::MatConstIterator_::operator *	core/core.hpp	/^    _Tp operator *() const;$/;"	p	class:cv::MatConstIterator_	access:public	signature:() const
cv::MatConstIterator_::operator *	core/mat.hpp	/^template<typename _Tp> inline _Tp MatConstIterator_<_Tp>::operator *() const { return *(_Tp*)(this->ptr); }$/;"	f	class:cv::MatConstIterator_	signature:() const
cv::MatConstIterator_::operator ++	core/core.hpp	/^    MatConstIterator_ operator ++(int);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(int)
cv::MatConstIterator_::operator ++	core/core.hpp	/^    MatConstIterator_& operator ++();$/;"	p	class:cv::MatConstIterator_	access:public	signature:()
cv::MatConstIterator_::operator ++	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> MatConstIterator_<_Tp>::operator ++(int)$/;"	f	class:cv::MatConstIterator_	signature:(int)
cv::MatConstIterator_::operator ++	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator ++()$/;"	f	class:cv::MatConstIterator_	signature:()
cv::MatConstIterator_::operator +=	core/core.hpp	/^    MatConstIterator_& operator += (ptrdiff_t ofs);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(ptrdiff_t ofs)
cv::MatConstIterator_::operator +=	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator += (ptrdiff_t ofs)$/;"	f	class:cv::MatConstIterator_	signature:(ptrdiff_t ofs)
cv::MatConstIterator_::operator --	core/core.hpp	/^    MatConstIterator_ operator --(int);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(int)
cv::MatConstIterator_::operator --	core/core.hpp	/^    MatConstIterator_& operator --();$/;"	p	class:cv::MatConstIterator_	access:public	signature:()
cv::MatConstIterator_::operator --	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> MatConstIterator_<_Tp>::operator --(int)$/;"	f	class:cv::MatConstIterator_	signature:(int)
cv::MatConstIterator_::operator --	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator --()$/;"	f	class:cv::MatConstIterator_	signature:()
cv::MatConstIterator_::operator -=	core/core.hpp	/^    MatConstIterator_& operator -= (ptrdiff_t ofs);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(ptrdiff_t ofs)
cv::MatConstIterator_::operator -=	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator -= (ptrdiff_t ofs)$/;"	f	class:cv::MatConstIterator_	signature:(ptrdiff_t ofs)
cv::MatConstIterator_::operator =	core/core.hpp	/^    MatConstIterator_& operator = (const MatConstIterator_& it);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const MatConstIterator_& it)
cv::MatConstIterator_::operator =	core/mat.hpp	/^    MatConstIterator_<_Tp>::operator = (const MatConstIterator_& it )$/;"	f	class:cv::MatConstIterator_	signature:(const MatConstIterator_& it )
cv::MatConstIterator_::operator []	core/core.hpp	/^    _Tp operator [](ptrdiff_t i) const;$/;"	p	class:cv::MatConstIterator_	access:public	signature:(ptrdiff_t i) const
cv::MatConstIterator_::operator []	core/mat.hpp	/^template<typename _Tp> inline _Tp MatConstIterator_<_Tp>::operator [](ptrdiff_t i) const$/;"	f	class:cv::MatConstIterator_	signature:(ptrdiff_t i) const
cv::MatConstIterator_::pointer	core/core.hpp	/^    typedef const _Tp* pointer;$/;"	t	class:cv::MatConstIterator_	access:public
cv::MatConstIterator_::pos	core/core.hpp	/^    Point pos() const;$/;"	p	class:cv::MatConstIterator_	access:public	signature:() const
cv::MatConstIterator_::pos	core/mat.hpp	/^template<typename _Tp> inline Point MatConstIterator_<_Tp>::pos() const$/;"	f	class:cv::MatConstIterator_	signature:() const
cv::MatConstIterator_::reference	core/core.hpp	/^    typedef const _Tp& reference;$/;"	t	class:cv::MatConstIterator_	access:public
cv::MatConstIterator_::value_type	core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::MatConstIterator_	access:public
cv::MatExpr	core/core.hpp	/^class CV_EXPORTS MatExpr;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::MatExpr	core/mat.hpp	/^class CV_EXPORTS MatExpr$/;"	c	namespace:cv
cv::MatExpr::MatExpr	core/mat.hpp	/^    MatExpr() : op(0), flags(0), a(Mat()), b(Mat()), c(Mat()), alpha(0), beta(0), s(Scalar()) {}$/;"	f	class:cv::MatExpr	access:public	signature:()
cv::MatExpr::MatExpr	core/mat.hpp	/^    MatExpr(const MatOp* _op, int _flags, const Mat& _a=Mat(), const Mat& _b=Mat(),$/;"	f	class:cv::MatExpr	access:public	signature:(const MatOp* _op, int _flags, const Mat& _a=Mat(), const Mat& _b=Mat(), const Mat& _c=Mat(), double _alpha=1, double _beta=1, const Scalar& _s=Scalar())
cv::MatExpr::MatExpr	core/mat.hpp	/^    explicit MatExpr(const Mat& m);$/;"	p	class:cv::MatExpr	access:public	signature:(const Mat& m)
cv::MatExpr::a	core/mat.hpp	/^    Mat a, b, c;$/;"	m	class:cv::MatExpr	access:public
cv::MatExpr::alpha	core/mat.hpp	/^    double alpha, beta;$/;"	m	class:cv::MatExpr	access:public
cv::MatExpr::b	core/mat.hpp	/^    Mat a, b, c;$/;"	m	class:cv::MatExpr	access:public
cv::MatExpr::beta	core/mat.hpp	/^    double alpha, beta;$/;"	m	class:cv::MatExpr	access:public
cv::MatExpr::c	core/mat.hpp	/^    Mat a, b, c;$/;"	m	class:cv::MatExpr	access:public
cv::MatExpr::col	core/mat.hpp	/^    MatExpr col(int x) const;$/;"	p	class:cv::MatExpr	access:public	signature:(int x) const
cv::MatExpr::cross	core/mat.hpp	/^    Mat cross(const Mat& m) const;$/;"	p	class:cv::MatExpr	access:public	signature:(const Mat& m) const
cv::MatExpr::diag	core/mat.hpp	/^    MatExpr diag(int d=0) const;$/;"	p	class:cv::MatExpr	access:public	signature:(int d=0) const
cv::MatExpr::dot	core/mat.hpp	/^    double dot(const Mat& m) const;$/;"	p	class:cv::MatExpr	access:public	signature:(const Mat& m) const
cv::MatExpr::flags	core/mat.hpp	/^    int flags;$/;"	m	class:cv::MatExpr	access:public
cv::MatExpr::inv	core/mat.hpp	/^    MatExpr inv(int method = DECOMP_LU) const;$/;"	p	class:cv::MatExpr	access:public	signature:(int method = DECOMP_LU) const
cv::MatExpr::mul	core/mat.hpp	/^    MatExpr mul(const Mat& m, double scale=1) const;$/;"	p	class:cv::MatExpr	access:public	signature:(const Mat& m, double scale=1) const
cv::MatExpr::mul	core/mat.hpp	/^    MatExpr mul(const MatExpr& e, double scale=1) const;$/;"	p	class:cv::MatExpr	access:public	signature:(const MatExpr& e, double scale=1) const
cv::MatExpr::op	core/mat.hpp	/^    const MatOp* op;$/;"	m	class:cv::MatExpr	access:public
cv::MatExpr::operator ()	core/mat.hpp	/^    MatExpr operator()( const Range& rowRange, const Range& colRange ) const;$/;"	p	class:cv::MatExpr	access:public	signature:( const Range& rowRange, const Range& colRange ) const
cv::MatExpr::operator ()	core/mat.hpp	/^    MatExpr operator()( const Rect& roi ) const;$/;"	p	class:cv::MatExpr	access:public	signature:( const Rect& roi ) const
cv::MatExpr::operator Mat	core/mat.hpp	/^    operator Mat() const$/;"	f	class:cv::MatExpr	access:public	signature:() const
cv::MatExpr::operator Mat_<_Tp>	core/mat.hpp	/^    template<typename _Tp> operator Mat_<_Tp>() const$/;"	f	class:cv::MatExpr	access:public	signature:() const
cv::MatExpr::row	core/mat.hpp	/^    MatExpr row(int y) const;$/;"	p	class:cv::MatExpr	access:public	signature:(int y) const
cv::MatExpr::s	core/mat.hpp	/^    Scalar s;$/;"	m	class:cv::MatExpr	access:public
cv::MatExpr::size	core/mat.hpp	/^    Size size() const;$/;"	p	class:cv::MatExpr	access:public	signature:() const
cv::MatExpr::t	core/mat.hpp	/^    MatExpr t() const;$/;"	p	class:cv::MatExpr	access:public	signature:() const
cv::MatExpr::type	core/mat.hpp	/^    int type() const;$/;"	p	class:cv::MatExpr	access:public	signature:() const
cv::MatIterator_	core/core.hpp	/^class CV_EXPORTS MatIterator_ : public MatConstIterator_<_Tp>$/;"	c	namespace:cv	inherits:MatConstIterator_
cv::MatIterator_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS MatIterator_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::MatIterator_::MatIterator_	core/core.hpp	/^    MatIterator_();$/;"	p	class:cv::MatIterator_	access:public	signature:()
cv::MatIterator_::MatIterator_	core/core.hpp	/^    MatIterator_(Mat_<_Tp>* _m);$/;"	p	class:cv::MatIterator_	access:public	signature:(Mat_<_Tp>* _m)
cv::MatIterator_::MatIterator_	core/core.hpp	/^    MatIterator_(Mat_<_Tp>* _m, int _row, int _col=0);$/;"	p	class:cv::MatIterator_	access:public	signature:(Mat_<_Tp>* _m, int _row, int _col=0)
cv::MatIterator_::MatIterator_	core/core.hpp	/^    MatIterator_(const MatIterator_& it);$/;"	p	class:cv::MatIterator_	access:public	signature:(const MatIterator_& it)
cv::MatIterator_::MatIterator_	core/core.hpp	/^    MatIterator_(const Mat_<_Tp>* _m, Point _pt);$/;"	p	class:cv::MatIterator_	access:public	signature:(const Mat_<_Tp>* _m, Point _pt)
cv::MatIterator_::MatIterator_	core/core.hpp	/^    MatIterator_(const Mat_<_Tp>* _m, const int* _idx);$/;"	p	class:cv::MatIterator_	access:public	signature:(const Mat_<_Tp>* _m, const int* _idx)
cv::MatIterator_::MatIterator_	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_() : MatConstIterator_<_Tp>() {}$/;"	f	class:cv::MatIterator_	signature:()
cv::MatIterator_::MatIterator_	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m)$/;"	f	class:cv::MatIterator_	signature:(Mat_<_Tp>* _m)
cv::MatIterator_::MatIterator_	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m, int _row, int _col)$/;"	f	class:cv::MatIterator_	signature:(Mat_<_Tp>* _m, int _row, int _col)
cv::MatIterator_::MatIterator_	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(const MatIterator_& it)$/;"	f	class:cv::MatIterator_	signature:(const MatIterator_& it)
cv::MatIterator_::MatIterator_	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(const Mat_<_Tp>* _m, Point _pt)$/;"	f	class:cv::MatIterator_	signature:(const Mat_<_Tp>* _m, Point _pt)
cv::MatIterator_::MatIterator_	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>::MatIterator_(const Mat_<_Tp>* _m, const int* _idx)$/;"	f	class:cv::MatIterator_	signature:(const Mat_<_Tp>* _m, const int* _idx)
cv::MatIterator_::iterator_category	core/core.hpp	/^    typedef std::random_access_iterator_tag iterator_category;$/;"	t	class:cv::MatIterator_	access:public
cv::MatIterator_::operator *	core/core.hpp	/^    _Tp& operator *() const;$/;"	p	class:cv::MatIterator_	access:public	signature:() const
cv::MatIterator_::operator *	core/mat.hpp	/^template<typename _Tp> inline _Tp& MatIterator_<_Tp>::operator *() const { return *(_Tp*)(this->ptr); }$/;"	f	class:cv::MatIterator_	signature:() const
cv::MatIterator_::operator ++	core/core.hpp	/^    MatIterator_ operator ++(int);$/;"	p	class:cv::MatIterator_	access:public	signature:(int)
cv::MatIterator_::operator ++	core/core.hpp	/^    MatIterator_& operator ++();$/;"	p	class:cv::MatIterator_	access:public	signature:()
cv::MatIterator_::operator ++	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> MatIterator_<_Tp>::operator ++(int)$/;"	f	class:cv::MatIterator_	signature:(int)
cv::MatIterator_::operator ++	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator ++()$/;"	f	class:cv::MatIterator_	signature:()
cv::MatIterator_::operator +=	core/core.hpp	/^    MatIterator_& operator += (ptrdiff_t ofs);$/;"	p	class:cv::MatIterator_	access:public	signature:(ptrdiff_t ofs)
cv::MatIterator_::operator +=	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator += (ptrdiff_t ofs)$/;"	f	class:cv::MatIterator_	signature:(ptrdiff_t ofs)
cv::MatIterator_::operator --	core/core.hpp	/^    MatIterator_ operator --(int);$/;"	p	class:cv::MatIterator_	access:public	signature:(int)
cv::MatIterator_::operator --	core/core.hpp	/^    MatIterator_& operator --();$/;"	p	class:cv::MatIterator_	access:public	signature:()
cv::MatIterator_::operator --	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> MatIterator_<_Tp>::operator --(int)$/;"	f	class:cv::MatIterator_	signature:(int)
cv::MatIterator_::operator --	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator --()$/;"	f	class:cv::MatIterator_	signature:()
cv::MatIterator_::operator -=	core/core.hpp	/^    MatIterator_& operator -= (ptrdiff_t ofs);$/;"	p	class:cv::MatIterator_	access:public	signature:(ptrdiff_t ofs)
cv::MatIterator_::operator -=	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator -= (ptrdiff_t ofs)$/;"	f	class:cv::MatIterator_	signature:(ptrdiff_t ofs)
cv::MatIterator_::operator =	core/core.hpp	/^    MatIterator_& operator = (const MatIterator_<_Tp>& it );$/;"	p	class:cv::MatIterator_	access:public	signature:(const MatIterator_<_Tp>& it )
cv::MatIterator_::operator =	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator = (const MatIterator_<_Tp>& it )$/;"	f	class:cv::MatIterator_	signature:(const MatIterator_<_Tp>& it )
cv::MatIterator_::operator []	core/core.hpp	/^    _Tp& operator [](ptrdiff_t i) const;$/;"	p	class:cv::MatIterator_	access:public	signature:(ptrdiff_t i) const
cv::MatIterator_::operator []	core/mat.hpp	/^template<typename _Tp> inline _Tp& MatIterator_<_Tp>::operator [](ptrdiff_t i) const$/;"	f	class:cv::MatIterator_	signature:(ptrdiff_t i) const
cv::MatIterator_::pointer	core/core.hpp	/^    typedef _Tp* pointer;$/;"	t	class:cv::MatIterator_	access:public
cv::MatIterator_::reference	core/core.hpp	/^    typedef _Tp& reference;$/;"	t	class:cv::MatIterator_	access:public
cv::MatND	core/core.hpp	/^typedef Mat MatND;$/;"	t	namespace:cv
cv::MatOp	core/mat.hpp	/^class CV_EXPORTS MatOp$/;"	c	namespace:cv
cv::MatOp::MatOp	core/mat.hpp	/^    MatOp() {};$/;"	f	class:cv::MatOp	access:public	signature:()
cv::MatOp::abs	core/mat.hpp	/^    virtual void abs(const MatExpr& expr, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, MatExpr& res) const
cv::MatOp::add	core/mat.hpp	/^    virtual void add(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const
cv::MatOp::add	core/mat.hpp	/^    virtual void add(const MatExpr& expr1, const Scalar& s, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const Scalar& s, MatExpr& res) const
cv::MatOp::assign	core/mat.hpp	/^    virtual void assign(const MatExpr& expr, Mat& m, int type=-1) const = 0;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m, int type=-1) const
cv::MatOp::augAssignAdd	core/mat.hpp	/^    virtual void augAssignAdd(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
cv::MatOp::augAssignAnd	core/mat.hpp	/^    virtual void augAssignAnd(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
cv::MatOp::augAssignDivide	core/mat.hpp	/^    virtual void augAssignDivide(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
cv::MatOp::augAssignMultiply	core/mat.hpp	/^    virtual void augAssignMultiply(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
cv::MatOp::augAssignOr	core/mat.hpp	/^    virtual void augAssignOr(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
cv::MatOp::augAssignSubtract	core/mat.hpp	/^    virtual void augAssignSubtract(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
cv::MatOp::augAssignXor	core/mat.hpp	/^    virtual void augAssignXor(const MatExpr& expr, Mat& m) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, Mat& m) const
cv::MatOp::diag	core/mat.hpp	/^    virtual void diag(const MatExpr& expr, int d, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, int d, MatExpr& res) const
cv::MatOp::divide	core/mat.hpp	/^    virtual void divide(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const
cv::MatOp::divide	core/mat.hpp	/^    virtual void divide(double s, const MatExpr& expr, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(double s, const MatExpr& expr, MatExpr& res) const
cv::MatOp::elementWise	core/mat.hpp	/^    virtual bool elementWise(const MatExpr& expr) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr) const
cv::MatOp::invert	core/mat.hpp	/^    virtual void invert(const MatExpr& expr, int method, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, int method, MatExpr& res) const
cv::MatOp::matmul	core/mat.hpp	/^    virtual void matmul(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const
cv::MatOp::multiply	core/mat.hpp	/^    virtual void multiply(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const
cv::MatOp::multiply	core/mat.hpp	/^    virtual void multiply(const MatExpr& expr1, double s, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, double s, MatExpr& res) const
cv::MatOp::roi	core/mat.hpp	/^    virtual void roi(const MatExpr& expr, const Range& rowRange,$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, const Range& rowRange, const Range& colRange, MatExpr& res) const
cv::MatOp::size	core/mat.hpp	/^    virtual Size size(const MatExpr& expr) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr) const
cv::MatOp::subtract	core/mat.hpp	/^    virtual void subtract(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const
cv::MatOp::subtract	core/mat.hpp	/^    virtual void subtract(const Scalar& s, const MatExpr& expr, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const Scalar& s, const MatExpr& expr, MatExpr& res) const
cv::MatOp::transpose	core/mat.hpp	/^    virtual void transpose(const MatExpr& expr, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, MatExpr& res) const
cv::MatOp::type	core/mat.hpp	/^    virtual int type(const MatExpr& expr) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr) const
cv::MatOp::~MatOp	core/mat.hpp	/^    virtual ~MatOp() {};$/;"	f	class:cv::MatOp	access:public	signature:()
cv::MatOp_Base	core/core.hpp	/^class CV_EXPORTS MatOp_Base;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::MatOp_Iter_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS MatOp_Iter_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::Mat_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Mat_ : public Mat$/;"	c	namespace:cv	inherits:Mat
cv::Mat_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Mat_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::Mat_::Mat_	core/core.hpp	/^    Mat_();$/;"	p	class:cv::Mat_	access:public	signature:()
cv::Mat_::Mat_	core/core.hpp	/^    Mat_(Size _size, const _Tp& value);$/;"	p	class:cv::Mat_	access:public	signature:(Size _size, const _Tp& value)
cv::Mat_::Mat_	core/core.hpp	/^    Mat_(const Mat& m);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat& m)
cv::Mat_::Mat_	core/core.hpp	/^    Mat_(const Mat_& m);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m)
cv::Mat_::Mat_	core/core.hpp	/^    Mat_(const Mat_& m, const Range& rowRange, const Range& colRange=Range::all());$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m, const Range& rowRange, const Range& colRange=Range::all())
cv::Mat_::Mat_	core/core.hpp	/^    Mat_(const Mat_& m, const Range* ranges);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m, const Range* ranges)
cv::Mat_::Mat_	core/core.hpp	/^    Mat_(const Mat_& m, const Rect& roi);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m, const Rect& roi)
cv::Mat_::Mat_	core/core.hpp	/^    Mat_(int _ndims, const int* _sizes);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes)
cv::Mat_::Mat_	core/core.hpp	/^    Mat_(int _ndims, const int* _sizes, _Tp* _data, const size_t* _steps=0);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes, _Tp* _data, const size_t* _steps=0)
cv::Mat_::Mat_	core/core.hpp	/^    Mat_(int _ndims, const int* _sizes, const _Tp& value);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes, const _Tp& value)
cv::Mat_::Mat_	core/core.hpp	/^    Mat_(int _rows, int _cols);$/;"	p	class:cv::Mat_	access:public	signature:(int _rows, int _cols)
cv::Mat_::Mat_	core/core.hpp	/^    Mat_(int _rows, int _cols, _Tp* _data, size_t _step=AUTO_STEP);$/;"	p	class:cv::Mat_	access:public	signature:(int _rows, int _cols, _Tp* _data, size_t _step=AUTO_STEP)
cv::Mat_::Mat_	core/core.hpp	/^    Mat_(int _rows, int _cols, const _Tp& value);$/;"	p	class:cv::Mat_	access:public	signature:(int _rows, int _cols, const _Tp& value)
cv::Mat_::Mat_	core/core.hpp	/^    explicit Mat_(Size _size);$/;"	p	class:cv::Mat_	access:public	signature:(Size _size)
cv::Mat_::Mat_	core/core.hpp	/^    explicit Mat_(const MatCommaInitializer_<_Tp>& commaInitializer);$/;"	p	class:cv::Mat_	access:public	signature:(const MatCommaInitializer_<_Tp>& commaInitializer)
cv::Mat_::Mat_	core/core.hpp	/^    explicit Mat_(const MatExpr& e);$/;"	p	class:cv::Mat_	access:public	signature:(const MatExpr& e)
cv::Mat_::Mat_	core/core.hpp	/^    explicit Mat_(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData=true);$/;"	p	class:cv::Mat_	access:public	signature:(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData=true)
cv::Mat_::Mat_	core/core.hpp	/^    explicit Mat_(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData=true);$/;"	p	class:cv::Mat_	access:public	signature:(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData=true)
cv::Mat_::Mat_	core/core.hpp	/^    explicit Mat_(const vector<_Tp>& vec, bool copyData=false);$/;"	p	class:cv::Mat_	access:public	signature:(const vector<_Tp>& vec, bool copyData=false)
cv::Mat_::Mat_	core/core.hpp	/^    template<int m, int n> explicit Mat_(const Matx<typename DataType<_Tp>::channel_type, m, n>& mtx, bool copyData=true);$/;"	p	class:cv::Mat_	access:public	signature:(const Matx<typename DataType<_Tp>::channel_type, m, n>& mtx, bool copyData=true)
cv::Mat_::Mat_	core/core.hpp	/^    template<int n> explicit Mat_(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData=true);$/;"	p	class:cv::Mat_	access:public	signature:(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData=true)
cv::Mat_::Mat_	core/mat.hpp	/^    Mat_<_Tp>::Mat_(const Matx<typename DataType<_Tp>::channel_type,m,n>& M, bool copyData)$/;"	f	class:cv::Mat_	signature:(const Matx<typename DataType<_Tp>::channel_type,m,n>& M, bool copyData)
cv::Mat_::Mat_	core/mat.hpp	/^    Mat_<_Tp>::Mat_(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData)$/;"	f	class:cv::Mat_	signature:(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData)
cv::Mat_::Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_()$/;"	f	class:cv::Mat_	signature:()
cv::Mat_::Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(Size _sz)$/;"	f	class:cv::Mat_	signature:(Size _sz)
cv::Mat_::Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(Size _sz, const _Tp& value)$/;"	f	class:cv::Mat_	signature:(Size _sz, const _Tp& value)
cv::Mat_::Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat& m)$/;"	f	class:cv::Mat_	signature:(const Mat& m)
cv::Mat_::Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const MatCommaInitializer_<_Tp>& commaInitializer)$/;"	f	class:cv::Mat_	signature:(const MatCommaInitializer_<_Tp>& commaInitializer)
cv::Mat_::Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const MatExpr& e)$/;"	f	class:cv::Mat_	signature:(const MatExpr& e)
cv::Mat_::Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_& m)$/;"	f	class:cv::Mat_	signature:(const Mat_& m)
cv::Mat_::Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_& m, const Range& rowRange, const Range& colRange)$/;"	f	class:cv::Mat_	signature:(const Mat_& m, const Range& rowRange, const Range& colRange)
cv::Mat_::Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_& m, const Rect& roi)$/;"	f	class:cv::Mat_	signature:(const Mat_& m, const Rect& roi)
cv::Mat_::Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Mat_<_Tp>& m, const Range* ranges)$/;"	f	class:cv::Mat_	signature:(const Mat_<_Tp>& m, const Range* ranges)
cv::Mat_::Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData)$/;"	f	class:cv::Mat_	signature:(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData)
cv::Mat_::Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData)$/;"	f	class:cv::Mat_	signature:(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData)
cv::Mat_::Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(const vector<_Tp>& vec, bool copyData)$/;"	f	class:cv::Mat_	signature:(const vector<_Tp>& vec, bool copyData)
cv::Mat_::Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(int _dims, const int* _sz)$/;"	f	class:cv::Mat_	signature:(int _dims, const int* _sz)
cv::Mat_::Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(int _dims, const int* _sz, const _Tp& _s)$/;"	f	class:cv::Mat_	signature:(int _dims, const int* _sz, const _Tp& _s)
cv::Mat_::Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(int _rows, int _cols)$/;"	f	class:cv::Mat_	signature:(int _rows, int _cols)
cv::Mat_::Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(int _rows, int _cols, _Tp* _data, size_t steps)$/;"	f	class:cv::Mat_	signature:(int _rows, int _cols, _Tp* _data, size_t steps)
cv::Mat_::Mat_	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::Mat_(int _rows, int _cols, const _Tp& value)$/;"	f	class:cv::Mat_	signature:(int _rows, int _cols, const _Tp& value)
cv::Mat_::adjustROI	core/core.hpp	/^    Mat_& adjustROI( int dtop, int dbottom, int dleft, int dright );$/;"	p	class:cv::Mat_	access:public	signature:( int dtop, int dbottom, int dleft, int dright )
cv::Mat_::adjustROI	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::adjustROI( int dtop, int dbottom, int dleft, int dright )$/;"	f	class:cv::Mat_	signature:( int dtop, int dbottom, int dleft, int dright )
cv::Mat_::begin	core/core.hpp	/^    const_iterator begin() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::begin	core/core.hpp	/^    iterator begin();$/;"	p	class:cv::Mat_	access:public	signature:()
cv::Mat_::begin	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> Mat_<_Tp>::begin() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::begin	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> Mat_<_Tp>::begin()$/;"	f	class:cv::Mat_	signature:()
cv::Mat_::channel_type	core/core.hpp	/^    typedef typename DataType<_Tp>::channel_type channel_type;$/;"	t	class:cv::Mat_	access:public
cv::Mat_::channels	core/core.hpp	/^    int channels() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::channels	core/mat.hpp	/^template<typename _Tp> inline int Mat_<_Tp>::channels() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::clone	core/core.hpp	/^    Mat_ clone() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::clone	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::clone() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::col	core/core.hpp	/^    Mat_ col(int x) const;$/;"	p	class:cv::Mat_	access:public	signature:(int x) const
cv::Mat_::col	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::col(int x) const$/;"	f	class:cv::Mat_	signature:(int x) const
cv::Mat_::const_iterator	core/core.hpp	/^    typedef MatConstIterator_<_Tp> const_iterator;$/;"	t	class:cv::Mat_	access:public
cv::Mat_::create	core/core.hpp	/^    void create(Size _size);$/;"	p	class:cv::Mat_	access:public	signature:(Size _size)
cv::Mat_::create	core/core.hpp	/^    void create(int _ndims, const int* _sizes);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes)
cv::Mat_::create	core/core.hpp	/^    void create(int _rows, int _cols);$/;"	p	class:cv::Mat_	access:public	signature:(int _rows, int _cols)
cv::Mat_::create	core/mat.hpp	/^template<typename _Tp> inline void Mat_<_Tp>::create(Size _sz)$/;"	f	class:cv::Mat_	signature:(Size _sz)
cv::Mat_::create	core/mat.hpp	/^template<typename _Tp> inline void Mat_<_Tp>::create(int _dims, const int* _sz)$/;"	f	class:cv::Mat_	signature:(int _dims, const int* _sz)
cv::Mat_::create	core/mat.hpp	/^template<typename _Tp> inline void Mat_<_Tp>::create(int _rows, int _cols)$/;"	f	class:cv::Mat_	signature:(int _rows, int _cols)
cv::Mat_::cross	core/core.hpp	/^    Mat_ cross(const Mat_& m) const;$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m) const
cv::Mat_::cross	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::cross(const Mat_& m) const$/;"	f	class:cv::Mat_	signature:(const Mat_& m) const
cv::Mat_::depth	core/core.hpp	/^    int depth() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::depth	core/mat.hpp	/^template<typename _Tp> inline int Mat_<_Tp>::depth() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::diag	core/core.hpp	/^    Mat_ diag(int d=0) const;$/;"	p	class:cv::Mat_	access:public	signature:(int d=0) const
cv::Mat_::diag	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::diag(int d) const$/;"	f	class:cv::Mat_	signature:(int d) const
cv::Mat_::elemSize	core/core.hpp	/^    size_t elemSize() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::elemSize	core/mat.hpp	/^template<typename _Tp> inline size_t Mat_<_Tp>::elemSize() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::elemSize1	core/core.hpp	/^    size_t elemSize1() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::elemSize1	core/mat.hpp	/^template<typename _Tp> inline size_t Mat_<_Tp>::elemSize1() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::end	core/core.hpp	/^    const_iterator end() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::end	core/core.hpp	/^    iterator end();$/;"	p	class:cv::Mat_	access:public	signature:()
cv::Mat_::end	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> Mat_<_Tp>::end() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::end	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> Mat_<_Tp>::end()$/;"	f	class:cv::Mat_	signature:()
cv::Mat_::eye	core/core.hpp	/^    static MatExpr eye(Size size);$/;"	p	class:cv::Mat_	access:public	signature:(Size size)
cv::Mat_::eye	core/core.hpp	/^    static MatExpr eye(int rows, int cols);$/;"	p	class:cv::Mat_	access:public	signature:(int rows, int cols)
cv::Mat_::eye	core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::eye(Size sz)$/;"	f	class:cv::Mat_	signature:(Size sz)
cv::Mat_::eye	core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::eye(int rows, int cols)$/;"	f	class:cv::Mat_	signature:(int rows, int cols)
cv::Mat_::iterator	core/core.hpp	/^    typedef MatIterator_<_Tp> iterator;$/;"	t	class:cv::Mat_	access:public
cv::Mat_::ones	core/core.hpp	/^    static MatExpr ones(Size size);$/;"	p	class:cv::Mat_	access:public	signature:(Size size)
cv::Mat_::ones	core/core.hpp	/^    static MatExpr ones(int _ndims, const int* _sizes);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes)
cv::Mat_::ones	core/core.hpp	/^    static MatExpr ones(int rows, int cols);$/;"	p	class:cv::Mat_	access:public	signature:(int rows, int cols)
cv::Mat_::ones	core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::ones(Size sz)$/;"	f	class:cv::Mat_	signature:(Size sz)
cv::Mat_::ones	core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::ones(int rows, int cols)$/;"	f	class:cv::Mat_	signature:(int rows, int cols)
cv::Mat_::operator ()	core/core.hpp	/^    Mat_ operator()( const Range& rowRange, const Range& colRange ) const;$/;"	p	class:cv::Mat_	access:public	signature:( const Range& rowRange, const Range& colRange ) const
cv::Mat_::operator ()	core/core.hpp	/^    Mat_ operator()( const Range* ranges ) const;$/;"	p	class:cv::Mat_	access:public	signature:( const Range* ranges ) const
cv::Mat_::operator ()	core/core.hpp	/^    Mat_ operator()( const Rect& roi ) const;$/;"	p	class:cv::Mat_	access:public	signature:( const Rect& roi ) const
cv::Mat_::operator ()	core/core.hpp	/^    _Tp& operator ()(Point pt);$/;"	p	class:cv::Mat_	access:public	signature:(Point pt)
cv::Mat_::operator ()	core/core.hpp	/^    _Tp& operator ()(const int* idx);$/;"	p	class:cv::Mat_	access:public	signature:(const int* idx)
cv::Mat_::operator ()	core/core.hpp	/^    _Tp& operator ()(int idx0);$/;"	p	class:cv::Mat_	access:public	signature:(int idx0)
cv::Mat_::operator ()	core/core.hpp	/^    _Tp& operator ()(int idx0, int idx1);$/;"	p	class:cv::Mat_	access:public	signature:(int idx0, int idx1)
cv::Mat_::operator ()	core/core.hpp	/^    _Tp& operator ()(int idx0, int idx1, int idx2);$/;"	p	class:cv::Mat_	access:public	signature:(int idx0, int idx1, int idx2)
cv::Mat_::operator ()	core/core.hpp	/^    const _Tp& operator ()(Point pt) const;$/;"	p	class:cv::Mat_	access:public	signature:(Point pt) const
cv::Mat_::operator ()	core/core.hpp	/^    const _Tp& operator ()(const int* idx) const;$/;"	p	class:cv::Mat_	access:public	signature:(const int* idx) const
cv::Mat_::operator ()	core/core.hpp	/^    const _Tp& operator ()(int idx0) const;$/;"	p	class:cv::Mat_	access:public	signature:(int idx0) const
cv::Mat_::operator ()	core/core.hpp	/^    const _Tp& operator ()(int idx0, int idx1) const;$/;"	p	class:cv::Mat_	access:public	signature:(int idx0, int idx1) const
cv::Mat_::operator ()	core/core.hpp	/^    const _Tp& operator ()(int idx0, int idx1, int idx2) const;$/;"	p	class:cv::Mat_	access:public	signature:(int idx0, int idx1, int idx2) const
cv::Mat_::operator ()	core/core.hpp	/^    template<int n> _Tp& operator ()(const Vec<int, n>& idx);$/;"	p	class:cv::Mat_	access:public	signature:(const Vec<int, n>& idx)
cv::Mat_::operator ()	core/core.hpp	/^    template<int n> const _Tp& operator ()(const Vec<int, n>& idx) const;$/;"	p	class:cv::Mat_	access:public	signature:(const Vec<int, n>& idx) const
cv::Mat_::operator ()	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::operator()( const Range& rowRange, const Range& colRange ) const$/;"	f	class:cv::Mat_	signature:( const Range& rowRange, const Range& colRange ) const
cv::Mat_::operator ()	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::operator()( const Range* ranges ) const$/;"	f	class:cv::Mat_	signature:( const Range* ranges ) const
cv::Mat_::operator ()	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::operator()( const Rect& roi ) const$/;"	f	class:cv::Mat_	signature:( const Rect& roi ) const
cv::Mat_::operator ()	core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(Point pt)$/;"	f	class:cv::Mat_	signature:(Point pt)
cv::Mat_::operator ()	core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(const int* idx)$/;"	f	class:cv::Mat_	signature:(const int* idx)
cv::Mat_::operator ()	core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(int i0)$/;"	f	class:cv::Mat_	signature:(int i0)
cv::Mat_::operator ()	core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(int i0, int i1)$/;"	f	class:cv::Mat_	signature:(int i0, int i1)
cv::Mat_::operator ()	core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(int i0, int i1, int i2)$/;"	f	class:cv::Mat_	signature:(int i0, int i1, int i2)
cv::Mat_::operator ()	core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(Point pt) const$/;"	f	class:cv::Mat_	signature:(Point pt) const
cv::Mat_::operator ()	core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(const int* idx) const$/;"	f	class:cv::Mat_	signature:(const int* idx) const
cv::Mat_::operator ()	core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(int i0) const$/;"	f	class:cv::Mat_	signature:(int i0) const
cv::Mat_::operator ()	core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(int i0, int i1) const$/;"	f	class:cv::Mat_	signature:(int i0, int i1) const
cv::Mat_::operator ()	core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(int i0, int i1, int i2) const$/;"	f	class:cv::Mat_	signature:(int i0, int i1, int i2) const
cv::Mat_::operator =	core/core.hpp	/^    Mat_& operator = (const Mat& m);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat& m)
cv::Mat_::operator =	core/core.hpp	/^    Mat_& operator = (const MatExpr& e);$/;"	p	class:cv::Mat_	access:public	signature:(const MatExpr& e)
cv::Mat_::operator =	core/core.hpp	/^    Mat_& operator = (const Mat_& m);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m)
cv::Mat_::operator =	core/core.hpp	/^    Mat_& operator = (const _Tp& s);$/;"	p	class:cv::Mat_	access:public	signature:(const _Tp& s)
cv::Mat_::operator =	core/mat.hpp	/^template<typename _Tp> Mat_<_Tp>& Mat_<_Tp>::operator = (const MatExpr& e)$/;"	f	class:cv::Mat_	signature:(const MatExpr& e)
cv::Mat_::operator =	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::operator = (const Mat& m)$/;"	f	class:cv::Mat_	signature:(const Mat& m)
cv::Mat_::operator =	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::operator = (const Mat_& m)$/;"	f	class:cv::Mat_	signature:(const Mat_& m)
cv::Mat_::operator =	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::operator = (const _Tp& s)$/;"	f	class:cv::Mat_	signature:(const _Tp& s)
cv::Mat_::operator Mat_<T2>	core/core.hpp	/^    template<typename T2> operator Mat_<T2>() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::operator Mat_<T2>	core/mat.hpp	/^template<typename _Tp> template<typename T2> inline Mat_<_Tp>::operator Mat_<T2>() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::operator Matx<typename DataType<_Tp>::channel_type, m, n>	core/core.hpp	/^    template<int m, int n> operator Matx<typename DataType<_Tp>::channel_type, m, n>() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::operator Matx<typename DataType<_Tp>::channel_type, m, n>	core/mat.hpp	/^template<typename _Tp> template<int m, int n> inline Mat_<_Tp>::operator Matx<typename DataType<_Tp>::channel_type, m, n>() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::operator Vec<typename DataType<_Tp>::channel_type, n>	core/core.hpp	/^    template<int n> operator Vec<typename DataType<_Tp>::channel_type, n>() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::operator Vec<typename DataType<_Tp>::channel_type, n>	core/mat.hpp	/^template<typename _Tp> template<int n> inline Mat_<_Tp>::operator Vec<typename DataType<_Tp>::channel_type, n>() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::operator []	core/core.hpp	/^    _Tp* operator [](int y);$/;"	p	class:cv::Mat_	access:public	signature:(int y)
cv::Mat_::operator []	core/core.hpp	/^    const _Tp* operator [](int y) const;$/;"	p	class:cv::Mat_	access:public	signature:(int y) const
cv::Mat_::operator []	core/mat.hpp	/^template<typename _Tp> inline _Tp* Mat_<_Tp>::operator [](int y)$/;"	f	class:cv::Mat_	signature:(int y)
cv::Mat_::operator []	core/mat.hpp	/^template<typename _Tp> inline const _Tp* Mat_<_Tp>::operator [](int y) const$/;"	f	class:cv::Mat_	signature:(int y) const
cv::Mat_::operator vector<_Tp>	core/core.hpp	/^    operator vector<_Tp>() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::operator vector<_Tp>	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::operator vector<_Tp>() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::reshape	core/core.hpp	/^    Mat_ reshape(int _rows) const;$/;"	p	class:cv::Mat_	access:public	signature:(int _rows) const
cv::Mat_::reshape	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::reshape(int _rows) const$/;"	f	class:cv::Mat_	signature:(int _rows) const
cv::Mat_::row	core/core.hpp	/^    Mat_ row(int y) const;$/;"	p	class:cv::Mat_	access:public	signature:(int y) const
cv::Mat_::row	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::row(int y) const$/;"	f	class:cv::Mat_	signature:(int y) const
cv::Mat_::step1	core/core.hpp	/^    size_t step1(int i=0) const;$/;"	p	class:cv::Mat_	access:public	signature:(int i=0) const
cv::Mat_::step1	core/mat.hpp	/^template<typename _Tp> inline size_t Mat_<_Tp>::step1(int i) const { return step.p[i]\/elemSize1(); }$/;"	f	class:cv::Mat_	signature:(int i) const
cv::Mat_::stepT	core/core.hpp	/^    size_t stepT(int i=0) const;$/;"	p	class:cv::Mat_	access:public	signature:(int i=0) const
cv::Mat_::stepT	core/mat.hpp	/^template<typename _Tp> inline size_t Mat_<_Tp>::stepT(int i) const { return step.p[i]\/elemSize(); }$/;"	f	class:cv::Mat_	signature:(int i) const
cv::Mat_::type	core/core.hpp	/^    int type() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
cv::Mat_::type	core/mat.hpp	/^template<typename _Tp> inline int Mat_<_Tp>::type() const$/;"	f	class:cv::Mat_	signature:() const
cv::Mat_::value_type	core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Mat_	access:public
cv::Mat_::zeros	core/core.hpp	/^    static MatExpr zeros(Size size);$/;"	p	class:cv::Mat_	access:public	signature:(Size size)
cv::Mat_::zeros	core/core.hpp	/^    static MatExpr zeros(int _ndims, const int* _sizes);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes)
cv::Mat_::zeros	core/core.hpp	/^    static MatExpr zeros(int rows, int cols);$/;"	p	class:cv::Mat_	access:public	signature:(int rows, int cols)
cv::Mat_::zeros	core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::zeros(Size sz)$/;"	f	class:cv::Mat_	signature:(Size sz)
cv::Mat_::zeros	core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::zeros(int rows, int cols)$/;"	f	class:cv::Mat_	signature:(int rows, int cols)
cv::Matx	core/core.hpp	/^template<typename _Tp, int m, int n> class CV_EXPORTS Matx$/;"	c	namespace:cv
cv::Matx	core/core.hpp	/^template<typename _Tp, int m, int n> class CV_EXPORTS Matx;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::Matx12d	core/core.hpp	/^typedef Matx<double, 1, 2> Matx12d;$/;"	t	namespace:cv
cv::Matx12f	core/core.hpp	/^typedef Matx<float, 1, 2> Matx12f;$/;"	t	namespace:cv
cv::Matx13d	core/core.hpp	/^typedef Matx<double, 1, 3> Matx13d;$/;"	t	namespace:cv
cv::Matx13f	core/core.hpp	/^typedef Matx<float, 1, 3> Matx13f;$/;"	t	namespace:cv
cv::Matx14d	core/core.hpp	/^typedef Matx<double, 1, 4> Matx14d;$/;"	t	namespace:cv
cv::Matx14f	core/core.hpp	/^typedef Matx<float, 1, 4> Matx14f;$/;"	t	namespace:cv
cv::Matx16d	core/core.hpp	/^typedef Matx<double, 1, 6> Matx16d;$/;"	t	namespace:cv
cv::Matx16f	core/core.hpp	/^typedef Matx<float, 1, 6> Matx16f;$/;"	t	namespace:cv
cv::Matx21d	core/core.hpp	/^typedef Matx<double, 2, 1> Matx21d;$/;"	t	namespace:cv
cv::Matx21f	core/core.hpp	/^typedef Matx<float, 2, 1> Matx21f;$/;"	t	namespace:cv
cv::Matx22d	core/core.hpp	/^typedef Matx<double, 2, 2> Matx22d;$/;"	t	namespace:cv
cv::Matx22f	core/core.hpp	/^typedef Matx<float, 2, 2> Matx22f;$/;"	t	namespace:cv
cv::Matx23d	core/core.hpp	/^typedef Matx<double, 2, 3> Matx23d;$/;"	t	namespace:cv
cv::Matx23f	core/core.hpp	/^typedef Matx<float, 2, 3> Matx23f;$/;"	t	namespace:cv
cv::Matx31d	core/core.hpp	/^typedef Matx<double, 3, 1> Matx31d;$/;"	t	namespace:cv
cv::Matx31f	core/core.hpp	/^typedef Matx<float, 3, 1> Matx31f;$/;"	t	namespace:cv
cv::Matx32d	core/core.hpp	/^typedef Matx<double, 3, 2> Matx32d;$/;"	t	namespace:cv
cv::Matx32f	core/core.hpp	/^typedef Matx<float, 3, 2> Matx32f;$/;"	t	namespace:cv
cv::Matx33d	core/core.hpp	/^typedef Matx<double, 3, 3> Matx33d;$/;"	t	namespace:cv
cv::Matx33f	core/core.hpp	/^typedef Matx<float, 3, 3> Matx33f;$/;"	t	namespace:cv
cv::Matx34d	core/core.hpp	/^typedef Matx<double, 3, 4> Matx34d;$/;"	t	namespace:cv
cv::Matx34f	core/core.hpp	/^typedef Matx<float, 3, 4> Matx34f;$/;"	t	namespace:cv
cv::Matx41d	core/core.hpp	/^typedef Matx<double, 4, 1> Matx41d;$/;"	t	namespace:cv
cv::Matx41f	core/core.hpp	/^typedef Matx<float, 4, 1> Matx41f;$/;"	t	namespace:cv
cv::Matx43d	core/core.hpp	/^typedef Matx<double, 4, 3> Matx43d;$/;"	t	namespace:cv
cv::Matx43f	core/core.hpp	/^typedef Matx<float, 4, 3> Matx43f;$/;"	t	namespace:cv
cv::Matx44d	core/core.hpp	/^typedef Matx<double, 4, 4> Matx44d;$/;"	t	namespace:cv
cv::Matx44f	core/core.hpp	/^typedef Matx<float, 4, 4> Matx44f;$/;"	t	namespace:cv
cv::Matx61d	core/core.hpp	/^typedef Matx<double, 6, 1> Matx61d;$/;"	t	namespace:cv
cv::Matx61f	core/core.hpp	/^typedef Matx<float, 6, 1> Matx61f;$/;"	t	namespace:cv
cv::Matx66d	core/core.hpp	/^typedef Matx<double, 6, 6> Matx66d;    $/;"	t	namespace:cv
cv::Matx66f	core/core.hpp	/^typedef Matx<float, 6, 6> Matx66f;$/;"	t	namespace:cv
cv::Matx::Matx	core/core.hpp	/^    Matx();$/;"	p	class:cv::Matx	access:public	signature:()
cv::Matx::Matx	core/core.hpp	/^    Matx(_Tp v0); \/\/!< 1x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0)
cv::Matx::Matx	core/core.hpp	/^    Matx(_Tp v0, _Tp v1); \/\/!< 1x2 or 2x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1)
cv::Matx::Matx	core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2); \/\/!< 1x3 or 3x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2)
cv::Matx::Matx	core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3); \/\/!< 1x4, 2x2 or 4x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
cv::Matx::Matx	core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4); \/\/!< 1x5 or 5x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)
cv::Matx::Matx	core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5); \/\/!< 1x6, 2x3, 3x2 or 6x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)
cv::Matx::Matx	core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6); \/\/!< 1x7 or 7x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6)
cv::Matx::Matx	core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7); \/\/!< 1x8, 2x4, 4x2 or 8x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7)
cv::Matx::Matx	core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8); \/\/!< 1x9, 3x3 or 9x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8)
cv::Matx::Matx	core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9); \/\/!< 1x10, 2x5 or 5x2 or 10x1 matrix$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9)
cv::Matx::Matx	core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11)
cv::Matx::Matx	core/core.hpp	/^    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	p	class:cv::Matx	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13, _Tp v14, _Tp v15)
cv::Matx::Matx	core/core.hpp	/^    Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_AddOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_AddOp)
cv::Matx::Matx	core/core.hpp	/^    Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_MulOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_MulOp)
cv::Matx::Matx	core/core.hpp	/^    Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_SubOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_SubOp)
cv::Matx::Matx	core/core.hpp	/^    Matx(const Matx<_Tp, n, m>& a, Matx_TOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, n, m>& a, Matx_TOp)
cv::Matx::Matx	core/core.hpp	/^    explicit Matx(const _Tp* vals); \/\/!< initialize from a plain array$/;"	p	class:cv::Matx	access:public	signature:(const _Tp* vals)
cv::Matx::Matx	core/core.hpp	/^    template<int l> Matx(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b, Matx_MatMulOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b, Matx_MatMulOp)
cv::Matx::Matx	core/core.hpp	/^    template<typename _T2> Matx(const Matx<_Tp, m, n>& a, _T2 alpha, Matx_ScaleOp);$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& a, _T2 alpha, Matx_ScaleOp)
cv::Matx::Matx	core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b, Matx_MatMulOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b, Matx_MatMulOp)
cv::Matx::Matx	core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, _T2 alpha, Matx_ScaleOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& a, _T2 alpha, Matx_ScaleOp)
cv::Matx::Matx	core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_AddOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_AddOp)
cv::Matx::Matx	core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_MulOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_MulOp)
cv::Matx::Matx	core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_SubOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_SubOp)
cv::Matx::Matx	core/operations.hpp	/^Matx<_Tp,m,n>::Matx(const Matx<_Tp, n, m>& a, Matx_TOp)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, n, m>& a, Matx_TOp)
cv::Matx::Matx	core/operations.hpp	/^inline Matx<_Tp,m,n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11)
cv::Matx::Matx	core/operations.hpp	/^inline Matx<_Tp,m,n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13, _Tp v14, _Tp v15)
cv::Matx::Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx()$/;"	f	class:cv::Matx	signature:()
cv::Matx::Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0)$/;"	f	class:cv::Matx	signature:(_Tp v0)
cv::Matx::Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1)$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1)
cv::Matx::Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2)$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2)
cv::Matx::Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3)$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
cv::Matx::Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)
cv::Matx::Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)
cv::Matx::Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6)
cv::Matx::Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7)
cv::Matx::Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8)
cv::Matx::Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Matx	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9)
cv::Matx::Matx	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n>::Matx(const _Tp* values)$/;"	f	class:cv::Matx	signature:(const _Tp* values)
cv::Matx::all	core/core.hpp	/^    static Matx all(_Tp alpha);$/;"	p	class:cv::Matx	access:public	signature:(_Tp alpha)
cv::Matx::all	core/operations.hpp	/^template<typename _Tp, int m, int n> inline Matx<_Tp, m, n> Matx<_Tp, m, n>::all(_Tp alpha)$/;"	f	class:cv::Matx	signature:(_Tp alpha)
cv::Matx::channels	core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, rows = m, cols = n, channels = rows*cols,$/;"	e	enum:cv::Matx::__anon113
cv::Matx::col	core/core.hpp	/^    Matx<_Tp, m, 1> col(int i) const;$/;"	p	class:cv::Matx	access:public	signature:(int i) const
cv::Matx::col	core/operations.hpp	/^Matx<_Tp, m, 1> Matx<_Tp, m, n>::col(int j) const$/;"	f	class:cv::Matx	signature:(int j) const
cv::Matx::cols	core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, rows = m, cols = n, channels = rows*cols,$/;"	e	enum:cv::Matx::__anon113
cv::Matx::ddot	core/core.hpp	/^    double ddot(const Matx<_Tp, m, n>& v) const;$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& v) const
cv::Matx::ddot	core/operations.hpp	/^template<typename _Tp, int m, int n> inline double Matx<_Tp, m, n>::ddot(const Matx<_Tp, m, n>& M) const$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& M) const
cv::Matx::depth	core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, rows = m, cols = n, channels = rows*cols,$/;"	e	enum:cv::Matx::__anon113
cv::Matx::diag	core/core.hpp	/^    Matx<_Tp, MIN(m,n), 1> diag() const;$/;"	p	class:cv::Matx	access:public	signature:() const
cv::Matx::diag	core/core.hpp	/^    static Matx diag(const diag_type& d);$/;"	p	class:cv::Matx	access:public	signature:(const diag_type& d)
cv::Matx::diag	core/operations.hpp	/^Matx<_Tp, MIN(m,n), 1> Matx<_Tp, m, n>::diag() const$/;"	f	class:cv::Matx	signature:() const
cv::Matx::diag	core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::diag(const Matx<_Tp,MIN(m,n),1>& d)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp,MIN(m,n),1>& d)
cv::Matx::diag_type	core/core.hpp	/^    typedef Matx<_Tp, MIN(m, n), 1> diag_type;$/;"	t	class:cv::Matx	access:public
cv::Matx::dot	core/core.hpp	/^    _Tp dot(const Matx<_Tp, m, n>& v) const;$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& v) const
cv::Matx::dot	core/operations.hpp	/^template<typename _Tp, int m, int n> inline _Tp Matx<_Tp, m, n>::dot(const Matx<_Tp, m, n>& M) const$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& M) const
cv::Matx::eye	core/core.hpp	/^    static Matx eye();$/;"	p	class:cv::Matx	access:public	signature:()
cv::Matx::eye	core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::eye()$/;"	f	class:cv::Matx	signature:()
cv::Matx::get_minor	core/core.hpp	/^    template<int m1, int n1> Matx<_Tp, m1, n1> get_minor(int i, int j) const;$/;"	p	class:cv::Matx	access:public	signature:(int i, int j) const
cv::Matx::get_minor	core/operations.hpp	/^Matx<_Tp, m1, n1> Matx<_Tp, m, n>::get_minor(int i, int j) const$/;"	f	class:cv::Matx	signature:(int i, int j) const
cv::Matx::inv	core/core.hpp	/^    Matx<_Tp, n, m> inv(int method=DECOMP_LU) const;$/;"	p	class:cv::Matx	access:public	signature:(int method=DECOMP_LU) const
cv::Matx::inv	core/operations.hpp	/^Matx<_Tp, n, m> Matx<_Tp, m, n>::inv(int method) const$/;"	f	class:cv::Matx	signature:(int method) const
cv::Matx::mat_type	core/core.hpp	/^    typedef Matx<_Tp, m, n> mat_type;$/;"	t	class:cv::Matx	access:public
cv::Matx::mul	core/core.hpp	/^    Matx<_Tp, m, n> mul(const Matx<_Tp, m, n>& a) const;$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& a) const
cv::Matx::mul	core/operations.hpp	/^Matx<_Tp, m, n> Matx<_Tp, m, n>::mul(const Matx<_Tp, m, n>& a) const$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& a) const
cv::Matx::ones	core/core.hpp	/^    static Matx ones();$/;"	p	class:cv::Matx	access:public	signature:()
cv::Matx::ones	core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::ones()$/;"	f	class:cv::Matx	signature:()
cv::Matx::operator ()	core/core.hpp	/^    _Tp& operator ()(int i);$/;"	p	class:cv::Matx	access:public	signature:(int i)
cv::Matx::operator ()	core/core.hpp	/^    _Tp& operator ()(int i, int j);$/;"	p	class:cv::Matx	access:public	signature:(int i, int j)
cv::Matx::operator ()	core/core.hpp	/^    const _Tp& operator ()(int i) const;$/;"	p	class:cv::Matx	access:public	signature:(int i) const
cv::Matx::operator ()	core/core.hpp	/^    const _Tp& operator ()(int i, int j) const;$/;"	p	class:cv::Matx	access:public	signature:(int i, int j) const
cv::Matx::operator ()	core/operations.hpp	/^_Tp& Matx<_Tp, m, n>::operator ()(int i)$/;"	f	class:cv::Matx	signature:(int i)
cv::Matx::operator ()	core/operations.hpp	/^_Tp& Matx<_Tp, m, n>::operator ()(int i, int j)$/;"	f	class:cv::Matx	signature:(int i, int j)
cv::Matx::operator ()	core/operations.hpp	/^const _Tp& Matx<_Tp, m, n>::operator ()(int i) const$/;"	f	class:cv::Matx	signature:(int i) const
cv::Matx::operator ()	core/operations.hpp	/^const _Tp& Matx<_Tp, m, n>::operator ()(int i, int j) const$/;"	f	class:cv::Matx	signature:(int i, int j) const
cv::Matx::operator Matx<T2, m, n>	core/core.hpp	/^    template<typename T2> operator Matx<T2, m, n>() const;$/;"	p	class:cv::Matx	access:public	signature:() const
cv::Matx::operator Matx<T2, m, n>	core/operations.hpp	/^inline Matx<_Tp, m, n>::operator Matx<T2, m, n>() const$/;"	f	class:cv::Matx	signature:() const
cv::Matx::randn	core/core.hpp	/^    static Matx randn(_Tp a, _Tp b);$/;"	p	class:cv::Matx	access:public	signature:(_Tp a, _Tp b)
cv::Matx::randn	core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::randn(_Tp a, _Tp b)$/;"	f	class:cv::Matx	signature:(_Tp a, _Tp b)
cv::Matx::randu	core/core.hpp	/^    static Matx randu(_Tp a, _Tp b);$/;"	p	class:cv::Matx	access:public	signature:(_Tp a, _Tp b)
cv::Matx::randu	core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::randu(_Tp a, _Tp b)$/;"	f	class:cv::Matx	signature:(_Tp a, _Tp b)
cv::Matx::reshape	core/core.hpp	/^    template<int m1, int n1> Matx<_Tp, m1, n1> reshape() const;$/;"	p	class:cv::Matx	access:public	signature:() const
cv::Matx::reshape	core/operations.hpp	/^Matx<_Tp, m1, n1> Matx<_Tp, m, n>::reshape() const$/;"	f	class:cv::Matx	signature:() const
cv::Matx::row	core/core.hpp	/^    Matx<_Tp, 1, n> row(int i) const;$/;"	p	class:cv::Matx	access:public	signature:(int i) const
cv::Matx::row	core/operations.hpp	/^Matx<_Tp, 1, n> Matx<_Tp, m, n>::row(int i) const$/;"	f	class:cv::Matx	signature:(int i) const
cv::Matx::rows	core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, rows = m, cols = n, channels = rows*cols,$/;"	e	enum:cv::Matx::__anon113
cv::Matx::solve	core/core.hpp	/^    Matx<_Tp, n, 1> solve(const Matx<_Tp, m, 1>& rhs, int method) const;$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, 1>& rhs, int method) const
cv::Matx::solve	core/core.hpp	/^    template<int l> Matx<_Tp, n, l> solve(const Matx<_Tp, m, l>& rhs, int flags=DECOMP_LU) const;$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, l>& rhs, int flags=DECOMP_LU) const
cv::Matx::solve	core/operations.hpp	/^Matx<_Tp, n, l> Matx<_Tp, m, n>::solve(const Matx<_Tp, m, l>& rhs, int method) const$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, l>& rhs, int method) const
cv::Matx::t	core/core.hpp	/^    Matx<_Tp, n, m> t() const;$/;"	p	class:cv::Matx	access:public	signature:() const
cv::Matx::t	core/operations.hpp	/^Matx<_Tp, n, m> Matx<_Tp, m, n>::t() const$/;"	f	class:cv::Matx	signature:() const
cv::Matx::type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::Matx::__anon113
cv::Matx::val	core/core.hpp	/^    _Tp val[m*n]; \/\/< matrix elements$/;"	m	class:cv::Matx	access:public
cv::Matx::value_type	core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Matx	access:public
cv::Matx::zeros	core/core.hpp	/^    static Matx zeros();$/;"	p	class:cv::Matx	access:public	signature:()
cv::Matx::zeros	core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::zeros()$/;"	f	class:cv::Matx	signature:()
cv::MatxCommaInitializer	core/core.hpp	/^template<typename _Tp, int m, int n> class CV_EXPORTS MatxCommaInitializer$/;"	c	namespace:cv
cv::MatxCommaInitializer::MatxCommaInitializer	core/core.hpp	/^    MatxCommaInitializer(Matx<_Tp, m, n>* _mtx);$/;"	p	class:cv::MatxCommaInitializer	access:public	signature:(Matx<_Tp, m, n>* _mtx)
cv::MatxCommaInitializer::MatxCommaInitializer	core/operations.hpp	/^MatxCommaInitializer<_Tp, m, n>::MatxCommaInitializer(Matx<_Tp, m, n>* _mtx)$/;"	f	class:cv::MatxCommaInitializer	signature:(Matx<_Tp, m, n>* _mtx)
cv::MatxCommaInitializer::dst	core/core.hpp	/^    Matx<_Tp, m, n>* dst;$/;"	m	class:cv::MatxCommaInitializer	access:public
cv::MatxCommaInitializer::idx	core/core.hpp	/^    int idx;$/;"	m	class:cv::MatxCommaInitializer	access:public
cv::MatxCommaInitializer::operator *	core/core.hpp	/^    Matx<_Tp, m, n> operator *() const;$/;"	p	class:cv::MatxCommaInitializer	access:public	signature:() const
cv::MatxCommaInitializer::operator *	core/operations.hpp	/^Matx<_Tp, m, n> MatxCommaInitializer<_Tp, m, n>::operator *() const$/;"	f	class:cv::MatxCommaInitializer	signature:() const
cv::MatxCommaInitializer::operator ,	core/core.hpp	/^    template<typename T2> MatxCommaInitializer<_Tp, m, n>& operator , (T2 val);$/;"	p	class:cv::MatxCommaInitializer	access:public	signature:(T2 val)
cv::MatxCommaInitializer::operator ,	core/operations.hpp	/^MatxCommaInitializer<_Tp, m, n>& MatxCommaInitializer<_Tp, m, n>::operator , (_T2 value)$/;"	f	class:cv::MatxCommaInitializer	signature:(_T2 value)
cv::Matx_AddOp	core/core.hpp	/^struct CV_EXPORTS Matx_AddOp {};$/;"	s	namespace:cv
cv::Matx_DetOp	core/operations.hpp	/^template<typename _Tp, int m> struct CV_EXPORTS Matx_DetOp$/;"	s	namespace:cv
cv::Matx_DetOp	core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_DetOp<_Tp, 1>$/;"	s	namespace:cv
cv::Matx_DetOp	core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_DetOp<_Tp, 2>$/;"	s	namespace:cv
cv::Matx_DetOp	core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_DetOp<_Tp, 3>$/;"	s	namespace:cv
cv::Matx_DetOp::operator ()	core/operations.hpp	/^    double operator ()(const Matx<_Tp, 1, 1>& a) const$/;"	f	struct:cv::Matx_DetOp	access:public	signature:(const Matx<_Tp, 1, 1>& a) const
cv::Matx_DetOp::operator ()	core/operations.hpp	/^    double operator ()(const Matx<_Tp, 2, 2>& a) const$/;"	f	struct:cv::Matx_DetOp	access:public	signature:(const Matx<_Tp, 2, 2>& a) const
cv::Matx_DetOp::operator ()	core/operations.hpp	/^    double operator ()(const Matx<_Tp, 3, 3>& a) const$/;"	f	struct:cv::Matx_DetOp	access:public	signature:(const Matx<_Tp, 3, 3>& a) const
cv::Matx_DetOp::operator ()	core/operations.hpp	/^    double operator ()(const Matx<_Tp, m, m>& a) const$/;"	f	struct:cv::Matx_DetOp	access:public	signature:(const Matx<_Tp, m, m>& a) const
cv::Matx_FastInvOp	core/operations.hpp	/^template<typename _Tp, int m> struct CV_EXPORTS Matx_FastInvOp$/;"	s	namespace:cv
cv::Matx_FastInvOp	core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_FastInvOp<_Tp, 2>$/;"	s	namespace:cv
cv::Matx_FastInvOp	core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_FastInvOp<_Tp, 3>$/;"	s	namespace:cv
cv::Matx_FastInvOp::operator ()	core/operations.hpp	/^    bool operator()(const Matx<_Tp, 2, 2>& a, Matx<_Tp, 2, 2>& b, int) const$/;"	f	struct:cv::Matx_FastInvOp	access:public	signature:(const Matx<_Tp, 2, 2>& a, Matx<_Tp, 2, 2>& b, int) const
cv::Matx_FastInvOp::operator ()	core/operations.hpp	/^    bool operator()(const Matx<_Tp, 3, 3>& a, Matx<_Tp, 3, 3>& b, int) const$/;"	f	struct:cv::Matx_FastInvOp	access:public	signature:(const Matx<_Tp, 3, 3>& a, Matx<_Tp, 3, 3>& b, int) const
cv::Matx_FastInvOp::operator ()	core/operations.hpp	/^    bool operator()(const Matx<_Tp, m, m>& a, Matx<_Tp, m, m>& b, int method) const$/;"	f	struct:cv::Matx_FastInvOp	access:public	signature:(const Matx<_Tp, m, m>& a, Matx<_Tp, m, m>& b, int method) const
cv::Matx_FastSolveOp	core/operations.hpp	/^template<typename _Tp, int m, int n> struct CV_EXPORTS Matx_FastSolveOp$/;"	s	namespace:cv
cv::Matx_FastSolveOp	core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_FastSolveOp<_Tp, 2, 1>$/;"	s	namespace:cv
cv::Matx_FastSolveOp	core/operations.hpp	/^template<typename _Tp> struct CV_EXPORTS Matx_FastSolveOp<_Tp, 3, 1>$/;"	s	namespace:cv
cv::Matx_FastSolveOp::operator ()	core/operations.hpp	/^    bool operator()(const Matx<_Tp, 2, 2>& a, const Matx<_Tp, 2, 1>& b,$/;"	f	struct:cv::Matx_FastSolveOp	access:public	signature:(const Matx<_Tp, 2, 2>& a, const Matx<_Tp, 2, 1>& b, Matx<_Tp, 2, 1>& x, int method) const
cv::Matx_FastSolveOp::operator ()	core/operations.hpp	/^    bool operator()(const Matx<_Tp, 3, 3>& a, const Matx<_Tp, 3, 1>& b,$/;"	f	struct:cv::Matx_FastSolveOp	access:public	signature:(const Matx<_Tp, 3, 3>& a, const Matx<_Tp, 3, 1>& b, Matx<_Tp, 3, 1>& x, int method) const
cv::Matx_FastSolveOp::operator ()	core/operations.hpp	/^    bool operator()(const Matx<_Tp, m, m>& a, const Matx<_Tp, m, n>& b,$/;"	f	struct:cv::Matx_FastSolveOp	access:public	signature:(const Matx<_Tp, m, m>& a, const Matx<_Tp, m, n>& b, Matx<_Tp, m, n>& x, int method) const
cv::Matx_MatMulOp	core/core.hpp	/^struct CV_EXPORTS Matx_MatMulOp {};$/;"	s	namespace:cv
cv::Matx_MulOp	core/core.hpp	/^struct CV_EXPORTS Matx_MulOp {};$/;"	s	namespace:cv
cv::Matx_ScaleOp	core/core.hpp	/^struct CV_EXPORTS Matx_ScaleOp {};$/;"	s	namespace:cv
cv::Matx_SubOp	core/core.hpp	/^struct CV_EXPORTS Matx_SubOp {};$/;"	s	namespace:cv
cv::Matx_TOp	core/core.hpp	/^struct CV_EXPORTS Matx_TOp {};$/;"	s	namespace:cv
cv::MemStorage	core/core.hpp	/^typedef Ptr<CvMemStorage> MemStorage;$/;"	t	namespace:cv
cv::Mesh3D	contrib/contrib.hpp	/^    class CV_EXPORTS Mesh3D$/;"	c	namespace:cv
cv::Mesh3D::EmptyMeshException	contrib/contrib.hpp	/^        struct EmptyMeshException {};$/;"	s	class:cv::Mesh3D	access:public
cv::Mesh3D::Mesh3D	contrib/contrib.hpp	/^        Mesh3D();$/;"	p	class:cv::Mesh3D	access:public	signature:()
cv::Mesh3D::Mesh3D	contrib/contrib.hpp	/^        Mesh3D(const vector<Point3f>& vtx);$/;"	p	class:cv::Mesh3D	access:public	signature:(const vector<Point3f>& vtx)
cv::Mesh3D::allzero	contrib/contrib.hpp	/^        const static Point3f allzero;$/;"	m	class:cv::Mesh3D	access:public
cv::Mesh3D::buildOctree	contrib/contrib.hpp	/^        void buildOctree();$/;"	p	class:cv::Mesh3D	access:public	signature:()
cv::Mesh3D::clearOctree	contrib/contrib.hpp	/^        void clearOctree();$/;"	p	class:cv::Mesh3D	access:public	signature:()
cv::Mesh3D::computeNormals	contrib/contrib.hpp	/^        void computeNormals(const vector<int>& subset, float normalRadius, int minNeighbors = 20);$/;"	p	class:cv::Mesh3D	access:public	signature:(const vector<int>& subset, float normalRadius, int minNeighbors = 20)
cv::Mesh3D::computeNormals	contrib/contrib.hpp	/^        void computeNormals(float normalRadius, int minNeighbors = 20);$/;"	p	class:cv::Mesh3D	access:public	signature:(float normalRadius, int minNeighbors = 20)
cv::Mesh3D::estimateResolution	contrib/contrib.hpp	/^        float estimateResolution(float tryRatio = 0.1f);$/;"	p	class:cv::Mesh3D	access:public	signature:(float tryRatio = 0.1f)
cv::Mesh3D::normals	contrib/contrib.hpp	/^        vector<Point3f> normals;$/;"	m	class:cv::Mesh3D	access:public
cv::Mesh3D::octree	contrib/contrib.hpp	/^        Octree octree;$/;"	m	class:cv::Mesh3D	access:public
cv::Mesh3D::resolution	contrib/contrib.hpp	/^        float resolution;$/;"	m	class:cv::Mesh3D	access:public
cv::Mesh3D::vtx	contrib/contrib.hpp	/^        vector<Point3f> vtx;$/;"	m	class:cv::Mesh3D	access:public
cv::Mesh3D::writeAsVrml	contrib/contrib.hpp	/^        void writeAsVrml(const String& file, const vector<Scalar>& colors = vector<Scalar>()) const;$/;"	p	class:cv::Mesh3D	access:public	signature:(const String& file, const vector<Scalar>& colors = vector<Scalar>()) const
cv::Mesh3D::~Mesh3D	contrib/contrib.hpp	/^        ~Mesh3D();$/;"	p	class:cv::Mesh3D	access:public	signature:()
cv::Moments	imgproc/imgproc.hpp	/^class CV_EXPORTS_W_MAP Moments$/;"	c	namespace:cv
cv::Moments::Moments	imgproc/imgproc.hpp	/^    Moments( const CvMoments& moments );$/;"	p	class:cv::Moments	access:public	signature:( const CvMoments& moments )
cv::Moments::Moments	imgproc/imgproc.hpp	/^    Moments();$/;"	p	class:cv::Moments	access:public	signature:()
cv::Moments::Moments	imgproc/imgproc.hpp	/^    Moments(double m00, double m10, double m01, double m20, double m11,$/;"	p	class:cv::Moments	access:public	signature:(double m00, double m10, double m01, double m20, double m11, double m02, double m30, double m21, double m12, double m03 )
cv::Moments::m00	imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
cv::Moments::m01	imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
cv::Moments::m02	imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
cv::Moments::m03	imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
cv::Moments::m10	imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
cv::Moments::m11	imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
cv::Moments::m12	imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
cv::Moments::m20	imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
cv::Moments::m21	imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
cv::Moments::m30	imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
cv::Moments::mu02	imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::mu03	imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::mu11	imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::mu12	imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::mu20	imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::mu21	imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::mu30	imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::nu02	imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::nu03	imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::nu11	imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::nu12	imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::nu20	imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::nu21	imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::nu30	imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
cv::Moments::operator CvMoments	imgproc/imgproc.hpp	/^    operator CvMoments() const;$/;"	p	class:cv::Moments	access:public	signature:() const
cv::MouseCallback	highgui/highgui.hpp	/^typedef void (*MouseCallback )(int event, int x, int y, int flags, void* param);$/;"	t	namespace:cv
cv::MserFeatureDetector	features2d/features2d.hpp	/^class CV_EXPORTS MserFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
cv::MserFeatureDetector::MserFeatureDetector	features2d/features2d.hpp	/^    MserFeatureDetector( CvMSERParams params=cvMSERParams() );$/;"	p	class:cv::MserFeatureDetector	access:public	signature:( CvMSERParams params=cvMSERParams() )
cv::MserFeatureDetector::MserFeatureDetector	features2d/features2d.hpp	/^    MserFeatureDetector( int delta, int minArea, int maxArea, double maxVariation, double minDiversity,$/;"	p	class:cv::MserFeatureDetector	access:public	signature:( int delta, int minArea, int maxArea, double maxVariation, double minDiversity, int maxEvolution, double areaThreshold, double minMargin, int edgeBlurSize )
cv::MserFeatureDetector::detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::MserFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::MserFeatureDetector::mser	features2d/features2d.hpp	/^    MSER mser;$/;"	m	class:cv::MserFeatureDetector	access:protected
cv::MserFeatureDetector::read	features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::MserFeatureDetector	access:public	signature:( const FileNode& fn )
cv::MserFeatureDetector::write	features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::MserFeatureDetector	access:public	signature:( FileStorage& fs ) const
cv::NAryMatIterator	core/core.hpp	/^class CV_EXPORTS NAryMatIterator$/;"	c	namespace:cv
cv::NAryMatIterator::NAryMatIterator	core/core.hpp	/^    NAryMatIterator();$/;"	p	class:cv::NAryMatIterator	access:public	signature:()
cv::NAryMatIterator::NAryMatIterator	core/core.hpp	/^    NAryMatIterator(const Mat** arrays, Mat* planes, int narrays=-1);$/;"	p	class:cv::NAryMatIterator	access:public	signature:(const Mat** arrays, Mat* planes, int narrays=-1)
cv::NAryMatIterator::NAryMatIterator	core/core.hpp	/^    NAryMatIterator(const Mat** arrays, uchar** ptrs, int narrays=-1);$/;"	p	class:cv::NAryMatIterator	access:public	signature:(const Mat** arrays, uchar** ptrs, int narrays=-1)
cv::NAryMatIterator::arrays	core/core.hpp	/^    const Mat** arrays;$/;"	m	class:cv::NAryMatIterator	access:public
cv::NAryMatIterator::idx	core/core.hpp	/^    size_t idx;$/;"	m	class:cv::NAryMatIterator	access:protected
cv::NAryMatIterator::init	core/core.hpp	/^    void init(const Mat** arrays, Mat* planes, uchar** ptrs, int narrays=-1);$/;"	p	class:cv::NAryMatIterator	access:public	signature:(const Mat** arrays, Mat* planes, uchar** ptrs, int narrays=-1)
cv::NAryMatIterator::iterdepth	core/core.hpp	/^    int iterdepth;$/;"	m	class:cv::NAryMatIterator	access:protected
cv::NAryMatIterator::narrays	core/core.hpp	/^    int narrays;$/;"	m	class:cv::NAryMatIterator	access:public
cv::NAryMatIterator::nplanes	core/core.hpp	/^    size_t nplanes;$/;"	m	class:cv::NAryMatIterator	access:public
cv::NAryMatIterator::operator ++	core/core.hpp	/^    NAryMatIterator operator ++(int);$/;"	p	class:cv::NAryMatIterator	access:public	signature:(int)
cv::NAryMatIterator::operator ++	core/core.hpp	/^    NAryMatIterator& operator ++();$/;"	p	class:cv::NAryMatIterator	access:public	signature:()
cv::NAryMatIterator::planes	core/core.hpp	/^    Mat* planes;$/;"	m	class:cv::NAryMatIterator	access:public
cv::NAryMatIterator::ptrs	core/core.hpp	/^    uchar** ptrs;$/;"	m	class:cv::NAryMatIterator	access:public
cv::NAryMatIterator::size	core/core.hpp	/^    size_t size;$/;"	m	class:cv::NAryMatIterator	access:public
cv::NORM_INF	core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon98
cv::NORM_L1	core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon98
cv::NORM_L2	core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon98
cv::NORM_MINMAX	core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon98
cv::NORM_RELATIVE	core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon98
cv::NORM_TYPE_MASK	core/core.hpp	/^enum { NORM_INF=1, NORM_L1=2, NORM_L2=4, NORM_TYPE_MASK=7, NORM_RELATIVE=8, NORM_MINMAX=32};$/;"	e	enum:cv::__anon98
cv::NeuralNet_MLP	ml/ml.hpp	/^typedef CvANN_MLP NeuralNet_MLP;$/;"	t	namespace:cv
cv::NormalBayesClassifier	ml/ml.hpp	/^typedef CvNormalBayesClassifier NormalBayesClassifier;$/;"	t	namespace:cv
cv::OPTFLOW_FARNEBACK_GAUSSIAN	video/tracking.hpp	/^enum { OPTFLOW_USE_INITIAL_FLOW=4, OPTFLOW_FARNEBACK_GAUSSIAN=256 };$/;"	e	enum:cv::__anon176
cv::OPTFLOW_USE_INITIAL_FLOW	video/tracking.hpp	/^enum { OPTFLOW_USE_INITIAL_FLOW=4, OPTFLOW_FARNEBACK_GAUSSIAN=256 };$/;"	e	enum:cv::__anon176
cv::ORB	features2d/features2d.hpp	/^class CV_EXPORTS ORB$/;"	c	namespace:cv
cv::ORB::CommonParams	features2d/features2d.hpp	/^  struct CV_EXPORTS CommonParams$/;"	s	class:cv::ORB	access:public
cv::ORB::CommonParams::CommonParams	features2d/features2d.hpp	/^    CommonParams(float scale_factor = 1.2f, unsigned int n_levels = DEFAULT_N_LEVELS, int edge_threshold = 31,$/;"	f	struct:cv::ORB::CommonParams	access:public	signature:(float scale_factor = 1.2f, unsigned int n_levels = DEFAULT_N_LEVELS, int edge_threshold = 31, unsigned int first_level = DEFAULT_FIRST_LEVEL)
cv::ORB::CommonParams::DEFAULT_FIRST_LEVEL	features2d/features2d.hpp	/^    enum { DEFAULT_N_LEVELS = 3, DEFAULT_FIRST_LEVEL = 0};$/;"	e	enum:cv::ORB::CommonParams::__anon192
cv::ORB::CommonParams::DEFAULT_N_LEVELS	features2d/features2d.hpp	/^    enum { DEFAULT_N_LEVELS = 3, DEFAULT_FIRST_LEVEL = 0};$/;"	e	enum:cv::ORB::CommonParams::__anon192
cv::ORB::CommonParams::edge_threshold_	features2d/features2d.hpp	/^    int edge_threshold_;$/;"	m	struct:cv::ORB::CommonParams	access:public
cv::ORB::CommonParams::first_level_	features2d/features2d.hpp	/^    unsigned int first_level_;$/;"	m	struct:cv::ORB::CommonParams	access:public
cv::ORB::CommonParams::n_levels_	features2d/features2d.hpp	/^    unsigned int n_levels_;$/;"	m	struct:cv::ORB::CommonParams	access:public
cv::ORB::CommonParams::patch_size_	features2d/features2d.hpp	/^    int patch_size_;$/;"	m	struct:cv::ORB::CommonParams	access:protected
cv::ORB::CommonParams::read	features2d/features2d.hpp	/^    void read(const FileNode& fn);$/;"	p	struct:cv::ORB::CommonParams	access:public	signature:(const FileNode& fn)
cv::ORB::CommonParams::scale_factor_	features2d/features2d.hpp	/^    float scale_factor_;$/;"	m	struct:cv::ORB::CommonParams	access:public
cv::ORB::CommonParams::write	features2d/features2d.hpp	/^    void write(FileStorage& fs) const;$/;"	p	struct:cv::ORB::CommonParams	access:public	signature:(FileStorage& fs) const
cv::ORB::ORB	features2d/features2d.hpp	/^  ORB(size_t n_features = 500, const CommonParams & detector_params = CommonParams());$/;"	p	class:cv::ORB	access:public	signature:(size_t n_features = 500, const CommonParams & detector_params = CommonParams())
cv::ORB::computeDescriptors	features2d/features2d.hpp	/^  computeDescriptors(const cv::Mat& image, const cv::Mat& integral_image, unsigned int level,$/;"	p	class:cv::ORB	access:private	signature:(const cv::Mat& image, const cv::Mat& integral_image, unsigned int level, std::vector<cv::KeyPoint>& keypoints, cv::Mat & descriptors) const
cv::ORB::computeIntegralImage	features2d/features2d.hpp	/^  void computeIntegralImage(const cv::Mat & image, unsigned int level, cv::Mat &integral_image);$/;"	p	class:cv::ORB	access:private	signature:(const cv::Mat & image, unsigned int level, cv::Mat &integral_image)
cv::ORB::computeKeyPoints	features2d/features2d.hpp	/^  void computeKeyPoints(const std::vector<cv::Mat>& image_pyramid, const std::vector<cv::Mat>& mask_pyramid,$/;"	p	class:cv::ORB	access:private	signature:(const std::vector<cv::Mat>& image_pyramid, const std::vector<cv::Mat>& mask_pyramid, std::vector<std::vector<cv::KeyPoint> >& keypoints) const
cv::ORB::computeOrientation	features2d/features2d.hpp	/^  computeOrientation(const cv::Mat& image, const cv::Mat& integral_image, unsigned int level,$/;"	p	class:cv::ORB	access:private	signature:(const cv::Mat& image, const cv::Mat& integral_image, unsigned int level, std::vector<cv::KeyPoint>& keypoints) const
cv::ORB::descriptorSize	features2d/features2d.hpp	/^  int descriptorSize() const;$/;"	p	class:cv::ORB	access:public	signature:() const
cv::ORB::half_patch_size_	features2d/features2d.hpp	/^  int half_patch_size_;$/;"	m	class:cv::ORB	access:private
cv::ORB::integral_image_steps_	features2d/features2d.hpp	/^  std::vector<size_t> integral_image_steps_;$/;"	m	class:cv::ORB	access:private
cv::ORB::kBytes	features2d/features2d.hpp	/^  enum { kBytes = 32 };$/;"	e	enum:cv::ORB::__anon191
cv::ORB::kKernelWidth	features2d/features2d.hpp	/^  static const int kKernelWidth = 5;$/;"	m	class:cv::ORB	access:private
cv::ORB::n_features_	features2d/features2d.hpp	/^  size_t n_features_;$/;"	m	class:cv::ORB	access:private
cv::ORB::n_features_per_level_	features2d/features2d.hpp	/^  std::vector<size_t> n_features_per_level_;$/;"	m	class:cv::ORB	access:private
cv::ORB::operator ()	features2d/features2d.hpp	/^  operator()(const cv::Mat &image, const cv::Mat &mask, std::vector<cv::KeyPoint> & keypoints);$/;"	p	class:cv::ORB	access:public	signature:(const cv::Mat &image, const cv::Mat &mask, std::vector<cv::KeyPoint> & keypoints)
cv::ORB::operator ()	features2d/features2d.hpp	/^  operator()(const cv::Mat &image, const cv::Mat &mask, std::vector<cv::KeyPoint> & keypoints, cv::Mat & descriptors,$/;"	p	class:cv::ORB	access:private	signature:(const cv::Mat &image, const cv::Mat &mask, std::vector<cv::KeyPoint> & keypoints, cv::Mat & descriptors, bool do_keypoints, bool do_descriptors)
cv::ORB::operator ()	features2d/features2d.hpp	/^  operator()(const cv::Mat &image, const cv::Mat &mask, std::vector<cv::KeyPoint> & keypoints, cv::Mat & descriptors,$/;"	p	class:cv::ORB	access:public	signature:(const cv::Mat &image, const cv::Mat &mask, std::vector<cv::KeyPoint> & keypoints, cv::Mat & descriptors, bool useProvidedKeypoints = false)
cv::ORB::orientation_horizontal_offsets_	features2d/features2d.hpp	/^  std::vector<std::vector<int> > orientation_horizontal_offsets_;$/;"	m	class:cv::ORB	access:private
cv::ORB::orientation_vertical_offsets_	features2d/features2d.hpp	/^  std::vector<std::vector<int> > orientation_vertical_offsets_;$/;"	m	class:cv::ORB	access:private
cv::ORB::params_	features2d/features2d.hpp	/^  CommonParams params_;$/;"	m	class:cv::ORB	access:private
cv::ORB::patterns_	features2d/features2d.hpp	/^  std::vector<OrbPatterns*> patterns_;$/;"	m	class:cv::ORB	access:private
cv::ORB::u_max_	features2d/features2d.hpp	/^  std::vector<int> u_max_;$/;"	m	class:cv::ORB	access:private
cv::ORB::~ORB	features2d/features2d.hpp	/^  ~ORB();$/;"	p	class:cv::ORB	access:public	signature:()
cv::Octree	contrib/contrib.hpp	/^    class CV_EXPORTS Octree$/;"	c	namespace:cv
cv::Octree::Node	contrib/contrib.hpp	/^        struct Node$/;"	s	class:cv::Octree	access:public
cv::Octree::Node::Node	contrib/contrib.hpp	/^            Node() {}$/;"	f	struct:cv::Octree::Node	access:public	signature:()
cv::Octree::Node::begin	contrib/contrib.hpp	/^            int begin, end;$/;"	m	struct:cv::Octree::Node	access:public
cv::Octree::Node::children	contrib/contrib.hpp	/^            int children[8];$/;"	m	struct:cv::Octree::Node	access:public
cv::Octree::Node::end	contrib/contrib.hpp	/^            int begin, end;$/;"	m	struct:cv::Octree::Node	access:public
cv::Octree::Node::isLeaf	contrib/contrib.hpp	/^            bool isLeaf;$/;"	m	struct:cv::Octree::Node	access:public
cv::Octree::Node::maxLevels	contrib/contrib.hpp	/^            int maxLevels;$/;"	m	struct:cv::Octree::Node	access:public
cv::Octree::Node::x_max	contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
cv::Octree::Node::x_min	contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
cv::Octree::Node::y_max	contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
cv::Octree::Node::y_min	contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
cv::Octree::Node::z_max	contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
cv::Octree::Node::z_min	contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
cv::Octree::Octree	contrib/contrib.hpp	/^        Octree( const vector<Point3f>& points, int maxLevels = 10, int minPoints = 20 );$/;"	p	class:cv::Octree	access:public	signature:( const vector<Point3f>& points, int maxLevels = 10, int minPoints = 20 )
cv::Octree::Octree	contrib/contrib.hpp	/^        Octree();$/;"	p	class:cv::Octree	access:public	signature:()
cv::Octree::buildNext	contrib/contrib.hpp	/^        virtual void buildNext(size_t node_ind);$/;"	p	class:cv::Octree	access:private	signature:(size_t node_ind)
cv::Octree::buildTree	contrib/contrib.hpp	/^        virtual void buildTree( const vector<Point3f>& points, int maxLevels = 10, int minPoints = 20 );$/;"	p	class:cv::Octree	access:public	signature:( const vector<Point3f>& points, int maxLevels = 10, int minPoints = 20 )
cv::Octree::getNodes	contrib/contrib.hpp	/^        const vector<Node>& getNodes() const { return nodes; }$/;"	f	class:cv::Octree	access:public	signature:() const
cv::Octree::getPointsWithinSphere	contrib/contrib.hpp	/^        virtual void getPointsWithinSphere( const Point3f& center, float radius,$/;"	p	class:cv::Octree	access:public	signature:( const Point3f& center, float radius, vector<Point3f>& points ) const
cv::Octree::minPoints	contrib/contrib.hpp	/^        int minPoints;$/;"	m	class:cv::Octree	access:private
cv::Octree::nodes	contrib/contrib.hpp	/^        vector<Node> nodes;$/;"	m	class:cv::Octree	access:private
cv::Octree::points	contrib/contrib.hpp	/^        vector<Point3f> points;$/;"	m	class:cv::Octree	access:private
cv::Octree::~Octree	contrib/contrib.hpp	/^        virtual ~Octree();$/;"	p	class:cv::Octree	access:public	signature:()
cv::OneWayDescriptor	features2d/features2d.hpp	/^class CV_EXPORTS OneWayDescriptor$/;"	c	namespace:cv
cv::OneWayDescriptor::Allocate	features2d/features2d.hpp	/^    void Allocate(int pose_count, CvSize size, int nChannels);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int pose_count, CvSize size, int nChannels)
cv::OneWayDescriptor::EstimatePose	features2d/features2d.hpp	/^    void EstimatePose(IplImage* patch, int& pose_idx, float& distance) const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(IplImage* patch, int& pose_idx, float& distance) const
cv::OneWayDescriptor::EstimatePosePCA	features2d/features2d.hpp	/^    void EstimatePosePCA(CvArr* patch, int& pose_idx, float& distance, CvMat* avg, CvMat* eigenvalues) const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(CvArr* patch, int& pose_idx, float& distance, CvMat* avg, CvMat* eigenvalues) const
cv::OneWayDescriptor::GenerateSamples	features2d/features2d.hpp	/^    void GenerateSamples(int pose_count, IplImage* frontal, int norm = 0);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int pose_count, IplImage* frontal, int norm = 0)
cv::OneWayDescriptor::GenerateSamplesFast	features2d/features2d.hpp	/^    void GenerateSamplesFast(IplImage* frontal, CvMat* pca_hr_avg,$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(IplImage* frontal, CvMat* pca_hr_avg, CvMat* pca_hr_eigenvectors, OneWayDescriptor* pca_descriptors)
cv::OneWayDescriptor::GetCenter	features2d/features2d.hpp	/^    CvPoint GetCenter() const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:() const
cv::OneWayDescriptor::GetFeatureName	features2d/features2d.hpp	/^    const char* GetFeatureName() const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:() const
cv::OneWayDescriptor::GetInputPatchSize	features2d/features2d.hpp	/^    CvSize GetInputPatchSize() const$/;"	f	class:cv::OneWayDescriptor	access:public	signature:() const
cv::OneWayDescriptor::GetPCACoeffs	features2d/features2d.hpp	/^    CvMat** GetPCACoeffs() const {return m_pca_coeffs;}$/;"	f	class:cv::OneWayDescriptor	access:public	signature:() const
cv::OneWayDescriptor::GetPCADimHigh	features2d/features2d.hpp	/^    int GetPCADimHigh() const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:() const
cv::OneWayDescriptor::GetPCADimLow	features2d/features2d.hpp	/^    int GetPCADimLow() const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:() const
cv::OneWayDescriptor::GetPatch	features2d/features2d.hpp	/^    IplImage* GetPatch(int index);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int index)
cv::OneWayDescriptor::GetPatchSize	features2d/features2d.hpp	/^    CvSize GetPatchSize() const$/;"	f	class:cv::OneWayDescriptor	access:public	signature:() const
cv::OneWayDescriptor::GetPose	features2d/features2d.hpp	/^    CvAffinePose GetPose(int index) const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int index) const
cv::OneWayDescriptor::Initialize	features2d/features2d.hpp	/^    void Initialize(int pose_count, IplImage* frontal, const char* feature_name = 0, int norm = 0);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int pose_count, IplImage* frontal, const char* feature_name = 0, int norm = 0)
cv::OneWayDescriptor::InitializeFast	features2d/features2d.hpp	/^    void InitializeFast(int pose_count, IplImage* frontal, const char* feature_name,$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(int pose_count, IplImage* frontal, const char* feature_name, CvMat* pca_hr_avg, CvMat* pca_hr_eigenvectors, OneWayDescriptor* pca_descriptors)
cv::OneWayDescriptor::InitializePCACoeffs	features2d/features2d.hpp	/^    void InitializePCACoeffs(CvMat* avg, CvMat* eigenvectors);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(CvMat* avg, CvMat* eigenvectors)
cv::OneWayDescriptor::OneWayDescriptor	features2d/features2d.hpp	/^    OneWayDescriptor();$/;"	p	class:cv::OneWayDescriptor	access:public	signature:()
cv::OneWayDescriptor::ProjectPCASample	features2d/features2d.hpp	/^    void ProjectPCASample(IplImage* patch, CvMat* avg, CvMat* eigenvectors, CvMat* pca_coeffs) const;$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(IplImage* patch, CvMat* avg, CvMat* eigenvectors, CvMat* pca_coeffs) const
cv::OneWayDescriptor::ReadByName	features2d/features2d.hpp	/^    int ReadByName(CvFileStorage* fs, CvFileNode* parent, const char* name);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(CvFileStorage* fs, CvFileNode* parent, const char* name)
cv::OneWayDescriptor::ReadByName	features2d/features2d.hpp	/^    int ReadByName(const FileNode &parent, const char* name);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(const FileNode &parent, const char* name)
cv::OneWayDescriptor::Save	features2d/features2d.hpp	/^    void Save(const char* path);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(const char* path)
cv::OneWayDescriptor::SetPCADimHigh	features2d/features2d.hpp	/^    void SetPCADimHigh(int pca_dim_high) {m_pca_dim_high = pca_dim_high;};$/;"	f	class:cv::OneWayDescriptor	access:public	signature:(int pca_dim_high)
cv::OneWayDescriptor::SetPCADimLow	features2d/features2d.hpp	/^    void SetPCADimLow(int pca_dim_low) {m_pca_dim_low = pca_dim_low;};$/;"	f	class:cv::OneWayDescriptor	access:public	signature:(int pca_dim_low)
cv::OneWayDescriptor::SetTransforms	features2d/features2d.hpp	/^    void SetTransforms(CvAffinePose* poses, CvMat** transforms);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(CvAffinePose* poses, CvMat** transforms)
cv::OneWayDescriptor::Write	features2d/features2d.hpp	/^    void Write(CvFileStorage* fs, const char* name);$/;"	p	class:cv::OneWayDescriptor	access:public	signature:(CvFileStorage* fs, const char* name)
cv::OneWayDescriptor::m_affine_poses	features2d/features2d.hpp	/^    CvAffinePose* m_affine_poses; \/\/ an array of poses$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::m_center	features2d/features2d.hpp	/^    CvPoint m_center; \/\/ the coordinates of the feature (the center of the input image ROI)$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::m_feature_name	features2d/features2d.hpp	/^    string m_feature_name; \/\/ the name of the feature associated with the descriptor$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::m_input_patch	features2d/features2d.hpp	/^    IplImage* m_input_patch;$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::m_patch_size	features2d/features2d.hpp	/^    CvSize m_patch_size; \/\/ size of each image$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::m_pca_coeffs	features2d/features2d.hpp	/^    CvMat** m_pca_coeffs; \/\/ an array of length m_pose_count containing pca decomposition of the patch in different poses$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::m_pca_dim_high	features2d/features2d.hpp	/^    int m_pca_dim_high; \/\/ the number of descriptor pca components to use for generating affine poses$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::m_pca_dim_low	features2d/features2d.hpp	/^    int m_pca_dim_low; \/\/ the number of pca components to use for comparison$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::m_pose_count	features2d/features2d.hpp	/^    int m_pose_count; \/\/ the number of poses$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::m_samples	features2d/features2d.hpp	/^    IplImage** m_samples; \/\/ an array of length m_pose_count containing the patch in different poses$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::m_train_patch	features2d/features2d.hpp	/^    IplImage* m_train_patch;$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::m_transforms	features2d/features2d.hpp	/^    CvMat** m_transforms; \/\/ an array of affine transforms corresponding to poses$/;"	m	class:cv::OneWayDescriptor	access:protected
cv::OneWayDescriptor::~OneWayDescriptor	features2d/features2d.hpp	/^    ~OneWayDescriptor();$/;"	p	class:cv::OneWayDescriptor	access:public	signature:()
cv::OneWayDescriptorBase	features2d/features2d.hpp	/^class CV_EXPORTS OneWayDescriptorBase$/;"	c	namespace:cv
cv::OneWayDescriptorBase::Allocate	features2d/features2d.hpp	/^    void Allocate(int train_feature_count);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(int train_feature_count)
cv::OneWayDescriptorBase::AllocatePCADescriptors	features2d/features2d.hpp	/^    void AllocatePCADescriptors();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
cv::OneWayDescriptorBase::ConvertDescriptorsArrayToTree	features2d/features2d.hpp	/^    void ConvertDescriptorsArrayToTree(); \/\/ Converting pca_descriptors array to KD tree$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
cv::OneWayDescriptorBase::CreateDescriptorsFromImage	features2d/features2d.hpp	/^    void CreateDescriptorsFromImage(IplImage* src, const std::vector<cv::KeyPoint>& features);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(IplImage* src, const std::vector<cv::KeyPoint>& features)
cv::OneWayDescriptorBase::CreatePCADescriptors	features2d/features2d.hpp	/^    void CreatePCADescriptors();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
cv::OneWayDescriptorBase::FindDescriptor	features2d/features2d.hpp	/^    void FindDescriptor(IplImage* patch, int n, std::vector<int>& desc_idxs, std::vector<int>& pose_idxs,$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(IplImage* patch, int n, std::vector<int>& desc_idxs, std::vector<int>& pose_idxs, std::vector<float>& distances, std::vector<float>& _scales, float* scale_ranges = 0) const
cv::OneWayDescriptorBase::FindDescriptor	features2d/features2d.hpp	/^    void FindDescriptor(IplImage* patch, int& desc_idx, int& pose_idx, float& distance, float* _scale = 0, float* scale_ranges = 0) const;$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(IplImage* patch, int& desc_idx, int& pose_idx, float& distance, float* _scale = 0, float* scale_ranges = 0) const
cv::OneWayDescriptorBase::FindDescriptor	features2d/features2d.hpp	/^    void FindDescriptor(IplImage* src, cv::Point2f pt, int& desc_idx, int& pose_idx, float& distance) const;$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(IplImage* src, cv::Point2f pt, int& desc_idx, int& pose_idx, float& distance) const
cv::OneWayDescriptorBase::GeneratePCA	features2d/features2d.hpp	/^    void GeneratePCA(const char* img_path, const char* images_list, int pose_count=500);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(const char* img_path, const char* images_list, int pose_count=500)
cv::OneWayDescriptorBase::GetDescriptor	features2d/features2d.hpp	/^    const OneWayDescriptor* GetDescriptor(int desc_idx) const {return &m_descriptors[desc_idx];};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:(int desc_idx) const
cv::OneWayDescriptorBase::GetDescriptorCount	features2d/features2d.hpp	/^    int GetDescriptorCount() const {return m_train_feature_count;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
cv::OneWayDescriptorBase::GetLowPCA	features2d/features2d.hpp	/^    int GetLowPCA(CvMat** avg, CvMat** eigenvectors)$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:(CvMat** avg, CvMat** eigenvectors)
cv::OneWayDescriptorBase::GetPCADimHigh	features2d/features2d.hpp	/^    int GetPCADimHigh() const {return m_pca_dim_high;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
cv::OneWayDescriptorBase::GetPCADimLow	features2d/features2d.hpp	/^    int GetPCADimLow() const {return m_pca_dim_low;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
cv::OneWayDescriptorBase::GetPCAFilename	features2d/features2d.hpp	/^    static string GetPCAFilename () { return "pca.yml"; }$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:()
cv::OneWayDescriptorBase::GetPatchSize	features2d/features2d.hpp	/^    CvSize GetPatchSize() const {return m_patch_size;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
cv::OneWayDescriptorBase::GetPoseCount	features2d/features2d.hpp	/^    int GetPoseCount() const {return m_pose_count;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
cv::OneWayDescriptorBase::GetPyrLevels	features2d/features2d.hpp	/^    int GetPyrLevels() const {return m_pyr_levels;};$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
cv::OneWayDescriptorBase::InitializeDescriptor	features2d/features2d.hpp	/^    void InitializeDescriptor(int desc_idx, IplImage* train_image, const char* feature_label);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(int desc_idx, IplImage* train_image, const char* feature_label)
cv::OneWayDescriptorBase::InitializeDescriptor	features2d/features2d.hpp	/^    void InitializeDescriptor(int desc_idx, IplImage* train_image, const cv::KeyPoint& keypoint, const char* feature_label);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(int desc_idx, IplImage* train_image, const cv::KeyPoint& keypoint, const char* feature_label)
cv::OneWayDescriptorBase::InitializeDescriptors	features2d/features2d.hpp	/^    void InitializeDescriptors(IplImage* train_image, const vector<cv::KeyPoint>& features,$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(IplImage* train_image, const vector<cv::KeyPoint>& features, const char* feature_label = , int desc_start_idx = 0)
cv::OneWayDescriptorBase::InitializePoseTransforms	features2d/features2d.hpp	/^    void InitializePoseTransforms();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
cv::OneWayDescriptorBase::InitializePoses	features2d/features2d.hpp	/^    void InitializePoses();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
cv::OneWayDescriptorBase::InitializeTransformsFromPoses	features2d/features2d.hpp	/^    void InitializeTransformsFromPoses();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
cv::OneWayDescriptorBase::LoadPCADescriptors	features2d/features2d.hpp	/^    int LoadPCADescriptors(const FileNode &fn);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(const FileNode &fn)
cv::OneWayDescriptorBase::LoadPCADescriptors	features2d/features2d.hpp	/^    int LoadPCADescriptors(const char* filename);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(const char* filename)
cv::OneWayDescriptorBase::LoadPCAall	features2d/features2d.hpp	/^    void LoadPCAall (const FileNode &fn);$/;"	p	class:cv::OneWayDescriptorBase	access:protected	signature:(const FileNode &fn)
cv::OneWayDescriptorBase::OneWayDescriptorBase	features2d/features2d.hpp	/^    OneWayDescriptorBase(CvSize patch_size, int pose_count, const char* train_path = 0, const char* pca_config = 0,$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(CvSize patch_size, int pose_count, const char* train_path = 0, const char* pca_config = 0, const char* pca_hr_config = 0, const char* pca_desc_config = 0, int pyr_levels = 1, int pca_dim_high = 100, int pca_dim_low = 100)
cv::OneWayDescriptorBase::OneWayDescriptorBase	features2d/features2d.hpp	/^    OneWayDescriptorBase(CvSize patch_size, int pose_count, const string &pca_filename, const string &train_path = string(), const string &images_list = string(),$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(CvSize patch_size, int pose_count, const string &pca_filename, const string &train_path = string(), const string &images_list = string(), float _scale_min = 0.7f, float _scale_max=1.5f, float _scale_step=1.2f, int pyr_levels = 1, int pca_dim_high = 100, int pca_dim_low = 100)
cv::OneWayDescriptorBase::Read	features2d/features2d.hpp	/^    void Read (const FileNode &fn);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(const FileNode &fn)
cv::OneWayDescriptorBase::SavePCADescriptors	features2d/features2d.hpp	/^    void SavePCADescriptors(CvFileStorage* fs) const;$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(CvFileStorage* fs) const
cv::OneWayDescriptorBase::SavePCADescriptors	features2d/features2d.hpp	/^    void SavePCADescriptors(const char* filename);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(const char* filename)
cv::OneWayDescriptorBase::SavePCAall	features2d/features2d.hpp	/^    void SavePCAall (FileStorage &fs) const;$/;"	p	class:cv::OneWayDescriptorBase	access:protected	signature:(FileStorage &fs) const
cv::OneWayDescriptorBase::SetPCAHigh	features2d/features2d.hpp	/^    void SetPCAHigh(CvMat* avg, CvMat* eigenvectors);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(CvMat* avg, CvMat* eigenvectors)
cv::OneWayDescriptorBase::SetPCALow	features2d/features2d.hpp	/^    void SetPCALow(CvMat* avg, CvMat* eigenvectors);$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(CvMat* avg, CvMat* eigenvectors)
cv::OneWayDescriptorBase::Write	features2d/features2d.hpp	/^    void Write (FileStorage &fs) const;$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:(FileStorage &fs) const
cv::OneWayDescriptorBase::clear	features2d/features2d.hpp	/^    void clear ();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
cv::OneWayDescriptorBase::empty	features2d/features2d.hpp	/^    virtual bool empty() const { return m_train_feature_count <= 0 ? true : false; }$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
cv::OneWayDescriptorBase::m_descriptors	features2d/features2d.hpp	/^    OneWayDescriptor* m_descriptors; \/\/ array of train feature descriptors$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_patch_size	features2d/features2d.hpp	/^    CvSize m_patch_size; \/\/ patch size$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_pca_avg	features2d/features2d.hpp	/^    CvMat* m_pca_avg; \/\/ PCA average Vector for small patches$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_pca_descriptors	features2d/features2d.hpp	/^    OneWayDescriptor* m_pca_descriptors; \/\/ an array of PCA descriptors$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_pca_descriptors_matrix	features2d/features2d.hpp	/^    CvMat* m_pca_descriptors_matrix;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_pca_descriptors_tree	features2d/features2d.hpp	/^    cv::flann::Index* m_pca_descriptors_tree;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_pca_dim_high	features2d/features2d.hpp	/^    int m_pca_dim_high;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_pca_dim_low	features2d/features2d.hpp	/^    int m_pca_dim_low;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_pca_eigenvectors	features2d/features2d.hpp	/^    CvMat* m_pca_eigenvectors; \/\/ PCA eigenvectors for small patches$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_pca_hr_avg	features2d/features2d.hpp	/^    CvMat* m_pca_hr_avg; \/\/ PCA average Vector for large patches$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_pca_hr_eigenvectors	features2d/features2d.hpp	/^    CvMat* m_pca_hr_eigenvectors; \/\/ PCA eigenvectors for large patches$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_pose_count	features2d/features2d.hpp	/^    int m_pose_count; \/\/ the number of poses for each descriptor$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_poses	features2d/features2d.hpp	/^    CvAffinePose* m_poses; \/\/ array of poses$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_pyr_levels	features2d/features2d.hpp	/^    int m_pyr_levels;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_train_feature_count	features2d/features2d.hpp	/^    int m_train_feature_count; \/\/ the number of the training features$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::m_transforms	features2d/features2d.hpp	/^    CvMat** m_transforms; \/\/ array of affine transformations corresponding to poses$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::scale_max	features2d/features2d.hpp	/^    float scale_max;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::scale_min	features2d/features2d.hpp	/^    float scale_min;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::scale_step	features2d/features2d.hpp	/^    float scale_step;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
cv::OneWayDescriptorBase::~OneWayDescriptorBase	features2d/features2d.hpp	/^    virtual ~OneWayDescriptorBase();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
cv::OneWayDescriptorMatch	features2d/features2d.hpp	/^typedef OneWayDescriptorMatcher OneWayDescriptorMatch;$/;"	t	namespace:cv
cv::OneWayDescriptorMatcher	features2d/features2d.hpp	/^class CV_EXPORTS OneWayDescriptorMatcher : public GenericDescriptorMatcher$/;"	c	namespace:cv	inherits:GenericDescriptorMatcher
cv::OneWayDescriptorMatcher::OneWayDescriptorMatcher	features2d/features2d.hpp	/^    OneWayDescriptorMatcher( const Params& params=Params() );$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:( const Params& params=Params() )
cv::OneWayDescriptorMatcher::Params	features2d/features2d.hpp	/^    class CV_EXPORTS Params$/;"	c	class:cv::OneWayDescriptorMatcher	access:public
cv::OneWayDescriptorMatcher::Params::GET_MAX_SCALE	features2d/features2d.hpp	/^        static float GET_MAX_SCALE() { return 1.5f; }$/;"	f	class:cv::OneWayDescriptorMatcher::Params	access:public	signature:()
cv::OneWayDescriptorMatcher::Params::GET_MIN_SCALE	features2d/features2d.hpp	/^        static float GET_MIN_SCALE() { return 0.7f; }$/;"	f	class:cv::OneWayDescriptorMatcher::Params	access:public	signature:()
cv::OneWayDescriptorMatcher::Params::GET_STEP_SCALE	features2d/features2d.hpp	/^        static float GET_STEP_SCALE() { return 1.2f; }$/;"	f	class:cv::OneWayDescriptorMatcher::Params	access:public	signature:()
cv::OneWayDescriptorMatcher::Params::PATCH_HEIGHT	features2d/features2d.hpp	/^        static const int PATCH_HEIGHT = 24;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
cv::OneWayDescriptorMatcher::Params::PATCH_WIDTH	features2d/features2d.hpp	/^        static const int PATCH_WIDTH = 24;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
cv::OneWayDescriptorMatcher::Params::POSE_COUNT	features2d/features2d.hpp	/^        static const int POSE_COUNT = 500;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
cv::OneWayDescriptorMatcher::Params::Params	features2d/features2d.hpp	/^        Params( int poseCount = POSE_COUNT,$/;"	p	class:cv::OneWayDescriptorMatcher::Params	access:public	signature:( int poseCount = POSE_COUNT, Size patchSize = Size(PATCH_WIDTH, PATCH_HEIGHT), string pcaFilename = string(), string trainPath = string(), string trainImagesList = string(), float minScale = GET_MIN_SCALE(), float maxScale = GET_MAX_SCALE(), float stepScale = GET_STEP_SCALE() )
cv::OneWayDescriptorMatcher::Params::maxScale	features2d/features2d.hpp	/^        float minScale, maxScale, stepScale;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
cv::OneWayDescriptorMatcher::Params::minScale	features2d/features2d.hpp	/^        float minScale, maxScale, stepScale;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
cv::OneWayDescriptorMatcher::Params::patchSize	features2d/features2d.hpp	/^        Size patchSize;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
cv::OneWayDescriptorMatcher::Params::pcaFilename	features2d/features2d.hpp	/^        string pcaFilename;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
cv::OneWayDescriptorMatcher::Params::poseCount	features2d/features2d.hpp	/^        int poseCount;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
cv::OneWayDescriptorMatcher::Params::stepScale	features2d/features2d.hpp	/^        float minScale, maxScale, stepScale;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
cv::OneWayDescriptorMatcher::Params::trainImagesList	features2d/features2d.hpp	/^        string trainImagesList;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
cv::OneWayDescriptorMatcher::Params::trainPath	features2d/features2d.hpp	/^        string trainPath;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
cv::OneWayDescriptorMatcher::base	features2d/features2d.hpp	/^    Ptr<OneWayDescriptorBase> base;$/;"	m	class:cv::OneWayDescriptorMatcher	access:protected
cv::OneWayDescriptorMatcher::clear	features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:()
cv::OneWayDescriptorMatcher::clone	features2d/features2d.hpp	/^    virtual Ptr<GenericDescriptorMatcher> clone( bool emptyTrainData=false ) const;$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:( bool emptyTrainData=false ) const
cv::OneWayDescriptorMatcher::empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:() const
cv::OneWayDescriptorMatcher::initialize	features2d/features2d.hpp	/^    void initialize( const Params& params, const Ptr<OneWayDescriptorBase>& base=Ptr<OneWayDescriptorBase>() );$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:( const Params& params, const Ptr<OneWayDescriptorBase>& base=Ptr<OneWayDescriptorBase>() )
cv::OneWayDescriptorMatcher::isMaskSupported	features2d/features2d.hpp	/^    virtual bool isMaskSupported();$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:()
cv::OneWayDescriptorMatcher::knnMatchImpl	features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::OneWayDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
cv::OneWayDescriptorMatcher::params	features2d/features2d.hpp	/^    Params params;$/;"	m	class:cv::OneWayDescriptorMatcher	access:protected
cv::OneWayDescriptorMatcher::prevTrainCount	features2d/features2d.hpp	/^    int prevTrainCount;$/;"	m	class:cv::OneWayDescriptorMatcher	access:protected
cv::OneWayDescriptorMatcher::radiusMatchImpl	features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::OneWayDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
cv::OneWayDescriptorMatcher::read	features2d/features2d.hpp	/^    virtual void read( const FileNode &fn );$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:( const FileNode &fn )
cv::OneWayDescriptorMatcher::train	features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:()
cv::OneWayDescriptorMatcher::write	features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:( FileStorage& fs ) const
cv::OneWayDescriptorMatcher::~OneWayDescriptorMatcher	features2d/features2d.hpp	/^    virtual ~OneWayDescriptorMatcher();$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:()
cv::OneWayDescriptorObject	features2d/features2d.hpp	/^class CV_EXPORTS OneWayDescriptorObject : public OneWayDescriptorBase$/;"	c	namespace:cv	inherits:OneWayDescriptorBase
cv::OneWayDescriptorObject::Allocate	features2d/features2d.hpp	/^    void Allocate(int train_feature_count, int object_feature_count);$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(int train_feature_count, int object_feature_count)
cv::OneWayDescriptorObject::GetDescriptorPart	features2d/features2d.hpp	/^    int GetDescriptorPart(int desc_idx) const;$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(int desc_idx) const
cv::OneWayDescriptorObject::GetLabeledFeatures	features2d/features2d.hpp	/^    const vector<cv::KeyPoint>& GetLabeledFeatures() const {return m_train_features;};$/;"	f	class:cv::OneWayDescriptorObject	access:public	signature:() const
cv::OneWayDescriptorObject::GetLabeledFeatures	features2d/features2d.hpp	/^    vector<cv::KeyPoint>& GetLabeledFeatures() {return m_train_features;};$/;"	f	class:cv::OneWayDescriptorObject	access:public	signature:()
cv::OneWayDescriptorObject::GetObjectFeatureCount	features2d/features2d.hpp	/^    int GetObjectFeatureCount() const {return m_object_feature_count;};$/;"	f	class:cv::OneWayDescriptorObject	access:public	signature:() const
cv::OneWayDescriptorObject::InitializeObjectDescriptors	features2d/features2d.hpp	/^    void InitializeObjectDescriptors(IplImage* train_image, const vector<cv::KeyPoint>& features,$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(IplImage* train_image, const vector<cv::KeyPoint>& features, const char* feature_label, int desc_start_idx = 0, float scale = 1.0f, int is_background = 0)
cv::OneWayDescriptorObject::IsDescriptorObject	features2d/features2d.hpp	/^    int IsDescriptorObject(int desc_idx) const;$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(int desc_idx) const
cv::OneWayDescriptorObject::MatchPointToPart	features2d/features2d.hpp	/^    int MatchPointToPart(CvPoint pt) const;$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(CvPoint pt) const
cv::OneWayDescriptorObject::OneWayDescriptorObject	features2d/features2d.hpp	/^    OneWayDescriptorObject(CvSize patch_size, int pose_count, const char* train_path, const char* pca_config,$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(CvSize patch_size, int pose_count, const char* train_path, const char* pca_config, const char* pca_hr_config = 0, const char* pca_desc_config = 0, int pyr_levels = 1)
cv::OneWayDescriptorObject::OneWayDescriptorObject	features2d/features2d.hpp	/^    OneWayDescriptorObject(CvSize patch_size, int pose_count, const string &pca_filename,$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:(CvSize patch_size, int pose_count, const string &pca_filename, const string &train_path = string (), const string &images_list = string (), float _scale_min = 0.7f, float _scale_max=1.5f, float _scale_step=1.2f, int pyr_levels = 1)
cv::OneWayDescriptorObject::SetLabeledFeatures	features2d/features2d.hpp	/^    void SetLabeledFeatures(const vector<cv::KeyPoint>& features) {m_train_features = features;};$/;"	f	class:cv::OneWayDescriptorObject	access:public	signature:(const vector<cv::KeyPoint>& features)
cv::OneWayDescriptorObject::_GetLabeledFeatures	features2d/features2d.hpp	/^    vector<cv::KeyPoint> _GetLabeledFeatures() const;$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:() const
cv::OneWayDescriptorObject::m_object_feature_count	features2d/features2d.hpp	/^    int m_object_feature_count; \/\/ the number of the positive features$/;"	m	class:cv::OneWayDescriptorObject	access:protected
cv::OneWayDescriptorObject::m_part_id	features2d/features2d.hpp	/^    int* m_part_id; \/\/ contains part id for each of object descriptors$/;"	m	class:cv::OneWayDescriptorObject	access:protected
cv::OneWayDescriptorObject::m_train_features	features2d/features2d.hpp	/^    vector<cv::KeyPoint> m_train_features; \/\/ train features$/;"	m	class:cv::OneWayDescriptorObject	access:protected
cv::OneWayDescriptorObject::~OneWayDescriptorObject	features2d/features2d.hpp	/^    virtual ~OneWayDescriptorObject();$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:()
cv::OpenGLCallback	highgui/highgui.hpp	/^typedef void (CV_CDECL *OpenGLCallback)(void* userdata);$/;"	t	namespace:cv
cv::OpponentColorDescriptorExtractor	features2d/features2d.hpp	/^class CV_EXPORTS OpponentColorDescriptorExtractor : public DescriptorExtractor$/;"	c	namespace:cv	inherits:DescriptorExtractor
cv::OpponentColorDescriptorExtractor::OpponentColorDescriptorExtractor	features2d/features2d.hpp	/^    OpponentColorDescriptorExtractor( const Ptr<DescriptorExtractor>& descriptorExtractor );$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:public	signature:( const Ptr<DescriptorExtractor>& descriptorExtractor )
cv::OpponentColorDescriptorExtractor::computeImpl	features2d/features2d.hpp	/^	virtual void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
cv::OpponentColorDescriptorExtractor::descriptorExtractor	features2d/features2d.hpp	/^    Ptr<DescriptorExtractor> descriptorExtractor;$/;"	m	class:cv::OpponentColorDescriptorExtractor	access:protected
cv::OpponentColorDescriptorExtractor::descriptorSize	features2d/features2d.hpp	/^    virtual int descriptorSize() const;$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:public	signature:() const
cv::OpponentColorDescriptorExtractor::descriptorType	features2d/features2d.hpp	/^    virtual int descriptorType() const;$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:public	signature:() const
cv::OpponentColorDescriptorExtractor::empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:public	signature:() const
cv::OpponentColorDescriptorExtractor::read	features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:public	signature:( const FileNode& )
cv::OpponentColorDescriptorExtractor::write	features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:public	signature:( FileStorage& ) const
cv::OrbDescriptorExtractor	features2d/features2d.hpp	/^class CV_EXPORTS OrbDescriptorExtractor : public cv::DescriptorExtractor$/;"	c	namespace:cv	inherits:cv::DescriptorExtractor
cv::OrbDescriptorExtractor::OrbDescriptorExtractor	features2d/features2d.hpp	/^  OrbDescriptorExtractor(ORB::CommonParams params = ORB::CommonParams());$/;"	p	class:cv::OrbDescriptorExtractor	access:public	signature:(ORB::CommonParams params = ORB::CommonParams())
cv::OrbDescriptorExtractor::computeImpl	features2d/features2d.hpp	/^  void computeImpl(const cv::Mat& image, std::vector<cv::KeyPoint>& keypoints, cv::Mat& descriptors) const;$/;"	p	class:cv::OrbDescriptorExtractor	access:protected	signature:(const cv::Mat& image, std::vector<cv::KeyPoint>& keypoints, cv::Mat& descriptors) const
cv::OrbDescriptorExtractor::descriptorSize	features2d/features2d.hpp	/^  virtual int descriptorSize() const;$/;"	p	class:cv::OrbDescriptorExtractor	access:public	signature:() const
cv::OrbDescriptorExtractor::descriptorType	features2d/features2d.hpp	/^  virtual int descriptorType() const;$/;"	p	class:cv::OrbDescriptorExtractor	access:public	signature:() const
cv::OrbDescriptorExtractor::orb_	features2d/features2d.hpp	/^  mutable ORB orb_;$/;"	m	class:cv::OrbDescriptorExtractor	access:private
cv::OrbDescriptorExtractor::params_	features2d/features2d.hpp	/^  ORB::CommonParams params_;$/;"	m	class:cv::OrbDescriptorExtractor	access:private
cv::OrbDescriptorExtractor::read	features2d/features2d.hpp	/^  virtual void read(const cv::FileNode&);$/;"	p	class:cv::OrbDescriptorExtractor	access:public	signature:(const cv::FileNode&)
cv::OrbDescriptorExtractor::write	features2d/features2d.hpp	/^  virtual void write(cv::FileStorage&) const;$/;"	p	class:cv::OrbDescriptorExtractor	access:public	signature:(cv::FileStorage&) const
cv::OrbDescriptorExtractor::~OrbDescriptorExtractor	features2d/features2d.hpp	/^  ~OrbDescriptorExtractor()$/;"	f	class:cv::OrbDescriptorExtractor	access:public	signature:()
cv::OrbFeatureDetector	features2d/features2d.hpp	/^class CV_EXPORTS OrbFeatureDetector : public cv::FeatureDetector$/;"	c	namespace:cv	inherits:cv::FeatureDetector
cv::OrbFeatureDetector::OrbFeatureDetector	features2d/features2d.hpp	/^  OrbFeatureDetector(size_t n_features = 700, ORB::CommonParams params = ORB::CommonParams());$/;"	p	class:cv::OrbFeatureDetector	access:public	signature:(size_t n_features = 700, ORB::CommonParams params = ORB::CommonParams())
cv::OrbFeatureDetector::detectImpl	features2d/features2d.hpp	/^  detectImpl(const cv::Mat& image, std::vector<cv::KeyPoint>& keypoints, const cv::Mat& mask = cv::Mat()) const;$/;"	p	class:cv::OrbFeatureDetector	access:protected	signature:(const cv::Mat& image, std::vector<cv::KeyPoint>& keypoints, const cv::Mat& mask = cv::Mat()) const
cv::OrbFeatureDetector::n_features_	features2d/features2d.hpp	/^  unsigned int n_features_;$/;"	m	class:cv::OrbFeatureDetector	access:private
cv::OrbFeatureDetector::orb_	features2d/features2d.hpp	/^  mutable ORB orb_;$/;"	m	class:cv::OrbFeatureDetector	access:private
cv::OrbFeatureDetector::params_	features2d/features2d.hpp	/^  ORB::CommonParams params_;$/;"	m	class:cv::OrbFeatureDetector	access:private
cv::OrbFeatureDetector::read	features2d/features2d.hpp	/^  virtual void read(const cv::FileNode&);$/;"	p	class:cv::OrbFeatureDetector	access:public	signature:(const cv::FileNode&)
cv::OrbFeatureDetector::write	features2d/features2d.hpp	/^  virtual void write(cv::FileStorage&) const;$/;"	p	class:cv::OrbFeatureDetector	access:public	signature:(cv::FileStorage&) const
cv::OutputArray	core/core.hpp	/^typedef const _OutputArray& OutputArray;$/;"	t	namespace:cv
cv::OutputArrayOfArrays	core/core.hpp	/^typedef OutputArray OutputArrayOfArrays;$/;"	t	namespace:cv
cv::PCA	core/core.hpp	/^class CV_EXPORTS PCA$/;"	c	namespace:cv
cv::PCA::PCA	core/core.hpp	/^    PCA();$/;"	p	class:cv::PCA	access:public	signature:()
cv::PCA::PCA	core/core.hpp	/^    PCA(InputArray data, InputArray mean, int flags, int maxComponents=0);$/;"	p	class:cv::PCA	access:public	signature:(InputArray data, InputArray mean, int flags, int maxComponents=0)
cv::PCA::backProject	core/core.hpp	/^    Mat backProject(InputArray vec) const;$/;"	p	class:cv::PCA	access:public	signature:(InputArray vec) const
cv::PCA::backProject	core/core.hpp	/^    void backProject(InputArray vec, OutputArray result) const;$/;"	p	class:cv::PCA	access:public	signature:(InputArray vec, OutputArray result) const
cv::PCA::eigenvalues	core/core.hpp	/^    Mat eigenvalues; \/\/!< eigenvalues of the covariation matrix$/;"	m	class:cv::PCA	access:public
cv::PCA::eigenvectors	core/core.hpp	/^    Mat eigenvectors; \/\/!< eigenvectors of the covariation matrix$/;"	m	class:cv::PCA	access:public
cv::PCA::mean	core/core.hpp	/^    Mat mean; \/\/!< mean value subtracted before the projection and added after the back projection$/;"	m	class:cv::PCA	access:public
cv::PCA::operator ()	core/core.hpp	/^    PCA& operator()(InputArray data, InputArray mean, int flags, int maxComponents=0);$/;"	p	class:cv::PCA	access:public	signature:(InputArray data, InputArray mean, int flags, int maxComponents=0)
cv::PCA::project	core/core.hpp	/^    Mat project(InputArray vec) const;$/;"	p	class:cv::PCA	access:public	signature:(InputArray vec) const
cv::PCA::project	core/core.hpp	/^    void project(InputArray vec, OutputArray result) const;$/;"	p	class:cv::PCA	access:public	signature:(InputArray vec, OutputArray result) const
cv::PCABackProject	core/core.hpp	/^CV_EXPORTS_W void PCABackProject(InputArray data, InputArray mean,$/;"	p	namespace:cv	signature:(InputArray data, InputArray mean, InputArray eigenvectors, OutputArray result)
cv::PCACompute	core/core.hpp	/^CV_EXPORTS_W void PCACompute(InputArray data, CV_OUT InputOutputArray mean,$/;"	p	namespace:cv	signature:(InputArray data, CV_OUT InputOutputArray mean, OutputArray eigenvectors, int maxComponents=0)
cv::PCAProject	core/core.hpp	/^CV_EXPORTS_W void PCAProject(InputArray data, InputArray mean,$/;"	p	namespace:cv	signature:(InputArray data, InputArray mean, InputArray eigenvectors, OutputArray result)
cv::PROJ_SPHERICAL_EQRECT	imgproc/imgproc.hpp	/^    PROJ_SPHERICAL_EQRECT = 1$/;"	e	enum:cv::__anon18
cv::PROJ_SPHERICAL_ORTHO	imgproc/imgproc.hpp	/^    PROJ_SPHERICAL_ORTHO = 0,$/;"	e	enum:cv::__anon18
cv::ParamGrid	ml/ml.hpp	/^typedef CvParamGrid ParamGrid;$/;"	t	namespace:cv
cv::PatchGenerator	features2d/features2d.hpp	/^class CV_EXPORTS PatchGenerator$/;"	c	namespace:cv
cv::PatchGenerator::PatchGenerator	features2d/features2d.hpp	/^    PatchGenerator();$/;"	p	class:cv::PatchGenerator	access:public	signature:()
cv::PatchGenerator::PatchGenerator	features2d/features2d.hpp	/^    PatchGenerator(double _backgroundMin, double _backgroundMax,$/;"	p	class:cv::PatchGenerator	access:public	signature:(double _backgroundMin, double _backgroundMax, double _noiseRange, bool _randomBlur=true, double _lambdaMin=0.6, double _lambdaMax=1.5, double _thetaMin=-CV_PI, double _thetaMax=CV_PI, double _phiMin=-CV_PI, double _phiMax=CV_PI )
cv::PatchGenerator::backgroundMax	features2d/features2d.hpp	/^    double backgroundMin, backgroundMax;$/;"	m	class:cv::PatchGenerator	access:public
cv::PatchGenerator::backgroundMin	features2d/features2d.hpp	/^    double backgroundMin, backgroundMax;$/;"	m	class:cv::PatchGenerator	access:public
cv::PatchGenerator::generateRandomTransform	features2d/features2d.hpp	/^    void generateRandomTransform(Point2f srcCenter, Point2f dstCenter,$/;"	p	class:cv::PatchGenerator	access:public	signature:(Point2f srcCenter, Point2f dstCenter, CV_OUT Mat& transform, RNG& rng, bool inverse=false) const
cv::PatchGenerator::lambdaMax	features2d/features2d.hpp	/^    double lambdaMin, lambdaMax;$/;"	m	class:cv::PatchGenerator	access:public
cv::PatchGenerator::lambdaMin	features2d/features2d.hpp	/^    double lambdaMin, lambdaMax;$/;"	m	class:cv::PatchGenerator	access:public
cv::PatchGenerator::noiseRange	features2d/features2d.hpp	/^    double noiseRange;$/;"	m	class:cv::PatchGenerator	access:public
cv::PatchGenerator::operator ()	features2d/features2d.hpp	/^    void operator()(const Mat& image, Point2f pt, Mat& patch, Size patchSize, RNG& rng) const;$/;"	p	class:cv::PatchGenerator	access:public	signature:(const Mat& image, Point2f pt, Mat& patch, Size patchSize, RNG& rng) const
cv::PatchGenerator::operator ()	features2d/features2d.hpp	/^    void operator()(const Mat& image, const Mat& transform, Mat& patch,$/;"	p	class:cv::PatchGenerator	access:public	signature:(const Mat& image, const Mat& transform, Mat& patch, Size patchSize, RNG& rng) const
cv::PatchGenerator::phiMax	features2d/features2d.hpp	/^    double phiMin, phiMax;$/;"	m	class:cv::PatchGenerator	access:public
cv::PatchGenerator::phiMin	features2d/features2d.hpp	/^    double phiMin, phiMax;$/;"	m	class:cv::PatchGenerator	access:public
cv::PatchGenerator::randomBlur	features2d/features2d.hpp	/^    bool randomBlur;$/;"	m	class:cv::PatchGenerator	access:public
cv::PatchGenerator::setAffineParam	features2d/features2d.hpp	/^    void setAffineParam(double lambda, double theta, double phi);$/;"	p	class:cv::PatchGenerator	access:public	signature:(double lambda, double theta, double phi)
cv::PatchGenerator::thetaMax	features2d/features2d.hpp	/^    double thetaMin, thetaMax;$/;"	m	class:cv::PatchGenerator	access:public
cv::PatchGenerator::thetaMin	features2d/features2d.hpp	/^    double thetaMin, thetaMax;$/;"	m	class:cv::PatchGenerator	access:public
cv::PatchGenerator::warpWholeImage	features2d/features2d.hpp	/^    void warpWholeImage(const Mat& image, Mat& matT, Mat& buf,$/;"	p	class:cv::PatchGenerator	access:public	signature:(const Mat& image, Mat& matT, Mat& buf, CV_OUT Mat& warped, int border, RNG& rng) const
cv::PlanarObjectDetector	objdetect/objdetect.hpp	/^class CV_EXPORTS PlanarObjectDetector$/;"	c	namespace:cv
cv::PlanarObjectDetector::PlanarObjectDetector	objdetect/objdetect.hpp	/^    PlanarObjectDetector();$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:()
cv::PlanarObjectDetector::PlanarObjectDetector	objdetect/objdetect.hpp	/^    PlanarObjectDetector(const FileNode& node);$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const FileNode& node)
cv::PlanarObjectDetector::PlanarObjectDetector	objdetect/objdetect.hpp	/^    PlanarObjectDetector(const vector<Mat>& pyr, int _npoints=300,$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const vector<Mat>& pyr, int _npoints=300, int _patchSize=FernClassifier::PATCH_SIZE, int _nstructs=FernClassifier::DEFAULT_STRUCTS, int _structSize=FernClassifier::DEFAULT_STRUCT_SIZE, int _nviews=FernClassifier::DEFAULT_VIEWS, const LDetector& detector=LDetector(), const PatchGenerator& patchGenerator=PatchGenerator())
cv::PlanarObjectDetector::fernClassifier	objdetect/objdetect.hpp	/^    FernClassifier fernClassifier;$/;"	m	class:cv::PlanarObjectDetector	access:protected
cv::PlanarObjectDetector::getClassifier	objdetect/objdetect.hpp	/^    const FernClassifier& getClassifier() const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:() const
cv::PlanarObjectDetector::getDetector	objdetect/objdetect.hpp	/^    const LDetector& getDetector() const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:() const
cv::PlanarObjectDetector::getModelPoints	objdetect/objdetect.hpp	/^    vector<KeyPoint> getModelPoints() const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:() const
cv::PlanarObjectDetector::getModelROI	objdetect/objdetect.hpp	/^    Rect getModelROI() const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:() const
cv::PlanarObjectDetector::ldetector	objdetect/objdetect.hpp	/^    LDetector ldetector;$/;"	m	class:cv::PlanarObjectDetector	access:protected
cv::PlanarObjectDetector::modelPoints	objdetect/objdetect.hpp	/^    vector<KeyPoint> modelPoints;$/;"	m	class:cv::PlanarObjectDetector	access:protected
cv::PlanarObjectDetector::modelROI	objdetect/objdetect.hpp	/^    Rect modelROI;$/;"	m	class:cv::PlanarObjectDetector	access:protected
cv::PlanarObjectDetector::operator ()	objdetect/objdetect.hpp	/^    bool operator()(const Mat& image, CV_OUT Mat& H, CV_OUT vector<Point2f>& corners) const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const Mat& image, CV_OUT Mat& H, CV_OUT vector<Point2f>& corners) const
cv::PlanarObjectDetector::operator ()	objdetect/objdetect.hpp	/^    bool operator()(const vector<Mat>& pyr, const vector<KeyPoint>& keypoints,$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const vector<Mat>& pyr, const vector<KeyPoint>& keypoints, CV_OUT Mat& H, CV_OUT vector<Point2f>& corners, CV_OUT vector<int>* pairs=0) const
cv::PlanarObjectDetector::read	objdetect/objdetect.hpp	/^    void read(const FileNode& node);$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const FileNode& node)
cv::PlanarObjectDetector::setVerbose	objdetect/objdetect.hpp	/^    void setVerbose(bool verbose);$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(bool verbose)
cv::PlanarObjectDetector::train	objdetect/objdetect.hpp	/^    virtual void train(const vector<Mat>& pyr, const vector<KeyPoint>& keypoints,$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const vector<Mat>& pyr, const vector<KeyPoint>& keypoints, int _patchSize=FernClassifier::PATCH_SIZE, int _nstructs=FernClassifier::DEFAULT_STRUCTS, int _structSize=FernClassifier::DEFAULT_STRUCT_SIZE, int _nviews=FernClassifier::DEFAULT_VIEWS, const LDetector& detector=LDetector(), const PatchGenerator& patchGenerator=PatchGenerator())
cv::PlanarObjectDetector::train	objdetect/objdetect.hpp	/^    virtual void train(const vector<Mat>& pyr, int _npoints=300,$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const vector<Mat>& pyr, int _npoints=300, int _patchSize=FernClassifier::PATCH_SIZE, int _nstructs=FernClassifier::DEFAULT_STRUCTS, int _structSize=FernClassifier::DEFAULT_STRUCT_SIZE, int _nviews=FernClassifier::DEFAULT_VIEWS, const LDetector& detector=LDetector(), const PatchGenerator& patchGenerator=PatchGenerator())
cv::PlanarObjectDetector::verbose	objdetect/objdetect.hpp	/^    bool verbose;$/;"	m	class:cv::PlanarObjectDetector	access:protected
cv::PlanarObjectDetector::write	objdetect/objdetect.hpp	/^    void write(FileStorage& fs, const String& name=String()) const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(FileStorage& fs, const String& name=String()) const
cv::PlanarObjectDetector::~PlanarObjectDetector	objdetect/objdetect.hpp	/^    virtual ~PlanarObjectDetector();$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:()
cv::Point	core/core.hpp	/^typedef Point2i Point;$/;"	t	namespace:cv
cv::Point2d	core/core.hpp	/^typedef Point_<double> Point2d;$/;"	t	namespace:cv
cv::Point2f	core/core.hpp	/^typedef Point_<float> Point2f;$/;"	t	namespace:cv
cv::Point2i	core/core.hpp	/^typedef Point_<int> Point2i;$/;"	t	namespace:cv
cv::Point3_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Point3_$/;"	c	namespace:cv
cv::Point3_::Point3_	core/core.hpp	/^    Point3_();$/;"	p	class:cv::Point3_	access:public	signature:()
cv::Point3_::Point3_	core/core.hpp	/^    Point3_(_Tp _x, _Tp _y, _Tp _z);$/;"	p	class:cv::Point3_	access:public	signature:(_Tp _x, _Tp _y, _Tp _z)
cv::Point3_::Point3_	core/core.hpp	/^    Point3_(const CvPoint3D32f& pt);$/;"	p	class:cv::Point3_	access:public	signature:(const CvPoint3D32f& pt)
cv::Point3_::Point3_	core/core.hpp	/^    Point3_(const Point3_& pt);$/;"	p	class:cv::Point3_	access:public	signature:(const Point3_& pt)
cv::Point3_::Point3_	core/core.hpp	/^    Point3_(const Vec<_Tp, 3>& v);$/;"	p	class:cv::Point3_	access:public	signature:(const Vec<_Tp, 3>& v)
cv::Point3_::Point3_	core/core.hpp	/^    explicit Point3_(const Point_<_Tp>& pt);$/;"	p	class:cv::Point3_	access:public	signature:(const Point_<_Tp>& pt)
cv::Point3_::Point3_	core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_() : x(0), y(0), z(0) {}$/;"	f	class:cv::Point3_	signature:()
cv::Point3_::Point3_	core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_(_Tp _x, _Tp _y, _Tp _z) : x(_x), y(_y), z(_z) {}$/;"	f	class:cv::Point3_	signature:(_Tp _x, _Tp _y, _Tp _z)
cv::Point3_::Point3_	core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_(const CvPoint3D32f& pt) :$/;"	f	class:cv::Point3_	signature:(const CvPoint3D32f& pt)
cv::Point3_::Point3_	core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_(const Point3_& pt) : x(pt.x), y(pt.y), z(pt.z) {}$/;"	f	class:cv::Point3_	signature:(const Point3_& pt)
cv::Point3_::Point3_	core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_(const Point_<_Tp>& pt) : x(pt.x), y(pt.y), z(_Tp()) {}$/;"	f	class:cv::Point3_	signature:(const Point_<_Tp>& pt)
cv::Point3_::Point3_	core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::Point3_(const Vec<_Tp, 3>& v) : x(v[0]), y(v[1]), z(v[2]) {}$/;"	f	class:cv::Point3_	signature:(const Vec<_Tp, 3>& v)
cv::Point3_::cross	core/core.hpp	/^    Point3_ cross(const Point3_& pt) const;$/;"	p	class:cv::Point3_	access:public	signature:(const Point3_& pt) const
cv::Point3_::cross	core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp> Point3_<_Tp>::cross(const Point3_<_Tp>& pt) const$/;"	f	class:cv::Point3_	signature:(const Point3_<_Tp>& pt) const
cv::Point3_::ddot	core/core.hpp	/^    double ddot(const Point3_& pt) const;$/;"	p	class:cv::Point3_	access:public	signature:(const Point3_& pt) const
cv::Point3_::ddot	core/operations.hpp	/^template<typename _Tp> inline double Point3_<_Tp>::ddot(const Point3_& pt) const$/;"	f	class:cv::Point3_	signature:(const Point3_& pt) const
cv::Point3_::dot	core/core.hpp	/^    _Tp dot(const Point3_& pt) const;$/;"	p	class:cv::Point3_	access:public	signature:(const Point3_& pt) const
cv::Point3_::dot	core/operations.hpp	/^template<typename _Tp> inline _Tp Point3_<_Tp>::dot(const Point3_& pt) const$/;"	f	class:cv::Point3_	signature:(const Point3_& pt) const
cv::Point3_::operator =	core/core.hpp	/^    Point3_& operator = (const Point3_& pt);$/;"	p	class:cv::Point3_	access:public	signature:(const Point3_& pt)
cv::Point3_::operator =	core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>& Point3_<_Tp>::operator = (const Point3_& pt)$/;"	f	class:cv::Point3_	signature:(const Point3_& pt)
cv::Point3_::operator CvPoint3D32f	core/core.hpp	/^    operator CvPoint3D32f() const;$/;"	p	class:cv::Point3_	access:public	signature:() const
cv::Point3_::operator CvPoint3D32f	core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::operator CvPoint3D32f() const$/;"	f	class:cv::Point3_	signature:() const
cv::Point3_::operator Point3_<_Tp2>	core/core.hpp	/^    template<typename _Tp2> operator Point3_<_Tp2>() const;$/;"	p	class:cv::Point3_	access:public	signature:() const
cv::Point3_::operator Point3_<_Tp2>	core/operations.hpp	/^template<typename _Tp> template<typename _Tp2> inline Point3_<_Tp>::operator Point3_<_Tp2>() const$/;"	f	class:cv::Point3_	signature:() const
cv::Point3_::operator Vec<_Tp, 3>	core/core.hpp	/^    operator Vec<_Tp, 3>() const;$/;"	p	class:cv::Point3_	access:public	signature:() const
cv::Point3_::operator Vec<_Tp, 3>	core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::operator Vec<_Tp, 3>() const$/;"	f	class:cv::Point3_	signature:() const
cv::Point3_::value_type	core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Point3_	access:public
cv::Point3_::x	core/core.hpp	/^    _Tp x, y, z; \/\/< the point coordinates$/;"	m	class:cv::Point3_	access:public
cv::Point3_::y	core/core.hpp	/^    _Tp x, y, z; \/\/< the point coordinates$/;"	m	class:cv::Point3_	access:public
cv::Point3_::z	core/core.hpp	/^    _Tp x, y, z; \/\/< the point coordinates$/;"	m	class:cv::Point3_	access:public
cv::Point3d	core/core.hpp	/^typedef Point3_<double> Point3d;$/;"	t	namespace:cv
cv::Point3f	core/core.hpp	/^typedef Point3_<float> Point3f;$/;"	t	namespace:cv
cv::Point3i	core/core.hpp	/^typedef Point3_<int> Point3i;$/;"	t	namespace:cv
cv::Point_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Point_$/;"	c	namespace:cv
cv::Point_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Point_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::Point_::Point_	core/core.hpp	/^    Point_();$/;"	p	class:cv::Point_	access:public	signature:()
cv::Point_::Point_	core/core.hpp	/^    Point_(_Tp _x, _Tp _y);$/;"	p	class:cv::Point_	access:public	signature:(_Tp _x, _Tp _y)
cv::Point_::Point_	core/core.hpp	/^    Point_(const CvPoint& pt);$/;"	p	class:cv::Point_	access:public	signature:(const CvPoint& pt)
cv::Point_::Point_	core/core.hpp	/^    Point_(const CvPoint2D32f& pt);$/;"	p	class:cv::Point_	access:public	signature:(const CvPoint2D32f& pt)
cv::Point_::Point_	core/core.hpp	/^    Point_(const Point_& pt);$/;"	p	class:cv::Point_	access:public	signature:(const Point_& pt)
cv::Point_::Point_	core/core.hpp	/^    Point_(const Size_<_Tp>& sz);$/;"	p	class:cv::Point_	access:public	signature:(const Size_<_Tp>& sz)
cv::Point_::Point_	core/core.hpp	/^    Point_(const Vec<_Tp, 2>& v);$/;"	p	class:cv::Point_	access:public	signature:(const Vec<_Tp, 2>& v)
cv::Point_::Point_	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_() : x(0), y(0) {}$/;"	f	class:cv::Point_	signature:()
cv::Point_::Point_	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(_Tp _x, _Tp _y) : x(_x), y(_y) {}$/;"	f	class:cv::Point_	signature:(_Tp _x, _Tp _y)
cv::Point_::Point_	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(const CvPoint& pt) : x((_Tp)pt.x), y((_Tp)pt.y) {}$/;"	f	class:cv::Point_	signature:(const CvPoint& pt)
cv::Point_::Point_	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(const CvPoint2D32f& pt)$/;"	f	class:cv::Point_	signature:(const CvPoint2D32f& pt)
cv::Point_::Point_	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(const Point_& pt) : x(pt.x), y(pt.y) {}$/;"	f	class:cv::Point_	signature:(const Point_& pt)
cv::Point_::Point_	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(const Size_<_Tp>& sz) : x(sz.width), y(sz.height) {}$/;"	f	class:cv::Point_	signature:(const Size_<_Tp>& sz)
cv::Point_::Point_	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::Point_(const Vec<_Tp,2>& v) : x(v[0]), y(v[1]) {}$/;"	f	class:cv::Point_	signature:(const Vec<_Tp,2>& v)
cv::Point_::ddot	core/core.hpp	/^    double ddot(const Point_& pt) const;$/;"	p	class:cv::Point_	access:public	signature:(const Point_& pt) const
cv::Point_::ddot	core/operations.hpp	/^template<typename _Tp> inline double Point_<_Tp>::ddot(const Point_& pt) const$/;"	f	class:cv::Point_	signature:(const Point_& pt) const
cv::Point_::dot	core/core.hpp	/^    _Tp dot(const Point_& pt) const;$/;"	p	class:cv::Point_	access:public	signature:(const Point_& pt) const
cv::Point_::dot	core/operations.hpp	/^template<typename _Tp> inline _Tp Point_<_Tp>::dot(const Point_& pt) const$/;"	f	class:cv::Point_	signature:(const Point_& pt) const
cv::Point_::inside	core/core.hpp	/^    bool inside(const Rect_<_Tp>& r) const;$/;"	p	class:cv::Point_	access:public	signature:(const Rect_<_Tp>& r) const
cv::Point_::inside	core/operations.hpp	/^template<typename _Tp> inline bool Point_<_Tp>::inside( const Rect_<_Tp>& r ) const$/;"	f	class:cv::Point_	signature:( const Rect_<_Tp>& r ) const
cv::Point_::operator =	core/core.hpp	/^    Point_& operator = (const Point_& pt);$/;"	p	class:cv::Point_	access:public	signature:(const Point_& pt)
cv::Point_::operator =	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>& Point_<_Tp>::operator = (const Point_& pt)$/;"	f	class:cv::Point_	signature:(const Point_& pt)
cv::Point_::operator CvPoint	core/core.hpp	/^    operator CvPoint() const;$/;"	p	class:cv::Point_	access:public	signature:() const
cv::Point_::operator CvPoint	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::operator CvPoint() const$/;"	f	class:cv::Point_	signature:() const
cv::Point_::operator CvPoint2D32f	core/core.hpp	/^    operator CvPoint2D32f() const;$/;"	p	class:cv::Point_	access:public	signature:() const
cv::Point_::operator CvPoint2D32f	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::operator CvPoint2D32f() const$/;"	f	class:cv::Point_	signature:() const
cv::Point_::operator Point_<_Tp2>	core/core.hpp	/^    template<typename _Tp2> operator Point_<_Tp2>() const;$/;"	p	class:cv::Point_	access:public	signature:() const
cv::Point_::operator Point_<_Tp2>	core/operations.hpp	/^template<typename _Tp> template<typename _Tp2> inline Point_<_Tp>::operator Point_<_Tp2>() const$/;"	f	class:cv::Point_	signature:() const
cv::Point_::operator Vec<_Tp, 2>	core/core.hpp	/^    operator Vec<_Tp, 2>() const;$/;"	p	class:cv::Point_	access:public	signature:() const
cv::Point_::operator Vec<_Tp, 2>	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::operator Vec<_Tp, 2>() const$/;"	f	class:cv::Point_	signature:() const
cv::Point_::value_type	core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Point_	access:public
cv::Point_::x	core/core.hpp	/^    _Tp x, y; \/\/< the point coordinates$/;"	m	class:cv::Point_	access:public
cv::Point_::y	core/core.hpp	/^    _Tp x, y; \/\/< the point coordinates$/;"	m	class:cv::Point_	access:public
cv::Ptr	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Ptr$/;"	c	namespace:cv
cv::Ptr::Ptr	core/core.hpp	/^    Ptr();$/;"	p	class:cv::Ptr	access:public	signature:()
cv::Ptr::Ptr	core/core.hpp	/^    Ptr(_Tp* _obj);$/;"	p	class:cv::Ptr	access:public	signature:(_Tp* _obj)
cv::Ptr::Ptr	core/core.hpp	/^    Ptr(const Ptr& ptr);$/;"	p	class:cv::Ptr	access:public	signature:(const Ptr& ptr)
cv::Ptr::Ptr	core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::Ptr() : obj(0), refcount(0) {}$/;"	f	class:cv::Ptr	signature:()
cv::Ptr::Ptr	core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::Ptr(_Tp* _obj) : obj(_obj)$/;"	f	class:cv::Ptr	signature:(_Tp* _obj)
cv::Ptr::Ptr	core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::Ptr(const Ptr<_Tp>& ptr)$/;"	f	class:cv::Ptr	signature:(const Ptr<_Tp>& ptr)
cv::Ptr::addref	core/core.hpp	/^    void addref();$/;"	p	class:cv::Ptr	access:public	signature:()
cv::Ptr::addref	core/operations.hpp	/^template<typename _Tp> inline void Ptr<_Tp>::addref()$/;"	f	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	calib3d/calib3d.hpp	/^template<> CV_EXPORTS void Ptr<CvStereoBMState>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	core/core.hpp	/^    void delete_obj();$/;"	p	class:cv::Ptr	access:public	signature:()
cv::Ptr::delete_obj	core/operations.hpp	/^template<> CV_EXPORTS void Ptr<CvFileStorage>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	core/operations.hpp	/^template<> CV_EXPORTS void Ptr<CvMat>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	core/operations.hpp	/^template<> CV_EXPORTS void Ptr<CvMatND>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	core/operations.hpp	/^template<> CV_EXPORTS void Ptr<CvMemStorage>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	core/operations.hpp	/^template<> CV_EXPORTS void Ptr<CvSparseMat>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	core/operations.hpp	/^template<> CV_EXPORTS void Ptr<IplImage>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	core/operations.hpp	/^template<typename _Tp> inline void Ptr<_Tp>::delete_obj()$/;"	f	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	highgui/highgui.hpp	/^template<> void CV_EXPORTS Ptr<CvCapture>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	highgui/highgui.hpp	/^template<> void CV_EXPORTS Ptr<CvVideoWriter>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	imgproc/imgproc.hpp	/^template<> CV_EXPORTS void Ptr<CvHistogram>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	imgproc/imgproc.hpp	/^template<> CV_EXPORTS void Ptr<IplConvKernel>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	ml/ml.hpp	/^template<> CV_EXPORTS void Ptr<CvDTreeSplit>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::delete_obj	objdetect/objdetect.hpp	/^template<> CV_EXPORTS void Ptr<CvHaarClassifierCascade>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
cv::Ptr::empty	core/core.hpp	/^    bool empty() const;$/;"	p	class:cv::Ptr	access:public	signature:() const
cv::Ptr::empty	core/operations.hpp	/^template<typename _Tp> inline bool Ptr<_Tp>::empty() const { return obj == 0; }$/;"	f	class:cv::Ptr	signature:() const
cv::Ptr::obj	core/core.hpp	/^    _Tp* obj; \/\/< the object pointer.$/;"	m	class:cv::Ptr	access:protected
cv::Ptr::operator ->	core/core.hpp	/^    _Tp* operator -> ();$/;"	p	class:cv::Ptr	access:public	signature:()
cv::Ptr::operator ->	core/core.hpp	/^    const _Tp* operator -> () const;$/;"	p	class:cv::Ptr	access:public	signature:() const
cv::Ptr::operator ->	core/operations.hpp	/^template<typename _Tp> inline _Tp* Ptr<_Tp>::operator -> () { return obj; }$/;"	f	class:cv::Ptr	signature:()
cv::Ptr::operator ->	core/operations.hpp	/^template<typename _Tp> inline const _Tp* Ptr<_Tp>::operator -> () const { return obj; }$/;"	f	class:cv::Ptr	signature:() const
cv::Ptr::operator =	core/core.hpp	/^    Ptr& operator = (const Ptr& ptr);$/;"	p	class:cv::Ptr	access:public	signature:(const Ptr& ptr)
cv::Ptr::operator =	core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>& Ptr<_Tp>::operator = (const Ptr<_Tp>& ptr)$/;"	f	class:cv::Ptr	signature:(const Ptr<_Tp>& ptr)
cv::Ptr::operator _Tp*	core/core.hpp	/^    operator _Tp* ();$/;"	p	class:cv::Ptr	access:public	signature:()
cv::Ptr::operator _Tp*	core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::operator _Tp* () { return obj; }$/;"	f	class:cv::Ptr	signature:()
cv::Ptr::operator const _Tp*	core/core.hpp	/^    operator const _Tp*() const;$/;"	p	class:cv::Ptr	access:public	signature:() const
cv::Ptr::operator const _Tp*	core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::operator const _Tp*() const { return obj; }$/;"	f	class:cv::Ptr	signature:() const
cv::Ptr::refcount	core/core.hpp	/^    int* refcount; \/\/< the associated reference counter$/;"	m	class:cv::Ptr	access:protected
cv::Ptr::release	core/core.hpp	/^    void release();$/;"	p	class:cv::Ptr	access:public	signature:()
cv::Ptr::release	core/operations.hpp	/^template<typename _Tp> inline void Ptr<_Tp>::release()$/;"	f	class:cv::Ptr	signature:()
cv::Ptr::~Ptr	core/core.hpp	/^    ~Ptr();$/;"	p	class:cv::Ptr	access:public	signature:()
cv::Ptr::~Ptr	core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::~Ptr() { release(); }$/;"	f	class:cv::Ptr	signature:()
cv::PyramidAdaptedFeatureDetector	features2d/features2d.hpp	/^class CV_EXPORTS PyramidAdaptedFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
cv::PyramidAdaptedFeatureDetector::PyramidAdaptedFeatureDetector	features2d/features2d.hpp	/^    PyramidAdaptedFeatureDetector( const Ptr<FeatureDetector>& detector, int maxLevel=2 );$/;"	p	class:cv::PyramidAdaptedFeatureDetector	access:public	signature:( const Ptr<FeatureDetector>& detector, int maxLevel=2 )
cv::PyramidAdaptedFeatureDetector::detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::PyramidAdaptedFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::PyramidAdaptedFeatureDetector::detector	features2d/features2d.hpp	/^    Ptr<FeatureDetector> detector;$/;"	m	class:cv::PyramidAdaptedFeatureDetector	access:protected
cv::PyramidAdaptedFeatureDetector::empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::PyramidAdaptedFeatureDetector	access:public	signature:() const
cv::PyramidAdaptedFeatureDetector::maxLevel	features2d/features2d.hpp	/^    int maxLevel;$/;"	m	class:cv::PyramidAdaptedFeatureDetector	access:protected
cv::RANSAC	calib3d/calib3d.hpp	/^    RANSAC=CV_RANSAC \/\/!< RANSAC algorithm$/;"	e	enum:cv::__anon87
cv::RETINA_COLORSAMPLINGMETHOD	contrib/retina.hpp	/^    enum RETINA_COLORSAMPLINGMETHOD$/;"	g	namespace:cv
cv::RETINA_COLOR_BAYER	contrib/retina.hpp	/^        RETINA_COLOR_BAYER\/\/\/ standard bayer sampling$/;"	e	enum:cv::RETINA_COLORSAMPLINGMETHOD
cv::RETINA_COLOR_DIAGONAL	contrib/retina.hpp	/^        RETINA_COLOR_DIAGONAL,\/\/\/ color sampling is RGBRGBRGB..., line 2 BRGBRGBRG..., line 3, GBRGBRGBR...$/;"	e	enum:cv::RETINA_COLORSAMPLINGMETHOD
cv::RETINA_COLOR_RANDOM	contrib/retina.hpp	/^        RETINA_COLOR_RANDOM, \/\/\/ each pixel position is either R, G or B in a random choice$/;"	e	enum:cv::RETINA_COLORSAMPLINGMETHOD
cv::RETR_CCOMP	imgproc/imgproc.hpp	/^    RETR_CCOMP=CV_RETR_CCOMP, \/\/!< retrieve the connected components (that can possibly be nested)$/;"	e	enum:cv::__anon25
cv::RETR_EXTERNAL	imgproc/imgproc.hpp	/^    RETR_EXTERNAL=CV_RETR_EXTERNAL, \/\/!< retrieve only the most external (top-level) contours$/;"	e	enum:cv::__anon25
cv::RETR_LIST	imgproc/imgproc.hpp	/^    RETR_LIST=CV_RETR_LIST, \/\/!< retrieve all the contours without any hierarchical information$/;"	e	enum:cv::__anon25
cv::RETR_TREE	imgproc/imgproc.hpp	/^    RETR_TREE=CV_RETR_TREE \/\/!< retrieve all the contours and the whole hierarchy$/;"	e	enum:cv::__anon25
cv::RNG	core/core.hpp	/^class CV_EXPORTS RNG$/;"	c	namespace:cv
cv::RNG::NORMAL	core/core.hpp	/^    enum { UNIFORM=0, NORMAL=1 };$/;"	e	enum:cv::RNG::__anon138
cv::RNG::RNG	core/core.hpp	/^    RNG();$/;"	p	class:cv::RNG	access:public	signature:()
cv::RNG::RNG	core/core.hpp	/^    RNG(uint64 _state);$/;"	p	class:cv::RNG	access:public	signature:(uint64 _state)
cv::RNG::RNG	core/operations.hpp	/^inline RNG::RNG() { state = 0xffffffff; }$/;"	f	class:cv::RNG	signature:()
cv::RNG::RNG	core/operations.hpp	/^inline RNG::RNG(uint64 _state) { state = _state ? _state : 0xffffffff; }$/;"	f	class:cv::RNG	signature:(uint64 _state)
cv::RNG::UNIFORM	core/core.hpp	/^    enum { UNIFORM=0, NORMAL=1 };$/;"	e	enum:cv::RNG::__anon138
cv::RNG::fill	core/core.hpp	/^    void fill( InputOutputArray mat, int distType, InputArray a, InputArray b );$/;"	p	class:cv::RNG	access:public	signature:( InputOutputArray mat, int distType, InputArray a, InputArray b )
cv::RNG::gaussian	core/core.hpp	/^    double gaussian(double sigma);$/;"	p	class:cv::RNG	access:public	signature:(double sigma)
cv::RNG::next	core/core.hpp	/^    unsigned next();$/;"	p	class:cv::RNG	access:public	signature:()
cv::RNG::next	core/operations.hpp	/^inline unsigned RNG::next()$/;"	f	class:cv::RNG	signature:()
cv::RNG::operator ()	core/core.hpp	/^    unsigned operator ()();$/;"	p	class:cv::RNG	access:public	signature:()
cv::RNG::operator ()	core/core.hpp	/^    unsigned operator()(unsigned N);$/;"	p	class:cv::RNG	access:public	signature:(unsigned N)
cv::RNG::operator ()	core/operations.hpp	/^inline unsigned RNG::operator ()() {return next();}$/;"	f	class:cv::RNG	signature:()
cv::RNG::operator ()	core/operations.hpp	/^inline unsigned RNG::operator ()(unsigned N) {return (unsigned)uniform(0,N);}$/;"	f	class:cv::RNG	signature:(unsigned N)
cv::RNG::operator double	core/core.hpp	/^    operator double();$/;"	p	class:cv::RNG	access:public	signature:()
cv::RNG::operator double	core/operations.hpp	/^inline RNG::operator double()$/;"	f	class:cv::RNG	signature:()
cv::RNG::operator float	core/core.hpp	/^    operator float();$/;"	p	class:cv::RNG	access:public	signature:()
cv::RNG::operator float	core/operations.hpp	/^inline RNG::operator float() { return next()*2.3283064365386962890625e-10f; }$/;"	f	class:cv::RNG	signature:()
cv::RNG::operator int	core/core.hpp	/^    operator int();$/;"	p	class:cv::RNG	access:public	signature:()
cv::RNG::operator int	core/operations.hpp	/^inline RNG::operator int() { return (int)next(); }$/;"	f	class:cv::RNG	signature:()
cv::RNG::operator schar	core/core.hpp	/^    operator schar();$/;"	p	class:cv::RNG	access:public	signature:()
cv::RNG::operator schar	core/operations.hpp	/^inline RNG::operator schar() { return (schar)next(); }$/;"	f	class:cv::RNG	signature:()
cv::RNG::operator short	core/core.hpp	/^    operator short();$/;"	p	class:cv::RNG	access:public	signature:()
cv::RNG::operator short	core/operations.hpp	/^inline RNG::operator short() { return (short)next(); }$/;"	f	class:cv::RNG	signature:()
cv::RNG::operator uchar	core/core.hpp	/^    operator uchar();$/;"	p	class:cv::RNG	access:public	signature:()
cv::RNG::operator uchar	core/operations.hpp	/^inline RNG::operator uchar() { return (uchar)next(); }$/;"	f	class:cv::RNG	signature:()
cv::RNG::operator unsigned	core/core.hpp	/^    operator unsigned();$/;"	p	class:cv::RNG	access:public	signature:()
cv::RNG::operator unsigned	core/operations.hpp	/^inline RNG::operator unsigned() { return next(); }$/;"	f	class:cv::RNG	signature:()
cv::RNG::operator ushort	core/core.hpp	/^    operator ushort();$/;"	p	class:cv::RNG	access:public	signature:()
cv::RNG::operator ushort	core/operations.hpp	/^inline RNG::operator ushort() { return (ushort)next(); }$/;"	f	class:cv::RNG	signature:()
cv::RNG::state	core/core.hpp	/^    uint64 state;$/;"	m	class:cv::RNG	access:public
cv::RNG::uniform	core/core.hpp	/^    double uniform(double a, double b);$/;"	p	class:cv::RNG	access:public	signature:(double a, double b)
cv::RNG::uniform	core/core.hpp	/^    float uniform(float a, float b);$/;"	p	class:cv::RNG	access:public	signature:(float a, float b)
cv::RNG::uniform	core/core.hpp	/^    int uniform(int a, int b);$/;"	p	class:cv::RNG	access:public	signature:(int a, int b)
cv::RNG::uniform	core/operations.hpp	/^inline double RNG::uniform(double a, double b) { return ((double)*this)*(b - a) + a; }$/;"	f	class:cv::RNG	signature:(double a, double b)
cv::RNG::uniform	core/operations.hpp	/^inline float RNG::uniform(float a, float b) { return ((float)*this)*(b - a) + a; }$/;"	f	class:cv::RNG	signature:(float a, float b)
cv::RNG::uniform	core/operations.hpp	/^inline int RNG::uniform(int a, int b) { return a == b ? a : next()%(b - a) + a; }$/;"	f	class:cv::RNG	signature:(int a, int b)
cv::RQDecomp3x3	calib3d/calib3d.hpp	/^CV_EXPORTS_W Vec3d RQDecomp3x3( InputArray src, OutputArray mtxR, OutputArray mtxQ,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray mtxR, OutputArray mtxQ, OutputArray Qx=noArray(), OutputArray Qy=noArray(), OutputArray Qz=noArray())
cv::RTTIImpl	core/operations.hpp	/^template<typename _ClsName> struct CV_EXPORTS RTTIImpl$/;"	s	namespace:cv
cv::RTTIImpl::clone	core/operations.hpp	/^    static void* clone(const void* ptr)$/;"	f	struct:cv::RTTIImpl	access:public	signature:(const void* ptr)
cv::RTTIImpl::isInstance	core/operations.hpp	/^    static int isInstance(const void* ptr)$/;"	f	struct:cv::RTTIImpl	access:public	signature:(const void* ptr)
cv::RTTIImpl::read	core/operations.hpp	/^    static void* read(CvFileStorage* fs, CvFileNode* n)$/;"	f	struct:cv::RTTIImpl	access:public	signature:(CvFileStorage* fs, CvFileNode* n)
cv::RTTIImpl::release	core/operations.hpp	/^    static void release(void** dbptr)$/;"	f	struct:cv::RTTIImpl	access:public	signature:(void** dbptr)
cv::RTTIImpl::write	core/operations.hpp	/^    static void write(CvFileStorage* _fs, const char* name, const void* ptr, CvAttrList)$/;"	f	struct:cv::RTTIImpl	access:public	signature:(CvFileStorage* _fs, const char* name, const void* ptr, CvAttrList)
cv::RTreeClassifier	features2d/features2d.hpp	/^class CV_EXPORTS RTreeClassifier$/;"	c	namespace:cv
cv::RTreeClassifier::DEFAULT_NUM_QUANT_BITS	features2d/features2d.hpp	/^  static const size_t DEFAULT_NUM_QUANT_BITS = 4;$/;"	m	class:cv::RTreeClassifier	access:public
cv::RTreeClassifier::DEFAULT_TREES	features2d/features2d.hpp	/^  static const int DEFAULT_TREES = 48;$/;"	m	class:cv::RTreeClassifier	access:public
cv::RTreeClassifier::RTreeClassifier	features2d/features2d.hpp	/^  RTreeClassifier();$/;"	p	class:cv::RTreeClassifier	access:public	signature:()
cv::RTreeClassifier::classes	features2d/features2d.hpp	/^  inline int classes() const { return classes_; }$/;"	f	class:cv::RTreeClassifier	access:public	signature:() const
cv::RTreeClassifier::classes_	features2d/features2d.hpp	/^  int classes_;$/;"	m	class:cv::RTreeClassifier	access:private
cv::RTreeClassifier::countNonZeroElements	features2d/features2d.hpp	/^  static int countNonZeroElements(float *vec, int n, double tol=1e-10);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(float *vec, int n, double tol=1e-10)
cv::RTreeClassifier::countZeroElements	features2d/features2d.hpp	/^  float countZeroElements();$/;"	p	class:cv::RTreeClassifier	access:public	signature:()
cv::RTreeClassifier::discardFloatPosteriors	features2d/features2d.hpp	/^  void discardFloatPosteriors();$/;"	p	class:cv::RTreeClassifier	access:public	signature:()
cv::RTreeClassifier::getFloatSignature	features2d/features2d.hpp	/^  void getFloatSignature(IplImage *patch, float *sig) const { getSignature(patch, sig); }$/;"	f	class:cv::RTreeClassifier	access:public	signature:(IplImage *patch, float *sig) const
cv::RTreeClassifier::getSignature	features2d/features2d.hpp	/^  void getSignature(IplImage *patch, float *sig) const;$/;"	p	class:cv::RTreeClassifier	access:public	signature:(IplImage *patch, float *sig) const
cv::RTreeClassifier::getSignature	features2d/features2d.hpp	/^  void getSignature(IplImage *patch, uchar *sig) const;$/;"	p	class:cv::RTreeClassifier	access:public	signature:(IplImage *patch, uchar *sig) const
cv::RTreeClassifier::getSparseSignature	features2d/features2d.hpp	/^  void getSparseSignature(IplImage *patch, float *sig, float thresh) const;$/;"	p	class:cv::RTreeClassifier	access:public	signature:(IplImage *patch, float *sig, float thresh) const
cv::RTreeClassifier::keep_floats_	features2d/features2d.hpp	/^  bool keep_floats_;$/;"	m	class:cv::RTreeClassifier	access:private
cv::RTreeClassifier::num_quant_bits_	features2d/features2d.hpp	/^  int num_quant_bits_;$/;"	m	class:cv::RTreeClassifier	access:private
cv::RTreeClassifier::original_num_classes	features2d/features2d.hpp	/^  inline int original_num_classes() const { return original_num_classes_; }$/;"	f	class:cv::RTreeClassifier	access:public	signature:() const
cv::RTreeClassifier::original_num_classes_	features2d/features2d.hpp	/^  int original_num_classes_;$/;"	m	class:cv::RTreeClassifier	access:private
cv::RTreeClassifier::posteriors_	features2d/features2d.hpp	/^  mutable uchar **posteriors_;$/;"	m	class:cv::RTreeClassifier	access:private
cv::RTreeClassifier::ptemp_	features2d/features2d.hpp	/^  mutable unsigned short *ptemp_;$/;"	m	class:cv::RTreeClassifier	access:private
cv::RTreeClassifier::read	features2d/features2d.hpp	/^  void read(const char* file_name);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(const char* file_name)
cv::RTreeClassifier::read	features2d/features2d.hpp	/^  void read(std::istream &is);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::istream &is)
cv::RTreeClassifier::safeSignatureAlloc	features2d/features2d.hpp	/^  static inline uchar* safeSignatureAlloc(int num_sig=1, int sig_len=176);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(int num_sig=1, int sig_len=176)
cv::RTreeClassifier::safeSignatureAlloc	features2d/features2d.hpp	/^  static inline void safeSignatureAlloc(uchar **sig, int num_sig=1, int sig_len=176);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(uchar **sig, int num_sig=1, int sig_len=176)
cv::RTreeClassifier::saveAllBytePosteriors	features2d/features2d.hpp	/^  void saveAllBytePosteriors(std::string file_url);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::string file_url)
cv::RTreeClassifier::saveAllFloatPosteriors	features2d/features2d.hpp	/^  void saveAllFloatPosteriors(std::string file_url);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::string file_url)
cv::RTreeClassifier::setFloatPosteriorsFromTextfile_176	features2d/features2d.hpp	/^  void setFloatPosteriorsFromTextfile_176(std::string url);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::string url)
cv::RTreeClassifier::setQuantization	features2d/features2d.hpp	/^  void setQuantization(int num_quant_bits);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(int num_quant_bits)
cv::RTreeClassifier::train	features2d/features2d.hpp	/^  void train(std::vector<BaseKeypoint> const& base_set,$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::vector<BaseKeypoint> const& base_set, RNG &rng, PatchGenerator &make_patch, int num_trees = RTreeClassifier::DEFAULT_TREES, int depth = RandomizedTree::DEFAULT_DEPTH, int views = RandomizedTree::DEFAULT_VIEWS, size_t reduced_num_dim = RandomizedTree::DEFAULT_REDUCED_NUM_DIM, int num_quant_bits = DEFAULT_NUM_QUANT_BITS)
cv::RTreeClassifier::train	features2d/features2d.hpp	/^  void train(std::vector<BaseKeypoint> const& base_set,$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::vector<BaseKeypoint> const& base_set, RNG &rng, int num_trees = RTreeClassifier::DEFAULT_TREES, int depth = RandomizedTree::DEFAULT_DEPTH, int views = RandomizedTree::DEFAULT_VIEWS, size_t reduced_num_dim = RandomizedTree::DEFAULT_REDUCED_NUM_DIM, int num_quant_bits = DEFAULT_NUM_QUANT_BITS)
cv::RTreeClassifier::trees_	features2d/features2d.hpp	/^  std::vector<RandomizedTree> trees_;$/;"	m	class:cv::RTreeClassifier	access:public
cv::RTreeClassifier::write	features2d/features2d.hpp	/^  void write(const char* file_name) const;$/;"	p	class:cv::RTreeClassifier	access:public	signature:(const char* file_name) const
cv::RTreeClassifier::write	features2d/features2d.hpp	/^  void write(std::ostream &os) const;$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::ostream &os) const
cv::RTreeNode	features2d/features2d.hpp	/^struct CV_EXPORTS RTreeNode$/;"	s	namespace:cv
cv::RTreeNode::RTreeNode	features2d/features2d.hpp	/^  RTreeNode() {}$/;"	f	struct:cv::RTreeNode	access:public	signature:()
cv::RTreeNode::RTreeNode	features2d/features2d.hpp	/^  RTreeNode(uchar x1, uchar y1, uchar x2, uchar y2)$/;"	f	struct:cv::RTreeNode	access:public	signature:(uchar x1, uchar y1, uchar x2, uchar y2)
cv::RTreeNode::offset1	features2d/features2d.hpp	/^  short offset1, offset2;$/;"	m	struct:cv::RTreeNode	access:public
cv::RTreeNode::offset2	features2d/features2d.hpp	/^  short offset1, offset2;$/;"	m	struct:cv::RTreeNode	access:public
cv::RTreeNode::operator ()	features2d/features2d.hpp	/^  inline bool operator() (uchar* patch_data) const$/;"	f	struct:cv::RTreeNode	access:public	signature:(uchar* patch_data) const
cv::RandomTreeParams	ml/ml.hpp	/^typedef CvRTParams RandomTreeParams;$/;"	t	namespace:cv
cv::RandomTrees	ml/ml.hpp	/^typedef CvRTrees RandomTrees;$/;"	t	namespace:cv
cv::RandomizedTree	features2d/features2d.hpp	/^class CV_EXPORTS RandomizedTree$/;"	c	namespace:cv
cv::RandomizedTree::DEFAULT_DEPTH	features2d/features2d.hpp	/^  static const int DEFAULT_DEPTH = 9;$/;"	m	class:cv::RandomizedTree	access:public
cv::RandomizedTree::DEFAULT_REDUCED_NUM_DIM	features2d/features2d.hpp	/^  static const size_t DEFAULT_REDUCED_NUM_DIM = 176;$/;"	m	class:cv::RandomizedTree	access:public
cv::RandomizedTree::DEFAULT_VIEWS	features2d/features2d.hpp	/^  static const int DEFAULT_VIEWS = 5000;$/;"	m	class:cv::RandomizedTree	access:public
cv::RandomizedTree::GET_LOWER_QUANT_PERC	features2d/features2d.hpp	/^  static float GET_LOWER_QUANT_PERC() { return .03f; }$/;"	f	class:cv::RandomizedTree	access:public	signature:()
cv::RandomizedTree::GET_UPPER_QUANT_PERC	features2d/features2d.hpp	/^  static float GET_UPPER_QUANT_PERC() { return .92f; }$/;"	f	class:cv::RandomizedTree	access:public	signature:()
cv::RandomizedTree::PATCH_SIZE	features2d/features2d.hpp	/^  static const uchar PATCH_SIZE = 32;$/;"	m	class:cv::RandomizedTree	access:public
cv::RandomizedTree::RandomizedTree	features2d/features2d.hpp	/^  RandomizedTree();$/;"	p	class:cv::RandomizedTree	access:public	signature:()
cv::RandomizedTree::addExample	features2d/features2d.hpp	/^  void addExample(int class_id, uchar* patch_data);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int class_id, uchar* patch_data)
cv::RandomizedTree::allocPosteriorsAligned	features2d/features2d.hpp	/^  void allocPosteriorsAligned(int num_leaves, int num_classes);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int num_leaves, int num_classes)
cv::RandomizedTree::applyQuantization	features2d/features2d.hpp	/^  inline void applyQuantization(int num_quant_bits) { makePosteriors2(num_quant_bits); }$/;"	f	class:cv::RandomizedTree	access:public	signature:(int num_quant_bits)
cv::RandomizedTree::classes	features2d/features2d.hpp	/^  int classes() { return classes_; }$/;"	f	class:cv::RandomizedTree	access:public	signature:()
cv::RandomizedTree::classes_	features2d/features2d.hpp	/^  int classes_;$/;"	m	class:cv::RandomizedTree	access:private
cv::RandomizedTree::compressLeaves	features2d/features2d.hpp	/^  void compressLeaves(size_t reduced_num_dim);$/;"	p	class:cv::RandomizedTree	access:private	signature:(size_t reduced_num_dim)
cv::RandomizedTree::convertPosteriorsToChar	features2d/features2d.hpp	/^  void convertPosteriorsToChar();$/;"	p	class:cv::RandomizedTree	access:private	signature:()
cv::RandomizedTree::createNodes	features2d/features2d.hpp	/^  void createNodes(int num_nodes, RNG &rng);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int num_nodes, RNG &rng)
cv::RandomizedTree::depth	features2d/features2d.hpp	/^  int depth() { return depth_; }$/;"	f	class:cv::RandomizedTree	access:public	signature:()
cv::RandomizedTree::depth_	features2d/features2d.hpp	/^  int depth_;$/;"	m	class:cv::RandomizedTree	access:private
cv::RandomizedTree::discardFloatPosteriors	features2d/features2d.hpp	/^  void discardFloatPosteriors() { freePosteriors(1); }$/;"	f	class:cv::RandomizedTree	access:public	signature:()
cv::RandomizedTree::estimateQuantPercForPosteriors	features2d/features2d.hpp	/^  void estimateQuantPercForPosteriors(float perc[2]);$/;"	p	class:cv::RandomizedTree	access:private	signature:(float perc[2])
cv::RandomizedTree::finalize	features2d/features2d.hpp	/^  void finalize(size_t reduced_num_dim, int num_quant_bits);$/;"	p	class:cv::RandomizedTree	access:private	signature:(size_t reduced_num_dim, int num_quant_bits)
cv::RandomizedTree::freePosteriors	features2d/features2d.hpp	/^  void freePosteriors(int which);    \/\/ which: 1=posteriors_, 2=posteriors2_, 3=both$/;"	p	class:cv::RandomizedTree	access:private	signature:(int which)
cv::RandomizedTree::getIndex	features2d/features2d.hpp	/^  int getIndex(uchar* patch_data) const;$/;"	p	class:cv::RandomizedTree	access:private	signature:(uchar* patch_data) const
cv::RandomizedTree::getPosterior	features2d/features2d.hpp	/^  const float* getPosterior(uchar* patch_data) const;$/;"	p	class:cv::RandomizedTree	access:public	signature:(uchar* patch_data) const
cv::RandomizedTree::getPosterior	features2d/features2d.hpp	/^  float* getPosterior(uchar* patch_data);$/;"	p	class:cv::RandomizedTree	access:public	signature:(uchar* patch_data)
cv::RandomizedTree::getPosterior2	features2d/features2d.hpp	/^  const uchar* getPosterior2(uchar* patch_data) const;$/;"	p	class:cv::RandomizedTree	access:public	signature:(uchar* patch_data) const
cv::RandomizedTree::getPosterior2	features2d/features2d.hpp	/^  uchar* getPosterior2(uchar* patch_data);$/;"	p	class:cv::RandomizedTree	access:public	signature:(uchar* patch_data)
cv::RandomizedTree::getPosteriorByIndex	features2d/features2d.hpp	/^  inline const float* getPosteriorByIndex(int index) const;$/;"	p	class:cv::RandomizedTree	access:private	signature:(int index) const
cv::RandomizedTree::getPosteriorByIndex	features2d/features2d.hpp	/^  inline float* getPosteriorByIndex(int index);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int index)
cv::RandomizedTree::getPosteriorByIndex	features2d/features2d.hpp	/^inline const float* RandomizedTree::getPosteriorByIndex(int index) const$/;"	f	class:cv::RandomizedTree	signature:(int index) const
cv::RandomizedTree::getPosteriorByIndex	features2d/features2d.hpp	/^inline float* RandomizedTree::getPosteriorByIndex(int index)$/;"	f	class:cv::RandomizedTree	signature:(int index)
cv::RandomizedTree::getPosteriorByIndex2	features2d/features2d.hpp	/^  inline const uchar* getPosteriorByIndex2(int index) const;$/;"	p	class:cv::RandomizedTree	access:private	signature:(int index) const
cv::RandomizedTree::getPosteriorByIndex2	features2d/features2d.hpp	/^  inline uchar* getPosteriorByIndex2(int index);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int index)
cv::RandomizedTree::getPosteriorByIndex2	features2d/features2d.hpp	/^inline const uchar* RandomizedTree::getPosteriorByIndex2(int index) const$/;"	f	class:cv::RandomizedTree	signature:(int index) const
cv::RandomizedTree::getPosteriorByIndex2	features2d/features2d.hpp	/^inline uchar* RandomizedTree::getPosteriorByIndex2(int index)$/;"	f	class:cv::RandomizedTree	signature:(int index)
cv::RandomizedTree::init	features2d/features2d.hpp	/^  void init(int classes, int depth, RNG &rng);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int classes, int depth, RNG &rng)
cv::RandomizedTree::leaf_counts_	features2d/features2d.hpp	/^  std::vector<int> leaf_counts_;$/;"	m	class:cv::RandomizedTree	access:private
cv::RandomizedTree::makePosteriors2	features2d/features2d.hpp	/^  void makePosteriors2(int num_quant_bits);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int num_quant_bits)
cv::RandomizedTree::nodes_	features2d/features2d.hpp	/^  std::vector<RTreeNode> nodes_;$/;"	m	class:cv::RandomizedTree	access:private
cv::RandomizedTree::num_leaves_	features2d/features2d.hpp	/^  int num_leaves_;$/;"	m	class:cv::RandomizedTree	access:private
cv::RandomizedTree::posteriors2_	features2d/features2d.hpp	/^  uchar **posteriors2_;     \/\/ 16-bytes aligned posteriors$/;"	m	class:cv::RandomizedTree	access:private
cv::RandomizedTree::posteriors_	features2d/features2d.hpp	/^  float **posteriors_;        \/\/ 16-bytes aligned posteriors$/;"	m	class:cv::RandomizedTree	access:private
cv::RandomizedTree::quantizeVector	features2d/features2d.hpp	/^  static void quantizeVector(float *src, int dim, int N, float bnds[2], uchar *dst);$/;"	p	class:cv::RandomizedTree	access:public	signature:(float *src, int dim, int N, float bnds[2], uchar *dst)
cv::RandomizedTree::quantizeVector	features2d/features2d.hpp	/^  static void quantizeVector(float *vec, int dim, int N, float bnds[2], int clamp_mode=0);$/;"	p	class:cv::RandomizedTree	access:public	signature:(float *vec, int dim, int N, float bnds[2], int clamp_mode=0)
cv::RandomizedTree::read	features2d/features2d.hpp	/^  void read(const char* file_name, int num_quant_bits);$/;"	p	class:cv::RandomizedTree	access:public	signature:(const char* file_name, int num_quant_bits)
cv::RandomizedTree::read	features2d/features2d.hpp	/^  void read(std::istream &is, int num_quant_bits);$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::istream &is, int num_quant_bits)
cv::RandomizedTree::savePosteriors	features2d/features2d.hpp	/^  void savePosteriors(std::string url, bool append=false);$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::string url, bool append=false)
cv::RandomizedTree::savePosteriors2	features2d/features2d.hpp	/^  void savePosteriors2(std::string url, bool append=false);$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::string url, bool append=false)
cv::RandomizedTree::train	features2d/features2d.hpp	/^  void train(std::vector<BaseKeypoint> const& base_set, RNG &rng,$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::vector<BaseKeypoint> const& base_set, RNG &rng, PatchGenerator &make_patch, int depth, int views, size_t reduced_num_dim, int num_quant_bits)
cv::RandomizedTree::train	features2d/features2d.hpp	/^  void train(std::vector<BaseKeypoint> const& base_set, RNG &rng,$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::vector<BaseKeypoint> const& base_set, RNG &rng, int depth, int views, size_t reduced_num_dim, int num_quant_bits)
cv::RandomizedTree::write	features2d/features2d.hpp	/^  void write(const char* file_name) const;$/;"	p	class:cv::RandomizedTree	access:public	signature:(const char* file_name) const
cv::RandomizedTree::write	features2d/features2d.hpp	/^  void write(std::ostream &os) const;$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::ostream &os) const
cv::RandomizedTree::~RandomizedTree	features2d/features2d.hpp	/^  ~RandomizedTree();$/;"	p	class:cv::RandomizedTree	access:public	signature:()
cv::Range	core/core.hpp	/^class CV_EXPORTS Range$/;"	c	namespace:cv
cv::Range::Range	core/core.hpp	/^    Range();$/;"	p	class:cv::Range	access:public	signature:()
cv::Range::Range	core/core.hpp	/^    Range(const CvSlice& slice);$/;"	p	class:cv::Range	access:public	signature:(const CvSlice& slice)
cv::Range::Range	core/core.hpp	/^    Range(int _start, int _end);$/;"	p	class:cv::Range	access:public	signature:(int _start, int _end)
cv::Range::Range	core/operations.hpp	/^inline Range::Range() : start(0), end(0) {}$/;"	f	class:cv::Range	signature:()
cv::Range::Range	core/operations.hpp	/^inline Range::Range(const CvSlice& slice) : start(slice.start_index), end(slice.end_index)$/;"	f	class:cv::Range	signature:(const CvSlice& slice)
cv::Range::Range	core/operations.hpp	/^inline Range::Range(int _start, int _end) : start(_start), end(_end) {}$/;"	f	class:cv::Range	signature:(int _start, int _end)
cv::Range::all	core/core.hpp	/^    static Range all();$/;"	p	class:cv::Range	access:public	signature:()
cv::Range::all	core/operations.hpp	/^inline Range Range::all() { return Range(INT_MIN, INT_MAX); }$/;"	f	class:cv::Range	signature:()
cv::Range::empty	core/core.hpp	/^    bool empty() const;$/;"	p	class:cv::Range	access:public	signature:() const
cv::Range::empty	core/operations.hpp	/^inline bool Range::empty() const { return start == end; }$/;"	f	class:cv::Range	signature:() const
cv::Range::end	core/core.hpp	/^    int start, end;$/;"	m	class:cv::Range	access:public
cv::Range::operator CvSlice	core/core.hpp	/^    operator CvSlice() const;$/;"	p	class:cv::Range	access:public	signature:() const
cv::Range::operator CvSlice	core/operations.hpp	/^inline Range::operator CvSlice() const$/;"	f	class:cv::Range	signature:() const
cv::Range::size	core/core.hpp	/^    int size() const;$/;"	p	class:cv::Range	access:public	signature:() const
cv::Range::size	core/operations.hpp	/^inline int Range::size() const { return end - start; }$/;"	f	class:cv::Range	signature:() const
cv::Range::start	core/core.hpp	/^    int start, end;$/;"	m	class:cv::Range	access:public
cv::Rect	core/core.hpp	/^typedef Rect_<int> Rect;$/;"	t	namespace:cv
cv::Rect_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Rect_$/;"	c	namespace:cv
cv::Rect_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Rect_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::Rect_::Rect_	core/core.hpp	/^    Rect_();$/;"	p	class:cv::Rect_	access:public	signature:()
cv::Rect_::Rect_	core/core.hpp	/^    Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height);$/;"	p	class:cv::Rect_	access:public	signature:(_Tp _x, _Tp _y, _Tp _width, _Tp _height)
cv::Rect_::Rect_	core/core.hpp	/^    Rect_(const CvRect& r);$/;"	p	class:cv::Rect_	access:public	signature:(const CvRect& r)
cv::Rect_::Rect_	core/core.hpp	/^    Rect_(const Point_<_Tp>& org, const Size_<_Tp>& sz);$/;"	p	class:cv::Rect_	access:public	signature:(const Point_<_Tp>& org, const Size_<_Tp>& sz)
cv::Rect_::Rect_	core/core.hpp	/^    Rect_(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2);$/;"	p	class:cv::Rect_	access:public	signature:(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2)
cv::Rect_::Rect_	core/core.hpp	/^    Rect_(const Rect_& r);$/;"	p	class:cv::Rect_	access:public	signature:(const Rect_& r)
cv::Rect_::Rect_	core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_() : x(0), y(0), width(0), height(0) {}$/;"	f	class:cv::Rect_	signature:()
cv::Rect_::Rect_	core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height) : x(_x), y(_y), width(_width), height(_height) {}$/;"	f	class:cv::Rect_	signature:(_Tp _x, _Tp _y, _Tp _width, _Tp _height)
cv::Rect_::Rect_	core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_(const CvRect& r) : x((_Tp)r.x), y((_Tp)r.y), width((_Tp)r.width), height((_Tp)r.height) {}$/;"	f	class:cv::Rect_	signature:(const CvRect& r)
cv::Rect_::Rect_	core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_(const Point_<_Tp>& org, const Size_<_Tp>& sz) :$/;"	f	class:cv::Rect_	signature:(const Point_<_Tp>& org, const Size_<_Tp>& sz)
cv::Rect_::Rect_	core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2)$/;"	f	class:cv::Rect_	signature:(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2)
cv::Rect_::Rect_	core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::Rect_(const Rect_<_Tp>& r) : x(r.x), y(r.y), width(r.width), height(r.height) {}$/;"	f	class:cv::Rect_	signature:(const Rect_<_Tp>& r)
cv::Rect_::area	core/core.hpp	/^    _Tp area() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
cv::Rect_::area	core/operations.hpp	/^template<typename _Tp> inline _Tp Rect_<_Tp>::area() const { return width*height; }$/;"	f	class:cv::Rect_	signature:() const
cv::Rect_::br	core/core.hpp	/^    Point_<_Tp> br() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
cv::Rect_::br	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp> Rect_<_Tp>::br() const { return Point_<_Tp>(x+width, y+height); }$/;"	f	class:cv::Rect_	signature:() const
cv::Rect_::contains	core/core.hpp	/^    bool contains(const Point_<_Tp>& pt) const;$/;"	p	class:cv::Rect_	access:public	signature:(const Point_<_Tp>& pt) const
cv::Rect_::contains	core/operations.hpp	/^template<typename _Tp> inline bool Rect_<_Tp>::contains(const Point_<_Tp>& pt) const$/;"	f	class:cv::Rect_	signature:(const Point_<_Tp>& pt) const
cv::Rect_::height	core/core.hpp	/^    _Tp x, y, width, height; \/\/< the top-left corner, as well as width and height of the rectangle$/;"	m	class:cv::Rect_	access:public
cv::Rect_::operator =	core/core.hpp	/^    Rect_& operator = ( const Rect_& r );$/;"	p	class:cv::Rect_	access:public	signature:( const Rect_& r )
cv::Rect_::operator =	core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>& Rect_<_Tp>::operator = ( const Rect_<_Tp>& r )$/;"	f	class:cv::Rect_	signature:( const Rect_<_Tp>& r )
cv::Rect_::operator CvRect	core/core.hpp	/^    operator CvRect() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
cv::Rect_::operator CvRect	core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::operator CvRect() const$/;"	f	class:cv::Rect_	signature:() const
cv::Rect_::operator Rect_<_Tp2>	core/core.hpp	/^    template<typename _Tp2> operator Rect_<_Tp2>() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
cv::Rect_::operator Rect_<_Tp2>	core/operations.hpp	/^template<typename _Tp> template<typename _Tp2> inline Rect_<_Tp>::operator Rect_<_Tp2>() const$/;"	f	class:cv::Rect_	signature:() const
cv::Rect_::size	core/core.hpp	/^    Size_<_Tp> size() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
cv::Rect_::size	core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp> Rect_<_Tp>::size() const { return Size_<_Tp>(width, height); }$/;"	f	class:cv::Rect_	signature:() const
cv::Rect_::tl	core/core.hpp	/^    Point_<_Tp> tl() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
cv::Rect_::tl	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp> Rect_<_Tp>::tl() const { return Point_<_Tp>(x,y); }$/;"	f	class:cv::Rect_	signature:() const
cv::Rect_::value_type	core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Rect_	access:public
cv::Rect_::width	core/core.hpp	/^    _Tp x, y, width, height; \/\/< the top-left corner, as well as width and height of the rectangle$/;"	m	class:cv::Rect_	access:public
cv::Rect_::x	core/core.hpp	/^    _Tp x, y, width, height; \/\/< the top-left corner, as well as width and height of the rectangle$/;"	m	class:cv::Rect_	access:public
cv::Rect_::y	core/core.hpp	/^    _Tp x, y, width, height; \/\/< the top-left corner, as well as width and height of the rectangle$/;"	m	class:cv::Rect_	access:public
cv::Retina	contrib/retina.hpp	/^    class CV_EXPORTS Retina {$/;"	c	namespace:cv
cv::Retina::Retina	contrib/retina.hpp	/^        Retina(const std::string parametersSaveFile, Size inputSize);$/;"	p	class:cv::Retina	access:public	signature:(const std::string parametersSaveFile, Size inputSize)
cv::Retina::Retina	contrib/retina.hpp	/^        Retina(const std::string parametersSaveFile, Size inputSize, const bool colorMode, RETINA_COLORSAMPLINGMETHOD colorSamplingMethod=RETINA_COLOR_BAYER, const bool useRetinaLogSampling=false, const double reductionFactor=1.0, const double samplingStrenght=10.0);$/;"	p	class:cv::Retina	access:public	signature:(const std::string parametersSaveFile, Size inputSize, const bool colorMode, RETINA_COLORSAMPLINGMETHOD colorSamplingMethod=RETINA_COLOR_BAYER, const bool useRetinaLogSampling=false, const double reductionFactor=1.0, const double samplingStrenght=10.0)
cv::Retina::_convertValarrayGrayBuffer2cvMat	contrib/retina.hpp	/^        void _convertValarrayGrayBuffer2cvMat(const std::valarray<double> &grayMatrixToConvert, const unsigned int nbRows, const unsigned int nbColumns, const bool colorMode, Mat &outBuffer);$/;"	p	class:cv::Retina	access:protected	signature:(const std::valarray<double> &grayMatrixToConvert, const unsigned int nbRows, const unsigned int nbColumns, const bool colorMode, Mat &outBuffer)
cv::Retina::_init	contrib/retina.hpp	/^        void _init(const std::string parametersSaveFile, Size inputSize, const bool colorMode, RETINA_COLORSAMPLINGMETHOD colorSamplingMethod=RETINA_COLOR_BAYER, const bool useRetinaLogSampling=false, const double reductionFactor=1.0, const double samplingStrenght=10.0);$/;"	p	class:cv::Retina	access:protected	signature:(const std::string parametersSaveFile, Size inputSize, const bool colorMode, RETINA_COLORSAMPLINGMETHOD colorSamplingMethod=RETINA_COLOR_BAYER, const bool useRetinaLogSampling=false, const double reductionFactor=1.0, const double samplingStrenght=10.0)
cv::Retina::_inputBuffer	contrib/retina.hpp	/^        std::valarray<double> _inputBuffer;$/;"	m	class:cv::Retina	access:protected
cv::Retina::_parametersSaveFile	contrib/retina.hpp	/^        FileStorage _parametersSaveFile;$/;"	m	class:cv::Retina	access:protected
cv::Retina::_parametersSaveFileName	contrib/retina.hpp	/^        std::string _parametersSaveFileName;$/;"	m	class:cv::Retina	access:protected
cv::Retina::_retinaFilter	contrib/retina.hpp	/^        RetinaFilter* _retinaFilter;$/;"	m	class:cv::Retina	access:protected
cv::Retina::clearBuffers	contrib/retina.hpp	/^        void clearBuffers();$/;"	p	class:cv::Retina	access:public	signature:()
cv::Retina::getMagno	contrib/retina.hpp	/^        void getMagno(Mat &retinaOutput_magno);$/;"	p	class:cv::Retina	access:public	signature:(Mat &retinaOutput_magno)
cv::Retina::getParvo	contrib/retina.hpp	/^        void getParvo(Mat &retinaOutput_parvo);$/;"	p	class:cv::Retina	access:public	signature:(Mat &retinaOutput_parvo)
cv::Retina::printSetup	contrib/retina.hpp	/^        const std::string printSetup();$/;"	p	class:cv::Retina	access:public	signature:()
cv::Retina::run	contrib/retina.hpp	/^        void run(const Mat &inputImage);$/;"	p	class:cv::Retina	access:public	signature:(const Mat &inputImage)
cv::Retina::setup	contrib/retina.hpp	/^        void setup(std::string retinaParameterFile="", const bool applyDefaultSetupOnFailure=true);$/;"	p	class:cv::Retina	access:public	signature:(std::string retinaParameterFile=, const bool applyDefaultSetupOnFailure=true)
cv::Retina::setupIPLMagnoChannel	contrib/retina.hpp	/^        void setupIPLMagnoChannel(const bool normaliseOutput = true, const double parasolCells_beta=0, const double parasolCells_tau=0, const double parasolCells_k=7, const double amacrinCellsTemporalCutFrequency=1.2, const double V0CompressionParameter=0.95, const double localAdaptintegration_tau=0, const double localAdaptintegration_k=7);$/;"	p	class:cv::Retina	access:public	signature:(const bool normaliseOutput = true, const double parasolCells_beta=0, const double parasolCells_tau=0, const double parasolCells_k=7, const double amacrinCellsTemporalCutFrequency=1.2, const double V0CompressionParameter=0.95, const double localAdaptintegration_tau=0, const double localAdaptintegration_k=7)
cv::Retina::setupOPLandIPLParvoChannel	contrib/retina.hpp	/^        void setupOPLandIPLParvoChannel(const bool colorMode=true, const bool normaliseOutput = true, const double photoreceptorsLocalAdaptationSensitivity=0.7, const double photoreceptorsTemporalConstant=0.5, const double photoreceptorsSpatialConstant=0.53, const double horizontalCellsGain=0, const double HcellsTemporalConstant=1, const double HcellsSpatialConstant=7, const double ganglionCellsSensitivity=0.7);$/;"	p	class:cv::Retina	access:public	signature:(const bool colorMode=true, const bool normaliseOutput = true, const double photoreceptorsLocalAdaptationSensitivity=0.7, const double photoreceptorsTemporalConstant=0.5, const double photoreceptorsSpatialConstant=0.53, const double horizontalCellsGain=0, const double HcellsTemporalConstant=1, const double HcellsSpatialConstant=7, const double ganglionCellsSensitivity=0.7)
cv::Retina::~Retina	contrib/retina.hpp	/^        virtual ~Retina();$/;"	p	class:cv::Retina	access:public	signature:()
cv::Rodrigues	calib3d/calib3d.hpp	/^CV_EXPORTS_W void Rodrigues(InputArray src, OutputArray dst, OutputArray jacobian=noArray());$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, OutputArray jacobian=noArray())
cv::RotatedRect	core/core.hpp	/^class CV_EXPORTS RotatedRect$/;"	c	namespace:cv
cv::RotatedRect::RotatedRect	core/core.hpp	/^    RotatedRect();$/;"	p	class:cv::RotatedRect	access:public	signature:()
cv::RotatedRect::RotatedRect	core/core.hpp	/^    RotatedRect(const CvBox2D& box);$/;"	p	class:cv::RotatedRect	access:public	signature:(const CvBox2D& box)
cv::RotatedRect::RotatedRect	core/core.hpp	/^    RotatedRect(const Point2f& _center, const Size2f& _size, float _angle);$/;"	p	class:cv::RotatedRect	access:public	signature:(const Point2f& _center, const Size2f& _size, float _angle)
cv::RotatedRect::RotatedRect	core/operations.hpp	/^inline RotatedRect::RotatedRect() { angle = 0; }$/;"	f	class:cv::RotatedRect	signature:()
cv::RotatedRect::RotatedRect	core/operations.hpp	/^inline RotatedRect::RotatedRect(const CvBox2D& box)$/;"	f	class:cv::RotatedRect	signature:(const CvBox2D& box)
cv::RotatedRect::RotatedRect	core/operations.hpp	/^inline RotatedRect::RotatedRect(const Point2f& _center, const Size2f& _size, float _angle)$/;"	f	class:cv::RotatedRect	signature:(const Point2f& _center, const Size2f& _size, float _angle)
cv::RotatedRect::angle	core/core.hpp	/^    float angle;    \/\/< the rotation angle. When the angle is 0, 90, 180, 270 etc., the rectangle becomes an up-right rectangle. $/;"	m	class:cv::RotatedRect	access:public
cv::RotatedRect::boundingRect	core/core.hpp	/^    Rect boundingRect() const;$/;"	p	class:cv::RotatedRect	access:public	signature:() const
cv::RotatedRect::center	core/core.hpp	/^    Point2f center; \/\/< the rectangle mass center$/;"	m	class:cv::RotatedRect	access:public
cv::RotatedRect::operator CvBox2D	core/core.hpp	/^    operator CvBox2D() const;$/;"	p	class:cv::RotatedRect	access:public	signature:() const
cv::RotatedRect::operator CvBox2D	core/operations.hpp	/^inline RotatedRect::operator CvBox2D() const$/;"	f	class:cv::RotatedRect	signature:() const
cv::RotatedRect::points	core/core.hpp	/^    void points(Point2f pts[]) const;$/;"	p	class:cv::RotatedRect	access:public	signature:(Point2f pts[]) const
cv::RotatedRect::size	core/core.hpp	/^    Size2f size;    \/\/< width and height of the rectangle$/;"	m	class:cv::RotatedRect	access:public
cv::SIFT	features2d/features2d.hpp	/^class CV_EXPORTS SIFT$/;"	c	namespace:cv
cv::SIFT::CommonParams	features2d/features2d.hpp	/^    struct CV_EXPORTS CommonParams$/;"	s	class:cv::SIFT	access:public
cv::SIFT::CommonParams::AVERAGE_ANGLE	features2d/features2d.hpp	/^        enum { FIRST_ANGLE = 0, AVERAGE_ANGLE = 1 };$/;"	e	enum:cv::SIFT::CommonParams::__anon190
cv::SIFT::CommonParams::CommonParams	features2d/features2d.hpp	/^        CommonParams( int _nOctaves, int _nOctaveLayers );$/;"	p	struct:cv::SIFT::CommonParams	access:public	signature:( int _nOctaves, int _nOctaveLayers )
cv::SIFT::CommonParams::CommonParams	features2d/features2d.hpp	/^        CommonParams( int _nOctaves, int _nOctaveLayers, int \/*_firstOctave*\/, int \/*_angleMode*\/ );$/;"	p	struct:cv::SIFT::CommonParams	access:public	signature:( int _nOctaves, int _nOctaveLayers, int , int )
cv::SIFT::CommonParams::CommonParams	features2d/features2d.hpp	/^        CommonParams();$/;"	p	struct:cv::SIFT::CommonParams	access:public	signature:()
cv::SIFT::CommonParams::DEFAULT_FIRST_OCTAVE	features2d/features2d.hpp	/^        static const int DEFAULT_FIRST_OCTAVE = -1;$/;"	m	struct:cv::SIFT::CommonParams	access:public
cv::SIFT::CommonParams::DEFAULT_NOCTAVES	features2d/features2d.hpp	/^        static const int DEFAULT_NOCTAVES = 4;$/;"	m	struct:cv::SIFT::CommonParams	access:public
cv::SIFT::CommonParams::DEFAULT_NOCTAVE_LAYERS	features2d/features2d.hpp	/^        static const int DEFAULT_NOCTAVE_LAYERS = 3;$/;"	m	struct:cv::SIFT::CommonParams	access:public
cv::SIFT::CommonParams::FIRST_ANGLE	features2d/features2d.hpp	/^        enum { FIRST_ANGLE = 0, AVERAGE_ANGLE = 1 };$/;"	e	enum:cv::SIFT::CommonParams::__anon190
cv::SIFT::CommonParams::angleMode	features2d/features2d.hpp	/^        int angleMode;   \/\/ it is not used now$/;"	m	struct:cv::SIFT::CommonParams	access:public
cv::SIFT::CommonParams::firstOctave	features2d/features2d.hpp	/^        int firstOctave; \/\/ it is not used now (firstOctave == 0 always)$/;"	m	struct:cv::SIFT::CommonParams	access:public
cv::SIFT::CommonParams::nOctaveLayers	features2d/features2d.hpp	/^        int nOctaves, nOctaveLayers;$/;"	m	struct:cv::SIFT::CommonParams	access:public
cv::SIFT::CommonParams::nOctaves	features2d/features2d.hpp	/^        int nOctaves, nOctaveLayers;$/;"	m	struct:cv::SIFT::CommonParams	access:public
cv::SIFT::DescriptorParams	features2d/features2d.hpp	/^    struct CV_EXPORTS DescriptorParams$/;"	s	class:cv::SIFT	access:public
cv::SIFT::DescriptorParams::DEFAULT_IS_NORMALIZE	features2d/features2d.hpp	/^        static const bool DEFAULT_IS_NORMALIZE = true;$/;"	m	struct:cv::SIFT::DescriptorParams	access:public
cv::SIFT::DescriptorParams::DESCRIPTOR_SIZE	features2d/features2d.hpp	/^        static const int DESCRIPTOR_SIZE = 128;$/;"	m	struct:cv::SIFT::DescriptorParams	access:public
cv::SIFT::DescriptorParams::DescriptorParams	features2d/features2d.hpp	/^        DescriptorParams( bool _recalculateAngles );$/;"	p	struct:cv::SIFT::DescriptorParams	access:public	signature:( bool _recalculateAngles )
cv::SIFT::DescriptorParams::DescriptorParams	features2d/features2d.hpp	/^        DescriptorParams( double _magnification, bool \/*_isNormalize*\/, bool _recalculateAngles );$/;"	p	struct:cv::SIFT::DescriptorParams	access:public	signature:( double _magnification, bool , bool _recalculateAngles )
cv::SIFT::DescriptorParams::DescriptorParams	features2d/features2d.hpp	/^        DescriptorParams();$/;"	p	struct:cv::SIFT::DescriptorParams	access:public	signature:()
cv::SIFT::DescriptorParams::GET_DEFAULT_MAGNIFICATION	features2d/features2d.hpp	/^        static double GET_DEFAULT_MAGNIFICATION() { return 3.0; }$/;"	f	struct:cv::SIFT::DescriptorParams	access:public	signature:()
cv::SIFT::DescriptorParams::isNormalize	features2d/features2d.hpp	/^        bool isNormalize; \/\/ it is not used now (true always)$/;"	m	struct:cv::SIFT::DescriptorParams	access:public
cv::SIFT::DescriptorParams::magnification	features2d/features2d.hpp	/^        double magnification;$/;"	m	struct:cv::SIFT::DescriptorParams	access:public
cv::SIFT::DescriptorParams::recalculateAngles	features2d/features2d.hpp	/^        bool recalculateAngles;$/;"	m	struct:cv::SIFT::DescriptorParams	access:public
cv::SIFT::DetectorParams	features2d/features2d.hpp	/^    struct CV_EXPORTS DetectorParams$/;"	s	class:cv::SIFT	access:public
cv::SIFT::DetectorParams::DetectorParams	features2d/features2d.hpp	/^        DetectorParams( double _threshold, double _edgeThreshold );$/;"	p	struct:cv::SIFT::DetectorParams	access:public	signature:( double _threshold, double _edgeThreshold )
cv::SIFT::DetectorParams::DetectorParams	features2d/features2d.hpp	/^        DetectorParams();$/;"	p	struct:cv::SIFT::DetectorParams	access:public	signature:()
cv::SIFT::DetectorParams::GET_DEFAULT_EDGE_THRESHOLD	features2d/features2d.hpp	/^        static double GET_DEFAULT_EDGE_THRESHOLD() { return 10.0; }$/;"	f	struct:cv::SIFT::DetectorParams	access:public	signature:()
cv::SIFT::DetectorParams::GET_DEFAULT_THRESHOLD	features2d/features2d.hpp	/^        static double GET_DEFAULT_THRESHOLD() { return 0.04; }$/;"	f	struct:cv::SIFT::DetectorParams	access:public	signature:()
cv::SIFT::DetectorParams::edgeThreshold	features2d/features2d.hpp	/^        double threshold, edgeThreshold;$/;"	m	struct:cv::SIFT::DetectorParams	access:public
cv::SIFT::DetectorParams::threshold	features2d/features2d.hpp	/^        double threshold, edgeThreshold;$/;"	m	struct:cv::SIFT::DetectorParams	access:public
cv::SIFT::SIFT	features2d/features2d.hpp	/^    SIFT( const CommonParams& _commParams,$/;"	p	class:cv::SIFT	access:public	signature:( const CommonParams& _commParams, const DetectorParams& _detectorParams = DetectorParams(), const DescriptorParams& _descriptorParams = DescriptorParams() )
cv::SIFT::SIFT	features2d/features2d.hpp	/^    SIFT( double _magnification, bool _isNormalize=true,$/;"	p	class:cv::SIFT	access:public	signature:( double _magnification, bool _isNormalize=true, bool _recalculateAngles = true, int _nOctaves=CommonParams::DEFAULT_NOCTAVES, int _nOctaveLayers=CommonParams::DEFAULT_NOCTAVE_LAYERS, int _firstOctave=CommonParams::DEFAULT_FIRST_OCTAVE, int _angleMode=CommonParams::FIRST_ANGLE )
cv::SIFT::SIFT	features2d/features2d.hpp	/^    SIFT( double _threshold, double _edgeThreshold,$/;"	p	class:cv::SIFT	access:public	signature:( double _threshold, double _edgeThreshold, int _nOctaves=CommonParams::DEFAULT_NOCTAVES, int _nOctaveLayers=CommonParams::DEFAULT_NOCTAVE_LAYERS, int _firstOctave=CommonParams::DEFAULT_FIRST_OCTAVE, int _angleMode=CommonParams::FIRST_ANGLE )
cv::SIFT::SIFT	features2d/features2d.hpp	/^    SIFT();$/;"	p	class:cv::SIFT	access:public	signature:()
cv::SIFT::commParams	features2d/features2d.hpp	/^    CommonParams commParams;$/;"	m	class:cv::SIFT	access:protected
cv::SIFT::descriptorParams	features2d/features2d.hpp	/^    DescriptorParams descriptorParams;$/;"	m	class:cv::SIFT	access:protected
cv::SIFT::descriptorSize	features2d/features2d.hpp	/^    int descriptorSize() const;$/;"	p	class:cv::SIFT	access:public	signature:() const
cv::SIFT::detectorParams	features2d/features2d.hpp	/^    DetectorParams detectorParams;$/;"	m	class:cv::SIFT	access:protected
cv::SIFT::getCommonParams	features2d/features2d.hpp	/^    CommonParams getCommonParams () const;$/;"	p	class:cv::SIFT	access:public	signature:() const
cv::SIFT::getDescriptorParams	features2d/features2d.hpp	/^    DescriptorParams getDescriptorParams () const;$/;"	p	class:cv::SIFT	access:public	signature:() const
cv::SIFT::getDetectorParams	features2d/features2d.hpp	/^    DetectorParams getDetectorParams () const;$/;"	p	class:cv::SIFT	access:public	signature:() const
cv::SIFT::operator ()	features2d/features2d.hpp	/^    void operator()(const Mat& img, const Mat& mask,$/;"	p	class:cv::SIFT	access:public	signature:(const Mat& img, const Mat& mask, vector<KeyPoint>& keypoints) const
cv::SIFT::operator ()	features2d/features2d.hpp	/^    void operator()(const Mat& img, const Mat& mask,$/;"	p	class:cv::SIFT	access:public	signature:(const Mat& img, const Mat& mask, vector<KeyPoint>& keypoints, Mat& descriptors, bool useProvidedKeypoints=false) const
cv::SL2	features2d/features2d.hpp	/^struct CV_EXPORTS SL2$/;"	s	namespace:cv
cv::SL2::ResultType	features2d/features2d.hpp	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cv::SL2	access:public
cv::SL2::ValueType	features2d/features2d.hpp	/^    typedef T ValueType;$/;"	t	struct:cv::SL2	access:public
cv::SL2::operator ()	features2d/features2d.hpp	/^    ResultType operator()( const T* a, const T* b, int size ) const$/;"	f	struct:cv::SL2	access:public	signature:( const T* a, const T* b, int size ) const
cv::SORT_ASCENDING	core/core.hpp	/^	SORT_ASCENDING=0,$/;"	e	enum:cv::__anon140
cv::SORT_DESCENDING	core/core.hpp	/^	SORT_DESCENDING=16$/;"	e	enum:cv::__anon140
cv::SORT_EVERY_COLUMN	core/core.hpp	/^	SORT_EVERY_COLUMN=1,$/;"	e	enum:cv::__anon140
cv::SORT_EVERY_ROW	core/core.hpp	/^	SORT_EVERY_ROW=0,$/;"	e	enum:cv::__anon140
cv::SURF	features2d/features2d.hpp	/^class CV_EXPORTS_W SURF : public CvSURFParams$/;"	c	namespace:cv	inherits:CvSURFParams
cv::SURF::SURF	features2d/features2d.hpp	/^    CV_WRAP SURF();$/;"	p	class:cv::SURF	access:public	signature:()
cv::SURF::SURF	features2d/features2d.hpp	/^    CV_WRAP SURF(double _hessianThreshold, int _nOctaves=4,$/;"	p	class:cv::SURF	access:public	signature:(double _hessianThreshold, int _nOctaves=4, int _nOctaveLayers=2, bool _extended=false, bool _upright=false)
cv::SURF::descriptorSize	features2d/features2d.hpp	/^    CV_WRAP int descriptorSize() const;$/;"	p	class:cv::SURF	access:public	signature:() const
cv::SURF::operator ()	features2d/features2d.hpp	/^    CV_WRAP_AS(detect) void operator()(const Mat& img, const Mat& mask,$/;"	p	class:cv::SURF	access:public	signature:(const Mat& img, const Mat& mask, CV_OUT vector<KeyPoint>& keypoints) const
cv::SURF::operator ()	features2d/features2d.hpp	/^    CV_WRAP_AS(detect) void operator()(const Mat& img, const Mat& mask,$/;"	p	class:cv::SURF	access:public	signature:(const Mat& img, const Mat& mask, CV_OUT vector<KeyPoint>& keypoints, CV_OUT vector<float>& descriptors, bool useProvidedKeypoints=false) const
cv::SVBackSubst	core/core.hpp	/^CV_EXPORTS_W void SVBackSubst( InputArray w, InputArray u, InputArray vt,$/;"	p	namespace:cv	signature:( InputArray w, InputArray u, InputArray vt, InputArray rhs, CV_OUT OutputArray dst )
cv::SVD	core/core.hpp	/^class CV_EXPORTS SVD$/;"	c	namespace:cv
cv::SVD::FULL_UV	core/core.hpp	/^    enum { MODIFY_A=1, NO_UV=2, FULL_UV=4 };$/;"	e	enum:cv::SVD::__anon142
cv::SVD::MODIFY_A	core/core.hpp	/^    enum { MODIFY_A=1, NO_UV=2, FULL_UV=4 };$/;"	e	enum:cv::SVD::__anon142
cv::SVD::NO_UV	core/core.hpp	/^    enum { MODIFY_A=1, NO_UV=2, FULL_UV=4 };$/;"	e	enum:cv::SVD::__anon142
cv::SVD::SVD	core/core.hpp	/^    SVD( InputArray src, int flags=0 );$/;"	p	class:cv::SVD	access:public	signature:( InputArray src, int flags=0 )
cv::SVD::SVD	core/core.hpp	/^    SVD();$/;"	p	class:cv::SVD	access:public	signature:()
cv::SVD::SVD	core/mat.hpp	/^inline SVD::SVD( InputArray m, int flags ) { operator ()(m, flags); }$/;"	f	class:cv::SVD	signature:( InputArray m, int flags )
cv::SVD::SVD	core/mat.hpp	/^inline SVD::SVD() {}$/;"	f	class:cv::SVD	signature:()
cv::SVD::backSubst	core/core.hpp	/^    static void backSubst( InputArray w, InputArray u,$/;"	p	class:cv::SVD	access:public	signature:( InputArray w, InputArray u, InputArray vt, InputArray rhs, OutputArray dst )
cv::SVD::backSubst	core/core.hpp	/^    template<typename _Tp, int m, int n, int nm, int nb> static void backSubst( const Matx<_Tp, nm, 1>& w,$/;"	p	class:cv::SVD	access:public	signature:( const Matx<_Tp, nm, 1>& w, const Matx<_Tp, m, nm>& u, const Matx<_Tp, n, nm>& vt, const Matx<_Tp, m, nb>& rhs, Matx<_Tp, n, nb>& dst )
cv::SVD::backSubst	core/core.hpp	/^    void backSubst( InputArray rhs, OutputArray dst ) const;$/;"	p	class:cv::SVD	access:public	signature:( InputArray rhs, OutputArray dst ) const
cv::SVD::backSubst	core/mat.hpp	/^SVD::backSubst( const Matx<_Tp, nm, 1>& w, const Matx<_Tp, m, nm>& u,$/;"	f	class:cv::SVD	signature:( const Matx<_Tp, nm, 1>& w, const Matx<_Tp, m, nm>& u, const Matx<_Tp, n, nm>& vt, const Matx<_Tp, m, nb>& rhs, Matx<_Tp, n, nb>& dst )
cv::SVD::compute	core/core.hpp	/^    static void compute( InputArray src, OutputArray w, int flags=0 );$/;"	p	class:cv::SVD	access:public	signature:( InputArray src, OutputArray w, int flags=0 )
cv::SVD::compute	core/core.hpp	/^    static void compute( InputArray src, OutputArray w,$/;"	p	class:cv::SVD	access:public	signature:( InputArray src, OutputArray w, OutputArray u, OutputArray vt, int flags=0 )
cv::SVD::compute	core/core.hpp	/^    template<typename _Tp, int m, int n, int nm> static void compute( const Matx<_Tp, m, n>& a,$/;"	p	class:cv::SVD	access:public	signature:( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w )
cv::SVD::compute	core/core.hpp	/^    template<typename _Tp, int m, int n, int nm> static void compute( const Matx<_Tp, m, n>& a,$/;"	p	class:cv::SVD	access:public	signature:( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w, Matx<_Tp, m, nm>& u, Matx<_Tp, n, nm>& vt )
cv::SVD::compute	core/mat.hpp	/^    SVD::compute( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w, Matx<_Tp, m, nm>& u, Matx<_Tp, n, nm>& vt )$/;"	f	class:cv::SVD	signature:( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w, Matx<_Tp, m, nm>& u, Matx<_Tp, n, nm>& vt )
cv::SVD::compute	core/mat.hpp	/^SVD::compute( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w )$/;"	f	class:cv::SVD	signature:( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w )
cv::SVD::operator ()	core/core.hpp	/^    SVD& operator ()( InputArray src, int flags=0 );$/;"	p	class:cv::SVD	access:public	signature:( InputArray src, int flags=0 )
cv::SVD::solveZ	core/core.hpp	/^    static void solveZ( InputArray src, OutputArray dst );$/;"	p	class:cv::SVD	access:public	signature:( InputArray src, OutputArray dst )
cv::SVD::solveZ	core/mat.hpp	/^inline void SVD::solveZ( InputArray m, OutputArray _dst )$/;"	f	class:cv::SVD	signature:( InputArray m, OutputArray _dst )
cv::SVD::u	core/core.hpp	/^    Mat u, w, vt;$/;"	m	class:cv::SVD	access:public
cv::SVD::vt	core/core.hpp	/^    Mat u, w, vt;$/;"	m	class:cv::SVD	access:public
cv::SVD::w	core/core.hpp	/^    Mat u, w, vt;$/;"	m	class:cv::SVD	access:public
cv::SVDecomp	core/core.hpp	/^CV_EXPORTS_W void SVDecomp( InputArray src, CV_OUT OutputArray w,$/;"	p	namespace:cv	signature:( InputArray src, CV_OUT OutputArray w, CV_OUT OutputArray u, CV_OUT OutputArray vt, int flags=0 )
cv::SVM	ml/ml.hpp	/^typedef CvSVM SVM;$/;"	t	namespace:cv
cv::SVMKernel	ml/ml.hpp	/^typedef CvSVMKernel SVMKernel;$/;"	t	namespace:cv
cv::SVMParams	ml/ml.hpp	/^typedef CvSVMParams SVMParams;$/;"	t	namespace:cv
cv::SVMSolver	ml/ml.hpp	/^typedef CvSVMSolver SVMSolver;$/;"	t	namespace:cv
cv::Scalar	core/core.hpp	/^typedef Scalar_<double> Scalar;$/;"	t	namespace:cv
cv::Scalar_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Scalar_ : public Vec<_Tp, 4>$/;"	c	namespace:cv	inherits:Vec
cv::Scalar_::Scalar_	core/core.hpp	/^    Scalar_();$/;"	p	class:cv::Scalar_	access:public	signature:()
cv::Scalar_::Scalar_	core/core.hpp	/^    Scalar_(_Tp v0);$/;"	p	class:cv::Scalar_	access:public	signature:(_Tp v0)
cv::Scalar_::Scalar_	core/core.hpp	/^    Scalar_(_Tp v0, _Tp v1, _Tp v2=0, _Tp v3=0);$/;"	p	class:cv::Scalar_	access:public	signature:(_Tp v0, _Tp v1, _Tp v2=0, _Tp v3=0)
cv::Scalar_::Scalar_	core/core.hpp	/^    Scalar_(const CvScalar& s);$/;"	p	class:cv::Scalar_	access:public	signature:(const CvScalar& s)
cv::Scalar_::Scalar_	core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp>::Scalar_()$/;"	f	class:cv::Scalar_	signature:()
cv::Scalar_::Scalar_	core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp>::Scalar_(_Tp v0)$/;"	f	class:cv::Scalar_	signature:(_Tp v0)
cv::Scalar_::Scalar_	core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp>::Scalar_(_Tp v0, _Tp v1, _Tp v2, _Tp v3)$/;"	f	class:cv::Scalar_	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
cv::Scalar_::Scalar_	core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp>::Scalar_(const CvScalar& s)$/;"	f	class:cv::Scalar_	signature:(const CvScalar& s)
cv::Scalar_::all	core/core.hpp	/^    static Scalar_<_Tp> all(_Tp v0);$/;"	p	class:cv::Scalar_	access:public	signature:(_Tp v0)
cv::Scalar_::all	core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp> Scalar_<_Tp>::all(_Tp v0)$/;"	f	class:cv::Scalar_	signature:(_Tp v0)
cv::Scalar_::conj	core/core.hpp	/^    Scalar_<_Tp> conj() const;$/;"	p	class:cv::Scalar_	access:public	signature:() const
cv::Scalar_::conj	core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp> Scalar_<_Tp>::conj() const$/;"	f	class:cv::Scalar_	signature:() const
cv::Scalar_::isReal	core/core.hpp	/^    bool isReal() const;$/;"	p	class:cv::Scalar_	access:public	signature:() const
cv::Scalar_::isReal	core/operations.hpp	/^template<typename _Tp> inline bool Scalar_<_Tp>::isReal() const$/;"	f	class:cv::Scalar_	signature:() const
cv::Scalar_::mul	core/core.hpp	/^    Scalar_<_Tp> mul(const Scalar_<_Tp>& t, double scale=1 ) const;$/;"	p	class:cv::Scalar_	access:public	signature:(const Scalar_<_Tp>& t, double scale=1 ) const
cv::Scalar_::mul	core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp> Scalar_<_Tp>::mul(const Scalar_<_Tp>& t, double scale ) const$/;"	f	class:cv::Scalar_	signature:(const Scalar_<_Tp>& t, double scale ) const
cv::Scalar_::operator CvScalar	core/core.hpp	/^    operator CvScalar() const;$/;"	p	class:cv::Scalar_	access:public	signature:() const
cv::Scalar_::operator CvScalar	core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp>::operator CvScalar() const$/;"	f	class:cv::Scalar_	signature:() const
cv::Scalar_::operator Scalar_<T2>	core/core.hpp	/^    template<typename T2> operator Scalar_<T2>() const;$/;"	p	class:cv::Scalar_	access:public	signature:() const
cv::Scalar_::operator Scalar_<T2>	core/operations.hpp	/^template<typename _Tp> template<typename T2> inline Scalar_<_Tp>::operator Scalar_<T2>() const$/;"	f	class:cv::Scalar_	signature:() const
cv::Scharr	imgproc/imgproc.hpp	/^CV_EXPORTS_W void Scharr( InputArray src, OutputArray dst, int ddepth,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale=1, double delta=0, int borderType=BORDER_DEFAULT )
cv::SelfSimDescriptor	contrib/contrib.hpp	/^    class CV_EXPORTS SelfSimDescriptor$/;"	c	namespace:cv
cv::SelfSimDescriptor::DEFAULT_LARGE_SIZE	contrib/contrib.hpp	/^        enum { DEFAULT_SMALL_SIZE = 5, DEFAULT_LARGE_SIZE = 41,$/;"	e	enum:cv::SelfSimDescriptor::__anon6
cv::SelfSimDescriptor::DEFAULT_NUM_ANGLES	contrib/contrib.hpp	/^            DEFAULT_NUM_ANGLES = 20, DEFAULT_START_DISTANCE_BUCKET = 3,$/;"	e	enum:cv::SelfSimDescriptor::__anon6
cv::SelfSimDescriptor::DEFAULT_NUM_DISTANCE_BUCKETS	contrib/contrib.hpp	/^            DEFAULT_NUM_DISTANCE_BUCKETS = 7 };$/;"	e	enum:cv::SelfSimDescriptor::__anon6
cv::SelfSimDescriptor::DEFAULT_SMALL_SIZE	contrib/contrib.hpp	/^        enum { DEFAULT_SMALL_SIZE = 5, DEFAULT_LARGE_SIZE = 41,$/;"	e	enum:cv::SelfSimDescriptor::__anon6
cv::SelfSimDescriptor::DEFAULT_START_DISTANCE_BUCKET	contrib/contrib.hpp	/^            DEFAULT_NUM_ANGLES = 20, DEFAULT_START_DISTANCE_BUCKET = 3,$/;"	e	enum:cv::SelfSimDescriptor::__anon6
cv::SelfSimDescriptor::SSD	contrib/contrib.hpp	/^        virtual void SSD(const Mat& img, Point pt, Mat& ssd) const;$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(const Mat& img, Point pt, Mat& ssd) const
cv::SelfSimDescriptor::SelfSimDescriptor	contrib/contrib.hpp	/^        SelfSimDescriptor();$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:()
cv::SelfSimDescriptor::SelfSimDescriptor	contrib/contrib.hpp	/^        SelfSimDescriptor(const SelfSimDescriptor& ss);$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(const SelfSimDescriptor& ss)
cv::SelfSimDescriptor::SelfSimDescriptor	contrib/contrib.hpp	/^        SelfSimDescriptor(int _ssize, int _lsize,$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(int _ssize, int _lsize, int _startDistanceBucket=DEFAULT_START_DISTANCE_BUCKET, int _numberOfDistanceBuckets=DEFAULT_NUM_DISTANCE_BUCKETS, int _nangles=DEFAULT_NUM_ANGLES)
cv::SelfSimDescriptor::compute	contrib/contrib.hpp	/^        virtual void compute(const Mat& img, vector<float>& descriptors, Size winStride=Size(),$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(const Mat& img, vector<float>& descriptors, Size winStride=Size(), const vector<Point>& locations=vector<Point>()) const
cv::SelfSimDescriptor::computeLogPolarMapping	contrib/contrib.hpp	/^        virtual void computeLogPolarMapping(Mat& mappingMask) const;$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(Mat& mappingMask) const
cv::SelfSimDescriptor::getDescriptorSize	contrib/contrib.hpp	/^        size_t getDescriptorSize() const;$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:() const
cv::SelfSimDescriptor::getGridSize	contrib/contrib.hpp	/^        Size getGridSize( Size imgsize, Size winStride ) const;$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:( Size imgsize, Size winStride ) const
cv::SelfSimDescriptor::largeSize	contrib/contrib.hpp	/^        int largeSize;$/;"	m	class:cv::SelfSimDescriptor	access:public
cv::SelfSimDescriptor::numberOfAngles	contrib/contrib.hpp	/^        int numberOfAngles;$/;"	m	class:cv::SelfSimDescriptor	access:public
cv::SelfSimDescriptor::numberOfDistanceBuckets	contrib/contrib.hpp	/^        int numberOfDistanceBuckets;$/;"	m	class:cv::SelfSimDescriptor	access:public
cv::SelfSimDescriptor::operator =	contrib/contrib.hpp	/^        SelfSimDescriptor& operator = (const SelfSimDescriptor& ss);$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(const SelfSimDescriptor& ss)
cv::SelfSimDescriptor::smallSize	contrib/contrib.hpp	/^        int smallSize;$/;"	m	class:cv::SelfSimDescriptor	access:public
cv::SelfSimDescriptor::startDistanceBucket	contrib/contrib.hpp	/^        int startDistanceBucket;$/;"	m	class:cv::SelfSimDescriptor	access:public
cv::SelfSimDescriptor::~SelfSimDescriptor	contrib/contrib.hpp	/^        virtual ~SelfSimDescriptor();$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:()
cv::Seq	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Seq$/;"	c	namespace:cv
cv::Seq::Seq	core/core.hpp	/^    Seq();$/;"	p	class:cv::Seq	access:public	signature:()
cv::Seq::Seq	core/core.hpp	/^    Seq(MemStorage& storage, int headerSize = sizeof(CvSeq));$/;"	p	class:cv::Seq	access:public	signature:(MemStorage& storage, int headerSize = sizeof(CvSeq))
cv::Seq::Seq	core/core.hpp	/^    Seq(const CvSeq* seq);$/;"	p	class:cv::Seq	access:public	signature:(const CvSeq* seq)
cv::Seq::Seq	core/operations.hpp	/^template<typename _Tp> inline Seq<_Tp>::Seq( MemStorage& storage,$/;"	f	class:cv::Seq	signature:( MemStorage& storage, int headerSize )
cv::Seq::Seq	core/operations.hpp	/^template<typename _Tp> inline Seq<_Tp>::Seq( const CvSeq* _seq ) : seq((CvSeq*)_seq)$/;"	f	class:cv::Seq	signature:( const CvSeq* _seq )
cv::Seq::Seq	core/operations.hpp	/^template<typename _Tp> inline Seq<_Tp>::Seq() : seq(0) {}$/;"	f	class:cv::Seq	signature:()
cv::Seq::back	core/core.hpp	/^    _Tp& back();$/;"	p	class:cv::Seq	access:public	signature:()
cv::Seq::back	core/core.hpp	/^    const _Tp& back() const;$/;"	p	class:cv::Seq	access:public	signature:() const
cv::Seq::back	core/operations.hpp	/^template<typename _Tp> inline _Tp& Seq<_Tp>::back()$/;"	f	class:cv::Seq	signature:()
cv::Seq::back	core/operations.hpp	/^template<typename _Tp> inline const _Tp& Seq<_Tp>::back() const$/;"	f	class:cv::Seq	signature:() const
cv::Seq::begin	core/core.hpp	/^    SeqIterator<_Tp> begin() const;$/;"	p	class:cv::Seq	access:public	signature:() const
cv::Seq::begin	core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp> Seq<_Tp>::begin() const$/;"	f	class:cv::Seq	signature:() const
cv::Seq::channels	core/core.hpp	/^    int channels() const;$/;"	p	class:cv::Seq	access:public	signature:() const
cv::Seq::channels	core/operations.hpp	/^template<typename _Tp> inline int Seq<_Tp>::channels() const$/;"	f	class:cv::Seq	signature:() const
cv::Seq::clear	core/core.hpp	/^    void clear();$/;"	p	class:cv::Seq	access:public	signature:()
cv::Seq::clear	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::clear()$/;"	f	class:cv::Seq	signature:()
cv::Seq::const_iterator	core/core.hpp	/^    typedef SeqIterator<_Tp> const_iterator;$/;"	t	class:cv::Seq	access:public
cv::Seq::copyTo	core/core.hpp	/^    void copyTo(vector<_Tp>& vec, const Range& range=Range::all()) const;$/;"	p	class:cv::Seq	access:public	signature:(vector<_Tp>& vec, const Range& range=Range::all()) const
cv::Seq::copyTo	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::copyTo(vector<_Tp>& vec, const Range& range) const$/;"	f	class:cv::Seq	signature:(vector<_Tp>& vec, const Range& range) const
cv::Seq::depth	core/core.hpp	/^    int depth() const;$/;"	p	class:cv::Seq	access:public	signature:() const
cv::Seq::depth	core/operations.hpp	/^template<typename _Tp> inline int Seq<_Tp>::depth() const$/;"	f	class:cv::Seq	signature:() const
cv::Seq::elemSize	core/core.hpp	/^    size_t elemSize() const;$/;"	p	class:cv::Seq	access:public	signature:() const
cv::Seq::elemSize	core/operations.hpp	/^template<typename _Tp> inline size_t Seq<_Tp>::elemSize() const$/;"	f	class:cv::Seq	signature:() const
cv::Seq::empty	core/core.hpp	/^    bool empty() const;$/;"	p	class:cv::Seq	access:public	signature:() const
cv::Seq::empty	core/operations.hpp	/^template<typename _Tp> inline bool Seq<_Tp>::empty() const$/;"	f	class:cv::Seq	signature:() const
cv::Seq::end	core/core.hpp	/^    SeqIterator<_Tp> end() const;$/;"	p	class:cv::Seq	access:public	signature:() const
cv::Seq::end	core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp> Seq<_Tp>::end() const$/;"	f	class:cv::Seq	signature:() const
cv::Seq::front	core/core.hpp	/^    _Tp& front();$/;"	p	class:cv::Seq	access:public	signature:()
cv::Seq::front	core/core.hpp	/^    const _Tp& front() const;$/;"	p	class:cv::Seq	access:public	signature:() const
cv::Seq::front	core/operations.hpp	/^template<typename _Tp> inline _Tp& Seq<_Tp>::front()$/;"	f	class:cv::Seq	signature:()
cv::Seq::front	core/operations.hpp	/^template<typename _Tp> inline const _Tp& Seq<_Tp>::front() const$/;"	f	class:cv::Seq	signature:() const
cv::Seq::index	core/core.hpp	/^    size_t index(const _Tp& elem) const;$/;"	p	class:cv::Seq	access:public	signature:(const _Tp& elem) const
cv::Seq::index	core/operations.hpp	/^template<typename _Tp> inline size_t Seq<_Tp>::index(const _Tp& elem) const$/;"	f	class:cv::Seq	signature:(const _Tp& elem) const
cv::Seq::insert	core/core.hpp	/^    void insert(int idx, const _Tp& elem);$/;"	p	class:cv::Seq	access:public	signature:(int idx, const _Tp& elem)
cv::Seq::insert	core/core.hpp	/^    void insert(int idx, const _Tp* elems, size_t count);$/;"	p	class:cv::Seq	access:public	signature:(int idx, const _Tp* elems, size_t count)
cv::Seq::insert	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::insert(int idx, const _Tp& elem)$/;"	f	class:cv::Seq	signature:(int idx, const _Tp& elem)
cv::Seq::insert	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::insert(int idx, const _Tp* elems, size_t count)$/;"	f	class:cv::Seq	signature:(int idx, const _Tp* elems, size_t count)
cv::Seq::iterator	core/core.hpp	/^    typedef SeqIterator<_Tp> iterator;$/;"	t	class:cv::Seq	access:public
cv::Seq::operator []	core/core.hpp	/^    _Tp& operator [](int idx);$/;"	p	class:cv::Seq	access:public	signature:(int idx)
cv::Seq::operator []	core/core.hpp	/^    const _Tp& operator[](int idx) const;$/;"	p	class:cv::Seq	access:public	signature:(int idx) const
cv::Seq::operator []	core/operations.hpp	/^template<typename _Tp> inline _Tp& Seq<_Tp>::operator [](int idx)$/;"	f	class:cv::Seq	signature:(int idx)
cv::Seq::operator []	core/operations.hpp	/^template<typename _Tp> inline const _Tp& Seq<_Tp>::operator [](int idx) const$/;"	f	class:cv::Seq	signature:(int idx) const
cv::Seq::operator vector<_Tp>	core/core.hpp	/^    operator vector<_Tp>() const;$/;"	p	class:cv::Seq	access:public	signature:() const
cv::Seq::operator vector<_Tp>	core/operations.hpp	/^template<typename _Tp> inline Seq<_Tp>::operator vector<_Tp>() const$/;"	f	class:cv::Seq	signature:() const
cv::Seq::pop_back	core/core.hpp	/^    void pop_back();$/;"	p	class:cv::Seq	access:public	signature:()
cv::Seq::pop_back	core/core.hpp	/^    void pop_back(_Tp* elems, size_t count);$/;"	p	class:cv::Seq	access:public	signature:(_Tp* elems, size_t count)
cv::Seq::pop_back	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::pop_back()$/;"	f	class:cv::Seq	signature:()
cv::Seq::pop_back	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::pop_back(_Tp* elem, size_t count)$/;"	f	class:cv::Seq	signature:(_Tp* elem, size_t count)
cv::Seq::pop_front	core/core.hpp	/^    void pop_front();$/;"	p	class:cv::Seq	access:public	signature:()
cv::Seq::pop_front	core/core.hpp	/^    void pop_front(_Tp* elems, size_t count);$/;"	p	class:cv::Seq	access:public	signature:(_Tp* elems, size_t count)
cv::Seq::pop_front	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::pop_front()$/;"	f	class:cv::Seq	signature:()
cv::Seq::pop_front	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::pop_front(_Tp* elem, size_t count)$/;"	f	class:cv::Seq	signature:(_Tp* elem, size_t count)
cv::Seq::push_back	core/core.hpp	/^    void push_back(const _Tp& elem);$/;"	p	class:cv::Seq	access:public	signature:(const _Tp& elem)
cv::Seq::push_back	core/core.hpp	/^    void push_back(const _Tp* elems, size_t count);$/;"	p	class:cv::Seq	access:public	signature:(const _Tp* elems, size_t count)
cv::Seq::push_back	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::push_back(const _Tp& elem)$/;"	f	class:cv::Seq	signature:(const _Tp& elem)
cv::Seq::push_back	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::push_back(const _Tp* elem, size_t count)$/;"	f	class:cv::Seq	signature:(const _Tp* elem, size_t count)
cv::Seq::push_front	core/core.hpp	/^    void push_front(const _Tp& elem);$/;"	p	class:cv::Seq	access:public	signature:(const _Tp& elem)
cv::Seq::push_front	core/core.hpp	/^    void push_front(const _Tp* elems, size_t count);$/;"	p	class:cv::Seq	access:public	signature:(const _Tp* elems, size_t count)
cv::Seq::push_front	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::push_front(const _Tp& elem)$/;"	f	class:cv::Seq	signature:(const _Tp& elem)
cv::Seq::push_front	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::push_front(const _Tp* elem, size_t count)$/;"	f	class:cv::Seq	signature:(const _Tp* elem, size_t count)
cv::Seq::remove	core/core.hpp	/^    void remove(const Range& r);$/;"	p	class:cv::Seq	access:public	signature:(const Range& r)
cv::Seq::remove	core/core.hpp	/^    void remove(int idx);$/;"	p	class:cv::Seq	access:public	signature:(int idx)
cv::Seq::remove	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::remove(const Range& r)$/;"	f	class:cv::Seq	signature:(const Range& r)
cv::Seq::remove	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::remove(int idx)$/;"	f	class:cv::Seq	signature:(int idx)
cv::Seq::seq	core/core.hpp	/^    CvSeq* seq;$/;"	m	class:cv::Seq	access:public
cv::Seq::size	core/core.hpp	/^    size_t size() const;$/;"	p	class:cv::Seq	access:public	signature:() const
cv::Seq::size	core/operations.hpp	/^template<typename _Tp> inline size_t Seq<_Tp>::size() const$/;"	f	class:cv::Seq	signature:() const
cv::Seq::type	core/core.hpp	/^    int type() const;$/;"	p	class:cv::Seq	access:public	signature:() const
cv::Seq::type	core/operations.hpp	/^template<typename _Tp> inline int Seq<_Tp>::type() const$/;"	f	class:cv::Seq	signature:() const
cv::SeqIterator	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS SeqIterator : public CvSeqReader$/;"	c	namespace:cv	inherits:CvSeqReader
cv::SeqIterator::SeqIterator	core/core.hpp	/^    SeqIterator();$/;"	p	class:cv::SeqIterator	access:public	signature:()
cv::SeqIterator::SeqIterator	core/core.hpp	/^    SeqIterator(const Seq<_Tp>& seq, bool seekEnd=false);$/;"	p	class:cv::SeqIterator	access:public	signature:(const Seq<_Tp>& seq, bool seekEnd=false)
cv::SeqIterator::SeqIterator	core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>::SeqIterator()$/;"	f	class:cv::SeqIterator	signature:()
cv::SeqIterator::SeqIterator	core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>::SeqIterator(const Seq<_Tp>& seq, bool seekEnd)$/;"	f	class:cv::SeqIterator	signature:(const Seq<_Tp>& seq, bool seekEnd)
cv::SeqIterator::index	core/core.hpp	/^    int index;$/;"	m	class:cv::SeqIterator	access:public
cv::SeqIterator::operator *	core/core.hpp	/^    _Tp& operator *();$/;"	p	class:cv::SeqIterator	access:public	signature:()
cv::SeqIterator::operator *	core/core.hpp	/^    const _Tp& operator *() const;$/;"	p	class:cv::SeqIterator	access:public	signature:() const
cv::SeqIterator::operator *	core/operations.hpp	/^template<typename _Tp> inline _Tp& SeqIterator<_Tp>::operator *()$/;"	f	class:cv::SeqIterator	signature:()
cv::SeqIterator::operator *	core/operations.hpp	/^template<typename _Tp> inline const _Tp& SeqIterator<_Tp>::operator *() const$/;"	f	class:cv::SeqIterator	signature:() const
cv::SeqIterator::operator ++	core/core.hpp	/^    SeqIterator operator ++(int) const;$/;"	p	class:cv::SeqIterator	access:public	signature:(int) const
cv::SeqIterator::operator ++	core/core.hpp	/^    SeqIterator& operator ++();$/;"	p	class:cv::SeqIterator	access:public	signature:()
cv::SeqIterator::operator ++	core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp> SeqIterator<_Tp>::operator ++(int) const$/;"	f	class:cv::SeqIterator	signature:(int) const
cv::SeqIterator::operator ++	core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator ++()$/;"	f	class:cv::SeqIterator	signature:()
cv::SeqIterator::operator +=	core/core.hpp	/^    SeqIterator& operator +=(int);$/;"	p	class:cv::SeqIterator	access:public	signature:(int)
cv::SeqIterator::operator +=	core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator +=(int delta)$/;"	f	class:cv::SeqIterator	signature:(int delta)
cv::SeqIterator::operator --	core/core.hpp	/^    SeqIterator operator --(int) const;$/;"	p	class:cv::SeqIterator	access:public	signature:(int) const
cv::SeqIterator::operator --	core/core.hpp	/^    SeqIterator& operator --();$/;"	p	class:cv::SeqIterator	access:public	signature:()
cv::SeqIterator::operator --	core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp> SeqIterator<_Tp>::operator --(int) const$/;"	f	class:cv::SeqIterator	signature:(int) const
cv::SeqIterator::operator --	core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator --()$/;"	f	class:cv::SeqIterator	signature:()
cv::SeqIterator::operator -=	core/core.hpp	/^    SeqIterator& operator -=(int);$/;"	p	class:cv::SeqIterator	access:public	signature:(int)
cv::SeqIterator::operator -=	core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator -=(int delta)$/;"	f	class:cv::SeqIterator	signature:(int delta)
cv::SeqIterator::seek	core/core.hpp	/^    void seek(size_t pos);$/;"	p	class:cv::SeqIterator	access:public	signature:(size_t pos)
cv::SeqIterator::seek	core/operations.hpp	/^template<typename _Tp> inline void SeqIterator<_Tp>::seek(size_t pos)$/;"	f	class:cv::SeqIterator	signature:(size_t pos)
cv::SeqIterator::tell	core/core.hpp	/^    size_t tell() const;$/;"	p	class:cv::SeqIterator	access:public	signature:() const
cv::SeqIterator::tell	core/operations.hpp	/^template<typename _Tp> inline size_t SeqIterator<_Tp>::tell() const$/;"	f	class:cv::SeqIterator	signature:() const
cv::SiftDescriptorExtractor	features2d/features2d.hpp	/^class CV_EXPORTS SiftDescriptorExtractor : public DescriptorExtractor$/;"	c	namespace:cv	inherits:DescriptorExtractor
cv::SiftDescriptorExtractor::SiftDescriptorExtractor	features2d/features2d.hpp	/^    SiftDescriptorExtractor( const SIFT::DescriptorParams& descriptorParams=SIFT::DescriptorParams(),$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:( const SIFT::DescriptorParams& descriptorParams=SIFT::DescriptorParams(), const SIFT::CommonParams& commonParams=SIFT::CommonParams() )
cv::SiftDescriptorExtractor::SiftDescriptorExtractor	features2d/features2d.hpp	/^    SiftDescriptorExtractor( double magnification, bool isNormalize=true, bool recalculateAngles=true,$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:( double magnification, bool isNormalize=true, bool recalculateAngles=true, int nOctaves=SIFT::CommonParams::DEFAULT_NOCTAVES, int nOctaveLayers=SIFT::CommonParams::DEFAULT_NOCTAVE_LAYERS, int firstOctave=SIFT::CommonParams::DEFAULT_FIRST_OCTAVE, int angleMode=SIFT::CommonParams::FIRST_ANGLE )
cv::SiftDescriptorExtractor::computeImpl	features2d/features2d.hpp	/^	virtual void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;$/;"	p	class:cv::SiftDescriptorExtractor	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
cv::SiftDescriptorExtractor::descriptorSize	features2d/features2d.hpp	/^    virtual int descriptorSize() const;$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:() const
cv::SiftDescriptorExtractor::descriptorType	features2d/features2d.hpp	/^    virtual int descriptorType() const;$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:() const
cv::SiftDescriptorExtractor::read	features2d/features2d.hpp	/^    virtual void read( const FileNode &fn );$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:( const FileNode &fn )
cv::SiftDescriptorExtractor::sift	features2d/features2d.hpp	/^    SIFT sift;$/;"	m	class:cv::SiftDescriptorExtractor	access:protected
cv::SiftDescriptorExtractor::write	features2d/features2d.hpp	/^    virtual void write( FileStorage &fs ) const;$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:( FileStorage &fs ) const
cv::SiftFeatureDetector	features2d/features2d.hpp	/^class CV_EXPORTS SiftFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
cv::SiftFeatureDetector::SiftFeatureDetector	features2d/features2d.hpp	/^    SiftFeatureDetector( const SIFT::DetectorParams& detectorParams=SIFT::DetectorParams(),$/;"	p	class:cv::SiftFeatureDetector	access:public	signature:( const SIFT::DetectorParams& detectorParams=SIFT::DetectorParams(), const SIFT::CommonParams& commonParams=SIFT::CommonParams() )
cv::SiftFeatureDetector::SiftFeatureDetector	features2d/features2d.hpp	/^    SiftFeatureDetector( double threshold, double edgeThreshold,$/;"	p	class:cv::SiftFeatureDetector	access:public	signature:( double threshold, double edgeThreshold, int nOctaves=SIFT::CommonParams::DEFAULT_NOCTAVES, int nOctaveLayers=SIFT::CommonParams::DEFAULT_NOCTAVE_LAYERS, int firstOctave=SIFT::CommonParams::DEFAULT_FIRST_OCTAVE, int angleMode=SIFT::CommonParams::FIRST_ANGLE )
cv::SiftFeatureDetector::detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::SiftFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::SiftFeatureDetector::read	features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::SiftFeatureDetector	access:public	signature:( const FileNode& fn )
cv::SiftFeatureDetector::sift	features2d/features2d.hpp	/^    SIFT sift;$/;"	m	class:cv::SiftFeatureDetector	access:protected
cv::SiftFeatureDetector::write	features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::SiftFeatureDetector	access:public	signature:( FileStorage& fs ) const
cv::SimpleBlobDetector	features2d/features2d.hpp	/^class CV_EXPORTS SimpleBlobDetector : public cv::FeatureDetector$/;"	c	namespace:cv	inherits:cv::FeatureDetector
cv::SimpleBlobDetector::Center	features2d/features2d.hpp	/^  struct CV_EXPORTS Center$/;"	s	class:cv::SimpleBlobDetector	access:protected
cv::SimpleBlobDetector::Center::confidence	features2d/features2d.hpp	/^      double confidence;$/;"	m	struct:cv::SimpleBlobDetector::Center	access:public
cv::SimpleBlobDetector::Center::location	features2d/features2d.hpp	/^      Point2d location;$/;"	m	struct:cv::SimpleBlobDetector::Center	access:public
cv::SimpleBlobDetector::Center::radius	features2d/features2d.hpp	/^      double radius;$/;"	m	struct:cv::SimpleBlobDetector::Center	access:public
cv::SimpleBlobDetector::Params	features2d/features2d.hpp	/^  struct CV_EXPORTS Params$/;"	s	class:cv::SimpleBlobDetector	access:public
cv::SimpleBlobDetector::Params::Params	features2d/features2d.hpp	/^      Params();$/;"	p	struct:cv::SimpleBlobDetector::Params	access:public	signature:()
cv::SimpleBlobDetector::Params::blobColor	features2d/features2d.hpp	/^      uchar blobColor;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
cv::SimpleBlobDetector::Params::filterByArea	features2d/features2d.hpp	/^      bool filterByArea;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
cv::SimpleBlobDetector::Params::filterByCircularity	features2d/features2d.hpp	/^      bool filterByCircularity;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
cv::SimpleBlobDetector::Params::filterByColor	features2d/features2d.hpp	/^      bool filterByColor;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
cv::SimpleBlobDetector::Params::filterByConvexity	features2d/features2d.hpp	/^      bool filterByConvexity;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
cv::SimpleBlobDetector::Params::filterByInertia	features2d/features2d.hpp	/^      bool filterByInertia;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
cv::SimpleBlobDetector::Params::maxArea	features2d/features2d.hpp	/^      float minArea, maxArea;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
cv::SimpleBlobDetector::Params::maxCircularity	features2d/features2d.hpp	/^      float minCircularity, maxCircularity;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
cv::SimpleBlobDetector::Params::maxConvexity	features2d/features2d.hpp	/^      float minConvexity, maxConvexity;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
cv::SimpleBlobDetector::Params::maxInertiaRatio	features2d/features2d.hpp	/^      float minInertiaRatio, maxInertiaRatio;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
cv::SimpleBlobDetector::Params::maxThreshold	features2d/features2d.hpp	/^      float maxThreshold;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
cv::SimpleBlobDetector::Params::minArea	features2d/features2d.hpp	/^      float minArea, maxArea;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
cv::SimpleBlobDetector::Params::minCircularity	features2d/features2d.hpp	/^      float minCircularity, maxCircularity;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
cv::SimpleBlobDetector::Params::minConvexity	features2d/features2d.hpp	/^      float minConvexity, maxConvexity;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
cv::SimpleBlobDetector::Params::minDistBetweenBlobs	features2d/features2d.hpp	/^      float minDistBetweenBlobs;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
cv::SimpleBlobDetector::Params::minInertiaRatio	features2d/features2d.hpp	/^      float minInertiaRatio, maxInertiaRatio;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
cv::SimpleBlobDetector::Params::minRepeatability	features2d/features2d.hpp	/^      size_t minRepeatability;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
cv::SimpleBlobDetector::Params::minThreshold	features2d/features2d.hpp	/^      float minThreshold;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
cv::SimpleBlobDetector::Params::read	features2d/features2d.hpp	/^      void read( const FileNode& fn );$/;"	p	struct:cv::SimpleBlobDetector::Params	access:public	signature:( const FileNode& fn )
cv::SimpleBlobDetector::Params::thresholdStep	features2d/features2d.hpp	/^      float thresholdStep;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
cv::SimpleBlobDetector::Params::write	features2d/features2d.hpp	/^      void write( FileStorage& fs ) const;$/;"	p	struct:cv::SimpleBlobDetector::Params	access:public	signature:( FileStorage& fs ) const
cv::SimpleBlobDetector::SimpleBlobDetector	features2d/features2d.hpp	/^  SimpleBlobDetector(const SimpleBlobDetector::Params &parameters = SimpleBlobDetector::Params());$/;"	p	class:cv::SimpleBlobDetector	access:public	signature:(const SimpleBlobDetector::Params &parameters = SimpleBlobDetector::Params())
cv::SimpleBlobDetector::detectImpl	features2d/features2d.hpp	/^  virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::SimpleBlobDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::SimpleBlobDetector::findBlobs	features2d/features2d.hpp	/^  virtual void findBlobs(const cv::Mat &image, const cv::Mat &binaryImage, std::vector<Center> &centers) const;$/;"	p	class:cv::SimpleBlobDetector	access:protected	signature:(const cv::Mat &image, const cv::Mat &binaryImage, std::vector<Center> &centers) const
cv::SimpleBlobDetector::params	features2d/features2d.hpp	/^  Params params;$/;"	m	class:cv::SimpleBlobDetector	access:protected
cv::SimpleBlobDetector::read	features2d/features2d.hpp	/^  virtual void read( const FileNode& fn );$/;"	p	class:cv::SimpleBlobDetector	access:public	signature:( const FileNode& fn )
cv::SimpleBlobDetector::write	features2d/features2d.hpp	/^  virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::SimpleBlobDetector	access:public	signature:( FileStorage& fs ) const
cv::Size	core/core.hpp	/^typedef Size2i Size;$/;"	t	namespace:cv
cv::Size2f	core/core.hpp	/^typedef Size_<float> Size2f;$/;"	t	namespace:cv
cv::Size2i	core/core.hpp	/^typedef Size_<int> Size2i;$/;"	t	namespace:cv
cv::Size_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Size_$/;"	c	namespace:cv
cv::Size_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS Size_;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::Size_::Size_	core/core.hpp	/^    Size_();$/;"	p	class:cv::Size_	access:public	signature:()
cv::Size_::Size_	core/core.hpp	/^    Size_(_Tp _width, _Tp _height);$/;"	p	class:cv::Size_	access:public	signature:(_Tp _width, _Tp _height)
cv::Size_::Size_	core/core.hpp	/^    Size_(const CvSize& sz);$/;"	p	class:cv::Size_	access:public	signature:(const CvSize& sz)
cv::Size_::Size_	core/core.hpp	/^    Size_(const CvSize2D32f& sz);$/;"	p	class:cv::Size_	access:public	signature:(const CvSize2D32f& sz)
cv::Size_::Size_	core/core.hpp	/^    Size_(const Point_<_Tp>& pt);$/;"	p	class:cv::Size_	access:public	signature:(const Point_<_Tp>& pt)
cv::Size_::Size_	core/core.hpp	/^    Size_(const Size_& sz);$/;"	p	class:cv::Size_	access:public	signature:(const Size_& sz)
cv::Size_::Size_	core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_()$/;"	f	class:cv::Size_	signature:()
cv::Size_::Size_	core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_(_Tp _width, _Tp _height)$/;"	f	class:cv::Size_	signature:(_Tp _width, _Tp _height)
cv::Size_::Size_	core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_(const CvSize& sz)$/;"	f	class:cv::Size_	signature:(const CvSize& sz)
cv::Size_::Size_	core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_(const CvSize2D32f& sz)$/;"	f	class:cv::Size_	signature:(const CvSize2D32f& sz)
cv::Size_::Size_	core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_(const Point_<_Tp>& pt) : width(pt.x), height(pt.y) {}$/;"	f	class:cv::Size_	signature:(const Point_<_Tp>& pt)
cv::Size_::Size_	core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::Size_(const Size_& sz)$/;"	f	class:cv::Size_	signature:(const Size_& sz)
cv::Size_::area	core/core.hpp	/^    _Tp area() const;$/;"	p	class:cv::Size_	access:public	signature:() const
cv::Size_::area	core/operations.hpp	/^template<typename _Tp> inline _Tp Size_<_Tp>::area() const { return width*height; }$/;"	f	class:cv::Size_	signature:() const
cv::Size_::height	core/core.hpp	/^    _Tp width, height; \/\/ the width and the height$/;"	m	class:cv::Size_	access:public
cv::Size_::operator =	core/core.hpp	/^    Size_& operator = (const Size_& sz);$/;"	p	class:cv::Size_	access:public	signature:(const Size_& sz)
cv::Size_::operator =	core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>& Size_<_Tp>::operator = (const Size_<_Tp>& sz)$/;"	f	class:cv::Size_	signature:(const Size_<_Tp>& sz)
cv::Size_::operator CvSize	core/core.hpp	/^    operator CvSize() const;$/;"	p	class:cv::Size_	access:public	signature:() const
cv::Size_::operator CvSize	core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::operator CvSize() const$/;"	f	class:cv::Size_	signature:() const
cv::Size_::operator CvSize2D32f	core/core.hpp	/^    operator CvSize2D32f() const;$/;"	p	class:cv::Size_	access:public	signature:() const
cv::Size_::operator CvSize2D32f	core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::operator CvSize2D32f() const$/;"	f	class:cv::Size_	signature:() const
cv::Size_::operator Size_<_Tp2>	core/core.hpp	/^    template<typename _Tp2> operator Size_<_Tp2>() const;$/;"	p	class:cv::Size_	access:public	signature:() const
cv::Size_::operator Size_<_Tp2>	core/operations.hpp	/^template<typename _Tp> template<typename _Tp2> inline Size_<_Tp>::operator Size_<_Tp2>() const$/;"	f	class:cv::Size_	signature:() const
cv::Size_::value_type	core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Size_	access:public
cv::Size_::width	core/core.hpp	/^    _Tp width, height; \/\/ the width and the height$/;"	m	class:cv::Size_	access:public
cv::Sobel	imgproc/imgproc.hpp	/^CV_EXPORTS_W void Sobel( InputArray src, OutputArray dst, int ddepth,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize=3, double scale=1, double delta=0, int borderType=BORDER_DEFAULT )
cv::SparseMat	core/core.hpp	/^class CV_EXPORTS SparseMat$/;"	c	namespace:cv
cv::SparseMat::HASH_BIT	core/core.hpp	/^    enum { MAGIC_VAL=0x42FD0000, MAX_DIM=CV_MAX_DIM, HASH_SCALE=0x5bd1e995, HASH_BIT=0x80000000 };$/;"	e	enum:cv::SparseMat::__anon146
cv::SparseMat::HASH_SCALE	core/core.hpp	/^    enum { MAGIC_VAL=0x42FD0000, MAX_DIM=CV_MAX_DIM, HASH_SCALE=0x5bd1e995, HASH_BIT=0x80000000 };$/;"	e	enum:cv::SparseMat::__anon146
cv::SparseMat::Hdr	core/core.hpp	/^    struct CV_EXPORTS Hdr$/;"	s	class:cv::SparseMat	access:public
cv::SparseMat::Hdr::Hdr	core/core.hpp	/^        Hdr(int _dims, const int* _sizes, int _type);$/;"	p	struct:cv::SparseMat::Hdr	access:public	signature:(int _dims, const int* _sizes, int _type)
cv::SparseMat::Hdr::clear	core/core.hpp	/^        void clear();$/;"	p	struct:cv::SparseMat::Hdr	access:public	signature:()
cv::SparseMat::Hdr::dims	core/core.hpp	/^        int dims;$/;"	m	struct:cv::SparseMat::Hdr	access:public
cv::SparseMat::Hdr::freeList	core/core.hpp	/^        size_t freeList;$/;"	m	struct:cv::SparseMat::Hdr	access:public
cv::SparseMat::Hdr::hashtab	core/core.hpp	/^        vector<size_t> hashtab;$/;"	m	struct:cv::SparseMat::Hdr	access:public
cv::SparseMat::Hdr::nodeCount	core/core.hpp	/^        size_t nodeCount;$/;"	m	struct:cv::SparseMat::Hdr	access:public
cv::SparseMat::Hdr::nodeSize	core/core.hpp	/^        size_t nodeSize;$/;"	m	struct:cv::SparseMat::Hdr	access:public
cv::SparseMat::Hdr::pool	core/core.hpp	/^        vector<uchar> pool;$/;"	m	struct:cv::SparseMat::Hdr	access:public
cv::SparseMat::Hdr::refcount	core/core.hpp	/^        int refcount;$/;"	m	struct:cv::SparseMat::Hdr	access:public
cv::SparseMat::Hdr::size	core/core.hpp	/^        int size[CV_MAX_DIM];$/;"	m	struct:cv::SparseMat::Hdr	access:public
cv::SparseMat::Hdr::valueOffset	core/core.hpp	/^        int valueOffset;$/;"	m	struct:cv::SparseMat::Hdr	access:public
cv::SparseMat::MAGIC_VAL	core/core.hpp	/^    enum { MAGIC_VAL=0x42FD0000, MAX_DIM=CV_MAX_DIM, HASH_SCALE=0x5bd1e995, HASH_BIT=0x80000000 };$/;"	e	enum:cv::SparseMat::__anon146
cv::SparseMat::MAX_DIM	core/core.hpp	/^    enum { MAGIC_VAL=0x42FD0000, MAX_DIM=CV_MAX_DIM, HASH_SCALE=0x5bd1e995, HASH_BIT=0x80000000 };$/;"	e	enum:cv::SparseMat::__anon146
cv::SparseMat::Node	core/core.hpp	/^    struct CV_EXPORTS Node$/;"	s	class:cv::SparseMat	access:public
cv::SparseMat::Node::hashval	core/core.hpp	/^        size_t hashval;$/;"	m	struct:cv::SparseMat::Node	access:public
cv::SparseMat::Node::idx	core/core.hpp	/^        int idx[CV_MAX_DIM];$/;"	m	struct:cv::SparseMat::Node	access:public
cv::SparseMat::Node::next	core/core.hpp	/^        size_t next;$/;"	m	struct:cv::SparseMat::Node	access:public
cv::SparseMat::SparseMat	core/core.hpp	/^    SparseMat();$/;"	p	class:cv::SparseMat	access:public	signature:()
cv::SparseMat::SparseMat	core/core.hpp	/^    SparseMat(const CvSparseMat* m);$/;"	p	class:cv::SparseMat	access:public	signature:(const CvSparseMat* m)
cv::SparseMat::SparseMat	core/core.hpp	/^    SparseMat(const SparseMat& m);$/;"	p	class:cv::SparseMat	access:public	signature:(const SparseMat& m)
cv::SparseMat::SparseMat	core/core.hpp	/^    SparseMat(int dims, const int* _sizes, int _type);$/;"	p	class:cv::SparseMat	access:public	signature:(int dims, const int* _sizes, int _type)
cv::SparseMat::SparseMat	core/core.hpp	/^    explicit SparseMat(const Mat& m);$/;"	p	class:cv::SparseMat	access:public	signature:(const Mat& m)
cv::SparseMat::SparseMat	core/mat.hpp	/^inline SparseMat::SparseMat()$/;"	f	class:cv::SparseMat	signature:()
cv::SparseMat::SparseMat	core/mat.hpp	/^inline SparseMat::SparseMat(const SparseMat& m)$/;"	f	class:cv::SparseMat	signature:(const SparseMat& m)
cv::SparseMat::SparseMat	core/mat.hpp	/^inline SparseMat::SparseMat(int _dims, const int* _sizes, int _type)$/;"	f	class:cv::SparseMat	signature:(int _dims, const int* _sizes, int _type)
cv::SparseMat::addref	core/core.hpp	/^    void addref();$/;"	p	class:cv::SparseMat	access:public	signature:()
cv::SparseMat::addref	core/mat.hpp	/^inline void SparseMat::addref()$/;"	f	class:cv::SparseMat	signature:()
cv::SparseMat::assignTo	core/core.hpp	/^    void assignTo( SparseMat& m, int type=-1 ) const;$/;"	p	class:cv::SparseMat	access:public	signature:( SparseMat& m, int type=-1 ) const
cv::SparseMat::assignTo	core/mat.hpp	/^inline void SparseMat::assignTo( SparseMat& m, int type ) const$/;"	f	class:cv::SparseMat	signature:( SparseMat& m, int type ) const
cv::SparseMat::begin	core/core.hpp	/^    SparseMatConstIterator begin() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::begin	core/core.hpp	/^    SparseMatIterator begin();$/;"	p	class:cv::SparseMat	access:public	signature:()
cv::SparseMat::begin	core/core.hpp	/^    template<typename _Tp> SparseMatConstIterator_<_Tp> begin() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::begin	core/core.hpp	/^    template<typename _Tp> SparseMatIterator_<_Tp> begin();$/;"	p	class:cv::SparseMat	access:public	signature:()
cv::SparseMat::begin	core/mat.hpp	/^inline SparseMatConstIterator SparseMat::begin() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::begin	core/mat.hpp	/^inline SparseMatIterator SparseMat::begin()$/;"	f	class:cv::SparseMat	signature:()
cv::SparseMat::begin	core/mat.hpp	/^template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat::begin() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::begin	core/mat.hpp	/^template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat::begin()$/;"	f	class:cv::SparseMat	signature:()
cv::SparseMat::channels	core/core.hpp	/^    int channels() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::channels	core/mat.hpp	/^inline int SparseMat::channels() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::clear	core/core.hpp	/^    void clear();$/;"	p	class:cv::SparseMat	access:public	signature:()
cv::SparseMat::clone	core/core.hpp	/^    SparseMat clone() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::clone	core/mat.hpp	/^inline SparseMat SparseMat::clone() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::const_iterator	core/core.hpp	/^    typedef SparseMatConstIterator const_iterator;$/;"	t	class:cv::SparseMat	access:public
cv::SparseMat::convertTo	core/core.hpp	/^    void convertTo( Mat& m, int rtype, double alpha=1, double beta=0 ) const;$/;"	p	class:cv::SparseMat	access:public	signature:( Mat& m, int rtype, double alpha=1, double beta=0 ) const
cv::SparseMat::convertTo	core/core.hpp	/^    void convertTo( SparseMat& m, int rtype, double alpha=1 ) const;$/;"	p	class:cv::SparseMat	access:public	signature:( SparseMat& m, int rtype, double alpha=1 ) const
cv::SparseMat::copyTo	core/core.hpp	/^    void copyTo( Mat& m ) const;$/;"	p	class:cv::SparseMat	access:public	signature:( Mat& m ) const
cv::SparseMat::copyTo	core/core.hpp	/^    void copyTo( SparseMat& m ) const;$/;"	p	class:cv::SparseMat	access:public	signature:( SparseMat& m ) const
cv::SparseMat::create	core/core.hpp	/^    void create(int dims, const int* _sizes, int _type);$/;"	p	class:cv::SparseMat	access:public	signature:(int dims, const int* _sizes, int _type)
cv::SparseMat::depth	core/core.hpp	/^    int depth() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::depth	core/mat.hpp	/^inline int SparseMat::depth() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::dims	core/core.hpp	/^    int dims() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::dims	core/mat.hpp	/^inline int SparseMat::dims() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::elemSize	core/core.hpp	/^    size_t elemSize() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::elemSize	core/mat.hpp	/^inline size_t SparseMat::elemSize() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::elemSize1	core/core.hpp	/^    size_t elemSize1() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::elemSize1	core/mat.hpp	/^inline size_t SparseMat::elemSize1() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::end	core/core.hpp	/^    SparseMatConstIterator end() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::end	core/core.hpp	/^    SparseMatIterator end();$/;"	p	class:cv::SparseMat	access:public	signature:()
cv::SparseMat::end	core/core.hpp	/^    template<typename _Tp> SparseMatConstIterator_<_Tp> end() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::end	core/core.hpp	/^    template<typename _Tp> SparseMatIterator_<_Tp> end();$/;"	p	class:cv::SparseMat	access:public	signature:()
cv::SparseMat::end	core/mat.hpp	/^inline SparseMatConstIterator SparseMat::end() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::end	core/mat.hpp	/^inline SparseMatIterator SparseMat::end()$/;"	f	class:cv::SparseMat	signature:()
cv::SparseMat::end	core/mat.hpp	/^template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat::end() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::end	core/mat.hpp	/^template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat::end()$/;"	f	class:cv::SparseMat	signature:()
cv::SparseMat::erase	core/core.hpp	/^    void erase(const int* idx, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, size_t* hashval=0)
cv::SparseMat::erase	core/core.hpp	/^    void erase(int i0, int i1, int i2, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0)
cv::SparseMat::erase	core/core.hpp	/^    void erase(int i0, int i1, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, size_t* hashval=0)
cv::SparseMat::find	core/core.hpp	/^    template<typename _Tp> const _Tp* find(const int* idx, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, size_t* hashval=0) const
cv::SparseMat::find	core/core.hpp	/^    template<typename _Tp> const _Tp* find(int i0, int i1, int i2, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0) const
cv::SparseMat::find	core/core.hpp	/^    template<typename _Tp> const _Tp* find(int i0, int i1, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, size_t* hashval=0) const
cv::SparseMat::find	core/core.hpp	/^    template<typename _Tp> const _Tp* find(int i0, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, size_t* hashval=0) const
cv::SparseMat::find	core/mat.hpp	/^template<typename _Tp> inline const _Tp* SparseMat::find(const int* idx, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(const int* idx, size_t* hashval) const
cv::SparseMat::find	core/mat.hpp	/^template<typename _Tp> inline const _Tp* SparseMat::find(int i0, int i1, int i2, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, int i2, size_t* hashval) const
cv::SparseMat::find	core/mat.hpp	/^template<typename _Tp> inline const _Tp* SparseMat::find(int i0, int i1, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, size_t* hashval) const
cv::SparseMat::find	core/mat.hpp	/^template<typename _Tp> inline const _Tp* SparseMat::find(int i0, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, size_t* hashval) const
cv::SparseMat::flags	core/core.hpp	/^    int flags;$/;"	m	class:cv::SparseMat	access:public
cv::SparseMat::hash	core/core.hpp	/^    size_t hash(const int* idx) const;$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx) const
cv::SparseMat::hash	core/core.hpp	/^    size_t hash(int i0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0) const
cv::SparseMat::hash	core/core.hpp	/^    size_t hash(int i0, int i1) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1) const
cv::SparseMat::hash	core/core.hpp	/^    size_t hash(int i0, int i1, int i2) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2) const
cv::SparseMat::hash	core/mat.hpp	/^inline size_t SparseMat::hash(const int* idx) const$/;"	f	class:cv::SparseMat	signature:(const int* idx) const
cv::SparseMat::hash	core/mat.hpp	/^inline size_t SparseMat::hash(int i0) const$/;"	f	class:cv::SparseMat	signature:(int i0) const
cv::SparseMat::hash	core/mat.hpp	/^inline size_t SparseMat::hash(int i0, int i1) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1) const
cv::SparseMat::hash	core/mat.hpp	/^inline size_t SparseMat::hash(int i0, int i1, int i2) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, int i2) const
cv::SparseMat::hdr	core/core.hpp	/^    Hdr* hdr;$/;"	m	class:cv::SparseMat	access:public
cv::SparseMat::iterator	core/core.hpp	/^    typedef SparseMatIterator iterator;$/;"	t	class:cv::SparseMat	access:public
cv::SparseMat::newNode	core/core.hpp	/^    uchar* newNode(const int* idx, size_t hashval);$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, size_t hashval)
cv::SparseMat::node	core/core.hpp	/^    Node* node(size_t nidx);$/;"	p	class:cv::SparseMat	access:public	signature:(size_t nidx)
cv::SparseMat::node	core/core.hpp	/^    const Node* node(size_t nidx) const;$/;"	p	class:cv::SparseMat	access:public	signature:(size_t nidx) const
cv::SparseMat::node	core/mat.hpp	/^inline SparseMat::Node* SparseMat::node(size_t nidx)$/;"	f	class:cv::SparseMat	signature:(size_t nidx)
cv::SparseMat::node	core/mat.hpp	/^inline const SparseMat::Node* SparseMat::node(size_t nidx) const$/;"	f	class:cv::SparseMat	signature:(size_t nidx) const
cv::SparseMat::nzcount	core/core.hpp	/^    size_t nzcount() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::nzcount	core/mat.hpp	/^inline size_t SparseMat::nzcount() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::operator =	core/core.hpp	/^    SparseMat& operator = (const Mat& m);$/;"	p	class:cv::SparseMat	access:public	signature:(const Mat& m)
cv::SparseMat::operator =	core/core.hpp	/^    SparseMat& operator = (const SparseMat& m);$/;"	p	class:cv::SparseMat	access:public	signature:(const SparseMat& m)
cv::SparseMat::operator =	core/mat.hpp	/^inline SparseMat& SparseMat::operator = (const Mat& m)$/;"	f	class:cv::SparseMat	signature:(const Mat& m)
cv::SparseMat::operator =	core/mat.hpp	/^inline SparseMat& SparseMat::operator = (const SparseMat& m)$/;"	f	class:cv::SparseMat	signature:(const SparseMat& m)
cv::SparseMat::operator CvSparseMat*	core/core.hpp	/^    operator CvSparseMat*() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::ptr	core/core.hpp	/^    uchar* ptr(const int* idx, bool createMissing, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, bool createMissing, size_t* hashval=0)
cv::SparseMat::ptr	core/core.hpp	/^    uchar* ptr(int i0, bool createMissing, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, bool createMissing, size_t* hashval=0)
cv::SparseMat::ptr	core/core.hpp	/^    uchar* ptr(int i0, int i1, bool createMissing, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, bool createMissing, size_t* hashval=0)
cv::SparseMat::ptr	core/core.hpp	/^    uchar* ptr(int i0, int i1, int i2, bool createMissing, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2, bool createMissing, size_t* hashval=0)
cv::SparseMat::ref	core/core.hpp	/^    template<typename _Tp> _Tp& ref(const int* idx, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, size_t* hashval=0)
cv::SparseMat::ref	core/core.hpp	/^    template<typename _Tp> _Tp& ref(int i0, int i1, int i2, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0)
cv::SparseMat::ref	core/core.hpp	/^    template<typename _Tp> _Tp& ref(int i0, int i1, size_t* hashval=0);   $/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, size_t* hashval=0)
cv::SparseMat::ref	core/core.hpp	/^    template<typename _Tp> _Tp& ref(int i0, size_t* hashval=0);   $/;"	p	class:cv::SparseMat	access:public	signature:(int i0, size_t* hashval=0)
cv::SparseMat::ref	core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMat::ref(const int* idx, size_t* hashval)$/;"	f	class:cv::SparseMat	signature:(const int* idx, size_t* hashval)
cv::SparseMat::ref	core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMat::ref(int i0, int i1, int i2, size_t* hashval)$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, int i2, size_t* hashval)
cv::SparseMat::ref	core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMat::ref(int i0, int i1, size_t* hashval)$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, size_t* hashval)
cv::SparseMat::ref	core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMat::ref(int i0, size_t* hashval)$/;"	f	class:cv::SparseMat	signature:(int i0, size_t* hashval)
cv::SparseMat::release	core/core.hpp	/^    void release();$/;"	p	class:cv::SparseMat	access:public	signature:()
cv::SparseMat::release	core/mat.hpp	/^inline void SparseMat::release()$/;"	f	class:cv::SparseMat	signature:()
cv::SparseMat::removeNode	core/core.hpp	/^    void removeNode(size_t hidx, size_t nidx, size_t previdx);$/;"	p	class:cv::SparseMat	access:public	signature:(size_t hidx, size_t nidx, size_t previdx)
cv::SparseMat::resizeHashTab	core/core.hpp	/^    void resizeHashTab(size_t newsize);$/;"	p	class:cv::SparseMat	access:public	signature:(size_t newsize)
cv::SparseMat::size	core/core.hpp	/^    const int* size() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::size	core/core.hpp	/^    int size(int i) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i) const
cv::SparseMat::size	core/mat.hpp	/^inline const int* SparseMat::size() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::size	core/mat.hpp	/^inline int SparseMat::size(int i) const$/;"	f	class:cv::SparseMat	signature:(int i) const
cv::SparseMat::type	core/core.hpp	/^    int type() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
cv::SparseMat::type	core/mat.hpp	/^inline int SparseMat::type() const$/;"	f	class:cv::SparseMat	signature:() const
cv::SparseMat::value	core/core.hpp	/^    template<typename _Tp> _Tp value(const int* idx, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, size_t* hashval=0) const
cv::SparseMat::value	core/core.hpp	/^    template<typename _Tp> _Tp value(int i0, int i1, int i2, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0) const
cv::SparseMat::value	core/core.hpp	/^    template<typename _Tp> _Tp value(int i0, int i1, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, size_t* hashval=0) const
cv::SparseMat::value	core/core.hpp	/^    template<typename _Tp> _Tp value(int i0, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, size_t* hashval=0) const
cv::SparseMat::value	core/core.hpp	/^    template<typename _Tp> _Tp& value(Node* n);$/;"	p	class:cv::SparseMat	access:public	signature:(Node* n)
cv::SparseMat::value	core/core.hpp	/^    template<typename _Tp> const _Tp& value(const Node* n) const;$/;"	p	class:cv::SparseMat	access:public	signature:(const Node* n) const
cv::SparseMat::value	core/mat.hpp	/^template<typename _Tp> inline _Tp SparseMat::value(const int* idx, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(const int* idx, size_t* hashval) const
cv::SparseMat::value	core/mat.hpp	/^template<typename _Tp> inline _Tp SparseMat::value(int i0, int i1, int i2, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, int i2, size_t* hashval) const
cv::SparseMat::value	core/mat.hpp	/^template<typename _Tp> inline _Tp SparseMat::value(int i0, int i1, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, size_t* hashval) const
cv::SparseMat::value	core/mat.hpp	/^template<typename _Tp> inline _Tp SparseMat::value(int i0, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, size_t* hashval) const
cv::SparseMat::value	core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMat::value(Node* n)$/;"	f	class:cv::SparseMat	signature:(Node* n)
cv::SparseMat::value	core/mat.hpp	/^template<typename _Tp> inline const _Tp& SparseMat::value(const Node* n) const$/;"	f	class:cv::SparseMat	signature:(const Node* n) const
cv::SparseMat::~SparseMat	core/core.hpp	/^    ~SparseMat();$/;"	p	class:cv::SparseMat	access:public	signature:()
cv::SparseMat::~SparseMat	core/mat.hpp	/^inline SparseMat::~SparseMat()$/;"	f	class:cv::SparseMat	signature:()
cv::SparseMatConstIterator	core/core.hpp	/^class CV_EXPORTS SparseMatConstIterator$/;"	c	namespace:cv
cv::SparseMatConstIterator::SparseMatConstIterator	core/core.hpp	/^    SparseMatConstIterator();$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:()
cv::SparseMatConstIterator::SparseMatConstIterator	core/core.hpp	/^    SparseMatConstIterator(const SparseMat* _m);$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:(const SparseMat* _m)
cv::SparseMatConstIterator::SparseMatConstIterator	core/core.hpp	/^    SparseMatConstIterator(const SparseMatConstIterator& it);$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:(const SparseMatConstIterator& it)
cv::SparseMatConstIterator::SparseMatConstIterator	core/mat.hpp	/^inline SparseMatConstIterator::SparseMatConstIterator()$/;"	f	class:cv::SparseMatConstIterator	signature:()
cv::SparseMatConstIterator::SparseMatConstIterator	core/mat.hpp	/^inline SparseMatConstIterator::SparseMatConstIterator(const SparseMatConstIterator& it)$/;"	f	class:cv::SparseMatConstIterator	signature:(const SparseMatConstIterator& it)
cv::SparseMatConstIterator::hashidx	core/core.hpp	/^    size_t hashidx;$/;"	m	class:cv::SparseMatConstIterator	access:public
cv::SparseMatConstIterator::m	core/core.hpp	/^    const SparseMat* m;$/;"	m	class:cv::SparseMatConstIterator	access:public
cv::SparseMatConstIterator::node	core/core.hpp	/^    const SparseMat::Node* node() const;$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:() const
cv::SparseMatConstIterator::node	core/mat.hpp	/^inline const SparseMat::Node* SparseMatConstIterator::node() const$/;"	f	class:cv::SparseMatConstIterator	signature:() const
cv::SparseMatConstIterator::operator ++	core/core.hpp	/^    SparseMatConstIterator operator ++(int);$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:(int)
cv::SparseMatConstIterator::operator ++	core/core.hpp	/^    SparseMatConstIterator& operator ++();$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:()
cv::SparseMatConstIterator::operator ++	core/mat.hpp	/^inline SparseMatConstIterator SparseMatConstIterator::operator ++(int)$/;"	f	class:cv::SparseMatConstIterator	signature:(int)
cv::SparseMatConstIterator::operator --	core/core.hpp	/^    SparseMatConstIterator operator --(int);$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:(int)
cv::SparseMatConstIterator::operator --	core/core.hpp	/^    SparseMatConstIterator& operator --();$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:()
cv::SparseMatConstIterator::operator =	core/core.hpp	/^    SparseMatConstIterator& operator = (const SparseMatConstIterator& it);$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:(const SparseMatConstIterator& it)
cv::SparseMatConstIterator::operator =	core/mat.hpp	/^inline SparseMatConstIterator& SparseMatConstIterator::operator = (const SparseMatConstIterator& it)$/;"	f	class:cv::SparseMatConstIterator	signature:(const SparseMatConstIterator& it)
cv::SparseMatConstIterator::ptr	core/core.hpp	/^    uchar* ptr;$/;"	m	class:cv::SparseMatConstIterator	access:public
cv::SparseMatConstIterator::seekEnd	core/core.hpp	/^    void seekEnd();$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:()
cv::SparseMatConstIterator::seekEnd	core/mat.hpp	/^inline void SparseMatConstIterator::seekEnd()$/;"	f	class:cv::SparseMatConstIterator	signature:()
cv::SparseMatConstIterator::value	core/core.hpp	/^    template<typename _Tp> const _Tp& value() const;$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:() const
cv::SparseMatConstIterator::value	core/mat.hpp	/^template<typename _Tp> inline const _Tp& SparseMatConstIterator::value() const$/;"	f	class:cv::SparseMatConstIterator	signature:() const
cv::SparseMatConstIterator_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS SparseMatConstIterator_ : public SparseMatConstIterator$/;"	c	namespace:cv	inherits:SparseMatConstIterator
cv::SparseMatConstIterator_::SparseMatConstIterator_	core/core.hpp	/^    SparseMatConstIterator_();$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:()
cv::SparseMatConstIterator_::SparseMatConstIterator_	core/core.hpp	/^    SparseMatConstIterator_(const SparseMatConstIterator_& it);$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:(const SparseMatConstIterator_& it)
cv::SparseMatConstIterator_::SparseMatConstIterator_	core/core.hpp	/^    SparseMatConstIterator_(const SparseMat_<_Tp>* _m);$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:(const SparseMat_<_Tp>* _m)
cv::SparseMatConstIterator_::SparseMatConstIterator_	core/mat.hpp	/^SparseMatConstIterator_<_Tp>::SparseMatConstIterator_()$/;"	f	class:cv::SparseMatConstIterator_	signature:()
cv::SparseMatConstIterator_::SparseMatConstIterator_	core/mat.hpp	/^SparseMatConstIterator_<_Tp>::SparseMatConstIterator_(const SparseMatConstIterator_<_Tp>& it)$/;"	f	class:cv::SparseMatConstIterator_	signature:(const SparseMatConstIterator_<_Tp>& it)
cv::SparseMatConstIterator_::SparseMatConstIterator_	core/mat.hpp	/^SparseMatConstIterator_<_Tp>::SparseMatConstIterator_(const SparseMat_<_Tp>* _m)$/;"	f	class:cv::SparseMatConstIterator_	signature:(const SparseMat_<_Tp>* _m)
cv::SparseMatConstIterator_::iterator_category	core/core.hpp	/^    typedef std::forward_iterator_tag iterator_category;$/;"	t	class:cv::SparseMatConstIterator_	access:public
cv::SparseMatConstIterator_::operator *	core/core.hpp	/^    const _Tp& operator *() const;$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:() const
cv::SparseMatConstIterator_::operator *	core/mat.hpp	/^SparseMatConstIterator_<_Tp>::operator *() const$/;"	f	class:cv::SparseMatConstIterator_	signature:() const
cv::SparseMatConstIterator_::operator ++	core/core.hpp	/^    SparseMatConstIterator_ operator ++(int);$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:(int)
cv::SparseMatConstIterator_::operator ++	core/core.hpp	/^    SparseMatConstIterator_& operator ++();$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:()
cv::SparseMatConstIterator_::operator ++	core/mat.hpp	/^SparseMatConstIterator_<_Tp>::operator ++()$/;"	f	class:cv::SparseMatConstIterator_	signature:()
cv::SparseMatConstIterator_::operator ++	core/mat.hpp	/^SparseMatConstIterator_<_Tp>::operator ++(int)$/;"	f	class:cv::SparseMatConstIterator_	signature:(int)
cv::SparseMatConstIterator_::operator =	core/core.hpp	/^    SparseMatConstIterator_& operator = (const SparseMatConstIterator_& it);$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:(const SparseMatConstIterator_& it)
cv::SparseMatConstIterator_::operator =	core/mat.hpp	/^SparseMatConstIterator_<_Tp>::operator = (const SparseMatConstIterator_<_Tp>& it)$/;"	f	class:cv::SparseMatConstIterator_	signature:(const SparseMatConstIterator_<_Tp>& it)
cv::SparseMatIterator	core/core.hpp	/^class CV_EXPORTS SparseMatIterator : public SparseMatConstIterator$/;"	c	namespace:cv	inherits:SparseMatConstIterator
cv::SparseMatIterator::SparseMatIterator	core/core.hpp	/^    SparseMatIterator();$/;"	p	class:cv::SparseMatIterator	access:public	signature:()
cv::SparseMatIterator::SparseMatIterator	core/core.hpp	/^    SparseMatIterator(SparseMat* _m);$/;"	p	class:cv::SparseMatIterator	access:public	signature:(SparseMat* _m)
cv::SparseMatIterator::SparseMatIterator	core/core.hpp	/^    SparseMatIterator(SparseMat* _m, const int* idx);$/;"	p	class:cv::SparseMatIterator	access:public	signature:(SparseMat* _m, const int* idx)
cv::SparseMatIterator::SparseMatIterator	core/core.hpp	/^    SparseMatIterator(const SparseMatIterator& it);$/;"	p	class:cv::SparseMatIterator	access:public	signature:(const SparseMatIterator& it)
cv::SparseMatIterator::SparseMatIterator	core/mat.hpp	/^inline SparseMatIterator::SparseMatIterator()$/;"	f	class:cv::SparseMatIterator	signature:()
cv::SparseMatIterator::SparseMatIterator	core/mat.hpp	/^inline SparseMatIterator::SparseMatIterator(SparseMat* _m)$/;"	f	class:cv::SparseMatIterator	signature:(SparseMat* _m)
cv::SparseMatIterator::SparseMatIterator	core/mat.hpp	/^inline SparseMatIterator::SparseMatIterator(const SparseMatIterator& it)$/;"	f	class:cv::SparseMatIterator	signature:(const SparseMatIterator& it)
cv::SparseMatIterator::node	core/core.hpp	/^    SparseMat::Node* node() const;$/;"	p	class:cv::SparseMatIterator	access:public	signature:() const
cv::SparseMatIterator::node	core/mat.hpp	/^inline SparseMat::Node* SparseMatIterator::node() const$/;"	f	class:cv::SparseMatIterator	signature:() const
cv::SparseMatIterator::operator ++	core/core.hpp	/^    SparseMatIterator operator ++(int);$/;"	p	class:cv::SparseMatIterator	access:public	signature:(int)
cv::SparseMatIterator::operator ++	core/core.hpp	/^    SparseMatIterator& operator ++();$/;"	p	class:cv::SparseMatIterator	access:public	signature:()
cv::SparseMatIterator::operator ++	core/mat.hpp	/^inline SparseMatIterator SparseMatIterator::operator ++(int)$/;"	f	class:cv::SparseMatIterator	signature:(int)
cv::SparseMatIterator::operator ++	core/mat.hpp	/^inline SparseMatIterator& SparseMatIterator::operator ++()$/;"	f	class:cv::SparseMatIterator	signature:()
cv::SparseMatIterator::operator =	core/core.hpp	/^    SparseMatIterator& operator = (const SparseMatIterator& it);$/;"	p	class:cv::SparseMatIterator	access:public	signature:(const SparseMatIterator& it)
cv::SparseMatIterator::operator =	core/mat.hpp	/^inline SparseMatIterator& SparseMatIterator::operator = (const SparseMatIterator& it)$/;"	f	class:cv::SparseMatIterator	signature:(const SparseMatIterator& it)
cv::SparseMatIterator::value	core/core.hpp	/^    template<typename _Tp> _Tp& value() const;$/;"	p	class:cv::SparseMatIterator	access:public	signature:() const
cv::SparseMatIterator::value	core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMatIterator::value() const$/;"	f	class:cv::SparseMatIterator	signature:() const
cv::SparseMatIterator_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS SparseMatIterator_ : public SparseMatConstIterator_<_Tp>$/;"	c	namespace:cv	inherits:SparseMatConstIterator_
cv::SparseMatIterator_::SparseMatIterator_	core/core.hpp	/^    SparseMatIterator_();$/;"	p	class:cv::SparseMatIterator_	access:public	signature:()
cv::SparseMatIterator_::SparseMatIterator_	core/core.hpp	/^    SparseMatIterator_(SparseMat_<_Tp>* _m);$/;"	p	class:cv::SparseMatIterator_	access:public	signature:(SparseMat_<_Tp>* _m)
cv::SparseMatIterator_::SparseMatIterator_	core/core.hpp	/^    SparseMatIterator_(const SparseMatIterator_& it);$/;"	p	class:cv::SparseMatIterator_	access:public	signature:(const SparseMatIterator_& it)
cv::SparseMatIterator_::SparseMatIterator_	core/mat.hpp	/^SparseMatIterator_<_Tp>::SparseMatIterator_()$/;"	f	class:cv::SparseMatIterator_	signature:()
cv::SparseMatIterator_::SparseMatIterator_	core/mat.hpp	/^SparseMatIterator_<_Tp>::SparseMatIterator_(SparseMat_<_Tp>* _m)$/;"	f	class:cv::SparseMatIterator_	signature:(SparseMat_<_Tp>* _m)
cv::SparseMatIterator_::SparseMatIterator_	core/mat.hpp	/^SparseMatIterator_<_Tp>::SparseMatIterator_(const SparseMatIterator_<_Tp>& it)$/;"	f	class:cv::SparseMatIterator_	signature:(const SparseMatIterator_<_Tp>& it)
cv::SparseMatIterator_::iterator_category	core/core.hpp	/^    typedef std::forward_iterator_tag iterator_category;$/;"	t	class:cv::SparseMatIterator_	access:public
cv::SparseMatIterator_::operator *	core/core.hpp	/^    _Tp& operator *() const;$/;"	p	class:cv::SparseMatIterator_	access:public	signature:() const
cv::SparseMatIterator_::operator *	core/mat.hpp	/^SparseMatIterator_<_Tp>::operator *() const$/;"	f	class:cv::SparseMatIterator_	signature:() const
cv::SparseMatIterator_::operator ++	core/core.hpp	/^    SparseMatIterator_ operator ++(int);$/;"	p	class:cv::SparseMatIterator_	access:public	signature:(int)
cv::SparseMatIterator_::operator ++	core/core.hpp	/^    SparseMatIterator_& operator ++();$/;"	p	class:cv::SparseMatIterator_	access:public	signature:()
cv::SparseMatIterator_::operator ++	core/mat.hpp	/^SparseMatIterator_<_Tp>::operator ++()$/;"	f	class:cv::SparseMatIterator_	signature:()
cv::SparseMatIterator_::operator ++	core/mat.hpp	/^SparseMatIterator_<_Tp>::operator ++(int)$/;"	f	class:cv::SparseMatIterator_	signature:(int)
cv::SparseMatIterator_::operator =	core/core.hpp	/^    SparseMatIterator_& operator = (const SparseMatIterator_& it);$/;"	p	class:cv::SparseMatIterator_	access:public	signature:(const SparseMatIterator_& it)
cv::SparseMatIterator_::operator =	core/mat.hpp	/^SparseMatIterator_<_Tp>::operator = (const SparseMatIterator_<_Tp>& it)$/;"	f	class:cv::SparseMatIterator_	signature:(const SparseMatIterator_<_Tp>& it)
cv::SparseMat_	core/core.hpp	/^template<typename _Tp> class CV_EXPORTS SparseMat_ : public SparseMat$/;"	c	namespace:cv	inherits:SparseMat
cv::SparseMat_::SparseMat_	core/core.hpp	/^    SparseMat_();$/;"	p	class:cv::SparseMat_	access:public	signature:()
cv::SparseMat_::SparseMat_	core/core.hpp	/^    SparseMat_(const CvSparseMat* m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const CvSparseMat* m)
cv::SparseMat_::SparseMat_	core/core.hpp	/^    SparseMat_(const Mat& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const Mat& m)
cv::SparseMat_::SparseMat_	core/core.hpp	/^    SparseMat_(const SparseMat& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const SparseMat& m)
cv::SparseMat_::SparseMat_	core/core.hpp	/^    SparseMat_(const SparseMat_& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const SparseMat_& m)
cv::SparseMat_::SparseMat_	core/core.hpp	/^    SparseMat_(int dims, const int* _sizes);$/;"	p	class:cv::SparseMat_	access:public	signature:(int dims, const int* _sizes)
cv::SparseMat_::SparseMat_	core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_()$/;"	f	class:cv::SparseMat_	signature:()
cv::SparseMat_::SparseMat_	core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const CvSparseMat* m)$/;"	f	class:cv::SparseMat_	signature:(const CvSparseMat* m)
cv::SparseMat_::SparseMat_	core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const Mat& m)$/;"	f	class:cv::SparseMat_	signature:(const Mat& m)
cv::SparseMat_::SparseMat_	core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const SparseMat& m)$/;"	f	class:cv::SparseMat_	signature:(const SparseMat& m)
cv::SparseMat_::SparseMat_	core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(const SparseMat_<_Tp>& m)$/;"	f	class:cv::SparseMat_	signature:(const SparseMat_<_Tp>& m)
cv::SparseMat_::SparseMat_	core/mat.hpp	/^template<typename _Tp> inline SparseMat_<_Tp>::SparseMat_(int _dims, const int* _sizes)$/;"	f	class:cv::SparseMat_	signature:(int _dims, const int* _sizes)
cv::SparseMat_::begin	core/core.hpp	/^    SparseMatConstIterator_<_Tp> begin() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
cv::SparseMat_::begin	core/core.hpp	/^    SparseMatIterator_<_Tp> begin();$/;"	p	class:cv::SparseMat_	access:public	signature:()
cv::SparseMat_::begin	core/mat.hpp	/^template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat_<_Tp>::begin() const$/;"	f	class:cv::SparseMat_	signature:() const
cv::SparseMat_::begin	core/mat.hpp	/^template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat_<_Tp>::begin()$/;"	f	class:cv::SparseMat_	signature:()
cv::SparseMat_::channels	core/core.hpp	/^    int channels() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
cv::SparseMat_::channels	core/mat.hpp	/^template<typename _Tp> inline int SparseMat_<_Tp>::channels() const$/;"	f	class:cv::SparseMat_	signature:() const
cv::SparseMat_::clone	core/core.hpp	/^    SparseMat_ clone() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
cv::SparseMat_::clone	core/mat.hpp	/^SparseMat_<_Tp>::clone() const$/;"	f	class:cv::SparseMat_	signature:() const
cv::SparseMat_::const_iterator	core/core.hpp	/^    typedef SparseMatConstIterator_<_Tp> const_iterator;$/;"	t	class:cv::SparseMat_	access:public
cv::SparseMat_::create	core/core.hpp	/^    void create(int dims, const int* _sizes);$/;"	p	class:cv::SparseMat_	access:public	signature:(int dims, const int* _sizes)
cv::SparseMat_::create	core/mat.hpp	/^SparseMat_<_Tp>::create(int _dims, const int* _sizes)$/;"	f	class:cv::SparseMat_	signature:(int _dims, const int* _sizes)
cv::SparseMat_::depth	core/core.hpp	/^    int depth() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
cv::SparseMat_::depth	core/mat.hpp	/^template<typename _Tp> inline int SparseMat_<_Tp>::depth() const$/;"	f	class:cv::SparseMat_	signature:() const
cv::SparseMat_::end	core/core.hpp	/^    SparseMatConstIterator_<_Tp> end() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
cv::SparseMat_::end	core/core.hpp	/^    SparseMatIterator_<_Tp> end();$/;"	p	class:cv::SparseMat_	access:public	signature:()
cv::SparseMat_::end	core/mat.hpp	/^template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat_<_Tp>::end() const$/;"	f	class:cv::SparseMat_	signature:() const
cv::SparseMat_::end	core/mat.hpp	/^template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat_<_Tp>::end()$/;"	f	class:cv::SparseMat_	signature:()
cv::SparseMat_::iterator	core/core.hpp	/^    typedef SparseMatIterator_<_Tp> iterator;$/;"	t	class:cv::SparseMat_	access:public
cv::SparseMat_::operator ()	core/core.hpp	/^    _Tp operator()(const int* idx, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat_	access:public	signature:(const int* idx, size_t* hashval=0) const
cv::SparseMat_::operator ()	core/core.hpp	/^    _Tp operator()(int i0, int i1, int i2, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0) const
cv::SparseMat_::operator ()	core/core.hpp	/^    _Tp operator()(int i0, int i1, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, int i1, size_t* hashval=0) const
cv::SparseMat_::operator ()	core/core.hpp	/^    _Tp operator()(int i0, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, size_t* hashval=0) const
cv::SparseMat_::operator ()	core/mat.hpp	/^SparseMat_<_Tp>::operator()(const int* idx, size_t* hashval) const$/;"	f	class:cv::SparseMat_	signature:(const int* idx, size_t* hashval) const
cv::SparseMat_::operator ()	core/mat.hpp	/^SparseMat_<_Tp>::operator()(int i0, int i1, int i2, size_t* hashval) const$/;"	f	class:cv::SparseMat_	signature:(int i0, int i1, int i2, size_t* hashval) const
cv::SparseMat_::operator ()	core/mat.hpp	/^SparseMat_<_Tp>::operator()(int i0, int i1, size_t* hashval) const$/;"	f	class:cv::SparseMat_	signature:(int i0, int i1, size_t* hashval) const
cv::SparseMat_::operator ()	core/mat.hpp	/^SparseMat_<_Tp>::operator()(int i0, size_t* hashval) const$/;"	f	class:cv::SparseMat_	signature:(int i0, size_t* hashval) const
cv::SparseMat_::operator =	core/core.hpp	/^    SparseMat_& operator = (const Mat& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const Mat& m)
cv::SparseMat_::operator =	core/core.hpp	/^    SparseMat_& operator = (const SparseMat& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const SparseMat& m)
cv::SparseMat_::operator =	core/core.hpp	/^    SparseMat_& operator = (const SparseMat_& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const SparseMat_& m)
cv::SparseMat_::operator =	core/mat.hpp	/^SparseMat_<_Tp>::operator = (const Mat& m)$/;"	f	class:cv::SparseMat_	signature:(const Mat& m)
cv::SparseMat_::operator =	core/mat.hpp	/^SparseMat_<_Tp>::operator = (const SparseMat& m)$/;"	f	class:cv::SparseMat_	signature:(const SparseMat& m)
cv::SparseMat_::operator =	core/mat.hpp	/^SparseMat_<_Tp>::operator = (const SparseMat_<_Tp>& m)$/;"	f	class:cv::SparseMat_	signature:(const SparseMat_<_Tp>& m)
cv::SparseMat_::operator CvSparseMat*	core/core.hpp	/^    operator CvSparseMat*() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
cv::SparseMat_::operator CvSparseMat*	core/mat.hpp	/^SparseMat_<_Tp>::operator CvSparseMat*() const$/;"	f	class:cv::SparseMat_	signature:() const
cv::SparseMat_::ref	core/core.hpp	/^    _Tp& ref(const int* idx, size_t* hashval=0);$/;"	p	class:cv::SparseMat_	access:public	signature:(const int* idx, size_t* hashval=0)
cv::SparseMat_::ref	core/core.hpp	/^    _Tp& ref(int i0, int i1, int i2, size_t* hashval=0);$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0)
cv::SparseMat_::ref	core/core.hpp	/^    _Tp& ref(int i0, int i1, size_t* hashval=0);$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, int i1, size_t* hashval=0)
cv::SparseMat_::ref	core/core.hpp	/^    _Tp& ref(int i0, size_t* hashval=0);$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, size_t* hashval=0)
cv::SparseMat_::ref	core/mat.hpp	/^SparseMat_<_Tp>::ref(const int* idx, size_t* hashval)$/;"	f	class:cv::SparseMat_	signature:(const int* idx, size_t* hashval)
cv::SparseMat_::ref	core/mat.hpp	/^SparseMat_<_Tp>::ref(int i0, int i1, int i2, size_t* hashval)$/;"	f	class:cv::SparseMat_	signature:(int i0, int i1, int i2, size_t* hashval)
cv::SparseMat_::ref	core/mat.hpp	/^SparseMat_<_Tp>::ref(int i0, int i1, size_t* hashval)$/;"	f	class:cv::SparseMat_	signature:(int i0, int i1, size_t* hashval)
cv::SparseMat_::ref	core/mat.hpp	/^SparseMat_<_Tp>::ref(int i0, size_t* hashval)$/;"	f	class:cv::SparseMat_	signature:(int i0, size_t* hashval)
cv::SparseMat_::type	core/core.hpp	/^    int type() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
cv::SparseMat_::type	core/mat.hpp	/^template<typename _Tp> inline int SparseMat_<_Tp>::type() const$/;"	f	class:cv::SparseMat_	signature:() const
cv::SpinImageModel	contrib/contrib.hpp	/^    class CV_EXPORTS SpinImageModel$/;"	c	namespace:cv
cv::SpinImageModel::SpinImageModel	contrib/contrib.hpp	/^        SpinImageModel();$/;"	p	class:cv::SpinImageModel	access:public	signature:()
cv::SpinImageModel::SpinImageModel	contrib/contrib.hpp	/^        explicit SpinImageModel(const Mesh3D& mesh);$/;"	p	class:cv::SpinImageModel	access:public	signature:(const Mesh3D& mesh)
cv::SpinImageModel::T_GeometriccConsistency	contrib/contrib.hpp	/^        float T_GeometriccConsistency;$/;"	m	class:cv::SpinImageModel	access:public
cv::SpinImageModel::T_GroupingCorespondances	contrib/contrib.hpp	/^        float T_GroupingCorespondances;$/;"	m	class:cv::SpinImageModel	access:public
cv::SpinImageModel::binSize	contrib/contrib.hpp	/^        float binSize;$/;"	m	class:cv::SpinImageModel	access:public
cv::SpinImageModel::calcSpinMapCoo	contrib/contrib.hpp	/^        static Point2f calcSpinMapCoo(const Point3f& point, const Point3f& vertex, const Point3f& normal);$/;"	p	class:cv::SpinImageModel	access:public	signature:(const Point3f& point, const Point3f& vertex, const Point3f& normal)
cv::SpinImageModel::compute	contrib/contrib.hpp	/^        void compute();$/;"	p	class:cv::SpinImageModel	access:public	signature:()
cv::SpinImageModel::defaultParams	contrib/contrib.hpp	/^        void defaultParams();$/;"	p	class:cv::SpinImageModel	access:protected	signature:()
cv::SpinImageModel::gamma	contrib/contrib.hpp	/^        float gamma;$/;"	m	class:cv::SpinImageModel	access:public
cv::SpinImageModel::geometricConsistency	contrib/contrib.hpp	/^        static float geometricConsistency(const Point3f& pointScene1, const Point3f& normalScene1,$/;"	p	class:cv::SpinImageModel	access:public	signature:(const Point3f& pointScene1, const Point3f& normalScene1, const Point3f& pointModel1, const Point3f& normalModel1, const Point3f& pointScene2, const Point3f& normalScene2, const Point3f& pointModel2, const Point3f& normalModel2)
cv::SpinImageModel::getMesh	contrib/contrib.hpp	/^        Mesh3D& getMesh() { return mesh; }$/;"	f	class:cv::SpinImageModel	access:public	signature:()
cv::SpinImageModel::getMesh	contrib/contrib.hpp	/^        const Mesh3D& getMesh() const { return mesh; }$/;"	f	class:cv::SpinImageModel	access:public	signature:() const
cv::SpinImageModel::getSpinCount	contrib/contrib.hpp	/^        size_t getSpinCount() const { return spinImages.rows; }$/;"	f	class:cv::SpinImageModel	access:public	signature:() const
cv::SpinImageModel::getSpinImage	contrib/contrib.hpp	/^        Mat getSpinImage(size_t index) const { return spinImages.row((int)index); }$/;"	f	class:cv::SpinImageModel	access:public	signature:(size_t index) const
cv::SpinImageModel::getSpinNormal	contrib/contrib.hpp	/^        const Point3f& getSpinNormal(size_t index) const { return mesh.normals[subset[index]]; }$/;"	f	class:cv::SpinImageModel	access:public	signature:(size_t index) const
cv::SpinImageModel::getSpinVertex	contrib/contrib.hpp	/^        const Point3f& getSpinVertex(size_t index) const { return mesh.vtx[subset[index]]; }$/;"	f	class:cv::SpinImageModel	access:public	signature:(size_t index) const
cv::SpinImageModel::groupingCreteria	contrib/contrib.hpp	/^        static float groupingCreteria(const Point3f& pointScene1, const Point3f& normalScene1,$/;"	p	class:cv::SpinImageModel	access:public	signature:(const Point3f& pointScene1, const Point3f& normalScene1, const Point3f& pointModel1, const Point3f& normalModel1, const Point3f& pointScene2, const Point3f& normalScene2, const Point3f& pointModel2, const Point3f& normalModel2, float gamma)
cv::SpinImageModel::imageWidth	contrib/contrib.hpp	/^        int imageWidth;$/;"	m	class:cv::SpinImageModel	access:public
cv::SpinImageModel::lambda	contrib/contrib.hpp	/^        float lambda;$/;"	m	class:cv::SpinImageModel	access:public
cv::SpinImageModel::match	contrib/contrib.hpp	/^        void match(const SpinImageModel& scene, vector< vector<Vec2i> >& result);$/;"	p	class:cv::SpinImageModel	access:public	signature:(const SpinImageModel& scene, vector< vector<Vec2i> >& result)
cv::SpinImageModel::matchSpinToModel	contrib/contrib.hpp	/^        void matchSpinToModel(const Mat& spin, vector<int>& indeces,$/;"	p	class:cv::SpinImageModel	access:protected	signature:(const Mat& spin, vector<int>& indeces, vector<float>& corrCoeffs, bool useExtremeOutliers = true) const
cv::SpinImageModel::mesh	contrib/contrib.hpp	/^        Mesh3D mesh;$/;"	m	class:cv::SpinImageModel	access:protected
cv::SpinImageModel::minNeighbors	contrib/contrib.hpp	/^        int minNeighbors;$/;"	m	class:cv::SpinImageModel	access:public
cv::SpinImageModel::normalRadius	contrib/contrib.hpp	/^        float normalRadius;$/;"	m	class:cv::SpinImageModel	access:public
cv::SpinImageModel::out	contrib/contrib.hpp	/^        std::ostream* out;$/;"	m	class:cv::SpinImageModel	access:protected
cv::SpinImageModel::packRandomScaledSpins	contrib/contrib.hpp	/^        Mat packRandomScaledSpins(bool separateScale = false, size_t xCount = 10, size_t yCount = 10) const;$/;"	p	class:cv::SpinImageModel	access:public	signature:(bool separateScale = false, size_t xCount = 10, size_t yCount = 10) const
cv::SpinImageModel::repackSpinImages	contrib/contrib.hpp	/^        void repackSpinImages(const vector<uchar>& mask, Mat& spinImages, bool reAlloc = true) const;$/;"	p	class:cv::SpinImageModel	access:protected	signature:(const vector<uchar>& mask, Mat& spinImages, bool reAlloc = true) const
cv::SpinImageModel::selectRandomSubset	contrib/contrib.hpp	/^        void selectRandomSubset(float ratio);$/;"	p	class:cv::SpinImageModel	access:public	signature:(float ratio)
cv::SpinImageModel::setLogger	contrib/contrib.hpp	/^        void setLogger(std::ostream* log);$/;"	p	class:cv::SpinImageModel	access:public	signature:(std::ostream* log)
cv::SpinImageModel::setSubset	contrib/contrib.hpp	/^        void setSubset(const vector<int>& subset);$/;"	p	class:cv::SpinImageModel	access:public	signature:(const vector<int>& subset)
cv::SpinImageModel::spinCorrelation	contrib/contrib.hpp	/^        static bool spinCorrelation(const Mat& spin1, const Mat& spin2, float lambda, float& result);$/;"	p	class:cv::SpinImageModel	access:public	signature:(const Mat& spin1, const Mat& spin2, float lambda, float& result)
cv::SpinImageModel::spinImages	contrib/contrib.hpp	/^        Mat spinImages;$/;"	m	class:cv::SpinImageModel	access:protected
cv::SpinImageModel::subset	contrib/contrib.hpp	/^        vector<int> subset;$/;"	m	class:cv::SpinImageModel	access:protected
cv::SpinImageModel::~SpinImageModel	contrib/contrib.hpp	/^        ~SpinImageModel();$/;"	p	class:cv::SpinImageModel	access:public	signature:()
cv::Split	core/internal.hpp	/^        typedef tbb::split Split;$/;"	t	namespace:cv
cv::StarAdjuster	features2d/features2d.hpp	/^class CV_EXPORTS StarAdjuster: public AdjusterAdapter$/;"	c	namespace:cv	inherits:AdjusterAdapter
cv::StarAdjuster::StarAdjuster	features2d/features2d.hpp	/^    StarAdjuster(double initial_thresh=30.0, double min_thresh=2., double max_thresh=200.);$/;"	p	class:cv::StarAdjuster	access:public	signature:(double initial_thresh=30.0, double min_thresh=2., double max_thresh=200.)
cv::StarAdjuster::clone	features2d/features2d.hpp	/^    virtual Ptr<AdjusterAdapter> clone() const;$/;"	p	class:cv::StarAdjuster	access:public	signature:() const
cv::StarAdjuster::detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::StarAdjuster	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::StarAdjuster::good	features2d/features2d.hpp	/^    virtual bool good() const;$/;"	p	class:cv::StarAdjuster	access:public	signature:() const
cv::StarAdjuster::init_thresh_	features2d/features2d.hpp	/^    double thresh_, init_thresh_, min_thresh_, max_thresh_;$/;"	m	class:cv::StarAdjuster	access:protected
cv::StarAdjuster::max_thresh_	features2d/features2d.hpp	/^    double thresh_, init_thresh_, min_thresh_, max_thresh_;$/;"	m	class:cv::StarAdjuster	access:protected
cv::StarAdjuster::min_thresh_	features2d/features2d.hpp	/^    double thresh_, init_thresh_, min_thresh_, max_thresh_;$/;"	m	class:cv::StarAdjuster	access:protected
cv::StarAdjuster::params_	features2d/features2d.hpp	/^    CvStarDetectorParams params_; \/\/todo use these instead of thresh_$/;"	m	class:cv::StarAdjuster	access:protected
cv::StarAdjuster::thresh_	features2d/features2d.hpp	/^    double thresh_, init_thresh_, min_thresh_, max_thresh_;$/;"	m	class:cv::StarAdjuster	access:protected
cv::StarAdjuster::tooFew	features2d/features2d.hpp	/^    virtual void tooFew(int min, int n_detected);$/;"	p	class:cv::StarAdjuster	access:public	signature:(int min, int n_detected)
cv::StarAdjuster::tooMany	features2d/features2d.hpp	/^    virtual void tooMany(int max, int n_detected);$/;"	p	class:cv::StarAdjuster	access:public	signature:(int max, int n_detected)
cv::StarDetector	features2d/features2d.hpp	/^class CV_EXPORTS_W StarDetector : public CvStarDetectorParams$/;"	c	namespace:cv	inherits:CvStarDetectorParams
cv::StarDetector::StarDetector	features2d/features2d.hpp	/^    CV_WRAP StarDetector();$/;"	p	class:cv::StarDetector	access:public	signature:()
cv::StarDetector::StarDetector	features2d/features2d.hpp	/^    CV_WRAP StarDetector(int _maxSize, int _responseThreshold,$/;"	p	class:cv::StarDetector	access:public	signature:(int _maxSize, int _responseThreshold, int _lineThresholdProjected, int _lineThresholdBinarized, int _suppressNonmaxSize)
cv::StarDetector::operator ()	features2d/features2d.hpp	/^    CV_WRAP_AS(detect) void operator()(const Mat& image,$/;"	p	class:cv::StarDetector	access:public	signature:(const Mat& image, CV_OUT vector<KeyPoint>& keypoints) const
cv::StarFeatureDetector	features2d/features2d.hpp	/^class CV_EXPORTS StarFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
cv::StarFeatureDetector::StarFeatureDetector	features2d/features2d.hpp	/^    StarFeatureDetector( const CvStarDetectorParams& params=cvStarDetectorParams() );$/;"	p	class:cv::StarFeatureDetector	access:public	signature:( const CvStarDetectorParams& params=cvStarDetectorParams() )
cv::StarFeatureDetector::StarFeatureDetector	features2d/features2d.hpp	/^    StarFeatureDetector( int maxSize, int responseThreshold=30, int lineThresholdProjected = 10,$/;"	p	class:cv::StarFeatureDetector	access:public	signature:( int maxSize, int responseThreshold=30, int lineThresholdProjected = 10, int lineThresholdBinarized=8, int suppressNonmaxSize=5 )
cv::StarFeatureDetector::detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::StarFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::StarFeatureDetector::read	features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::StarFeatureDetector	access:public	signature:( const FileNode& fn )
cv::StarFeatureDetector::star	features2d/features2d.hpp	/^    StarDetector star;$/;"	m	class:cv::StarFeatureDetector	access:protected
cv::StarFeatureDetector::write	features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::StarFeatureDetector	access:public	signature:( FileStorage& fs ) const
cv::StatModel	ml/ml.hpp	/^typedef CvStatModel StatModel;$/;"	t	namespace:cv
cv::StereoBM	calib3d/calib3d.hpp	/^class CV_EXPORTS_W StereoBM$/;"	c	namespace:cv
cv::StereoBM::BASIC_PRESET	calib3d/calib3d.hpp	/^        BASIC_PRESET=0, FISH_EYE_PRESET=1, NARROW_PRESET=2 };$/;"	e	enum:cv::StereoBM::__anon92
cv::StereoBM::FISH_EYE_PRESET	calib3d/calib3d.hpp	/^        BASIC_PRESET=0, FISH_EYE_PRESET=1, NARROW_PRESET=2 };$/;"	e	enum:cv::StereoBM::__anon92
cv::StereoBM::NARROW_PRESET	calib3d/calib3d.hpp	/^        BASIC_PRESET=0, FISH_EYE_PRESET=1, NARROW_PRESET=2 };$/;"	e	enum:cv::StereoBM::__anon92
cv::StereoBM::PREFILTER_NORMALIZED_RESPONSE	calib3d/calib3d.hpp	/^    enum { PREFILTER_NORMALIZED_RESPONSE = 0, PREFILTER_XSOBEL = 1,$/;"	e	enum:cv::StereoBM::__anon92
cv::StereoBM::PREFILTER_XSOBEL	calib3d/calib3d.hpp	/^    enum { PREFILTER_NORMALIZED_RESPONSE = 0, PREFILTER_XSOBEL = 1,$/;"	e	enum:cv::StereoBM::__anon92
cv::StereoBM::StereoBM	calib3d/calib3d.hpp	/^    CV_WRAP StereoBM();$/;"	p	class:cv::StereoBM	access:public	signature:()
cv::StereoBM::StereoBM	calib3d/calib3d.hpp	/^    CV_WRAP StereoBM(int preset, int ndisparities=0, int SADWindowSize=21);$/;"	p	class:cv::StereoBM	access:public	signature:(int preset, int ndisparities=0, int SADWindowSize=21)
cv::StereoBM::init	calib3d/calib3d.hpp	/^    void init(int preset, int ndisparities=0, int SADWindowSize=21);$/;"	p	class:cv::StereoBM	access:public	signature:(int preset, int ndisparities=0, int SADWindowSize=21)
cv::StereoBM::operator ()	calib3d/calib3d.hpp	/^    CV_WRAP_AS(compute) void operator()( InputArray left, InputArray right,$/;"	p	class:cv::StereoBM	access:public	signature:( InputArray left, InputArray right, OutputArray disparity, int disptype=CV_16S )
cv::StereoBM::state	calib3d/calib3d.hpp	/^    Ptr<CvStereoBMState> state;$/;"	m	class:cv::StereoBM	access:public
cv::StereoSGBM	calib3d/calib3d.hpp	/^class CV_EXPORTS_W StereoSGBM$/;"	c	namespace:cv
cv::StereoSGBM::DISP_SCALE	calib3d/calib3d.hpp	/^    enum { DISP_SHIFT=4, DISP_SCALE = (1<<DISP_SHIFT) };$/;"	e	enum:cv::StereoSGBM::__anon93
cv::StereoSGBM::DISP_SHIFT	calib3d/calib3d.hpp	/^    enum { DISP_SHIFT=4, DISP_SCALE = (1<<DISP_SHIFT) };$/;"	e	enum:cv::StereoSGBM::__anon93
cv::StereoSGBM::P1	calib3d/calib3d.hpp	/^    CV_PROP_RW int P1;$/;"	m	class:cv::StereoSGBM	access:public
cv::StereoSGBM::P2	calib3d/calib3d.hpp	/^    CV_PROP_RW int P2;$/;"	m	class:cv::StereoSGBM	access:public
cv::StereoSGBM::SADWindowSize	calib3d/calib3d.hpp	/^    CV_PROP_RW int SADWindowSize;$/;"	m	class:cv::StereoSGBM	access:public
cv::StereoSGBM::StereoSGBM	calib3d/calib3d.hpp	/^    CV_WRAP StereoSGBM();$/;"	p	class:cv::StereoSGBM	access:public	signature:()
cv::StereoSGBM::StereoSGBM	calib3d/calib3d.hpp	/^    CV_WRAP StereoSGBM(int minDisparity, int numDisparities, int SADWindowSize,$/;"	p	class:cv::StereoSGBM	access:public	signature:(int minDisparity, int numDisparities, int SADWindowSize, int P1=0, int P2=0, int disp12MaxDiff=0, int preFilterCap=0, int uniquenessRatio=0, int speckleWindowSize=0, int speckleRange=0, bool fullDP=false)
cv::StereoSGBM::buffer	calib3d/calib3d.hpp	/^    Mat buffer;$/;"	m	class:cv::StereoSGBM	access:protected
cv::StereoSGBM::disp12MaxDiff	calib3d/calib3d.hpp	/^    CV_PROP_RW int disp12MaxDiff;$/;"	m	class:cv::StereoSGBM	access:public
cv::StereoSGBM::fullDP	calib3d/calib3d.hpp	/^    CV_PROP_RW bool fullDP;$/;"	m	class:cv::StereoSGBM	access:public
cv::StereoSGBM::minDisparity	calib3d/calib3d.hpp	/^    CV_PROP_RW int minDisparity;$/;"	m	class:cv::StereoSGBM	access:public
cv::StereoSGBM::numberOfDisparities	calib3d/calib3d.hpp	/^    CV_PROP_RW int numberOfDisparities;$/;"	m	class:cv::StereoSGBM	access:public
cv::StereoSGBM::operator ()	calib3d/calib3d.hpp	/^    CV_WRAP_AS(compute) virtual void operator()(InputArray left, InputArray right,$/;"	p	class:cv::StereoSGBM	access:public	signature:(InputArray left, InputArray right, OutputArray disp)
cv::StereoSGBM::preFilterCap	calib3d/calib3d.hpp	/^    CV_PROP_RW int preFilterCap;$/;"	m	class:cv::StereoSGBM	access:public
cv::StereoSGBM::speckleRange	calib3d/calib3d.hpp	/^    CV_PROP_RW int speckleRange;$/;"	m	class:cv::StereoSGBM	access:public
cv::StereoSGBM::speckleWindowSize	calib3d/calib3d.hpp	/^    CV_PROP_RW int speckleWindowSize;$/;"	m	class:cv::StereoSGBM	access:public
cv::StereoSGBM::uniquenessRatio	calib3d/calib3d.hpp	/^    CV_PROP_RW int uniquenessRatio;$/;"	m	class:cv::StereoSGBM	access:public
cv::StereoSGBM::~StereoSGBM	calib3d/calib3d.hpp	/^    virtual ~StereoSGBM();$/;"	p	class:cv::StereoSGBM	access:public	signature:()
cv::StereoVar	contrib/contrib.hpp	/^    class CV_EXPORTS StereoVar$/;"	c	namespace:cv
cv::StereoVar::CYCLE_O	contrib/contrib.hpp	/^        enum {CYCLE_O, CYCLE_V};$/;"	e	enum:cv::StereoVar::__anon8
cv::StereoVar::CYCLE_V	contrib/contrib.hpp	/^        enum {CYCLE_O, CYCLE_V};$/;"	e	enum:cv::StereoVar::__anon8
cv::StereoVar::FMG	contrib/contrib.hpp	/^		void FMG(Mat &I1, Mat &I2, Mat &I2x, Mat &u, int level);$/;"	p	class:cv::StereoVar	access:private	signature:(Mat &I1, Mat &I2, Mat &I2x, Mat &u, int level)
cv::StereoVar::PENALIZATION_CHARBONNIER	contrib/contrib.hpp	/^        enum {PENALIZATION_TICHONOV, PENALIZATION_CHARBONNIER, PENALIZATION_PERONA_MALIK};$/;"	e	enum:cv::StereoVar::__anon9
cv::StereoVar::PENALIZATION_PERONA_MALIK	contrib/contrib.hpp	/^        enum {PENALIZATION_TICHONOV, PENALIZATION_CHARBONNIER, PENALIZATION_PERONA_MALIK};$/;"	e	enum:cv::StereoVar::__anon9
cv::StereoVar::PENALIZATION_TICHONOV	contrib/contrib.hpp	/^        enum {PENALIZATION_TICHONOV, PENALIZATION_CHARBONNIER, PENALIZATION_PERONA_MALIK};$/;"	e	enum:cv::StereoVar::__anon9
cv::StereoVar::StereoVar	contrib/contrib.hpp	/^        CV_WRAP StereoVar();$/;"	p	class:cv::StereoVar	access:public	signature:()
cv::StereoVar::StereoVar	contrib/contrib.hpp	/^        CV_WRAP StereoVar(int levels, double pyrScale, int nIt, int minDisp, int maxDisp, int poly_n, double poly_sigma, float fi, float lambda, int penalization, int cycle, int flags);$/;"	p	class:cv::StereoVar	access:public	signature:(int levels, double pyrScale, int nIt, int minDisp, int maxDisp, int poly_n, double poly_sigma, float fi, float lambda, int penalization, int cycle, int flags)
cv::StereoVar::USE_AUTO_PARAMS	contrib/contrib.hpp	/^        enum {USE_INITIAL_DISPARITY = 1, USE_EQUALIZE_HIST = 2, USE_SMART_ID = 4, USE_AUTO_PARAMS = 8, USE_MEDIAN_FILTERING = 16};$/;"	e	enum:cv::StereoVar::__anon7
cv::StereoVar::USE_EQUALIZE_HIST	contrib/contrib.hpp	/^        enum {USE_INITIAL_DISPARITY = 1, USE_EQUALIZE_HIST = 2, USE_SMART_ID = 4, USE_AUTO_PARAMS = 8, USE_MEDIAN_FILTERING = 16};$/;"	e	enum:cv::StereoVar::__anon7
cv::StereoVar::USE_INITIAL_DISPARITY	contrib/contrib.hpp	/^        enum {USE_INITIAL_DISPARITY = 1, USE_EQUALIZE_HIST = 2, USE_SMART_ID = 4, USE_AUTO_PARAMS = 8, USE_MEDIAN_FILTERING = 16};$/;"	e	enum:cv::StereoVar::__anon7
cv::StereoVar::USE_MEDIAN_FILTERING	contrib/contrib.hpp	/^        enum {USE_INITIAL_DISPARITY = 1, USE_EQUALIZE_HIST = 2, USE_SMART_ID = 4, USE_AUTO_PARAMS = 8, USE_MEDIAN_FILTERING = 16};$/;"	e	enum:cv::StereoVar::__anon7
cv::StereoVar::USE_SMART_ID	contrib/contrib.hpp	/^        enum {USE_INITIAL_DISPARITY = 1, USE_EQUALIZE_HIST = 2, USE_SMART_ID = 4, USE_AUTO_PARAMS = 8, USE_MEDIAN_FILTERING = 16};$/;"	e	enum:cv::StereoVar::__anon7
cv::StereoVar::VCycle_MyFAS	contrib/contrib.hpp	/^        void VCycle_MyFAS(Mat &I1_h, Mat &I2_h, Mat &I2x_h, Mat &u_h, int level);$/;"	p	class:cv::StereoVar	access:private	signature:(Mat &I1_h, Mat &I2_h, Mat &I2x_h, Mat &u_h, int level)
cv::StereoVar::VariationalSolver	contrib/contrib.hpp	/^        void VariationalSolver(Mat &I1_h, Mat &I2_h, Mat &I2x_h, Mat &u_h, int level);$/;"	p	class:cv::StereoVar	access:private	signature:(Mat &I1_h, Mat &I2_h, Mat &I2x_h, Mat &u_h, int level)
cv::StereoVar::autoParams	contrib/contrib.hpp	/^        void autoParams();$/;"	p	class:cv::StereoVar	access:private	signature:()
cv::StereoVar::cycle	contrib/contrib.hpp	/^        CV_PROP_RW int		cycle;$/;"	m	class:cv::StereoVar	access:public
cv::StereoVar::fi	contrib/contrib.hpp	/^        CV_PROP_RW float	fi;$/;"	m	class:cv::StereoVar	access:public
cv::StereoVar::flags	contrib/contrib.hpp	/^        CV_PROP_RW int		flags;$/;"	m	class:cv::StereoVar	access:public
cv::StereoVar::lambda	contrib/contrib.hpp	/^        CV_PROP_RW float	lambda;$/;"	m	class:cv::StereoVar	access:public
cv::StereoVar::levels	contrib/contrib.hpp	/^        CV_PROP_RW int		levels;$/;"	m	class:cv::StereoVar	access:public
cv::StereoVar::maxDisp	contrib/contrib.hpp	/^        CV_PROP_RW int		maxDisp;$/;"	m	class:cv::StereoVar	access:public
cv::StereoVar::minDisp	contrib/contrib.hpp	/^        CV_PROP_RW int		minDisp;$/;"	m	class:cv::StereoVar	access:public
cv::StereoVar::nIt	contrib/contrib.hpp	/^        CV_PROP_RW int		nIt;$/;"	m	class:cv::StereoVar	access:public
cv::StereoVar::operator ()	contrib/contrib.hpp	/^        CV_WRAP_AS(compute) virtual void operator()(const Mat& left, const Mat& right, Mat& disp);$/;"	p	class:cv::StereoVar	access:public	signature:(const Mat& left, const Mat& right, Mat& disp)
cv::StereoVar::penalization	contrib/contrib.hpp	/^        CV_PROP_RW int		penalization;$/;"	m	class:cv::StereoVar	access:public
cv::StereoVar::poly_n	contrib/contrib.hpp	/^        CV_PROP_RW int		poly_n;$/;"	m	class:cv::StereoVar	access:public
cv::StereoVar::poly_sigma	contrib/contrib.hpp	/^        CV_PROP_RW double	poly_sigma;$/;"	m	class:cv::StereoVar	access:public
cv::StereoVar::pyrScale	contrib/contrib.hpp	/^        CV_PROP_RW double	pyrScale;$/;"	m	class:cv::StereoVar	access:public
cv::StereoVar::~StereoVar	contrib/contrib.hpp	/^        virtual ~StereoVar();$/;"	p	class:cv::StereoVar	access:public	signature:()
cv::String	core/core.hpp	/^typedef std::string String;$/;"	t	namespace:cv
cv::Subdiv2D	imgproc/imgproc.hpp	/^class CV_EXPORTS_W Subdiv2D$/;"	c	namespace:cv
cv::Subdiv2D::NEXT_AROUND_DST	imgproc/imgproc.hpp	/^        NEXT_AROUND_DST   = 0x22,$/;"	e	enum:cv::Subdiv2D::__anon28
cv::Subdiv2D::NEXT_AROUND_LEFT	imgproc/imgproc.hpp	/^        NEXT_AROUND_LEFT  = 0x13,$/;"	e	enum:cv::Subdiv2D::__anon28
cv::Subdiv2D::NEXT_AROUND_ORG	imgproc/imgproc.hpp	/^        NEXT_AROUND_ORG   = 0x00,$/;"	e	enum:cv::Subdiv2D::__anon28
cv::Subdiv2D::NEXT_AROUND_RIGHT	imgproc/imgproc.hpp	/^        NEXT_AROUND_RIGHT = 0x31,$/;"	e	enum:cv::Subdiv2D::__anon28
cv::Subdiv2D::PREV_AROUND_DST	imgproc/imgproc.hpp	/^        PREV_AROUND_DST   = 0x33,$/;"	e	enum:cv::Subdiv2D::__anon28
cv::Subdiv2D::PREV_AROUND_LEFT	imgproc/imgproc.hpp	/^        PREV_AROUND_LEFT  = 0x20,$/;"	e	enum:cv::Subdiv2D::__anon28
cv::Subdiv2D::PREV_AROUND_ORG	imgproc/imgproc.hpp	/^        PREV_AROUND_ORG   = 0x11,$/;"	e	enum:cv::Subdiv2D::__anon28
cv::Subdiv2D::PREV_AROUND_RIGHT	imgproc/imgproc.hpp	/^        PREV_AROUND_RIGHT = 0x02$/;"	e	enum:cv::Subdiv2D::__anon28
cv::Subdiv2D::PTLOC_ERROR	imgproc/imgproc.hpp	/^        PTLOC_ERROR = -2,$/;"	e	enum:cv::Subdiv2D::__anon27
cv::Subdiv2D::PTLOC_INSIDE	imgproc/imgproc.hpp	/^        PTLOC_INSIDE = 0,$/;"	e	enum:cv::Subdiv2D::__anon27
cv::Subdiv2D::PTLOC_ON_EDGE	imgproc/imgproc.hpp	/^        PTLOC_ON_EDGE = 2$/;"	e	enum:cv::Subdiv2D::__anon27
cv::Subdiv2D::PTLOC_OUTSIDE_RECT	imgproc/imgproc.hpp	/^        PTLOC_OUTSIDE_RECT = -1,$/;"	e	enum:cv::Subdiv2D::__anon27
cv::Subdiv2D::PTLOC_VERTEX	imgproc/imgproc.hpp	/^        PTLOC_VERTEX = 1,$/;"	e	enum:cv::Subdiv2D::__anon27
cv::Subdiv2D::QuadEdge	imgproc/imgproc.hpp	/^    struct CV_EXPORTS QuadEdge$/;"	s	class:cv::Subdiv2D	access:protected
cv::Subdiv2D::QuadEdge::QuadEdge	imgproc/imgproc.hpp	/^        QuadEdge();$/;"	p	struct:cv::Subdiv2D::QuadEdge	access:public	signature:()
cv::Subdiv2D::QuadEdge::QuadEdge	imgproc/imgproc.hpp	/^        QuadEdge(int edgeidx);$/;"	p	struct:cv::Subdiv2D::QuadEdge	access:public	signature:(int edgeidx)
cv::Subdiv2D::QuadEdge::isfree	imgproc/imgproc.hpp	/^        bool isfree() const;$/;"	p	struct:cv::Subdiv2D::QuadEdge	access:public	signature:() const
cv::Subdiv2D::QuadEdge::next	imgproc/imgproc.hpp	/^        int next[4];$/;"	m	struct:cv::Subdiv2D::QuadEdge	access:public
cv::Subdiv2D::QuadEdge::pt	imgproc/imgproc.hpp	/^        int pt[4];$/;"	m	struct:cv::Subdiv2D::QuadEdge	access:public
cv::Subdiv2D::Subdiv2D	imgproc/imgproc.hpp	/^    CV_WRAP Subdiv2D();$/;"	p	class:cv::Subdiv2D	access:public	signature:()
cv::Subdiv2D::Subdiv2D	imgproc/imgproc.hpp	/^    CV_WRAP Subdiv2D(Rect rect);$/;"	p	class:cv::Subdiv2D	access:public	signature:(Rect rect)
cv::Subdiv2D::Vertex	imgproc/imgproc.hpp	/^    struct CV_EXPORTS Vertex$/;"	s	class:cv::Subdiv2D	access:protected
cv::Subdiv2D::Vertex::Vertex	imgproc/imgproc.hpp	/^        Vertex();$/;"	p	struct:cv::Subdiv2D::Vertex	access:public	signature:()
cv::Subdiv2D::Vertex::Vertex	imgproc/imgproc.hpp	/^        Vertex(Point2f pt, bool _isvirtual, int _firstEdge=0);$/;"	p	struct:cv::Subdiv2D::Vertex	access:public	signature:(Point2f pt, bool _isvirtual, int _firstEdge=0)
cv::Subdiv2D::Vertex::firstEdge	imgproc/imgproc.hpp	/^        int firstEdge;$/;"	m	struct:cv::Subdiv2D::Vertex	access:public
cv::Subdiv2D::Vertex::isfree	imgproc/imgproc.hpp	/^        bool isfree() const;$/;"	p	struct:cv::Subdiv2D::Vertex	access:public	signature:() const
cv::Subdiv2D::Vertex::isvirtual	imgproc/imgproc.hpp	/^        bool isvirtual() const;$/;"	p	struct:cv::Subdiv2D::Vertex	access:public	signature:() const
cv::Subdiv2D::Vertex::pt	imgproc/imgproc.hpp	/^        Point2f pt;$/;"	m	struct:cv::Subdiv2D::Vertex	access:public
cv::Subdiv2D::Vertex::type	imgproc/imgproc.hpp	/^        int type;$/;"	m	struct:cv::Subdiv2D::Vertex	access:public
cv::Subdiv2D::bottomRight	imgproc/imgproc.hpp	/^    Point2f bottomRight;$/;"	m	class:cv::Subdiv2D	access:protected
cv::Subdiv2D::calcVoronoi	imgproc/imgproc.hpp	/^    void calcVoronoi();$/;"	p	class:cv::Subdiv2D	access:protected	signature:()
cv::Subdiv2D::check	imgproc/imgproc.hpp	/^    void check() const;$/;"	p	class:cv::Subdiv2D	access:protected	signature:() const
cv::Subdiv2D::clearVoronoi	imgproc/imgproc.hpp	/^    void clearVoronoi();$/;"	p	class:cv::Subdiv2D	access:protected	signature:()
cv::Subdiv2D::connectEdges	imgproc/imgproc.hpp	/^    int connectEdges( int edgeA, int edgeB );$/;"	p	class:cv::Subdiv2D	access:protected	signature:( int edgeA, int edgeB )
cv::Subdiv2D::deleteEdge	imgproc/imgproc.hpp	/^    void deleteEdge(int edge);$/;"	p	class:cv::Subdiv2D	access:protected	signature:(int edge)
cv::Subdiv2D::deletePoint	imgproc/imgproc.hpp	/^    void deletePoint(int vtx);$/;"	p	class:cv::Subdiv2D	access:protected	signature:(int vtx)
cv::Subdiv2D::edgeDst	imgproc/imgproc.hpp	/^    CV_WRAP int edgeDst(int edge, CV_OUT Point2f* dstpt=0) const;$/;"	p	class:cv::Subdiv2D	access:public	signature:(int edge, CV_OUT Point2f* dstpt=0) const
cv::Subdiv2D::edgeOrg	imgproc/imgproc.hpp	/^    CV_WRAP int edgeOrg(int edge, CV_OUT Point2f* orgpt=0) const;$/;"	p	class:cv::Subdiv2D	access:public	signature:(int edge, CV_OUT Point2f* orgpt=0) const
cv::Subdiv2D::findNearest	imgproc/imgproc.hpp	/^    CV_WRAP int findNearest(Point2f pt, CV_OUT Point2f* nearestPt=0);$/;"	p	class:cv::Subdiv2D	access:public	signature:(Point2f pt, CV_OUT Point2f* nearestPt=0)
cv::Subdiv2D::freePoint	imgproc/imgproc.hpp	/^    int freePoint;$/;"	m	class:cv::Subdiv2D	access:protected
cv::Subdiv2D::freeQEdge	imgproc/imgproc.hpp	/^    int freeQEdge;$/;"	m	class:cv::Subdiv2D	access:protected
cv::Subdiv2D::getEdge	imgproc/imgproc.hpp	/^    CV_WRAP int getEdge( int edge, int nextEdgeType ) const;$/;"	p	class:cv::Subdiv2D	access:public	signature:( int edge, int nextEdgeType ) const
cv::Subdiv2D::getEdgeList	imgproc/imgproc.hpp	/^    CV_WRAP void getEdgeList(CV_OUT vector<Vec4f>& edgeList) const;$/;"	p	class:cv::Subdiv2D	access:public	signature:(CV_OUT vector<Vec4f>& edgeList) const
cv::Subdiv2D::getTriangleList	imgproc/imgproc.hpp	/^    CV_WRAP void getTriangleList(CV_OUT vector<Vec6f>& triangleList) const;$/;"	p	class:cv::Subdiv2D	access:public	signature:(CV_OUT vector<Vec6f>& triangleList) const
cv::Subdiv2D::getVertex	imgproc/imgproc.hpp	/^    CV_WRAP Point2f getVertex(int vertex, CV_OUT int* firstEdge=0) const;$/;"	p	class:cv::Subdiv2D	access:public	signature:(int vertex, CV_OUT int* firstEdge=0) const
cv::Subdiv2D::getVoronoiFacetList	imgproc/imgproc.hpp	/^    CV_WRAP void getVoronoiFacetList(const vector<int>& idx, CV_OUT vector<vector<Point2f> >& facetList,$/;"	p	class:cv::Subdiv2D	access:public	signature:(const vector<int>& idx, CV_OUT vector<vector<Point2f> >& facetList, CV_OUT vector<Point2f>& facetCenters)
cv::Subdiv2D::initDelaunay	imgproc/imgproc.hpp	/^    CV_WRAP void initDelaunay(Rect rect);$/;"	p	class:cv::Subdiv2D	access:public	signature:(Rect rect)
cv::Subdiv2D::insert	imgproc/imgproc.hpp	/^    CV_WRAP int insert(Point2f pt);$/;"	p	class:cv::Subdiv2D	access:public	signature:(Point2f pt)
cv::Subdiv2D::insert	imgproc/imgproc.hpp	/^    CV_WRAP void insert(const vector<Point2f>& ptvec);$/;"	p	class:cv::Subdiv2D	access:public	signature:(const vector<Point2f>& ptvec)
cv::Subdiv2D::isRightOf	imgproc/imgproc.hpp	/^    int isRightOf(Point2f pt, int edge) const;$/;"	p	class:cv::Subdiv2D	access:protected	signature:(Point2f pt, int edge) const
cv::Subdiv2D::locate	imgproc/imgproc.hpp	/^    CV_WRAP int locate(Point2f pt, CV_OUT int& edge, CV_OUT int& vertex);$/;"	p	class:cv::Subdiv2D	access:public	signature:(Point2f pt, CV_OUT int& edge, CV_OUT int& vertex)
cv::Subdiv2D::newEdge	imgproc/imgproc.hpp	/^    int newEdge();$/;"	p	class:cv::Subdiv2D	access:protected	signature:()
cv::Subdiv2D::newPoint	imgproc/imgproc.hpp	/^    int newPoint(Point2f pt, bool isvirtual, int firstEdge=0);$/;"	p	class:cv::Subdiv2D	access:protected	signature:(Point2f pt, bool isvirtual, int firstEdge=0)
cv::Subdiv2D::nextEdge	imgproc/imgproc.hpp	/^    CV_WRAP int nextEdge(int edge) const;$/;"	p	class:cv::Subdiv2D	access:public	signature:(int edge) const
cv::Subdiv2D::qedges	imgproc/imgproc.hpp	/^    vector<QuadEdge> qedges;$/;"	m	class:cv::Subdiv2D	access:protected
cv::Subdiv2D::recentEdge	imgproc/imgproc.hpp	/^    int recentEdge;$/;"	m	class:cv::Subdiv2D	access:protected
cv::Subdiv2D::rotateEdge	imgproc/imgproc.hpp	/^    CV_WRAP int rotateEdge(int edge, int rotate) const;$/;"	p	class:cv::Subdiv2D	access:public	signature:(int edge, int rotate) const
cv::Subdiv2D::setEdgePoints	imgproc/imgproc.hpp	/^    void setEdgePoints( int edge, int orgPt, int dstPt );$/;"	p	class:cv::Subdiv2D	access:protected	signature:( int edge, int orgPt, int dstPt )
cv::Subdiv2D::splice	imgproc/imgproc.hpp	/^    void splice( int edgeA, int edgeB );$/;"	p	class:cv::Subdiv2D	access:protected	signature:( int edgeA, int edgeB )
cv::Subdiv2D::swapEdges	imgproc/imgproc.hpp	/^    void swapEdges( int edge );$/;"	p	class:cv::Subdiv2D	access:protected	signature:( int edge )
cv::Subdiv2D::symEdge	imgproc/imgproc.hpp	/^    CV_WRAP int symEdge(int edge) const;$/;"	p	class:cv::Subdiv2D	access:public	signature:(int edge) const
cv::Subdiv2D::topLeft	imgproc/imgproc.hpp	/^    Point2f topLeft;$/;"	m	class:cv::Subdiv2D	access:protected
cv::Subdiv2D::validGeometry	imgproc/imgproc.hpp	/^    bool validGeometry;$/;"	m	class:cv::Subdiv2D	access:protected
cv::Subdiv2D::vtx	imgproc/imgproc.hpp	/^    vector<Vertex> vtx;$/;"	m	class:cv::Subdiv2D	access:protected
cv::SurfAdjuster	features2d/features2d.hpp	/^class CV_EXPORTS SurfAdjuster: public AdjusterAdapter$/;"	c	namespace:cv	inherits:AdjusterAdapter
cv::SurfAdjuster::SurfAdjuster	features2d/features2d.hpp	/^    SurfAdjuster( double initial_thresh=400.f, double min_thresh=2, double max_thresh=1000 );$/;"	p	class:cv::SurfAdjuster	access:public	signature:( double initial_thresh=400.f, double min_thresh=2, double max_thresh=1000 )
cv::SurfAdjuster::clone	features2d/features2d.hpp	/^    virtual Ptr<AdjusterAdapter> clone() const;$/;"	p	class:cv::SurfAdjuster	access:public	signature:() const
cv::SurfAdjuster::detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::SurfAdjuster	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::SurfAdjuster::good	features2d/features2d.hpp	/^    virtual bool good() const;$/;"	p	class:cv::SurfAdjuster	access:public	signature:() const
cv::SurfAdjuster::init_thresh_	features2d/features2d.hpp	/^    double thresh_, init_thresh_, min_thresh_, max_thresh_;$/;"	m	class:cv::SurfAdjuster	access:protected
cv::SurfAdjuster::max_thresh_	features2d/features2d.hpp	/^    double thresh_, init_thresh_, min_thresh_, max_thresh_;$/;"	m	class:cv::SurfAdjuster	access:protected
cv::SurfAdjuster::min_thresh_	features2d/features2d.hpp	/^    double thresh_, init_thresh_, min_thresh_, max_thresh_;$/;"	m	class:cv::SurfAdjuster	access:protected
cv::SurfAdjuster::thresh_	features2d/features2d.hpp	/^    double thresh_, init_thresh_, min_thresh_, max_thresh_;$/;"	m	class:cv::SurfAdjuster	access:protected
cv::SurfAdjuster::tooFew	features2d/features2d.hpp	/^    virtual void tooFew(int min, int n_detected);$/;"	p	class:cv::SurfAdjuster	access:public	signature:(int min, int n_detected)
cv::SurfAdjuster::tooMany	features2d/features2d.hpp	/^    virtual void tooMany(int max, int n_detected);$/;"	p	class:cv::SurfAdjuster	access:public	signature:(int max, int n_detected)
cv::SurfDescriptorExtractor	features2d/features2d.hpp	/^class CV_EXPORTS SurfDescriptorExtractor : public DescriptorExtractor$/;"	c	namespace:cv	inherits:DescriptorExtractor
cv::SurfDescriptorExtractor::SurfDescriptorExtractor	features2d/features2d.hpp	/^    SurfDescriptorExtractor( int nOctaves=4, int nOctaveLayers=2, bool extended=false, bool upright=false );$/;"	p	class:cv::SurfDescriptorExtractor	access:public	signature:( int nOctaves=4, int nOctaveLayers=2, bool extended=false, bool upright=false )
cv::SurfDescriptorExtractor::computeImpl	features2d/features2d.hpp	/^    virtual void computeImpl( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const;$/;"	p	class:cv::SurfDescriptorExtractor	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors ) const
cv::SurfDescriptorExtractor::descriptorSize	features2d/features2d.hpp	/^    virtual int descriptorSize() const;$/;"	p	class:cv::SurfDescriptorExtractor	access:public	signature:() const
cv::SurfDescriptorExtractor::descriptorType	features2d/features2d.hpp	/^    virtual int descriptorType() const;$/;"	p	class:cv::SurfDescriptorExtractor	access:public	signature:() const
cv::SurfDescriptorExtractor::read	features2d/features2d.hpp	/^    virtual void read( const FileNode &fn );$/;"	p	class:cv::SurfDescriptorExtractor	access:public	signature:( const FileNode &fn )
cv::SurfDescriptorExtractor::surf	features2d/features2d.hpp	/^    SURF surf;$/;"	m	class:cv::SurfDescriptorExtractor	access:protected
cv::SurfDescriptorExtractor::write	features2d/features2d.hpp	/^    virtual void write( FileStorage &fs ) const;$/;"	p	class:cv::SurfDescriptorExtractor	access:public	signature:( FileStorage &fs ) const
cv::SurfFeatureDetector	features2d/features2d.hpp	/^class CV_EXPORTS SurfFeatureDetector : public FeatureDetector$/;"	c	namespace:cv	inherits:FeatureDetector
cv::SurfFeatureDetector::SurfFeatureDetector	features2d/features2d.hpp	/^    SurfFeatureDetector( double hessianThreshold=400., int octaves=3, int octaveLayers=4, bool upright=false );$/;"	p	class:cv::SurfFeatureDetector	access:public	signature:( double hessianThreshold=400., int octaves=3, int octaveLayers=4, bool upright=false )
cv::SurfFeatureDetector::detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::SurfFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
cv::SurfFeatureDetector::read	features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::SurfFeatureDetector	access:public	signature:( const FileNode& fn )
cv::SurfFeatureDetector::surf	features2d/features2d.hpp	/^    SURF surf;$/;"	m	class:cv::SurfFeatureDetector	access:protected
cv::SurfFeatureDetector::write	features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::SurfFeatureDetector	access:public	signature:( FileStorage& fs ) const
cv::THRESH_BINARY	imgproc/imgproc.hpp	/^enum { THRESH_BINARY=CV_THRESH_BINARY, THRESH_BINARY_INV=CV_THRESH_BINARY_INV,$/;"	e	enum:cv::__anon16
cv::THRESH_BINARY_INV	imgproc/imgproc.hpp	/^enum { THRESH_BINARY=CV_THRESH_BINARY, THRESH_BINARY_INV=CV_THRESH_BINARY_INV,$/;"	e	enum:cv::__anon16
cv::THRESH_MASK	imgproc/imgproc.hpp	/^       THRESH_TOZERO_INV=CV_THRESH_TOZERO_INV, THRESH_MASK=CV_THRESH_MASK,$/;"	e	enum:cv::__anon16
cv::THRESH_OTSU	imgproc/imgproc.hpp	/^       THRESH_OTSU=CV_THRESH_OTSU };$/;"	e	enum:cv::__anon16
cv::THRESH_TOZERO	imgproc/imgproc.hpp	/^       THRESH_TRUNC=CV_THRESH_TRUNC, THRESH_TOZERO=CV_THRESH_TOZERO,$/;"	e	enum:cv::__anon16
cv::THRESH_TOZERO_INV	imgproc/imgproc.hpp	/^       THRESH_TOZERO_INV=CV_THRESH_TOZERO_INV, THRESH_MASK=CV_THRESH_MASK,$/;"	e	enum:cv::__anon16
cv::THRESH_TRUNC	imgproc/imgproc.hpp	/^       THRESH_TRUNC=CV_THRESH_TRUNC, THRESH_TOZERO=CV_THRESH_TOZERO,$/;"	e	enum:cv::__anon16
cv::TM_CCOEFF	imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon24
cv::TM_CCOEFF_NORMED	imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon24
cv::TM_CCORR	imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon24
cv::TM_CCORR_NORMED	imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon24
cv::TM_SQDIFF	imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon24
cv::TM_SQDIFF_NORMED	imgproc/imgproc.hpp	/^enum { TM_SQDIFF=0, TM_SQDIFF_NORMED=1, TM_CCORR=2, TM_CCORR_NORMED=3, TM_CCOEFF=4, TM_CCOEFF_NORMED=5 };$/;"	e	enum:cv::__anon24
cv::TYPE_MASK	core/core.hpp	/^enum { MAGIC_MASK=0xFFFF0000, TYPE_MASK=0x00000FFF, DEPTH_MASK=7 };$/;"	e	enum:cv::__anon136
cv::TermCriteria	core/core.hpp	/^class CV_EXPORTS TermCriteria$/;"	c	namespace:cv
cv::TermCriteria::COUNT	core/core.hpp	/^        COUNT=1, \/\/!< the maximum number of iterations or elements to compute$/;"	e	enum:cv::TermCriteria::__anon139
cv::TermCriteria::EPS	core/core.hpp	/^        EPS=2 \/\/!< the desired accuracy or change in parameters at which the iterative algorithm stops$/;"	e	enum:cv::TermCriteria::__anon139
cv::TermCriteria::MAX_ITER	core/core.hpp	/^        MAX_ITER=COUNT, \/\/!< ditto$/;"	e	enum:cv::TermCriteria::__anon139
cv::TermCriteria::TermCriteria	core/core.hpp	/^    TermCriteria();$/;"	p	class:cv::TermCriteria	access:public	signature:()
cv::TermCriteria::TermCriteria	core/core.hpp	/^    TermCriteria(const CvTermCriteria& criteria);$/;"	p	class:cv::TermCriteria	access:public	signature:(const CvTermCriteria& criteria)
cv::TermCriteria::TermCriteria	core/core.hpp	/^    TermCriteria(int _type, int _maxCount, double _epsilon);$/;"	p	class:cv::TermCriteria	access:public	signature:(int _type, int _maxCount, double _epsilon)
cv::TermCriteria::TermCriteria	core/operations.hpp	/^inline TermCriteria::TermCriteria() : type(0), maxCount(0), epsilon(0) {}$/;"	f	class:cv::TermCriteria	signature:()
cv::TermCriteria::TermCriteria	core/operations.hpp	/^inline TermCriteria::TermCriteria(const CvTermCriteria& criteria)$/;"	f	class:cv::TermCriteria	signature:(const CvTermCriteria& criteria)
cv::TermCriteria::TermCriteria	core/operations.hpp	/^inline TermCriteria::TermCriteria(int _type, int _maxCount, double _epsilon)$/;"	f	class:cv::TermCriteria	signature:(int _type, int _maxCount, double _epsilon)
cv::TermCriteria::epsilon	core/core.hpp	/^    double epsilon; \/\/ the desired accuracy$/;"	m	class:cv::TermCriteria	access:public
cv::TermCriteria::maxCount	core/core.hpp	/^    int maxCount; \/\/ the maximum number of iterations\/elements$/;"	m	class:cv::TermCriteria	access:public
cv::TermCriteria::operator CvTermCriteria	core/core.hpp	/^    operator CvTermCriteria() const;$/;"	p	class:cv::TermCriteria	access:public	signature:() const
cv::TermCriteria::operator CvTermCriteria	core/operations.hpp	/^inline TermCriteria::operator CvTermCriteria() const$/;"	f	class:cv::TermCriteria	signature:() const
cv::TermCriteria::type	core/core.hpp	/^    int type; \/\/!< the type of termination criteria: COUNT, EPS or COUNT + EPS$/;"	m	class:cv::TermCriteria	access:public
cv::TickMeter	contrib/contrib.hpp	/^    class CV_EXPORTS TickMeter$/;"	c	namespace:cv
cv::TickMeter::TickMeter	contrib/contrib.hpp	/^        TickMeter();$/;"	p	class:cv::TickMeter	access:public	signature:()
cv::TickMeter::counter	contrib/contrib.hpp	/^        int64 counter;$/;"	m	class:cv::TickMeter	access:private
cv::TickMeter::getCounter	contrib/contrib.hpp	/^        int64 getCounter() const;$/;"	p	class:cv::TickMeter	access:public	signature:() const
cv::TickMeter::getTimeMicro	contrib/contrib.hpp	/^        double getTimeMicro() const;$/;"	p	class:cv::TickMeter	access:public	signature:() const
cv::TickMeter::getTimeMilli	contrib/contrib.hpp	/^        double getTimeMilli() const;$/;"	p	class:cv::TickMeter	access:public	signature:() const
cv::TickMeter::getTimeSec	contrib/contrib.hpp	/^        double getTimeSec()   const;$/;"	p	class:cv::TickMeter	access:public	signature:() const
cv::TickMeter::getTimeTicks	contrib/contrib.hpp	/^        int64 getTimeTicks() const;$/;"	p	class:cv::TickMeter	access:public	signature:() const
cv::TickMeter::reset	contrib/contrib.hpp	/^        void reset();$/;"	p	class:cv::TickMeter	access:public	signature:()
cv::TickMeter::start	contrib/contrib.hpp	/^        void start();$/;"	p	class:cv::TickMeter	access:public	signature:()
cv::TickMeter::startTime	contrib/contrib.hpp	/^        int64 startTime;$/;"	m	class:cv::TickMeter	access:private
cv::TickMeter::stop	contrib/contrib.hpp	/^        void stop();$/;"	p	class:cv::TickMeter	access:public	signature:()
cv::TickMeter::sumTime	contrib/contrib.hpp	/^        int64 sumTime;$/;"	m	class:cv::TickMeter	access:private
cv::TrackbarCallback	highgui/highgui.hpp	/^typedef void (CV_CDECL *TrackbarCallback)(int pos, void* userdata);$/;"	t	namespace:cv
cv::TrainData	ml/ml.hpp	/^typedef CvMLData TrainData;$/;"	t	namespace:cv
cv::Vec	core/core.hpp	/^template<typename _Tp, int cn> class CV_EXPORTS Vec : public Matx<_Tp, cn, 1>$/;"	c	namespace:cv	inherits:Matx
cv::Vec	core/core.hpp	/^template<typename _Tp, int cn> class CV_EXPORTS Vec;$/;"	m	namespace:cv	typeref:class:cv::CV_EXPORTS
cv::Vec2b	core/core.hpp	/^typedef Vec<uchar, 2> Vec2b;$/;"	t	namespace:cv
cv::Vec2d	core/core.hpp	/^typedef Vec<double, 2> Vec2d;$/;"	t	namespace:cv
cv::Vec2f	core/core.hpp	/^typedef Vec<float, 2> Vec2f;$/;"	t	namespace:cv
cv::Vec2i	core/core.hpp	/^typedef Vec<int, 2> Vec2i;$/;"	t	namespace:cv
cv::Vec2s	core/core.hpp	/^typedef Vec<short, 2> Vec2s;$/;"	t	namespace:cv
cv::Vec2w	core/core.hpp	/^typedef Vec<ushort, 2> Vec2w;$/;"	t	namespace:cv
cv::Vec3b	core/core.hpp	/^typedef Vec<uchar, 3> Vec3b;$/;"	t	namespace:cv
cv::Vec3d	core/core.hpp	/^typedef Vec<double, 3> Vec3d;$/;"	t	namespace:cv
cv::Vec3f	core/core.hpp	/^typedef Vec<float, 3> Vec3f;$/;"	t	namespace:cv
cv::Vec3i	core/core.hpp	/^typedef Vec<int, 3> Vec3i;$/;"	t	namespace:cv
cv::Vec3s	core/core.hpp	/^typedef Vec<short, 3> Vec3s;$/;"	t	namespace:cv
cv::Vec3w	core/core.hpp	/^typedef Vec<ushort, 3> Vec3w;$/;"	t	namespace:cv
cv::Vec4b	core/core.hpp	/^typedef Vec<uchar, 4> Vec4b;$/;"	t	namespace:cv
cv::Vec4d	core/core.hpp	/^typedef Vec<double, 4> Vec4d;$/;"	t	namespace:cv
cv::Vec4f	core/core.hpp	/^typedef Vec<float, 4> Vec4f;$/;"	t	namespace:cv
cv::Vec4i	core/core.hpp	/^typedef Vec<int, 4> Vec4i;$/;"	t	namespace:cv
cv::Vec4s	core/core.hpp	/^typedef Vec<short, 4> Vec4s;$/;"	t	namespace:cv
cv::Vec4w	core/core.hpp	/^typedef Vec<ushort, 4> Vec4w;    $/;"	t	namespace:cv
cv::Vec6d	core/core.hpp	/^typedef Vec<double, 6> Vec6d;$/;"	t	namespace:cv
cv::Vec6f	core/core.hpp	/^typedef Vec<float, 6> Vec6f;$/;"	t	namespace:cv
cv::Vec6i	core/core.hpp	/^typedef Vec<int, 6> Vec6i;$/;"	t	namespace:cv
cv::Vec8i	core/core.hpp	/^typedef Vec<int, 8> Vec8i;$/;"	t	namespace:cv
cv::Vec::Vec	core/core.hpp	/^    Vec();$/;"	p	class:cv::Vec	access:public	signature:()
cv::Vec::Vec	core/core.hpp	/^    Vec(_Tp v0); \/\/!< 1-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0)
cv::Vec::Vec	core/core.hpp	/^    Vec(_Tp v0, _Tp v1); \/\/!< 2-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1)
cv::Vec::Vec	core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2); \/\/!< 3-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2)
cv::Vec::Vec	core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3); \/\/!< 4-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
cv::Vec::Vec	core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4); \/\/!< 5-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)
cv::Vec::Vec	core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5); \/\/!< 6-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)
cv::Vec::Vec	core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6); \/\/!< 7-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6)
cv::Vec::Vec	core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7); \/\/!< 8-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7)
cv::Vec::Vec	core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8); \/\/!< 9-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8)
cv::Vec::Vec	core/core.hpp	/^    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9); \/\/!< 10-element vector constructor$/;"	p	class:cv::Vec	access:public	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9)
cv::Vec::Vec	core/core.hpp	/^    Vec(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_AddOp);$/;"	p	class:cv::Vec	access:public	signature:(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_AddOp)
cv::Vec::Vec	core/core.hpp	/^    Vec(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_SubOp);$/;"	p	class:cv::Vec	access:public	signature:(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_SubOp)
cv::Vec::Vec	core/core.hpp	/^    Vec(const Vec<_Tp, cn>& v);$/;"	p	class:cv::Vec	access:public	signature:(const Vec<_Tp, cn>& v)
cv::Vec::Vec	core/core.hpp	/^    explicit Vec(const _Tp* values);$/;"	p	class:cv::Vec	access:public	signature:(const _Tp* values)
cv::Vec::Vec	core/core.hpp	/^    template<typename _T2> Vec(const Matx<_Tp, cn, 1>& a, _T2 alpha, Matx_ScaleOp);$/;"	p	class:cv::Vec	access:public	signature:(const Matx<_Tp, cn, 1>& a, _T2 alpha, Matx_ScaleOp)
cv::Vec::Vec	core/operations.hpp	/^Vec<_Tp, cn>::Vec(const Matx<_Tp, cn, 1>& a, _T2 alpha, Matx_ScaleOp op)$/;"	f	class:cv::Vec	signature:(const Matx<_Tp, cn, 1>& a, _T2 alpha, Matx_ScaleOp op)
cv::Vec::Vec	core/operations.hpp	/^Vec<_Tp, cn>::Vec(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_AddOp op)$/;"	f	class:cv::Vec	signature:(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_AddOp op)
cv::Vec::Vec	core/operations.hpp	/^Vec<_Tp, cn>::Vec(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_SubOp op)$/;"	f	class:cv::Vec	signature:(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_SubOp op)
cv::Vec::Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec()$/;"	f	class:cv::Vec	signature:()
cv::Vec::Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0)$/;"	f	class:cv::Vec	signature:(_Tp v0)
cv::Vec::Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1)$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1)
cv::Vec::Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2)$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2)
cv::Vec::Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3)$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
cv::Vec::Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)
cv::Vec::Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)
cv::Vec::Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6)
cv::Vec::Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7)
cv::Vec::Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8)
cv::Vec::Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3,$/;"	f	class:cv::Vec	signature:(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9)
cv::Vec::Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(const Vec<_Tp, cn>& m)$/;"	f	class:cv::Vec	signature:(const Vec<_Tp, cn>& m)
cv::Vec::Vec	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::Vec(const _Tp* values)$/;"	f	class:cv::Vec	signature:(const _Tp* values)
cv::Vec::all	core/core.hpp	/^    static Vec all(_Tp alpha);$/;"	p	class:cv::Vec	access:public	signature:(_Tp alpha)
cv::Vec::all	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn> Vec<_Tp, cn>::all(_Tp alpha)$/;"	f	class:cv::Vec	signature:(_Tp alpha)
cv::Vec::channels	core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, channels = cn, type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::Vec::__anon114
cv::Vec::cross	core/core.hpp	/^    Vec cross(const Vec& v) const;$/;"	p	class:cv::Vec	access:public	signature:(const Vec& v) const
cv::Vec::cross	core/operations.hpp	/^template<> inline Vec<double, 3> Vec<double, 3>::cross(const Vec<double, 3>& v) const$/;"	f	class:cv::Vec	signature:(const Vec<double, 3>& v) const
cv::Vec::cross	core/operations.hpp	/^template<> inline Vec<float, 3> Vec<float, 3>::cross(const Vec<float, 3>& v) const$/;"	f	class:cv::Vec	signature:(const Vec<float, 3>& v) const
cv::Vec::cross	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn> Vec<_Tp, cn>::cross(const Vec<_Tp, cn>& v) const$/;"	f	class:cv::Vec	signature:(const Vec<_Tp, cn>& v) const
cv::Vec::depth	core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, channels = cn, type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::Vec::__anon114
cv::Vec::mul	core/core.hpp	/^    Vec mul(const Vec<_Tp, cn>& v) const;$/;"	p	class:cv::Vec	access:public	signature:(const Vec<_Tp, cn>& v) const
cv::Vec::mul	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn> Vec<_Tp, cn>::mul(const Vec<_Tp, cn>& v) const$/;"	f	class:cv::Vec	signature:(const Vec<_Tp, cn>& v) const
cv::Vec::operator ()	core/core.hpp	/^    _Tp& operator ()(int i);$/;"	p	class:cv::Vec	access:public	signature:(int i)
cv::Vec::operator ()	core/core.hpp	/^    const _Tp& operator ()(int i) const;$/;"	p	class:cv::Vec	access:public	signature:(int i) const
cv::Vec::operator ()	core/operations.hpp	/^template<typename _Tp, int cn> inline _Tp& Vec<_Tp, cn>::operator ()(int i)$/;"	f	class:cv::Vec	signature:(int i)
cv::Vec::operator ()	core/operations.hpp	/^template<typename _Tp, int cn> inline const _Tp& Vec<_Tp, cn>::operator ()(int i) const$/;"	f	class:cv::Vec	signature:(int i) const
cv::Vec::operator CvScalar	core/core.hpp	/^    operator CvScalar() const;$/;"	p	class:cv::Vec	access:public	signature:() const
cv::Vec::operator CvScalar	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::operator CvScalar() const$/;"	f	class:cv::Vec	signature:() const
cv::Vec::operator Vec<T2, cn>	core/core.hpp	/^    template<typename T2> operator Vec<T2, cn>() const;$/;"	p	class:cv::Vec	access:public	signature:() const
cv::Vec::operator Vec<T2, cn>	core/operations.hpp	/^inline Vec<_Tp, cn>::operator Vec<T2, cn>() const$/;"	f	class:cv::Vec	signature:() const
cv::Vec::operator []	core/core.hpp	/^    _Tp& operator[](int i);$/;"	p	class:cv::Vec	access:public	signature:(int i)
cv::Vec::operator []	core/core.hpp	/^    const _Tp& operator [](int i) const;$/;"	p	class:cv::Vec	access:public	signature:(int i) const
cv::Vec::operator []	core/operations.hpp	/^template<typename _Tp, int cn> inline _Tp& Vec<_Tp, cn>::operator [](int i)$/;"	f	class:cv::Vec	signature:(int i)
cv::Vec::operator []	core/operations.hpp	/^template<typename _Tp, int cn> inline const _Tp& Vec<_Tp, cn>::operator [](int i) const$/;"	f	class:cv::Vec	signature:(int i) const
cv::Vec::type	core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, channels = cn, type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::Vec::__anon114
cv::Vec::value_type	core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Vec	access:public
cv::VecCommaInitializer	core/core.hpp	/^template<typename _Tp, int m> class CV_EXPORTS VecCommaInitializer : public MatxCommaInitializer<_Tp, m, 1>$/;"	c	namespace:cv	inherits:MatxCommaInitializer
cv::VecCommaInitializer::VecCommaInitializer	core/core.hpp	/^    VecCommaInitializer(Vec<_Tp, m>* _vec);$/;"	p	class:cv::VecCommaInitializer	access:public	signature:(Vec<_Tp, m>* _vec)
cv::VecCommaInitializer::VecCommaInitializer	core/operations.hpp	/^VecCommaInitializer<_Tp, cn>::VecCommaInitializer(Vec<_Tp, cn>* _vec)$/;"	f	class:cv::VecCommaInitializer	signature:(Vec<_Tp, cn>* _vec)
cv::VecCommaInitializer::operator *	core/core.hpp	/^    Vec<_Tp, m> operator *() const;$/;"	p	class:cv::VecCommaInitializer	access:public	signature:() const
cv::VecCommaInitializer::operator *	core/operations.hpp	/^Vec<_Tp, cn> VecCommaInitializer<_Tp, cn>::operator *() const$/;"	f	class:cv::VecCommaInitializer	signature:() const
cv::VecCommaInitializer::operator ,	core/core.hpp	/^    template<typename T2> VecCommaInitializer<_Tp, m>& operator , (T2 val);$/;"	p	class:cv::VecCommaInitializer	access:public	signature:(T2 val)
cv::VecCommaInitializer::operator ,	core/operations.hpp	/^VecCommaInitializer<_Tp, cn>& VecCommaInitializer<_Tp, cn>::operator , (_T2 value)$/;"	f	class:cv::VecCommaInitializer	signature:(_T2 value)
cv::VecReaderProxy	core/operations.hpp	/^template<typename _Tp, int numflag> class CV_EXPORTS VecReaderProxy$/;"	c	namespace:cv
cv::VecReaderProxy	core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS VecReaderProxy<_Tp,1>$/;"	c	namespace:cv
cv::VecReaderProxy::VecReaderProxy	core/operations.hpp	/^    VecReaderProxy( FileNodeIterator* _it ) : it(_it) {}$/;"	f	class:cv::VecReaderProxy	access:public	signature:( FileNodeIterator* _it )
cv::VecReaderProxy::it	core/operations.hpp	/^    FileNodeIterator* it;$/;"	m	class:cv::VecReaderProxy	access:public
cv::VecReaderProxy::operator ()	core/operations.hpp	/^    void operator()(vector<_Tp>& vec, size_t count) const$/;"	f	class:cv::VecReaderProxy	access:public	signature:(vector<_Tp>& vec, size_t count) const
cv::VecWriterProxy	core/operations.hpp	/^template<typename _Tp, int numflag> class CV_EXPORTS VecWriterProxy$/;"	c	namespace:cv
cv::VecWriterProxy	core/operations.hpp	/^template<typename _Tp> class CV_EXPORTS VecWriterProxy<_Tp,1>$/;"	c	namespace:cv
cv::VecWriterProxy::VecWriterProxy	core/operations.hpp	/^    VecWriterProxy( FileStorage* _fs ) : fs(_fs) {}$/;"	f	class:cv::VecWriterProxy	access:public	signature:( FileStorage* _fs )
cv::VecWriterProxy::fs	core/operations.hpp	/^    FileStorage* fs;$/;"	m	class:cv::VecWriterProxy	access:public
cv::VecWriterProxy::operator ()	core/operations.hpp	/^    void operator()(const vector<_Tp>& vec) const$/;"	f	class:cv::VecWriterProxy	access:public	signature:(const vector<_Tp>& vec) const
cv::Vector	core/operations.hpp	/^template <typename _Tp> class CV_EXPORTS Vector$/;"	c	namespace:cv
cv::Vector::Hdr	core/operations.hpp	/^    struct CV_EXPORTS Hdr$/;"	s	class:cv::Vector	access:public
cv::Vector::Hdr::Hdr	core/operations.hpp	/^        Hdr() : data(0), datastart(0), refcount(0), size(0), capacity(0) {};$/;"	f	struct:cv::Vector::Hdr	access:public	signature:()
cv::Vector::Hdr::capacity	core/operations.hpp	/^        size_t capacity;$/;"	m	struct:cv::Vector::Hdr	access:public
cv::Vector::Hdr::data	core/operations.hpp	/^        _Tp* data;$/;"	m	struct:cv::Vector::Hdr	access:public
cv::Vector::Hdr::datastart	core/operations.hpp	/^        _Tp* datastart;$/;"	m	struct:cv::Vector::Hdr	access:public
cv::Vector::Hdr::refcount	core/operations.hpp	/^        int* refcount;$/;"	m	struct:cv::Vector::Hdr	access:public
cv::Vector::Hdr::size	core/operations.hpp	/^        size_t size;$/;"	m	struct:cv::Vector::Hdr	access:public
cv::Vector::Vector	core/operations.hpp	/^    Vector() {}$/;"	f	class:cv::Vector	access:public	signature:()
cv::Vector::Vector	core/operations.hpp	/^    Vector(_Tp* _data, size_t _size, bool _copyData=false)$/;"	f	class:cv::Vector	access:public	signature:(_Tp* _data, size_t _size, bool _copyData=false)
cv::Vector::Vector	core/operations.hpp	/^    Vector(const Vector& d) { *this = d; }$/;"	f	class:cv::Vector	access:public	signature:(const Vector& d)
cv::Vector::Vector	core/operations.hpp	/^    Vector(const Vector& d, const Range& r_)$/;"	f	class:cv::Vector	access:public	signature:(const Vector& d, const Range& r_)
cv::Vector::Vector	core/operations.hpp	/^    Vector(const std::vector<_Tp>& vec, bool _copyData=false)$/;"	f	class:cv::Vector	access:public	signature:(const std::vector<_Tp>& vec, bool _copyData=false)
cv::Vector::Vector	core/operations.hpp	/^    Vector(size_t _size)  { resize(_size); }$/;"	f	class:cv::Vector	access:public	signature:(size_t _size)
cv::Vector::Vector	core/operations.hpp	/^    Vector(size_t _size, const _Tp& val)$/;"	f	class:cv::Vector	access:public	signature:(size_t _size, const _Tp& val)
cv::Vector::Vector	core/operations.hpp	/^    template<int n> Vector(const Vec<_Tp, n>& vec)$/;"	f	class:cv::Vector	access:public	signature:(const Vec<_Tp, n>& vec)
cv::Vector::addref	core/operations.hpp	/^    void addref() { if( hdr.refcount ) CV_XADD(hdr.refcount, 1); }$/;"	f	class:cv::Vector	access:public	signature:()
cv::Vector::back	core/operations.hpp	/^    _Tp& back() { CV_DbgAssert(!empty()); return hdr.data[hdr.size-1]; }$/;"	f	class:cv::Vector	access:public	signature:()
cv::Vector::back	core/operations.hpp	/^    const _Tp& back() const { CV_DbgAssert(!empty()); return hdr.data[hdr.size-1]; }$/;"	f	class:cv::Vector	access:public	signature:() const
cv::Vector::begin	core/operations.hpp	/^    _Tp* begin() { return hdr.data; }$/;"	f	class:cv::Vector	access:public	signature:()
cv::Vector::begin	core/operations.hpp	/^    const _Tp* begin() const { return hdr.data; }$/;"	f	class:cv::Vector	access:public	signature:() const
cv::Vector::capacity	core/operations.hpp	/^    size_t capacity() const { return hdr.capacity; }$/;"	f	class:cv::Vector	access:public	signature:() const
cv::Vector::clear	core/operations.hpp	/^    void clear() { resize(0); }$/;"	f	class:cv::Vector	access:public	signature:()
cv::Vector::clone	core/operations.hpp	/^    Vector<_Tp> clone() const$/;"	f	class:cv::Vector	access:public	signature:() const
cv::Vector::const_iterator	core/operations.hpp	/^    typedef const _Tp* const_iterator;$/;"	t	class:cv::Vector	access:public
cv::Vector::const_reference	core/operations.hpp	/^    typedef const _Tp& const_reference;$/;"	t	class:cv::Vector	access:public
cv::Vector::copyTo	core/operations.hpp	/^    void copyTo(Vector<_Tp>& vec) const$/;"	f	class:cv::Vector	access:public	signature:(Vector<_Tp>& vec) const
cv::Vector::copyTo	core/operations.hpp	/^    void copyTo(std::vector<_Tp>& vec) const$/;"	f	class:cv::Vector	access:public	signature:(std::vector<_Tp>& vec) const
cv::Vector::empty	core/operations.hpp	/^    bool empty() const { return hdr.size == 0; }$/;"	f	class:cv::Vector	access:public	signature:() const
cv::Vector::end	core/operations.hpp	/^    _Tp* end() { return hdr.data + hdr.size; }$/;"	f	class:cv::Vector	access:public	signature:()
cv::Vector::end	core/operations.hpp	/^    const _Tp* end() const { return hdr.data + hdr.size; }$/;"	f	class:cv::Vector	access:public	signature:() const
cv::Vector::front	core/operations.hpp	/^    _Tp& front() { CV_DbgAssert(!empty()); return hdr.data[0]; }$/;"	f	class:cv::Vector	access:public	signature:()
cv::Vector::front	core/operations.hpp	/^    const _Tp& front() const { CV_DbgAssert(!empty()); return hdr.data[0]; }$/;"	f	class:cv::Vector	access:public	signature:() const
cv::Vector::hdr	core/operations.hpp	/^    Hdr hdr;$/;"	m	class:cv::Vector	access:protected
cv::Vector::iterator	core/operations.hpp	/^    typedef _Tp* iterator;$/;"	t	class:cv::Vector	access:public
cv::Vector::operator ()	core/operations.hpp	/^    Vector operator() (const Range& r) const { return Vector(*this, r); }$/;"	f	class:cv::Vector	access:public	signature:(const Range& r) const
cv::Vector::operator =	core/operations.hpp	/^    Vector<_Tp>& operator = (const Vector& d)$/;"	f	class:cv::Vector	access:public	signature:(const Vector& d)
cv::Vector::operator CvMat	core/operations.hpp	/^    operator CvMat() const$/;"	f	class:cv::Vector	access:public	signature:() const
cv::Vector::operator []	core/operations.hpp	/^    _Tp& operator [] (size_t i) { CV_DbgAssert( i < size() ); return hdr.data[i]; }$/;"	f	class:cv::Vector	access:public	signature:(size_t i)
cv::Vector::operator []	core/operations.hpp	/^    const _Tp& operator [] (size_t i) const { CV_DbgAssert( i < size() ); return hdr.data[i]; }$/;"	f	class:cv::Vector	access:public	signature:(size_t i) const
cv::Vector::pop_back	core/operations.hpp	/^    Vector<_Tp>& pop_back()$/;"	f	class:cv::Vector	access:public	signature:()
cv::Vector::push_back	core/operations.hpp	/^    Vector<_Tp>& push_back(const _Tp& elem)$/;"	f	class:cv::Vector	access:public	signature:(const _Tp& elem)
cv::Vector::reference	core/operations.hpp	/^    typedef _Tp& reference;$/;"	t	class:cv::Vector	access:public
cv::Vector::release	core/operations.hpp	/^    void release()$/;"	f	class:cv::Vector	access:public	signature:()
cv::Vector::reserve	core/operations.hpp	/^    void reserve(size_t newCapacity)$/;"	f	class:cv::Vector	access:public	signature:(size_t newCapacity)
cv::Vector::resize	core/operations.hpp	/^    void resize(size_t newSize)$/;"	f	class:cv::Vector	access:public	signature:(size_t newSize)
cv::Vector::set	core/operations.hpp	/^    void set(_Tp* _data, size_t _size, bool _copyData=false)$/;"	f	class:cv::Vector	access:public	signature:(_Tp* _data, size_t _size, bool _copyData=false)
cv::Vector::size	core/operations.hpp	/^    size_t size() const { return hdr.size; }$/;"	f	class:cv::Vector	access:public	signature:() const
cv::Vector::type	core/operations.hpp	/^    int type() const { return DataType<_Tp>::type; }$/;"	f	class:cv::Vector	access:public	signature:() const
cv::Vector::value_type	core/operations.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Vector	access:public
cv::Vector::~Vector	core/operations.hpp	/^    ~Vector()  { release(); }$/;"	f	class:cv::Vector	access:public	signature:()
cv::VectorDescriptorMatch	features2d/features2d.hpp	/^typedef VectorDescriptorMatcher VectorDescriptorMatch;$/;"	t	namespace:cv
cv::VectorDescriptorMatcher	features2d/features2d.hpp	/^class CV_EXPORTS VectorDescriptorMatcher : public GenericDescriptorMatcher$/;"	c	namespace:cv	inherits:GenericDescriptorMatcher
cv::VectorDescriptorMatcher::VectorDescriptorMatcher	features2d/features2d.hpp	/^    VectorDescriptorMatcher( const Ptr<DescriptorExtractor>& extractor, const Ptr<DescriptorMatcher>& matcher );$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:( const Ptr<DescriptorExtractor>& extractor, const Ptr<DescriptorMatcher>& matcher )
cv::VectorDescriptorMatcher::add	features2d/features2d.hpp	/^    virtual void add( const vector<Mat>& imgCollection,$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:( const vector<Mat>& imgCollection, vector<vector<KeyPoint> >& pointCollection )
cv::VectorDescriptorMatcher::clear	features2d/features2d.hpp	/^    virtual void clear();$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:()
cv::VectorDescriptorMatcher::clone	features2d/features2d.hpp	/^    virtual Ptr<GenericDescriptorMatcher> clone( bool emptyTrainData=false ) const;$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:( bool emptyTrainData=false ) const
cv::VectorDescriptorMatcher::empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:() const
cv::VectorDescriptorMatcher::extractor	features2d/features2d.hpp	/^    Ptr<DescriptorExtractor> extractor;$/;"	m	class:cv::VectorDescriptorMatcher	access:protected
cv::VectorDescriptorMatcher::isMaskSupported	features2d/features2d.hpp	/^    virtual bool isMaskSupported();$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:()
cv::VectorDescriptorMatcher::knnMatchImpl	features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::VectorDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
cv::VectorDescriptorMatcher::matcher	features2d/features2d.hpp	/^    Ptr<DescriptorMatcher> matcher;$/;"	m	class:cv::VectorDescriptorMatcher	access:protected
cv::VectorDescriptorMatcher::radiusMatchImpl	features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::VectorDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
cv::VectorDescriptorMatcher::read	features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:( const FileNode& fn )
cv::VectorDescriptorMatcher::train	features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:()
cv::VectorDescriptorMatcher::write	features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:( FileStorage& fs ) const
cv::VectorDescriptorMatcher::~VectorDescriptorMatcher	features2d/features2d.hpp	/^    virtual ~VectorDescriptorMatcher();$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:()
cv::VideoCapture	highgui/highgui.hpp	/^class CV_EXPORTS_W VideoCapture$/;"	c	namespace:cv
cv::VideoCapture::VideoCapture	highgui/highgui.hpp	/^    CV_WRAP VideoCapture();$/;"	p	class:cv::VideoCapture	access:public	signature:()
cv::VideoCapture::VideoCapture	highgui/highgui.hpp	/^    CV_WRAP VideoCapture(const string& filename);$/;"	p	class:cv::VideoCapture	access:public	signature:(const string& filename)
cv::VideoCapture::VideoCapture	highgui/highgui.hpp	/^    CV_WRAP VideoCapture(int device);$/;"	p	class:cv::VideoCapture	access:public	signature:(int device)
cv::VideoCapture::cap	highgui/highgui.hpp	/^    Ptr<CvCapture> cap;$/;"	m	class:cv::VideoCapture	access:protected
cv::VideoCapture::get	highgui/highgui.hpp	/^    CV_WRAP virtual double get(int propId);$/;"	p	class:cv::VideoCapture	access:public	signature:(int propId)
cv::VideoCapture::grab	highgui/highgui.hpp	/^    CV_WRAP virtual bool grab();$/;"	p	class:cv::VideoCapture	access:public	signature:()
cv::VideoCapture::isOpened	highgui/highgui.hpp	/^    CV_WRAP virtual bool isOpened() const;$/;"	p	class:cv::VideoCapture	access:public	signature:() const
cv::VideoCapture::open	highgui/highgui.hpp	/^    CV_WRAP virtual bool open(const string& filename);$/;"	p	class:cv::VideoCapture	access:public	signature:(const string& filename)
cv::VideoCapture::open	highgui/highgui.hpp	/^    CV_WRAP virtual bool open(int device);$/;"	p	class:cv::VideoCapture	access:public	signature:(int device)
cv::VideoCapture::operator >>	highgui/highgui.hpp	/^    virtual VideoCapture& operator >> (CV_OUT Mat& image);$/;"	p	class:cv::VideoCapture	access:public	signature:(CV_OUT Mat& image)
cv::VideoCapture::read	highgui/highgui.hpp	/^    CV_WRAP virtual bool read(CV_OUT Mat& image);$/;"	p	class:cv::VideoCapture	access:public	signature:(CV_OUT Mat& image)
cv::VideoCapture::release	highgui/highgui.hpp	/^    CV_WRAP virtual void release();$/;"	p	class:cv::VideoCapture	access:public	signature:()
cv::VideoCapture::retrieve	highgui/highgui.hpp	/^    CV_WRAP virtual bool retrieve(CV_OUT Mat& image, int channel=0);$/;"	p	class:cv::VideoCapture	access:public	signature:(CV_OUT Mat& image, int channel=0)
cv::VideoCapture::set	highgui/highgui.hpp	/^    CV_WRAP virtual bool set(int propId, double value);$/;"	p	class:cv::VideoCapture	access:public	signature:(int propId, double value)
cv::VideoCapture::~VideoCapture	highgui/highgui.hpp	/^    virtual ~VideoCapture();$/;"	p	class:cv::VideoCapture	access:public	signature:()
cv::VideoWriter	highgui/highgui.hpp	/^class CV_EXPORTS_W VideoWriter$/;"	c	namespace:cv
cv::VideoWriter::VideoWriter	highgui/highgui.hpp	/^    CV_WRAP VideoWriter();$/;"	p	class:cv::VideoWriter	access:public	signature:()
cv::VideoWriter::VideoWriter	highgui/highgui.hpp	/^    CV_WRAP VideoWriter(const string& filename, int fourcc, double fps,$/;"	p	class:cv::VideoWriter	access:public	signature:(const string& filename, int fourcc, double fps, Size frameSize, bool isColor=true)
cv::VideoWriter::isOpened	highgui/highgui.hpp	/^    CV_WRAP virtual bool isOpened() const;$/;"	p	class:cv::VideoWriter	access:public	signature:() const
cv::VideoWriter::open	highgui/highgui.hpp	/^    CV_WRAP virtual bool open(const string& filename, int fourcc, double fps,$/;"	p	class:cv::VideoWriter	access:public	signature:(const string& filename, int fourcc, double fps, Size frameSize, bool isColor=true)
cv::VideoWriter::operator <<	highgui/highgui.hpp	/^    virtual VideoWriter& operator << (const Mat& image);$/;"	p	class:cv::VideoWriter	access:public	signature:(const Mat& image)
cv::VideoWriter::write	highgui/highgui.hpp	/^    CV_WRAP virtual void write(const Mat& image);$/;"	p	class:cv::VideoWriter	access:public	signature:(const Mat& image)
cv::VideoWriter::writer	highgui/highgui.hpp	/^    Ptr<CvVideoWriter> writer;$/;"	m	class:cv::VideoWriter	access:protected
cv::VideoWriter::~VideoWriter	highgui/highgui.hpp	/^    virtual ~VideoWriter();$/;"	p	class:cv::VideoWriter	access:public	signature:()
cv::WARP_INVERSE_MAP	imgproc/imgproc.hpp	/^    WARP_INVERSE_MAP=CV_WARP_INVERSE_MAP$/;"	e	enum:cv::__anon14
cv::WINDOW_AUTOSIZE	highgui/highgui.hpp	/^enum { WINDOW_AUTOSIZE=1 };$/;"	e	enum:cv::__anon159
cv::WImage	core/wimage.hpp	/^class WImage$/;"	c	namespace:cv
cv::WImage1_16s	core/wimage.hpp	/^typedef WImageC<short, 1>        WImage1_16s;$/;"	t	namespace:cv
cv::WImage1_16u	core/wimage.hpp	/^typedef WImageC<ushort, 1>        WImage1_16u;$/;"	t	namespace:cv
cv::WImage1_b	core/wimage.hpp	/^typedef WImageC<uchar, 1>        WImage1_b;$/;"	t	namespace:cv
cv::WImage1_f	core/wimage.hpp	/^typedef WImageC<float, 1>        WImage1_f;$/;"	t	namespace:cv
cv::WImage3_16s	core/wimage.hpp	/^typedef WImageC<short, 3>        WImage3_16s;$/;"	t	namespace:cv
cv::WImage3_16u	core/wimage.hpp	/^typedef WImageC<ushort, 3>        WImage3_16u;$/;"	t	namespace:cv
cv::WImage3_b	core/wimage.hpp	/^typedef WImageC<uchar, 3>        WImage3_b;$/;"	t	namespace:cv
cv::WImage3_f	core/wimage.hpp	/^typedef WImageC<float, 3>        WImage3_f;$/;"	t	namespace:cv
cv::WImage::BaseType	core/wimage.hpp	/^    typedef T BaseType;$/;"	t	class:cv::WImage	access:public
cv::WImage::ChannelSize	core/wimage.hpp	/^    int ChannelSize() const {return sizeof(T); }  \/\/ number of bytes per channel$/;"	f	class:cv::WImage	access:public	signature:() const
cv::WImage::Channels	core/wimage.hpp	/^    int Channels() const {return image_->nChannels; }$/;"	f	class:cv::WImage	access:public	signature:() const
cv::WImage::CopyFrom	core/wimage.hpp	/^    void CopyFrom(const WImage<T>& src) { cvCopy(src.Ipl(), image_); }$/;"	f	class:cv::WImage	access:public	signature:(const WImage<T>& src)
cv::WImage::Depth	core/wimage.hpp	/^    int Depth() const;$/;"	p	class:cv::WImage	access:public	signature:() const
cv::WImage::Depth	core/wimage.hpp	/^inline int WImage<double>::Depth() const {return IPL_DEPTH_64F; }$/;"	f	class:cv::WImage	signature:() const
cv::WImage::Depth	core/wimage.hpp	/^inline int WImage<float>::Depth() const {return IPL_DEPTH_32F; }$/;"	f	class:cv::WImage	signature:() const
cv::WImage::Depth	core/wimage.hpp	/^inline int WImage<int>::Depth() const {return IPL_DEPTH_32S; }$/;"	f	class:cv::WImage	signature:() const
cv::WImage::Depth	core/wimage.hpp	/^inline int WImage<short>::Depth() const {return IPL_DEPTH_16S; }$/;"	f	class:cv::WImage	signature:() const
cv::WImage::Depth	core/wimage.hpp	/^inline int WImage<signed char>::Depth() const {return IPL_DEPTH_8S; }$/;"	f	class:cv::WImage	signature:() const
cv::WImage::Depth	core/wimage.hpp	/^inline int WImage<uchar>::Depth() const {return IPL_DEPTH_8U; }$/;"	f	class:cv::WImage	signature:() const
cv::WImage::Depth	core/wimage.hpp	/^inline int WImage<ushort>::Depth() const {return IPL_DEPTH_16U; }$/;"	f	class:cv::WImage	signature:() const
cv::WImage::Height	core/wimage.hpp	/^    int Height() const {return image_->height; }$/;"	f	class:cv::WImage	access:public	signature:() const
cv::WImage::ImageData	core/wimage.hpp	/^    T* ImageData() { return reinterpret_cast<T*>(image_->imageData); }$/;"	f	class:cv::WImage	access:public	signature:()
cv::WImage::ImageData	core/wimage.hpp	/^    const T* ImageData() const {$/;"	f	class:cv::WImage	access:public	signature:() const
cv::WImage::Ipl	core/wimage.hpp	/^    IplImage* Ipl() {return image_; }$/;"	f	class:cv::WImage	access:public	signature:()
cv::WImage::Ipl	core/wimage.hpp	/^    const IplImage* Ipl() const {return image_; }$/;"	f	class:cv::WImage	access:public	signature:() const
cv::WImage::PixelSize	core/wimage.hpp	/^    int PixelSize() const {return Channels() * ChannelSize(); }$/;"	f	class:cv::WImage	access:public	signature:() const
cv::WImage::Row	core/wimage.hpp	/^    inline T* Row(int r) {$/;"	f	class:cv::WImage	access:public	signature:(int r)
cv::WImage::Row	core/wimage.hpp	/^    inline const T* Row(int r) const {$/;"	f	class:cv::WImage	access:public	signature:(int r) const
cv::WImage::SetIpl	core/wimage.hpp	/^    void SetIpl(IplImage* image) {$/;"	f	class:cv::WImage	access:protected	signature:(IplImage* image)
cv::WImage::SetZero	core/wimage.hpp	/^    void SetZero() { cvSetZero(image_); }$/;"	f	class:cv::WImage	access:public	signature:()
cv::WImage::View	core/wimage.hpp	/^    WImageView<T> View(int c, int r, int width, int height);$/;"	p	class:cv::WImage	access:public	signature:(int c, int r, int width, int height)
cv::WImage::View	core/wimage.hpp	/^WImageView<T> WImage<T>::View(int c, int r, int width, int height) {$/;"	f	class:cv::WImage	signature:(int c, int r, int width, int height)
cv::WImage::WImage	core/wimage.hpp	/^    WImage(const WImage&);$/;"	p	class:cv::WImage	access:protected	signature:(const WImage&)
cv::WImage::WImage	core/wimage.hpp	/^    explicit WImage(IplImage* img) : image_(img) {$/;"	f	class:cv::WImage	access:protected	signature:(IplImage* img)
cv::WImage::Width	core/wimage.hpp	/^    int Width() const {return image_->width; }$/;"	f	class:cv::WImage	access:public	signature:() const
cv::WImage::WidthStep	core/wimage.hpp	/^    int WidthStep() const {return image_->widthStep; }$/;"	f	class:cv::WImage	access:public	signature:() const
cv::WImage::image_	core/wimage.hpp	/^    IplImage* image_;$/;"	m	class:cv::WImage	access:protected
cv::WImage::operator ()	core/wimage.hpp	/^    inline T* operator() (int c, int r)  {$/;"	f	class:cv::WImage	access:public	signature:(int c, int r)
cv::WImage::operator ()	core/wimage.hpp	/^    inline const T* operator() (int c, int r) const  {$/;"	f	class:cv::WImage	access:public	signature:(int c, int r) const
cv::WImage::operator =	core/wimage.hpp	/^    void operator=(const WImage&);$/;"	p	class:cv::WImage	access:protected	signature:(const WImage&)
cv::WImage::~WImage	core/wimage.hpp	/^    virtual ~WImage() = 0;$/;"	p	class:cv::WImage	access:public	signature:()
cv::WImage::~WImage	core/wimage.hpp	/^template<typename T> inline WImage<T>::~WImage() {}$/;"	f	class:cv::WImage	signature:()
cv::WImageBuffer	core/wimage.hpp	/^class WImageBuffer : public WImage<T>$/;"	c	namespace:cv	inherits:WImage
cv::WImageBuffer1_16s	core/wimage.hpp	/^typedef WImageBufferC<short, 1>  WImageBuffer1_16s;$/;"	t	namespace:cv
cv::WImageBuffer1_16u	core/wimage.hpp	/^typedef WImageBufferC<ushort, 1>  WImageBuffer1_16u;$/;"	t	namespace:cv
cv::WImageBuffer1_b	core/wimage.hpp	/^typedef WImageBufferC<uchar, 1>  WImageBuffer1_b;$/;"	t	namespace:cv
cv::WImageBuffer1_f	core/wimage.hpp	/^typedef WImageBufferC<float, 1>  WImageBuffer1_f;$/;"	t	namespace:cv
cv::WImageBuffer3_16s	core/wimage.hpp	/^typedef WImageBufferC<short, 3>  WImageBuffer3_16s;$/;"	t	namespace:cv
cv::WImageBuffer3_16u	core/wimage.hpp	/^typedef WImageBufferC<ushort, 3>  WImageBuffer3_16u;$/;"	t	namespace:cv
cv::WImageBuffer3_b	core/wimage.hpp	/^typedef WImageBufferC<uchar, 3>  WImageBuffer3_b;$/;"	t	namespace:cv
cv::WImageBuffer3_f	core/wimage.hpp	/^typedef WImageBufferC<float, 3>  WImageBuffer3_f;$/;"	t	namespace:cv
cv::WImageBuffer::Allocate	core/wimage.hpp	/^    void Allocate(int width, int height, int nchannels);$/;"	p	class:cv::WImageBuffer	access:public	signature:(int width, int height, int nchannels)
cv::WImageBuffer::Allocate	core/wimage.hpp	/^inline void WImageBuffer<T>::Allocate(int width, int height, int nchannels)$/;"	f	class:cv::WImageBuffer	signature:(int width, int height, int nchannels)
cv::WImageBuffer::BaseType	core/wimage.hpp	/^    typedef typename WImage<T>::BaseType BaseType;$/;"	t	class:cv::WImageBuffer	access:public
cv::WImageBuffer::CloneFrom	core/wimage.hpp	/^    void CloneFrom(const WImage<T>& src) {$/;"	f	class:cv::WImageBuffer	access:public	signature:(const WImage<T>& src)
cv::WImageBuffer::IsNull	core/wimage.hpp	/^    bool IsNull() const {return WImage<T>::image_ == NULL; }$/;"	f	class:cv::WImageBuffer	access:public	signature:() const
cv::WImageBuffer::ReleaseImage	core/wimage.hpp	/^    void ReleaseImage() {$/;"	f	class:cv::WImageBuffer	access:public	signature:()
cv::WImageBuffer::SetIpl	core/wimage.hpp	/^    void SetIpl(IplImage* img) {$/;"	f	class:cv::WImageBuffer	access:public	signature:(IplImage* img)
cv::WImageBuffer::WImageBuffer	core/wimage.hpp	/^    WImageBuffer() : WImage<T>(0) {}$/;"	f	class:cv::WImageBuffer	access:public	signature:()
cv::WImageBuffer::WImageBuffer	core/wimage.hpp	/^    WImageBuffer(const WImageBuffer&);$/;"	p	class:cv::WImageBuffer	access:private	signature:(const WImageBuffer&)
cv::WImageBuffer::WImageBuffer	core/wimage.hpp	/^    WImageBuffer(int width, int height, int nchannels) : WImage<T>(0) {$/;"	f	class:cv::WImageBuffer	access:public	signature:(int width, int height, int nchannels)
cv::WImageBuffer::WImageBuffer	core/wimage.hpp	/^    explicit WImageBuffer(IplImage* img) : WImage<T>(img) {}$/;"	f	class:cv::WImageBuffer	access:public	signature:(IplImage* img)
cv::WImageBuffer::operator =	core/wimage.hpp	/^    void operator=(const WImageBuffer&);$/;"	p	class:cv::WImageBuffer	access:private	signature:(const WImageBuffer&)
cv::WImageBuffer::~WImageBuffer	core/wimage.hpp	/^    ~WImageBuffer() {$/;"	f	class:cv::WImageBuffer	access:public	signature:()
cv::WImageBufferC	core/wimage.hpp	/^class WImageBufferC : public WImageC<T, C>$/;"	c	namespace:cv	inherits:WImageC
cv::WImageBufferC::Allocate	core/wimage.hpp	/^    void Allocate(int width, int height);$/;"	p	class:cv::WImageBufferC	access:public	signature:(int width, int height)
cv::WImageBufferC::Allocate	core/wimage.hpp	/^inline void WImageBufferC<T, C>::Allocate(int width, int height)$/;"	f	class:cv::WImageBufferC	signature:(int width, int height)
cv::WImageBufferC::BaseType	core/wimage.hpp	/^    typedef typename WImage<T>::BaseType BaseType;$/;"	t	class:cv::WImageBufferC	access:public
cv::WImageBufferC::CloneFrom	core/wimage.hpp	/^    void CloneFrom(const WImageC<T, C>& src) {$/;"	f	class:cv::WImageBufferC	access:public	signature:(const WImageC<T, C>& src)
cv::WImageBufferC::IsNull	core/wimage.hpp	/^    bool IsNull() const {return WImage<T>::image_ == NULL; }$/;"	f	class:cv::WImageBufferC	access:public	signature:() const
cv::WImageBufferC::ReleaseImage	core/wimage.hpp	/^    void ReleaseImage() {$/;"	f	class:cv::WImageBufferC	access:public	signature:()
cv::WImageBufferC::SetIpl	core/wimage.hpp	/^    void SetIpl(IplImage* img) {$/;"	f	class:cv::WImageBufferC	access:public	signature:(IplImage* img)
cv::WImageBufferC::WImageBufferC	core/wimage.hpp	/^    WImageBufferC() : WImageC<T, C>(0) {}$/;"	f	class:cv::WImageBufferC	access:public	signature:()
cv::WImageBufferC::WImageBufferC	core/wimage.hpp	/^    WImageBufferC(const WImageBufferC&);$/;"	p	class:cv::WImageBufferC	access:private	signature:(const WImageBufferC&)
cv::WImageBufferC::WImageBufferC	core/wimage.hpp	/^    WImageBufferC(int width, int height) : WImageC<T, C>(0) {$/;"	f	class:cv::WImageBufferC	access:public	signature:(int width, int height)
cv::WImageBufferC::WImageBufferC	core/wimage.hpp	/^    explicit WImageBufferC(IplImage* img) : WImageC<T, C>(img) {}$/;"	f	class:cv::WImageBufferC	access:public	signature:(IplImage* img)
cv::WImageBufferC::kChannels	core/wimage.hpp	/^    enum { kChannels = C };$/;"	e	enum:cv::WImageBufferC::__anon95
cv::WImageBufferC::operator =	core/wimage.hpp	/^    void operator=(const WImageBufferC&);$/;"	p	class:cv::WImageBufferC	access:private	signature:(const WImageBufferC&)
cv::WImageBufferC::~WImageBufferC	core/wimage.hpp	/^    ~WImageBufferC() {$/;"	f	class:cv::WImageBufferC	access:public	signature:()
cv::WImageBuffer_16s	core/wimage.hpp	/^typedef WImageBuffer<short>      WImageBuffer_16s;$/;"	t	namespace:cv
cv::WImageBuffer_16u	core/wimage.hpp	/^typedef WImageBuffer<ushort>      WImageBuffer_16u;$/;"	t	namespace:cv
cv::WImageBuffer_b	core/wimage.hpp	/^typedef WImageBuffer<uchar>      WImageBuffer_b;$/;"	t	namespace:cv
cv::WImageBuffer_f	core/wimage.hpp	/^typedef WImageBuffer<float>      WImageBuffer_f;$/;"	t	namespace:cv
cv::WImageC	core/wimage.hpp	/^class WImageC : public WImage<T>$/;"	c	namespace:cv	inherits:WImage
cv::WImageC::BaseType	core/wimage.hpp	/^    typedef typename WImage<T>::BaseType BaseType;$/;"	t	class:cv::WImageC	access:public
cv::WImageC::Channels	core/wimage.hpp	/^    int Channels() const {return C; }$/;"	f	class:cv::WImageC	access:public	signature:() const
cv::WImageC::CopyFrom	core/wimage.hpp	/^    void CopyFrom(const WImageC<T, C>& src) {$/;"	f	class:cv::WImageC	access:public	signature:(const WImageC<T, C>& src)
cv::WImageC::SetIpl	core/wimage.hpp	/^    void SetIpl(IplImage* image) {$/;"	f	class:cv::WImageC	access:protected	signature:(IplImage* image)
cv::WImageC::View	core/wimage.hpp	/^    WImageViewC<T, C> View(int c, int r, int width, int height);$/;"	p	class:cv::WImageC	access:public	signature:(int c, int r, int width, int height)
cv::WImageC::View	core/wimage.hpp	/^WImageViewC<T, C> WImageC<T, C>::View(int c, int r, int width, int height) {$/;"	f	class:cv::WImageC	signature:(int c, int r, int width, int height)
cv::WImageC::WImageC	core/wimage.hpp	/^    WImageC(const WImageC&);$/;"	p	class:cv::WImageC	access:protected	signature:(const WImageC&)
cv::WImageC::WImageC	core/wimage.hpp	/^    explicit WImageC(IplImage* img) : WImage<T>(img) {$/;"	f	class:cv::WImageC	access:public	signature:(IplImage* img)
cv::WImageC::kChannels	core/wimage.hpp	/^    enum { kChannels = C };$/;"	e	enum:cv::WImageC::__anon94
cv::WImageC::operator =	core/wimage.hpp	/^    void operator=(const WImageC&);$/;"	p	class:cv::WImageC	access:protected	signature:(const WImageC&)
cv::WImageC::~WImageC	core/wimage.hpp	/^    virtual ~WImageC() = 0;$/;"	p	class:cv::WImageC	access:public	signature:()
cv::WImageC::~WImageC	core/wimage.hpp	/^template<typename T, int C> inline WImageC<T, C>::~WImageC() {}$/;"	f	class:cv::WImageC	signature:()
cv::WImageView	core/wimage.hpp	/^class WImageView : public WImage<T>$/;"	c	namespace:cv	inherits:WImage
cv::WImageView1_16s	core/wimage.hpp	/^typedef WImageViewC<short, 1>    WImageView1_16s;$/;"	t	namespace:cv
cv::WImageView1_16u	core/wimage.hpp	/^typedef WImageViewC<ushort, 1>    WImageView1_16u;$/;"	t	namespace:cv
cv::WImageView1_b	core/wimage.hpp	/^typedef WImageViewC<uchar, 1>    WImageView1_b;$/;"	t	namespace:cv
cv::WImageView1_f	core/wimage.hpp	/^typedef WImageViewC<float, 1>    WImageView1_f;$/;"	t	namespace:cv
cv::WImageView3_16s	core/wimage.hpp	/^typedef WImageViewC<short, 3>    WImageView3_16s;$/;"	t	namespace:cv
cv::WImageView3_16u	core/wimage.hpp	/^typedef WImageViewC<ushort, 3>    WImageView3_16u;$/;"	t	namespace:cv
cv::WImageView3_b	core/wimage.hpp	/^typedef WImageViewC<uchar, 3>    WImageView3_b;$/;"	t	namespace:cv
cv::WImageView3_f	core/wimage.hpp	/^typedef WImageViewC<float, 3>    WImageView3_f;$/;"	t	namespace:cv
cv::WImageView::BaseType	core/wimage.hpp	/^    typedef typename WImage<T>::BaseType BaseType;$/;"	t	class:cv::WImageView	access:public
cv::WImageView::WImageView	core/wimage.hpp	/^    WImageView(IplImage* img) : WImage<T>(img) {}$/;"	f	class:cv::WImageView	access:public	signature:(IplImage* img)
cv::WImageView::WImageView	core/wimage.hpp	/^    WImageView(T* data, int width, int height, int channels, int width_step = -1);$/;"	p	class:cv::WImageView	access:public	signature:(T* data, int width, int height, int channels, int width_step = -1)
cv::WImageView::WImageView	core/wimage.hpp	/^    WImageView(WImage<T>* img, int c, int r, int width, int height);$/;"	p	class:cv::WImageView	access:public	signature:(WImage<T>* img, int c, int r, int width, int height)
cv::WImageView::WImageView	core/wimage.hpp	/^    WImageView(const WImage<T>& img) : WImage<T>(0) {$/;"	f	class:cv::WImageView	access:public	signature:(const WImage<T>& img)
cv::WImageView::WImageView	core/wimage.hpp	/^WImageView<T>::WImageView(T* data, int width, int height, int nchannels, int width_step)$/;"	f	class:cv::WImageView	signature:(T* data, int width, int height, int nchannels, int width_step)
cv::WImageView::WImageView	core/wimage.hpp	/^WImageView<T>::WImageView(WImage<T>* img, int c, int r, int width, int height)$/;"	f	class:cv::WImageView	signature:(WImage<T>* img, int c, int r, int width, int height)
cv::WImageView::header_	core/wimage.hpp	/^    IplImage header_;$/;"	m	class:cv::WImageView	access:protected
cv::WImageView::operator =	core/wimage.hpp	/^    WImageView& operator=(const WImage<T>& img) {$/;"	f	class:cv::WImageView	access:public	signature:(const WImage<T>& img)
cv::WImageViewC	core/wimage.hpp	/^class WImageViewC : public WImageC<T, C>$/;"	c	namespace:cv	inherits:WImageC
cv::WImageViewC::BaseType	core/wimage.hpp	/^    typedef typename WImage<T>::BaseType BaseType;$/;"	t	class:cv::WImageViewC	access:public
cv::WImageViewC::WImageViewC	core/wimage.hpp	/^    WImageViewC();$/;"	p	class:cv::WImageViewC	access:public	signature:()
cv::WImageViewC::WImageViewC	core/wimage.hpp	/^    WImageViewC(IplImage* img) : WImageC<T, C>(img) {}$/;"	f	class:cv::WImageViewC	access:public	signature:(IplImage* img)
cv::WImageViewC::WImageViewC	core/wimage.hpp	/^    WImageViewC(T* data, int width, int height, int width_step = -1);$/;"	p	class:cv::WImageViewC	access:public	signature:(T* data, int width, int height, int width_step = -1)
cv::WImageViewC::WImageViewC	core/wimage.hpp	/^    WImageViewC(WImageC<T, C>* img,$/;"	p	class:cv::WImageViewC	access:public	signature:(WImageC<T, C>* img, int c, int r, int width, int height)
cv::WImageViewC::WImageViewC	core/wimage.hpp	/^    WImageViewC(const WImageC<T, C>& img) : WImageC<T, C>(0) {$/;"	f	class:cv::WImageViewC	access:public	signature:(const WImageC<T, C>& img)
cv::WImageViewC::WImageViewC	core/wimage.hpp	/^    WImageViewC(const WImageViewC<T, C>& img) : WImageC<T, C>(0) {$/;"	f	class:cv::WImageViewC	access:public	signature:(const WImageViewC<T, C>& img)
cv::WImageViewC::WImageViewC	core/wimage.hpp	/^WImageViewC<T, C>::WImageViewC() : WImageC<T, C>(0) {$/;"	f	class:cv::WImageViewC	signature:()
cv::WImageViewC::WImageViewC	core/wimage.hpp	/^WImageViewC<T, C>::WImageViewC(T* data, int width, int height, int width_step)$/;"	f	class:cv::WImageViewC	signature:(T* data, int width, int height, int width_step)
cv::WImageViewC::WImageViewC	core/wimage.hpp	/^WImageViewC<T, C>::WImageViewC(WImageC<T, C>* img, int c, int r, int width, int height)$/;"	f	class:cv::WImageViewC	signature:(WImageC<T, C>* img, int c, int r, int width, int height)
cv::WImageViewC::header_	core/wimage.hpp	/^    IplImage header_;$/;"	m	class:cv::WImageViewC	access:protected
cv::WImageViewC::kChannels	core/wimage.hpp	/^    enum { kChannels = C };$/;"	e	enum:cv::WImageViewC::__anon96
cv::WImageViewC::operator =	core/wimage.hpp	/^    WImageViewC& operator=(const WImageC<T, C>& img) {$/;"	f	class:cv::WImageViewC	access:public	signature:(const WImageC<T, C>& img)
cv::WImageViewC::operator =	core/wimage.hpp	/^    WImageViewC& operator=(const WImageViewC<T, C>& img) {$/;"	f	class:cv::WImageViewC	access:public	signature:(const WImageViewC<T, C>& img)
cv::WImageViewC::~WImageViewC	core/wimage.hpp	/^    virtual ~WImageViewC() {}$/;"	f	class:cv::WImageViewC	access:public	signature:()
cv::WImageView_16s	core/wimage.hpp	/^typedef WImageView<short>        WImageView_16s;$/;"	t	namespace:cv
cv::WImageView_16u	core/wimage.hpp	/^typedef WImageView<ushort>        WImageView_16u;$/;"	t	namespace:cv
cv::WImageView_b	core/wimage.hpp	/^typedef WImageView<uchar>        WImageView_b;$/;"	t	namespace:cv
cv::WImageView_f	core/wimage.hpp	/^typedef WImageView<float>        WImageView_f;$/;"	t	namespace:cv
cv::WImage_16s	core/wimage.hpp	/^typedef WImage<short>            WImage_16s;$/;"	t	namespace:cv
cv::WImage_16u	core/wimage.hpp	/^typedef WImage<ushort>            WImage_16u;$/;"	t	namespace:cv
cv::WImage_b	core/wimage.hpp	/^typedef WImage<uchar>            WImage_b;$/;"	t	namespace:cv
cv::WImage_f	core/wimage.hpp	/^typedef WImage<float>            WImage_f;$/;"	t	namespace:cv
cv::WString	core/core.hpp	/^typedef std::basic_string<wchar_t> WString;$/;"	t	namespace:cv
cv::WriteStructContext	core/operations.hpp	/^class CV_EXPORTS WriteStructContext$/;"	c	namespace:cv
cv::WriteStructContext::WriteStructContext	core/operations.hpp	/^    WriteStructContext(FileStorage& _fs, const string& name,$/;"	p	class:cv::WriteStructContext	access:public	signature:(FileStorage& _fs, const string& name, int flags, const string& typeName=string())
cv::WriteStructContext::fs	core/operations.hpp	/^    FileStorage* fs;$/;"	m	class:cv::WriteStructContext	access:public
cv::WriteStructContext::~WriteStructContext	core/operations.hpp	/^    ~WriteStructContext();$/;"	p	class:cv::WriteStructContext	access:public	signature:()
cv::YAPE	features2d/features2d.hpp	/^typedef LDetector YAPE;$/;"	t	namespace:cv
cv::_InputArray	core/core.hpp	/^class CV_EXPORTS _InputArray$/;"	c	namespace:cv
cv::_InputArray::EXPR	core/core.hpp	/^        STD_VECTOR_MAT=5<<KIND_SHIFT, EXPR=6<<KIND_SHIFT };$/;"	e	enum:cv::_InputArray::__anon134
cv::_InputArray::KIND_SHIFT	core/core.hpp	/^    enum { KIND_SHIFT=16, NONE=0<<KIND_SHIFT, MAT=1<<KIND_SHIFT,$/;"	e	enum:cv::_InputArray::__anon134
cv::_InputArray::MAT	core/core.hpp	/^    enum { KIND_SHIFT=16, NONE=0<<KIND_SHIFT, MAT=1<<KIND_SHIFT,$/;"	e	enum:cv::_InputArray::__anon134
cv::_InputArray::MATX	core/core.hpp	/^        MATX=2<<KIND_SHIFT, STD_VECTOR=3<<KIND_SHIFT,$/;"	e	enum:cv::_InputArray::__anon134
cv::_InputArray::NONE	core/core.hpp	/^    enum { KIND_SHIFT=16, NONE=0<<KIND_SHIFT, MAT=1<<KIND_SHIFT,$/;"	e	enum:cv::_InputArray::__anon134
cv::_InputArray::STD_VECTOR	core/core.hpp	/^        MATX=2<<KIND_SHIFT, STD_VECTOR=3<<KIND_SHIFT,$/;"	e	enum:cv::_InputArray::__anon134
cv::_InputArray::STD_VECTOR_MAT	core/core.hpp	/^        STD_VECTOR_MAT=5<<KIND_SHIFT, EXPR=6<<KIND_SHIFT };$/;"	e	enum:cv::_InputArray::__anon134
cv::_InputArray::STD_VECTOR_VECTOR	core/core.hpp	/^        STD_VECTOR_VECTOR=4<<KIND_SHIFT,$/;"	e	enum:cv::_InputArray::__anon134
cv::_InputArray::_InputArray	core/core.hpp	/^    _InputArray();$/;"	p	class:cv::_InputArray	access:public	signature:()
cv::_InputArray::_InputArray	core/core.hpp	/^    _InputArray(const Mat& m);$/;"	p	class:cv::_InputArray	access:public	signature:(const Mat& m)
cv::_InputArray::_InputArray	core/core.hpp	/^    _InputArray(const MatExpr& expr);$/;"	p	class:cv::_InputArray	access:public	signature:(const MatExpr& expr)
cv::_InputArray::_InputArray	core/core.hpp	/^    _InputArray(const Scalar& s);$/;"	p	class:cv::_InputArray	access:public	signature:(const Scalar& s)
cv::_InputArray::_InputArray	core/core.hpp	/^    _InputArray(const double& val);$/;"	p	class:cv::_InputArray	access:public	signature:(const double& val)
cv::_InputArray::_InputArray	core/core.hpp	/^    _InputArray(const vector<Mat>& vec);$/;"	p	class:cv::_InputArray	access:public	signature:(const vector<Mat>& vec)
cv::_InputArray::_InputArray	core/core.hpp	/^    template<typename _Tp, int m, int n> _InputArray(const Matx<_Tp, m, n>& matx);$/;"	p	class:cv::_InputArray	access:public	signature:(const Matx<_Tp, m, n>& matx)
cv::_InputArray::_InputArray	core/core.hpp	/^    template<typename _Tp> _InputArray(const vector<_Tp>& vec);$/;"	p	class:cv::_InputArray	access:public	signature:(const vector<_Tp>& vec)
cv::_InputArray::_InputArray	core/core.hpp	/^    template<typename _Tp> _InputArray(const vector<vector<_Tp> >& vec);$/;"	p	class:cv::_InputArray	access:public	signature:(const vector<vector<_Tp> >& vec)
cv::_InputArray::_InputArray	core/mat.hpp	/^inline _InputArray::_InputArray(const Scalar& s)$/;"	f	class:cv::_InputArray	signature:(const Scalar& s)
cv::_InputArray::_InputArray	core/mat.hpp	/^template<typename _Tp, int m, int n> inline _InputArray::_InputArray(const Matx<_Tp, m, n>& mtx)$/;"	f	class:cv::_InputArray	signature:(const Matx<_Tp, m, n>& mtx)
cv::_InputArray::_InputArray	core/mat.hpp	/^template<typename _Tp> inline _InputArray::_InputArray(const vector<_Tp>& vec)$/;"	f	class:cv::_InputArray	signature:(const vector<_Tp>& vec)
cv::_InputArray::_InputArray	core/mat.hpp	/^template<typename _Tp> inline _InputArray::_InputArray(const vector<vector<_Tp> >& vec)$/;"	f	class:cv::_InputArray	signature:(const vector<vector<_Tp> >& vec)
cv::_InputArray::channels	core/core.hpp	/^    virtual int channels(int i=-1) const;$/;"	p	class:cv::_InputArray	access:public	signature:(int i=-1) const
cv::_InputArray::depth	core/core.hpp	/^    virtual int depth(int i=-1) const;$/;"	p	class:cv::_InputArray	access:public	signature:(int i=-1) const
cv::_InputArray::empty	core/core.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::_InputArray	access:public	signature:() const
cv::_InputArray::flags	core/core.hpp	/^    int flags;$/;"	m	class:cv::_InputArray	access:public
cv::_InputArray::getMat	core/core.hpp	/^    virtual Mat getMat(int i=-1) const;$/;"	p	class:cv::_InputArray	access:public	signature:(int i=-1) const
cv::_InputArray::getMatVector	core/core.hpp	/^    virtual void getMatVector(vector<Mat>& mv) const;$/;"	p	class:cv::_InputArray	access:public	signature:(vector<Mat>& mv) const
cv::_InputArray::kind	core/core.hpp	/^    virtual int kind() const;$/;"	p	class:cv::_InputArray	access:public	signature:() const
cv::_InputArray::obj	core/core.hpp	/^    void* obj;$/;"	m	class:cv::_InputArray	access:public
cv::_InputArray::size	core/core.hpp	/^    virtual Size size(int i=-1) const;$/;"	p	class:cv::_InputArray	access:public	signature:(int i=-1) const
cv::_InputArray::sz	core/core.hpp	/^    Size sz;$/;"	m	class:cv::_InputArray	access:public
cv::_InputArray::total	core/core.hpp	/^    virtual size_t total(int i=-1) const;$/;"	p	class:cv::_InputArray	access:public	signature:(int i=-1) const
cv::_InputArray::type	core/core.hpp	/^    virtual int type(int i=-1) const;$/;"	p	class:cv::_InputArray	access:public	signature:(int i=-1) const
cv::_OutputArray	core/core.hpp	/^class CV_EXPORTS _OutputArray : public _InputArray$/;"	c	namespace:cv	inherits:_InputArray
cv::_OutputArray::_OutputArray	core/core.hpp	/^    _OutputArray();$/;"	p	class:cv::_OutputArray	access:public	signature:()
cv::_OutputArray::_OutputArray	core/core.hpp	/^    _OutputArray(Mat& m);$/;"	p	class:cv::_OutputArray	access:public	signature:(Mat& m)
cv::_OutputArray::_OutputArray	core/core.hpp	/^    _OutputArray(vector<Mat>& vec);$/;"	p	class:cv::_OutputArray	access:public	signature:(vector<Mat>& vec)
cv::_OutputArray::_OutputArray	core/core.hpp	/^    template<typename _Tp, int m, int n> _OutputArray(Matx<_Tp, m, n>& matx);$/;"	p	class:cv::_OutputArray	access:public	signature:(Matx<_Tp, m, n>& matx)
cv::_OutputArray::_OutputArray	core/core.hpp	/^    template<typename _Tp> _OutputArray(vector<_Tp>& vec);$/;"	p	class:cv::_OutputArray	access:public	signature:(vector<_Tp>& vec)
cv::_OutputArray::_OutputArray	core/core.hpp	/^    template<typename _Tp> _OutputArray(vector<vector<_Tp> >& vec);$/;"	p	class:cv::_OutputArray	access:public	signature:(vector<vector<_Tp> >& vec)
cv::_OutputArray::_OutputArray	core/mat.hpp	/^template<typename _Tp, int m, int n> inline _OutputArray::_OutputArray(Matx<_Tp, m, n>& mtx) : _InputArray(mtx) {}$/;"	f	class:cv::_OutputArray	signature:(Matx<_Tp, m, n>& mtx)
cv::_OutputArray::_OutputArray	core/mat.hpp	/^template<typename _Tp> inline _OutputArray::_OutputArray(vector<_Tp>& vec) : _InputArray(vec) {}$/;"	f	class:cv::_OutputArray	signature:(vector<_Tp>& vec)
cv::_OutputArray::_OutputArray	core/mat.hpp	/^template<typename _Tp> inline _OutputArray::_OutputArray(vector<vector<_Tp> >& vec) : _InputArray(vec) {}$/;"	f	class:cv::_OutputArray	signature:(vector<vector<_Tp> >& vec)
cv::_OutputArray::clear	core/core.hpp	/^    virtual void clear() const;$/;"	p	class:cv::_OutputArray	access:public	signature:() const
cv::_OutputArray::create	core/core.hpp	/^    virtual void create(Size sz, int type, int i=-1, bool allocateVector=false, int fixedDepthMask=0) const;$/;"	p	class:cv::_OutputArray	access:public	signature:(Size sz, int type, int i=-1, bool allocateVector=false, int fixedDepthMask=0) const
cv::_OutputArray::create	core/core.hpp	/^    virtual void create(int dims, const int* size, int type, int i=-1, bool allowTransposed=false, int fixedDepthMask=0) const;$/;"	p	class:cv::_OutputArray	access:public	signature:(int dims, const int* size, int type, int i=-1, bool allowTransposed=false, int fixedDepthMask=0) const
cv::_OutputArray::create	core/core.hpp	/^    virtual void create(int rows, int cols, int type, int i=-1, bool allowTransposed=false, int fixedDepthMask=0) const;$/;"	p	class:cv::_OutputArray	access:public	signature:(int rows, int cols, int type, int i=-1, bool allowTransposed=false, int fixedDepthMask=0) const
cv::_OutputArray::fixedSize	core/core.hpp	/^    virtual bool fixedSize() const;$/;"	p	class:cv::_OutputArray	access:public	signature:() const
cv::_OutputArray::fixedType	core/core.hpp	/^    virtual bool fixedType() const;$/;"	p	class:cv::_OutputArray	access:public	signature:() const
cv::_OutputArray::getMatRef	core/core.hpp	/^    virtual Mat& getMatRef(int i=-1) const;$/;"	p	class:cv::_OutputArray	access:public	signature:(int i=-1) const
cv::_OutputArray::needed	core/core.hpp	/^    virtual bool needed() const;$/;"	p	class:cv::_OutputArray	access:public	signature:() const
cv::_OutputArray::release	core/core.hpp	/^    virtual void release() const;$/;"	p	class:cv::_OutputArray	access:public	signature:() const
cv::abs	core/mat.hpp	/^CV_EXPORTS MatExpr abs(const Mat& m);$/;"	p	namespace:cv	signature:(const Mat& m)
cv::abs	core/mat.hpp	/^CV_EXPORTS MatExpr abs(const MatExpr& e);$/;"	p	namespace:cv	signature:(const MatExpr& e)
cv::abs	core/mat.hpp	/^template<typename _Tp> static inline MatExpr abs(const Mat_<_Tp>& m)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& m)
cv::abs	core/operations.hpp	/^double abs(const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a)
cv::absdiff	core/core.hpp	/^CV_EXPORTS_W void absdiff(InputArray src1, InputArray src2, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst)
cv::accumulate	imgproc/imgproc.hpp	/^CV_EXPORTS_W void accumulate( InputArray src, InputOutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, InputOutputArray dst, InputArray mask=noArray() )
cv::accumulateProduct	imgproc/imgproc.hpp	/^CV_EXPORTS_W void accumulateProduct( InputArray src1, InputArray src2,$/;"	p	namespace:cv	signature:( InputArray src1, InputArray src2, InputOutputArray dst, InputArray mask=noArray() )
cv::accumulateSquare	imgproc/imgproc.hpp	/^CV_EXPORTS_W void accumulateSquare( InputArray src, InputOutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, InputOutputArray dst, InputArray mask=noArray() )
cv::accumulateWeighted	imgproc/imgproc.hpp	/^CV_EXPORTS_W void accumulateWeighted( InputArray src, InputOutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, InputOutputArray dst, double alpha, InputArray mask=noArray() )
cv::adaptiveThreshold	imgproc/imgproc.hpp	/^CV_EXPORTS_W void adaptiveThreshold( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C )
cv::add	core/core.hpp	/^CV_EXPORTS_W void add(InputArray src1, InputArray src2, OutputArray dst,$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst, InputArray mask=noArray(), int dtype=-1)
cv::addText	highgui/highgui.hpp	/^CV_EXPORTS void addText( const Mat& img, const string& text, Point org, CvFont font);$/;"	p	namespace:cv	signature:( const Mat& img, const string& text, Point org, CvFont font)
cv::addWeighted	core/core.hpp	/^CV_EXPORTS_W void addWeighted(InputArray src1, double alpha, InputArray src2,$/;"	p	namespace:cv	signature:(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, int dtype=-1)
cv::alignPtr	core/core.hpp	/^template<typename _Tp> static inline _Tp* alignPtr(_Tp* ptr, int n=(int)sizeof(_Tp))$/;"	f	namespace:cv	signature:(_Tp* ptr, int n=(int)sizeof(_Tp))
cv::alignSize	core/core.hpp	/^static inline size_t alignSize(size_t sz, int n)$/;"	f	namespace:cv	signature:(size_t sz, int n)
cv::allocate	core/core.hpp	/^template<typename _Tp> static inline _Tp* allocate(size_t n)$/;"	f	namespace:cv	signature:(size_t n)
cv::approxPolyDP	imgproc/imgproc.hpp	/^CV_EXPORTS_W void approxPolyDP( InputArray curve,$/;"	p	namespace:cv	signature:( InputArray curve, OutputArray approxCurve, double epsilon, bool closed )
cv::arcLength	imgproc/imgproc.hpp	/^CV_EXPORTS_W double arcLength( InputArray curve, bool closed );$/;"	p	namespace:cv	signature:( InputArray curve, bool closed )
cv::bilateralFilter	imgproc/imgproc.hpp	/^CV_EXPORTS_W void bilateralFilter( InputArray src, OutputArray dst, int d,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType=BORDER_DEFAULT )
cv::bitwise_and	core/core.hpp	/^CV_EXPORTS_W void bitwise_and(InputArray src1, InputArray src2,$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst, InputArray mask=noArray())
cv::bitwise_not	core/core.hpp	/^CV_EXPORTS_W void bitwise_not(InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, InputArray mask=noArray())
cv::bitwise_or	core/core.hpp	/^CV_EXPORTS_W void bitwise_or(InputArray src1, InputArray src2,$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst, InputArray mask=noArray())
cv::bitwise_xor	core/core.hpp	/^CV_EXPORTS_W void bitwise_xor(InputArray src1, InputArray src2,$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst, InputArray mask=noArray())
cv::blur	imgproc/imgproc.hpp	/^CV_EXPORTS_W void blur( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, Size ksize, Point anchor=Point(-1,-1), int borderType=BORDER_DEFAULT )
cv::borderInterpolate	imgproc/imgproc.hpp	/^CV_EXPORTS_W int borderInterpolate( int p, int len, int borderType );$/;"	p	namespace:cv	signature:( int p, int len, int borderType )
cv::boundingRect	imgproc/imgproc.hpp	/^CV_EXPORTS_W Rect boundingRect( InputArray points );$/;"	p	namespace:cv	signature:( InputArray points )
cv::boxFilter	imgproc/imgproc.hpp	/^CV_EXPORTS_W void boxFilter( InputArray src, OutputArray dst, int ddepth,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor=Point(-1,-1), bool normalize=true, int borderType=BORDER_DEFAULT )
cv::buildPyramid	imgproc/imgproc.hpp	/^CV_EXPORTS void buildPyramid( InputArray src, OutputArrayOfArrays dst, int maxlevel );$/;"	p	namespace:cv	signature:( InputArray src, OutputArrayOfArrays dst, int maxlevel )
cv::calcBackProject	imgproc/imgproc.hpp	/^CV_EXPORTS void calcBackProject( const Mat* images, int nimages,$/;"	p	namespace:cv	signature:( const Mat* images, int nimages, const int* channels, InputArray hist, OutputArray backProject, const float** ranges, double scale=1, bool uniform=true )
cv::calcBackProject	imgproc/imgproc.hpp	/^CV_EXPORTS void calcBackProject( const Mat* images, int nimages,$/;"	p	namespace:cv	signature:( const Mat* images, int nimages, const int* channels, const SparseMat& hist, OutputArray backProject, const float** ranges, double scale=1, bool uniform=true )
cv::calcBackProject	imgproc/imgproc.hpp	/^CV_EXPORTS_W void calcBackProject( InputArrayOfArrays images, const vector<int>& channels,$/;"	p	namespace:cv	signature:( InputArrayOfArrays images, const vector<int>& channels, InputArray hist, OutputArray dst, const vector<float>& ranges, double scale )
cv::calcCovarMatrix	core/core.hpp	/^CV_EXPORTS void calcCovarMatrix( const Mat* samples, int nsamples, Mat& covar, Mat& mean,$/;"	p	namespace:cv	signature:( const Mat* samples, int nsamples, Mat& covar, Mat& mean, int flags, int ctype=CV_64F)
cv::calcCovarMatrix	core/core.hpp	/^CV_EXPORTS_W void calcCovarMatrix( InputArray samples, OutputArray covar,$/;"	p	namespace:cv	signature:( InputArray samples, OutputArray covar, OutputArray mean, int flags, int ctype=CV_64F)
cv::calcGlobalOrientation	video/tracking.hpp	/^CV_EXPORTS_W double calcGlobalOrientation( InputArray orientation, InputArray mask,$/;"	p	namespace:cv	signature:( InputArray orientation, InputArray mask, InputArray mhi, double timestamp, double duration )
cv::calcHist	imgproc/imgproc.hpp	/^CV_EXPORTS void calcHist( const Mat* images, int nimages,$/;"	p	namespace:cv	signature:( const Mat* images, int nimages, const int* channels, InputArray mask, OutputArray hist, int dims, const int* histSize, const float** ranges, bool uniform=true, bool accumulate=false )
cv::calcHist	imgproc/imgproc.hpp	/^CV_EXPORTS void calcHist( const Mat* images, int nimages,$/;"	p	namespace:cv	signature:( const Mat* images, int nimages, const int* channels, InputArray mask, SparseMat& hist, int dims, const int* histSize, const float** ranges, bool uniform=true, bool accumulate=false )
cv::calcHist	imgproc/imgproc.hpp	/^CV_EXPORTS_W void calcHist( InputArrayOfArrays images,$/;"	p	namespace:cv	signature:( InputArrayOfArrays images, const vector<int>& channels, InputArray mask, OutputArray hist, const vector<int>& histSize, const vector<float>& ranges, bool accumulate=false )
cv::calcMotionGradient	video/tracking.hpp	/^CV_EXPORTS_W void calcMotionGradient( InputArray mhi, OutputArray mask,$/;"	p	namespace:cv	signature:( InputArray mhi, OutputArray mask, OutputArray orientation, double delta1, double delta2, int apertureSize=3 )
cv::calcOpticalFlowFarneback	video/tracking.hpp	/^CV_EXPORTS_W void calcOpticalFlowFarneback( InputArray prev, InputArray next,$/;"	p	namespace:cv	signature:( InputArray prev, InputArray next, CV_OUT InputOutputArray flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags )
cv::calcOpticalFlowPyrLK	video/tracking.hpp	/^CV_EXPORTS_W void calcOpticalFlowPyrLK( InputArray prevImg, InputArray nextImg,$/;"	p	namespace:cv	signature:( InputArray prevImg, InputArray nextImg, InputArray prevPts, CV_OUT InputOutputArray nextPts, OutputArray status, OutputArray err, Size winSize=Size(21,21), int maxLevel=3, TermCriteria criteria=TermCriteria( TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), double derivLambda=0.5, int flags=0, double minEigThreshold=1e-4)
cv::calibrateCamera	calib3d/calib3d.hpp	/^CV_EXPORTS_W double calibrateCamera( InputArrayOfArrays objectPoints,$/;"	p	namespace:cv	signature:( InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, CV_OUT InputOutputArray cameraMatrix, CV_OUT InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags=0 )
cv::calibrationMatrixValues	calib3d/calib3d.hpp	/^CV_EXPORTS_W void calibrationMatrixValues( InputArray cameraMatrix,$/;"	p	namespace:cv	signature:( InputArray cameraMatrix, Size imageSize, double apertureWidth, double apertureHeight, CV_OUT double& fovx, CV_OUT double& fovy, CV_OUT double& focalLength, CV_OUT Point2d& principalPoint, CV_OUT double& aspectRatio )
cv::cartToPolar	core/core.hpp	/^CV_EXPORTS_W void cartToPolar(InputArray x, InputArray y,$/;"	p	namespace:cv	signature:(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees=false)
cv::chamerMatching	contrib/contrib.hpp	/^    CV_EXPORTS int chamerMatching( Mat& img, Mat& templ,$/;"	p	namespace:cv	signature:( Mat& img, Mat& templ, vector<vector<Point> >& results, vector<float>& cost, double templScale=1, int maxMatches = 20, double minMatchDistance = 1.0, int padX = 3, int padY = 3, int scales = 5, double minScale = 0.6, double maxScale = 1.6, double orientationWeight = 0.5, double truncate = 20)
cv::checkHardwareSupport	core/core.hpp	/^CV_EXPORTS_W bool checkHardwareSupport(int feature);$/;"	p	namespace:cv	signature:(int feature)
cv::checkRange	core/core.hpp	/^CV_EXPORTS_W bool checkRange(InputArray a, bool quiet=true, CV_OUT Point* pt=0,$/;"	p	namespace:cv	signature:(InputArray a, bool quiet=true, CV_OUT Point* pt=0, double minVal=-DBL_MAX, double maxVal=DBL_MAX)
cv::circle	core/core.hpp	/^CV_EXPORTS_W void circle(Mat& img, Point center, int radius,$/;"	p	namespace:cv	signature:(Mat& img, Point center, int radius, const Scalar& color, int thickness=1, int lineType=8, int shift=0)
cv::clearSeq	core/operations.hpp	/^CV_EXPORTS void  clearSeq( CvSeq* seq );$/;"	p	namespace:cv	signature:( CvSeq* seq )
cv::clipLine	core/core.hpp	/^CV_EXPORTS bool clipLine(Size imgSize, CV_IN_OUT Point& pt1, CV_IN_OUT Point& pt2);$/;"	p	namespace:cv	signature:(Size imgSize, CV_IN_OUT Point& pt1, CV_IN_OUT Point& pt2)
cv::clipLine	core/core.hpp	/^CV_EXPORTS_W bool clipLine(Rect imgRect, CV_OUT CV_IN_OUT Point& pt1, CV_OUT CV_IN_OUT Point& pt2);$/;"	p	namespace:cv	signature:(Rect imgRect, CV_OUT CV_IN_OUT Point& pt1, CV_OUT CV_IN_OUT Point& pt2)
cv::compare	core/core.hpp	/^CV_EXPORTS_W void compare(InputArray src1, InputArray src2, OutputArray dst, int cmpop);$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst, int cmpop)
cv::compareHist	imgproc/imgproc.hpp	/^CV_EXPORTS double compareHist( const SparseMat& H1, const SparseMat& H2, int method );$/;"	p	namespace:cv	signature:( const SparseMat& H1, const SparseMat& H2, int method )
cv::compareHist	imgproc/imgproc.hpp	/^CV_EXPORTS_W double compareHist( InputArray H1, InputArray H2, int method );$/;"	p	namespace:cv	signature:( InputArray H1, InputArray H2, int method )
cv::completeSymm	core/core.hpp	/^CV_EXPORTS_W void completeSymm(InputOutputArray mtx, bool lowerToUpper=false);$/;"	p	namespace:cv	signature:(InputOutputArray mtx, bool lowerToUpper=false)
cv::composeRT	calib3d/calib3d.hpp	/^CV_EXPORTS_W void composeRT( InputArray rvec1, InputArray tvec1,$/;"	p	namespace:cv	signature:( InputArray rvec1, InputArray tvec1, InputArray rvec2, InputArray tvec2, OutputArray rvec3, OutputArray tvec3, OutputArray dr3dr1=noArray(), OutputArray dr3dt1=noArray(), OutputArray dr3dr2=noArray(), OutputArray dr3dt2=noArray(), OutputArray dt3dr1=noArray(), OutputArray dt3dt1=noArray(), OutputArray dt3dr2=noArray(), OutputArray dt3dt2=noArray() )
cv::computeCorrespondEpilines	calib3d/calib3d.hpp	/^CV_EXPORTS void computeCorrespondEpilines( InputArray points1,$/;"	p	namespace:cv	signature:( InputArray points1, int whichImage, InputArray F, OutputArray lines )
cv::computeRecallPrecisionCurve	features2d/features2d.hpp	/^CV_EXPORTS void computeRecallPrecisionCurve( const vector<vector<DMatch> >& matches1to2,$/;"	p	namespace:cv	signature:( const vector<vector<DMatch> >& matches1to2, const vector<vector<uchar> >& correctMatches1to2Mask, vector<Point2f>& recallPrecisionCurve )
cv::contourArea	imgproc/imgproc.hpp	/^CV_EXPORTS_W double contourArea( InputArray contour, bool oriented=false );$/;"	p	namespace:cv	signature:( InputArray contour, bool oriented=false )
cv::convertMaps	imgproc/imgproc.hpp	/^CV_EXPORTS_W void convertMaps( InputArray map1, InputArray map2,$/;"	p	namespace:cv	signature:( InputArray map1, InputArray map2, OutputArray dstmap1, OutputArray dstmap2, int dstmap1type, bool nninterpolation=false )
cv::convertPointsFromHomogeneous	calib3d/calib3d.hpp	/^CV_EXPORTS_W void convertPointsFromHomogeneous( InputArray src, OutputArray dst );$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst )
cv::convertPointsHomogeneous	calib3d/calib3d.hpp	/^CV_EXPORTS void convertPointsHomogeneous( InputArray src, OutputArray dst );$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst )
cv::convertPointsToHomogeneous	calib3d/calib3d.hpp	/^CV_EXPORTS_W void convertPointsToHomogeneous( InputArray src, OutputArray dst );$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst )
cv::convertScaleAbs	core/core.hpp	/^CV_EXPORTS_W void convertScaleAbs(InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, double alpha=1, double beta=0)
cv::convexHull	imgproc/imgproc.hpp	/^CV_EXPORTS_W void convexHull( InputArray points, OutputArray hull,$/;"	p	namespace:cv	signature:( InputArray points, OutputArray hull, bool clockwise=false, bool returnPoints=true )
cv::copyMakeBorder	imgproc/imgproc.hpp	/^CV_EXPORTS_W void copyMakeBorder( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar& value=Scalar() )
cv::cornerEigenValsAndVecs	imgproc/imgproc.hpp	/^CV_EXPORTS_W void cornerEigenValsAndVecs( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int blockSize, int ksize, int borderType=BORDER_DEFAULT )
cv::cornerHarris	imgproc/imgproc.hpp	/^CV_EXPORTS_W void cornerHarris( InputArray src, OutputArray dst, int blockSize,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int blockSize, int ksize, double k, int borderType=BORDER_DEFAULT )
cv::cornerMinEigenVal	imgproc/imgproc.hpp	/^CV_EXPORTS_W void cornerMinEigenVal( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int blockSize, int ksize=3, int borderType=BORDER_DEFAULT )
cv::cornerSubPix	imgproc/imgproc.hpp	/^CV_EXPORTS_W void cornerSubPix( InputArray image, InputOutputArray corners,$/;"	p	namespace:cv	signature:( InputArray image, InputOutputArray corners, Size winSize, Size zeroZone, TermCriteria criteria )
cv::countNonZero	core/core.hpp	/^CV_EXPORTS_W int countNonZero( InputArray src );$/;"	p	namespace:cv	signature:( InputArray src )
cv::createBoxFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createBoxFilter( int srcType, int dstType, Size ksize,$/;"	p	namespace:cv	signature:( int srcType, int dstType, Size ksize, Point anchor=Point(-1,-1), bool normalize=true, int borderType=BORDER_DEFAULT)
cv::createButton	highgui/highgui.hpp	/^CV_EXPORTS int createButton( const string& bar_name, ButtonCallback on_change,$/;"	p	namespace:cv	signature:( const string& bar_name, ButtonCallback on_change, void* userdata=NULL, int type=CV_PUSH_BUTTON, bool initial_button_state=0)
cv::createDerivFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createDerivFilter( int srcType, int dstType,$/;"	p	namespace:cv	signature:( int srcType, int dstType, int dx, int dy, int ksize, int borderType=BORDER_DEFAULT )
cv::createGaussianFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createGaussianFilter( int type, Size ksize,$/;"	p	namespace:cv	signature:( int type, Size ksize, double sigma1, double sigma2=0, int borderType=BORDER_DEFAULT)
cv::createLinearFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createLinearFilter(int srcType, int dstType,$/;"	p	namespace:cv	signature:(int srcType, int dstType, InputArray kernel, Point _anchor=Point(-1,-1), double delta=0, int _rowBorderType=BORDER_DEFAULT, int _columnBorderType=-1, const Scalar& _borderValue=Scalar())
cv::createMorphologyFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createMorphologyFilter(int op, int type, InputArray kernel,$/;"	p	namespace:cv	signature:(int op, int type, InputArray kernel, Point anchor=Point(-1,-1), int _rowBorderType=BORDER_CONSTANT, int _columnBorderType=-1, const Scalar& _borderValue=morphologyDefaultBorderValue())
cv::createOpenGLCallback	highgui/highgui.hpp	/^CV_EXPORTS void createOpenGLCallback(const string& winname, CvOpenGLCallback callbackOpenGL, void* userdata=0);$/;"	p	namespace:cv	signature:(const string& winname, CvOpenGLCallback callbackOpenGL, void* userdata=0)
cv::createSeparableLinearFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<FilterEngine> createSeparableLinearFilter(int srcType, int dstType,$/;"	p	namespace:cv	signature:(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point _anchor=Point(-1,-1), double delta=0, int _rowBorderType=BORDER_DEFAULT, int _columnBorderType=-1, const Scalar& _borderValue=Scalar())
cv::createTrackbar	highgui/highgui.hpp	/^CV_EXPORTS int createTrackbar( const string& trackbarname, const string& winname,$/;"	p	namespace:cv	signature:( const string& trackbarname, const string& winname, int* value, int count, TrackbarCallback onChange=0, void* userdata=0)
cv::cubeRoot	core/core.hpp	/^CV_EXPORTS_W float cubeRoot(float val);$/;"	p	namespace:cv	signature:(float val)
cv::cv2eigen	core/eigen.hpp	/^void cv2eigen( const Mat& src,$/;"	f	namespace:cv	signature:( const Mat& src, Eigen::Matrix<_Tp, 1, Eigen::Dynamic>& dst )
cv::cv2eigen	core/eigen.hpp	/^void cv2eigen( const Mat& src,$/;"	f	namespace:cv	signature:( const Mat& src, Eigen::Matrix<_Tp, Eigen::Dynamic, 1>& dst )
cv::cv2eigen	core/eigen.hpp	/^void cv2eigen( const Mat& src,$/;"	f	namespace:cv	signature:( const Mat& src, Eigen::Matrix<_Tp, Eigen::Dynamic, Eigen::Dynamic>& dst )
cv::cv2eigen	core/eigen.hpp	/^void cv2eigen( const Mat& src,$/;"	f	namespace:cv	signature:( const Mat& src, Eigen::Matrix<_Tp, _rows, _cols, _options, _maxRows, _maxCols>& dst )
cv::cvarrToMat	core/core.hpp	/^CV_EXPORTS Mat cvarrToMat(const CvArr* arr, bool copyData=false,$/;"	p	namespace:cv	signature:(const CvArr* arr, bool copyData=false, bool allowND=true, int coiMode=0)
cv::cvarrToMatND	core/mat.hpp	/^static inline Mat cvarrToMatND(const CvArr* arr, bool copyData=false, int coiMode=0)$/;"	f	namespace:cv	signature:(const CvArr* arr, bool copyData=false, int coiMode=0)
cv::cvtColor	imgproc/imgproc.hpp	/^CV_EXPORTS_W void cvtColor( InputArray src, OutputArray dst, int code, int dstCn=0 );$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int code, int dstCn=0 )
cv::dct	core/core.hpp	/^CV_EXPORTS_W void dct(InputArray src, OutputArray dst, int flags=0);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, int flags=0)
cv::deallocate	core/core.hpp	/^template<typename _Tp> static inline void deallocate(_Tp* ptr, size_t)$/;"	f	namespace:cv	signature:(_Tp* ptr, size_t)
cv::decomposeProjectionMatrix	calib3d/calib3d.hpp	/^CV_EXPORTS_W void decomposeProjectionMatrix( InputArray projMatrix, OutputArray cameraMatrix,$/;"	p	namespace:cv	signature:( InputArray projMatrix, OutputArray cameraMatrix, OutputArray rotMatrix, OutputArray transVect, OutputArray rotMatrixX=noArray(), OutputArray rotMatrixY=noArray(), OutputArray rotMatrixZ=noArray(), OutputArray eulerAngles=noArray() )
cv::destroyAllWindows	highgui/highgui.hpp	/^CV_EXPORTS_W void destroyAllWindows();$/;"	p	namespace:cv	signature:()
cv::destroyWindow	highgui/highgui.hpp	/^CV_EXPORTS_W void destroyWindow( const string& winname );$/;"	p	namespace:cv	signature:( const string& winname )
cv::determinant	core/core.hpp	/^CV_EXPORTS_W double determinant(InputArray mtx);$/;"	p	namespace:cv	signature:(InputArray mtx)
cv::determinant	core/operations.hpp	/^double determinant(const Matx<_Tp, m, m>& a)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, m>& a)
cv::dft	core/core.hpp	/^CV_EXPORTS_W void dft(InputArray src, OutputArray dst, int flags=0, int nonzeroRows=0);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, int flags=0, int nonzeroRows=0)
cv::dilate	imgproc/imgproc.hpp	/^CV_EXPORTS_W void dilate( InputArray src, OutputArray dst, InputArray kernel,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, InputArray kernel, Point anchor=Point(-1,-1), int iterations=1, int borderType=BORDER_CONSTANT, const Scalar& borderValue=morphologyDefaultBorderValue() )
cv::displayOverlay	highgui/highgui.hpp	/^CV_EXPORTS void displayOverlay(const string& winname, const string& text, int delayms);$/;"	p	namespace:cv	signature:(const string& winname, const string& text, int delayms)
cv::displayStatusBar	highgui/highgui.hpp	/^CV_EXPORTS void displayStatusBar(const string& winname, const string& text, int delayms);$/;"	p	namespace:cv	signature:(const string& winname, const string& text, int delayms)
cv::distanceTransform	imgproc/imgproc.hpp	/^CV_EXPORTS void distanceTransform( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int distanceType, int maskSize )
cv::distanceTransform	imgproc/imgproc.hpp	/^CV_EXPORTS_W void distanceTransform( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, OutputArray labels, int distanceType, int maskSize )
cv::divide	core/core.hpp	/^CV_EXPORTS_W void divide(InputArray src1, InputArray src2, OutputArray dst,$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst, double scale=1, int dtype=-1)
cv::divide	core/core.hpp	/^CV_EXPORTS_W void divide(double scale, InputArray src2,$/;"	p	namespace:cv	signature:(double scale, InputArray src2, OutputArray dst, int dtype=-1)
cv::dot	core/operations.hpp	/^dot(const Vector<_Tp>& v1, const Vector<_Tp>& v2)$/;"	f	namespace:cv	signature:(const Vector<_Tp>& v1, const Vector<_Tp>& v2)
cv::drawChessboardCorners	calib3d/calib3d.hpp	/^CV_EXPORTS_W void drawChessboardCorners( InputOutputArray image, Size patternSize,$/;"	p	namespace:cv	signature:( InputOutputArray image, Size patternSize, InputArray corners, bool patternWasFound )
cv::drawContours	imgproc/imgproc.hpp	/^CV_EXPORTS_W void drawContours( InputOutputArray image, InputArrayOfArrays contours,$/;"	p	namespace:cv	signature:( InputOutputArray image, InputArrayOfArrays contours, int contourIdx, const Scalar& color, int thickness=1, int lineType=8, InputArray hierarchy=noArray(), int maxLevel=INT_MAX, Point offset=Point() )
cv::drawDataMatrixCodes	objdetect/objdetect.hpp	/^CV_EXPORTS  void drawDataMatrixCodes(const std::vector<DataMatrixCode>& codes, Mat& drawImage);$/;"	p	namespace:cv	signature:(const std::vector<DataMatrixCode>& codes, Mat& drawImage)
cv::drawKeypoints	features2d/features2d.hpp	/^CV_EXPORTS void drawKeypoints( const Mat& image, const vector<KeyPoint>& keypoints, Mat& outImage,$/;"	p	namespace:cv	signature:( const Mat& image, const vector<KeyPoint>& keypoints, Mat& outImage, const Scalar& color=Scalar::all(-1), int flags=DrawMatchesFlags::DEFAULT )
cv::drawMatches	features2d/features2d.hpp	/^CV_EXPORTS void drawMatches( const Mat& img1, const vector<KeyPoint>& keypoints1,$/;"	p	namespace:cv	signature:( const Mat& img1, const vector<KeyPoint>& keypoints1, const Mat& img2, const vector<KeyPoint>& keypoints2, const vector<DMatch>& matches1to2, Mat& outImg, const Scalar& matchColor=Scalar::all(-1), const Scalar& singlePointColor=Scalar::all(-1), const vector<char>& matchesMask=vector<char>(), int flags=DrawMatchesFlags::DEFAULT )
cv::drawMatches	features2d/features2d.hpp	/^CV_EXPORTS void drawMatches( const Mat& img1, const vector<KeyPoint>& keypoints1,$/;"	p	namespace:cv	signature:( const Mat& img1, const vector<KeyPoint>& keypoints1, const Mat& img2, const vector<KeyPoint>& keypoints2, const vector<vector<DMatch> >& matches1to2, Mat& outImg, const Scalar& matchColor=Scalar::all(-1), const Scalar& singlePointColor=Scalar::all(-1), const vector<vector<char> >& matchesMask=vector<vector<char> >(), int flags=DrawMatchesFlags::DEFAULT )
cv::eigen	core/core.hpp	/^CV_EXPORTS bool eigen(InputArray src, OutputArray eigenvalues, int lowindex=-1,$/;"	p	namespace:cv	signature:(InputArray src, OutputArray eigenvalues, int lowindex=-1, int highindex=-1)
cv::eigen	core/core.hpp	/^CV_EXPORTS bool eigen(InputArray src, OutputArray eigenvalues,$/;"	p	namespace:cv	signature:(InputArray src, OutputArray eigenvalues, OutputArray eigenvectors, int lowindex=-1, int highindex=-1)
cv::eigen	core/core.hpp	/^CV_EXPORTS_W bool eigen(InputArray src, bool computeEigenvectors,$/;"	p	namespace:cv	signature:(InputArray src, bool computeEigenvectors, OutputArray eigenvalues, OutputArray eigenvectors)
cv::eigen2cv	core/eigen.hpp	/^void eigen2cv( const Eigen::Matrix<_Tp, _rows, _cols, _options, _maxRows, _maxCols>& src, Mat& dst )$/;"	f	namespace:cv	signature:( const Eigen::Matrix<_Tp, _rows, _cols, _options, _maxRows, _maxCols>& src, Mat& dst )
cv::ellipse	core/core.hpp	/^CV_EXPORTS_W void ellipse(Mat& img, Point center, Size axes,$/;"	p	namespace:cv	signature:(Mat& img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar& color, int thickness=1, int lineType=8, int shift=0)
cv::ellipse	core/core.hpp	/^CV_EXPORTS_W void ellipse(Mat& img, const RotatedRect& box, const Scalar& color,$/;"	p	namespace:cv	signature:(Mat& img, const RotatedRect& box, const Scalar& color, int thickness=1, int lineType=8)
cv::ellipse2Poly	core/core.hpp	/^CV_EXPORTS_W void ellipse2Poly( Point center, Size axes, int angle,$/;"	p	namespace:cv	signature:( Point center, Size axes, int angle, int arcStart, int arcEnd, int delta, CV_OUT vector<Point>& pts )
cv::equalizeHist	imgproc/imgproc.hpp	/^CV_EXPORTS_W void equalizeHist( InputArray src, OutputArray dst );$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst )
cv::erode	imgproc/imgproc.hpp	/^CV_EXPORTS_W void erode( InputArray src, OutputArray dst, InputArray kernel,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, InputArray kernel, Point anchor=Point(-1,-1), int iterations=1, int borderType=BORDER_CONSTANT, const Scalar& borderValue=morphologyDefaultBorderValue() )
cv::error	core/core.hpp	/^CV_EXPORTS void error( const Exception& exc );$/;"	p	namespace:cv	signature:( const Exception& exc )
cv::estimateAffine3D	calib3d/calib3d.hpp	/^CV_EXPORTS_W  int estimateAffine3D(InputArray _from, InputArray _to,$/;"	p	namespace:cv	signature:(InputArray _from, InputArray _to, OutputArray _out, OutputArray _inliers, double param1=3, double param2=0.99)
cv::estimateRigidTransform	video/tracking.hpp	/^CV_EXPORTS_W Mat estimateRigidTransform( InputArray src, InputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, InputArray dst, bool fullAffine)
cv::evaluateFeatureDetector	features2d/features2d.hpp	/^CV_EXPORTS void evaluateFeatureDetector( const Mat& img1, const Mat& img2, const Mat& H1to2,$/;"	p	namespace:cv	signature:( const Mat& img1, const Mat& img2, const Mat& H1to2, vector<KeyPoint>* keypoints1, vector<KeyPoint>* keypoints2, float& repeatability, int& correspCount, const Ptr<FeatureDetector>& fdetector=Ptr<FeatureDetector>() )
cv::evaluateGenericDescriptorMatcher	features2d/features2d.hpp	/^CV_EXPORTS void evaluateGenericDescriptorMatcher( const Mat& img1, const Mat& img2, const Mat& H1to2,$/;"	p	namespace:cv	signature:( const Mat& img1, const Mat& img2, const Mat& H1to2, vector<KeyPoint>& keypoints1, vector<KeyPoint>& keypoints2, vector<vector<DMatch> >* matches1to2, vector<vector<uchar> >* correctMatches1to2Mask, vector<Point2f>& recallPrecisionCurve, const Ptr<GenericDescriptorMatcher>& dmatch=Ptr<GenericDescriptorMatcher>() )
cv::exp	core/core.hpp	/^CV_EXPORTS_W void exp(InputArray src, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst)
cv::extractChannel	core/core.hpp	/^CV_EXPORTS_W void extractChannel(InputArray src, OutputArray dst, int coi);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, int coi)
cv::extractImageCOI	core/core.hpp	/^CV_EXPORTS void extractImageCOI(const CvArr* arr, OutputArray coiimg, int coi=-1);$/;"	p	namespace:cv	signature:(const CvArr* arr, OutputArray coiimg, int coi=-1)
cv::fastAtan2	core/core.hpp	/^CV_EXPORTS_W float fastAtan2(float y, float x);$/;"	p	namespace:cv	signature:(float y, float x)
cv::fastFree	core/core.hpp	/^CV_EXPORTS void fastFree(void* ptr);$/;"	p	namespace:cv	signature:(void* ptr)
cv::fastMalloc	core/core.hpp	/^CV_EXPORTS void* fastMalloc(size_t bufSize);$/;"	p	namespace:cv	signature:(size_t bufSize)
cv::fillConvexPoly	core/core.hpp	/^CV_EXPORTS void fillConvexPoly(Mat& img, const Point* pts, int npts,$/;"	p	namespace:cv	signature:(Mat& img, const Point* pts, int npts, const Scalar& color, int lineType=8, int shift=0)
cv::fillConvexPoly	core/core.hpp	/^CV_EXPORTS_W void fillConvexPoly(InputOutputArray img, InputArray points,$/;"	p	namespace:cv	signature:(InputOutputArray img, InputArray points, const Scalar& color, int lineType=8, int shift=0)
cv::fillPoly	core/core.hpp	/^CV_EXPORTS void fillPoly(Mat& img, const Point** pts,$/;"	p	namespace:cv	signature:(Mat& img, const Point** pts, const int* npts, int ncontours, const Scalar& color, int lineType=8, int shift=0, Point offset=Point() )
cv::fillPoly	core/core.hpp	/^CV_EXPORTS_W void fillPoly(InputOutputArray img, InputArrayOfArrays pts,$/;"	p	namespace:cv	signature:(InputOutputArray img, InputArrayOfArrays pts, const Scalar& color, int lineType=8, int shift=0, Point offset=Point() )
cv::filter2D	imgproc/imgproc.hpp	/^CV_EXPORTS_W void filter2D( InputArray src, OutputArray dst, int ddepth,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor=Point(-1,-1), double delta=0, int borderType=BORDER_DEFAULT )
cv::filterSpeckles	calib3d/calib3d.hpp	/^CV_EXPORTS_W void filterSpeckles( InputOutputArray img, double newVal, int maxSpeckleSize, double maxDiff,$/;"	p	namespace:cv	signature:( InputOutputArray img, double newVal, int maxSpeckleSize, double maxDiff, InputOutputArray buf=noArray() )
cv::filterSpeckles	gpu/gpu.hpp	/^    CV_EXPORTS void filterSpeckles( Mat& img, uchar newVal, int maxSpeckleSize, uchar diffThreshold, Mat& buf);$/;"	p	namespace:cv	signature:( Mat& img, uchar newVal, int maxSpeckleSize, uchar diffThreshold, Mat& buf)
cv::find4QuadCornerSubpix	calib3d/calib3d.hpp	/^CV_EXPORTS bool find4QuadCornerSubpix(InputArray img, InputOutputArray corners, Size region_size);$/;"	p	namespace:cv	signature:(InputArray img, InputOutputArray corners, Size region_size)
cv::findChessboardCorners	calib3d/calib3d.hpp	/^CV_EXPORTS_W bool findChessboardCorners( InputArray image, Size patternSize,$/;"	p	namespace:cv	signature:( InputArray image, Size patternSize, OutputArray corners, int flags=CALIB_CB_ADAPTIVE_THRESH+ CALIB_CB_NORMALIZE_IMAGE )
cv::findCirclesGrid	calib3d/calib3d.hpp	/^CV_EXPORTS bool findCirclesGrid( InputArray image, Size patternSize,$/;"	p	namespace:cv	signature:( InputArray image, Size patternSize, OutputArray centers, int flags=CALIB_CB_SYMMETRIC_GRID, const Ptr<FeatureDetector> &blobDetector = new SimpleBlobDetector())
cv::findCirclesGridDefault	calib3d/calib3d.hpp	/^CV_EXPORTS_W bool findCirclesGridDefault( InputArray image, Size patternSize,$/;"	p	namespace:cv	signature:( InputArray image, Size patternSize, OutputArray centers, int flags=CALIB_CB_SYMMETRIC_GRID )
cv::findContours	imgproc/imgproc.hpp	/^CV_EXPORTS void findContours( InputOutputArray image, OutputArrayOfArrays contours,$/;"	p	namespace:cv	signature:( InputOutputArray image, OutputArrayOfArrays contours, int mode, int method, Point offset=Point())
cv::findContours	imgproc/imgproc.hpp	/^CV_EXPORTS_W void findContours( InputOutputArray image, OutputArrayOfArrays contours,$/;"	p	namespace:cv	signature:( InputOutputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset=Point())
cv::findDataMatrix	objdetect/objdetect.hpp	/^CV_EXPORTS void findDataMatrix(const Mat& image, std::vector<DataMatrixCode>& codes);$/;"	p	namespace:cv	signature:(const Mat& image, std::vector<DataMatrixCode>& codes)
cv::findFundamentalMat	calib3d/calib3d.hpp	/^CV_EXPORTS Mat findFundamentalMat( InputArray points1, InputArray points2,$/;"	p	namespace:cv	signature:( InputArray points1, InputArray points2, OutputArray mask, int method=FM_RANSAC, double param1=3., double param2=0.99)
cv::findFundamentalMat	calib3d/calib3d.hpp	/^CV_EXPORTS_W Mat findFundamentalMat( InputArray points1, InputArray points2,$/;"	p	namespace:cv	signature:( InputArray points1, InputArray points2, int method=FM_RANSAC, double param1=3., double param2=0.99, OutputArray mask=noArray())
cv::findHomography	calib3d/calib3d.hpp	/^CV_EXPORTS Mat findHomography( InputArray srcPoints, InputArray dstPoints,$/;"	p	namespace:cv	signature:( InputArray srcPoints, InputArray dstPoints, OutputArray mask, int method=0, double ransacReprojThreshold=3)
cv::findHomography	calib3d/calib3d.hpp	/^CV_EXPORTS_W Mat findHomography( InputArray srcPoints, InputArray dstPoints,$/;"	p	namespace:cv	signature:( InputArray srcPoints, InputArray dstPoints, int method=0, double ransacReprojThreshold=3, OutputArray mask=noArray())
cv::fitEllipse	imgproc/imgproc.hpp	/^CV_EXPORTS_W RotatedRect fitEllipse( InputArray points );$/;"	p	namespace:cv	signature:( InputArray points )
cv::fitLine	imgproc/imgproc.hpp	/^CV_EXPORTS_W void fitLine( InputArray points, OutputArray line, int distType,$/;"	p	namespace:cv	signature:( InputArray points, OutputArray line, int distType, double param, double reps, double aeps )
cv::flann	flann/flann.hpp	/^namespace flann$/;"	n	namespace:cv
cv::flann	flann/miniflann.hpp	/^namespace flann$/;"	n	namespace:cv
cv::flann::AutotunedIndexParams	flann/miniflann.hpp	/^struct CV_EXPORTS AutotunedIndexParams : public IndexParams$/;"	s	namespace:cv::flann	inherits:IndexParams
cv::flann::AutotunedIndexParams::AutotunedIndexParams	flann/miniflann.hpp	/^    AutotunedIndexParams(float target_precision = 0.8, float build_weight = 0.01,$/;"	p	struct:cv::flann::AutotunedIndexParams	access:public	signature:(float target_precision = 0.8, float build_weight = 0.01, float memory_weight = 0, float sample_fraction = 0.1)
cv::flann::CompositeIndexParams	flann/miniflann.hpp	/^struct CV_EXPORTS CompositeIndexParams : public IndexParams$/;"	s	namespace:cv::flann	inherits:IndexParams
cv::flann::CompositeIndexParams::CompositeIndexParams	flann/miniflann.hpp	/^    CompositeIndexParams(int trees = 4, int branching = 32, int iterations = 11,$/;"	p	struct:cv::flann::CompositeIndexParams	access:public	signature:(int trees = 4, int branching = 32, int iterations = 11, cvflann::flann_centers_init_t centers_init = cvflann::FLANN_CENTERS_RANDOM, float cb_index = 0.2 )
cv::flann::CvType	flann/flann.hpp	/^template <> struct CvType<char> { static int type() { return CV_8S; } };$/;"	s	namespace:cv::flann
cv::flann::CvType	flann/flann.hpp	/^template <> struct CvType<double> { static int type() { return CV_64F; } };$/;"	s	namespace:cv::flann
cv::flann::CvType	flann/flann.hpp	/^template <> struct CvType<float> { static int type() { return CV_32F; } };$/;"	s	namespace:cv::flann
cv::flann::CvType	flann/flann.hpp	/^template <> struct CvType<int> { static int type() { return CV_32S; } };$/;"	s	namespace:cv::flann
cv::flann::CvType	flann/flann.hpp	/^template <> struct CvType<short> { static int type() { return CV_16S; } };$/;"	s	namespace:cv::flann
cv::flann::CvType	flann/flann.hpp	/^template <> struct CvType<unsigned char> { static int type() { return CV_8U; } };$/;"	s	namespace:cv::flann
cv::flann::CvType	flann/flann.hpp	/^template <> struct CvType<unsigned short> { static int type() { return CV_16U; } };$/;"	s	namespace:cv::flann
cv::flann::CvType	flann/flann.hpp	/^template <typename T> struct CvType {};$/;"	s	namespace:cv::flann
cv::flann::CvType::type	flann/flann.hpp	/^template <> struct CvType<char> { static int type() { return CV_8S; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
cv::flann::CvType::type	flann/flann.hpp	/^template <> struct CvType<double> { static int type() { return CV_64F; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
cv::flann::CvType::type	flann/flann.hpp	/^template <> struct CvType<float> { static int type() { return CV_32F; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
cv::flann::CvType::type	flann/flann.hpp	/^template <> struct CvType<int> { static int type() { return CV_32S; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
cv::flann::CvType::type	flann/flann.hpp	/^template <> struct CvType<short> { static int type() { return CV_16S; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
cv::flann::CvType::type	flann/flann.hpp	/^template <> struct CvType<unsigned char> { static int type() { return CV_8U; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
cv::flann::CvType::type	flann/flann.hpp	/^template <> struct CvType<unsigned short> { static int type() { return CV_16U; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
cv::flann::GenericIndex	flann/flann.hpp	/^class GenericIndex $/;"	c	namespace:cv::flann
cv::flann::GenericIndex::DistanceType	flann/flann.hpp	/^        typedef typename Distance::ResultType DistanceType;$/;"	t	class:cv::flann::GenericIndex	access:public
cv::flann::GenericIndex::ElementType	flann/flann.hpp	/^        typedef typename Distance::ElementType ElementType;$/;"	t	class:cv::flann::GenericIndex	access:public
cv::flann::GenericIndex::GenericIndex	flann/flann.hpp	/^        GenericIndex(const Mat& features, const ::cvflann::IndexParams& params, Distance distance = Distance());$/;"	p	class:cv::flann::GenericIndex	access:public	signature:(const Mat& features, const ::cvflann::IndexParams& params, Distance distance = Distance())
cv::flann::GenericIndex::GenericIndex	flann/flann.hpp	/^GenericIndex<Distance>::GenericIndex(const Mat& dataset, const ::cvflann::IndexParams& params, Distance distance)$/;"	f	class:cv::flann::GenericIndex	signature:(const Mat& dataset, const ::cvflann::IndexParams& params, Distance distance)
cv::flann::GenericIndex::getIndexParameters	flann/flann.hpp	/^        FLANN_DEPRECATED const ::cvflann::IndexParams* getIndexParameters() { return nnIndex->getIndexParameters(); }$/;"	f	class:cv::flann::GenericIndex	access:public	signature:()
cv::flann::GenericIndex::getParameters	flann/flann.hpp	/^        ::cvflann::IndexParams getParameters() { return nnIndex->getParameters(); }$/;"	f	class:cv::flann::GenericIndex	access:public	signature:()
cv::flann::GenericIndex::knnSearch	flann/flann.hpp	/^        void knnSearch(const Mat& queries, Mat& indices, Mat& dists, int knn, const ::cvflann::SearchParams& params);$/;"	p	class:cv::flann::GenericIndex	access:public	signature:(const Mat& queries, Mat& indices, Mat& dists, int knn, const ::cvflann::SearchParams& params)
cv::flann::GenericIndex::knnSearch	flann/flann.hpp	/^        void knnSearch(const vector<ElementType>& query, vector<int>& indices, $/;"	p	class:cv::flann::GenericIndex	access:public	signature:(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, int knn, const ::cvflann::SearchParams& params)
cv::flann::GenericIndex::knnSearch	flann/flann.hpp	/^void GenericIndex<Distance>::knnSearch(const Mat& queries, Mat& indices, Mat& dists, int knn, const ::cvflann::SearchParams& searchParams)$/;"	f	class:cv::flann::GenericIndex	signature:(const Mat& queries, Mat& indices, Mat& dists, int knn, const ::cvflann::SearchParams& searchParams)
cv::flann::GenericIndex::knnSearch	flann/flann.hpp	/^void GenericIndex<Distance>::knnSearch(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, int knn, const ::cvflann::SearchParams& searchParams)$/;"	f	class:cv::flann::GenericIndex	signature:(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, int knn, const ::cvflann::SearchParams& searchParams)
cv::flann::GenericIndex::nnIndex	flann/flann.hpp	/^        ::cvflann::Index<Distance>* nnIndex;$/;"	m	class:cv::flann::GenericIndex	access:private
cv::flann::GenericIndex::radiusSearch	flann/flann.hpp	/^        int radiusSearch(const Mat& query, Mat& indices, Mat& dists, $/;"	p	class:cv::flann::GenericIndex	access:public	signature:(const Mat& query, Mat& indices, Mat& dists, DistanceType radius, const ::cvflann::SearchParams& params)
cv::flann::GenericIndex::radiusSearch	flann/flann.hpp	/^        int radiusSearch(const vector<ElementType>& query, vector<int>& indices, $/;"	p	class:cv::flann::GenericIndex	access:public	signature:(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, DistanceType radius, const ::cvflann::SearchParams& params)
cv::flann::GenericIndex::radiusSearch	flann/flann.hpp	/^int GenericIndex<Distance>::radiusSearch(const Mat& query, Mat& indices, Mat& dists, DistanceType radius, const ::cvflann::SearchParams& searchParams)$/;"	f	class:cv::flann::GenericIndex	signature:(const Mat& query, Mat& indices, Mat& dists, DistanceType radius, const ::cvflann::SearchParams& searchParams)
cv::flann::GenericIndex::radiusSearch	flann/flann.hpp	/^int GenericIndex<Distance>::radiusSearch(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, DistanceType radius, const ::cvflann::SearchParams& searchParams)$/;"	f	class:cv::flann::GenericIndex	signature:(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, DistanceType radius, const ::cvflann::SearchParams& searchParams)
cv::flann::GenericIndex::save	flann/flann.hpp	/^        void save(std::string filename) { nnIndex->save(filename); }$/;"	f	class:cv::flann::GenericIndex	access:public	signature:(std::string filename)
cv::flann::GenericIndex::size	flann/flann.hpp	/^        int size() const { return nnIndex->size(); }$/;"	f	class:cv::flann::GenericIndex	access:public	signature:() const
cv::flann::GenericIndex::veclen	flann/flann.hpp	/^        int veclen() const { return nnIndex->veclen(); }$/;"	f	class:cv::flann::GenericIndex	access:public	signature:() const
cv::flann::GenericIndex::~GenericIndex	flann/flann.hpp	/^        ~GenericIndex();$/;"	p	class:cv::flann::GenericIndex	access:public	signature:()
cv::flann::GenericIndex::~GenericIndex	flann/flann.hpp	/^GenericIndex<Distance>::~GenericIndex()$/;"	f	class:cv::flann::GenericIndex	signature:()
cv::flann::Index	flann/miniflann.hpp	/^class CV_EXPORTS_W Index$/;"	c	namespace:cv::flann
cv::flann::Index::Index	flann/miniflann.hpp	/^    CV_WRAP Index();$/;"	p	class:cv::flann::Index	access:public	signature:()
cv::flann::Index::Index	flann/miniflann.hpp	/^    CV_WRAP Index(InputArray features, const IndexParams& params, cvflann::flann_distance_t distType=cvflann::FLANN_DIST_L2);$/;"	p	class:cv::flann::Index	access:public	signature:(InputArray features, const IndexParams& params, cvflann::flann_distance_t distType=cvflann::FLANN_DIST_L2)
cv::flann::Index::algo	flann/miniflann.hpp	/^    cvflann::flann_algorithm_t algo;$/;"	m	class:cv::flann::Index	access:protected
cv::flann::Index::build	flann/miniflann.hpp	/^    CV_WRAP virtual void build(InputArray features, const IndexParams& params, cvflann::flann_distance_t distType=cvflann::FLANN_DIST_L2);$/;"	p	class:cv::flann::Index	access:public	signature:(InputArray features, const IndexParams& params, cvflann::flann_distance_t distType=cvflann::FLANN_DIST_L2)
cv::flann::Index::distType	flann/miniflann.hpp	/^    cvflann::flann_distance_t distType;$/;"	m	class:cv::flann::Index	access:protected
cv::flann::Index::featureType	flann/miniflann.hpp	/^    int featureType;$/;"	m	class:cv::flann::Index	access:protected
cv::flann::Index::getAlgorithm	flann/miniflann.hpp	/^    CV_WRAP cvflann::flann_algorithm_t getAlgorithm() const;$/;"	p	class:cv::flann::Index	access:public	signature:() const
cv::flann::Index::getDistance	flann/miniflann.hpp	/^    CV_WRAP cvflann::flann_distance_t getDistance() const;$/;"	p	class:cv::flann::Index	access:public	signature:() const
cv::flann::Index::index	flann/miniflann.hpp	/^    void* index;$/;"	m	class:cv::flann::Index	access:protected
cv::flann::Index::knnSearch	flann/miniflann.hpp	/^    CV_WRAP virtual void knnSearch(InputArray query, OutputArray indices, $/;"	p	class:cv::flann::Index	access:public	signature:(InputArray query, OutputArray indices, OutputArray dists, int knn, const SearchParams& params=SearchParams())
cv::flann::Index::load	flann/miniflann.hpp	/^    CV_WRAP virtual bool load(InputArray features, const std::string& filename);$/;"	p	class:cv::flann::Index	access:public	signature:(InputArray features, const std::string& filename)
cv::flann::Index::radiusSearch	flann/miniflann.hpp	/^    CV_WRAP virtual int radiusSearch(InputArray query, OutputArray indices,$/;"	p	class:cv::flann::Index	access:public	signature:(InputArray query, OutputArray indices, OutputArray dists, double radius, int maxResults, const SearchParams& params=SearchParams())
cv::flann::Index::release	flann/miniflann.hpp	/^    CV_WRAP virtual void release();$/;"	p	class:cv::flann::Index	access:public	signature:()
cv::flann::Index::save	flann/miniflann.hpp	/^    CV_WRAP virtual void save(const std::string& filename) const;$/;"	p	class:cv::flann::Index	access:public	signature:(const std::string& filename) const
cv::flann::Index::~Index	flann/miniflann.hpp	/^    virtual ~Index();$/;"	p	class:cv::flann::Index	access:public	signature:()
cv::flann::IndexParams	flann/miniflann.hpp	/^struct CV_EXPORTS IndexParams$/;"	s	namespace:cv::flann
cv::flann::IndexParams::IndexParams	flann/miniflann.hpp	/^    IndexParams();$/;"	p	struct:cv::flann::IndexParams	access:public	signature:()
cv::flann::IndexParams::getAll	flann/miniflann.hpp	/^    void getAll(std::vector<std::string>& names,$/;"	p	struct:cv::flann::IndexParams	access:public	signature:(std::vector<std::string>& names, std::vector<int>& types, std::vector<std::string>& strValues, std::vector<double>& numValues) const
cv::flann::IndexParams::getDouble	flann/miniflann.hpp	/^    double getDouble(const std::string& key, double defaultVal=-1) const;$/;"	p	struct:cv::flann::IndexParams	access:public	signature:(const std::string& key, double defaultVal=-1) const
cv::flann::IndexParams::getInt	flann/miniflann.hpp	/^    int getInt(const std::string& key, int defaultVal=-1) const;$/;"	p	struct:cv::flann::IndexParams	access:public	signature:(const std::string& key, int defaultVal=-1) const
cv::flann::IndexParams::getString	flann/miniflann.hpp	/^    std::string getString(const std::string& key, const std::string& defaultVal=std::string()) const;$/;"	p	struct:cv::flann::IndexParams	access:public	signature:(const std::string& key, const std::string& defaultVal=std::string()) const
cv::flann::IndexParams::params	flann/miniflann.hpp	/^    void* params;$/;"	m	struct:cv::flann::IndexParams	access:public
cv::flann::IndexParams::setAlgorithm	flann/miniflann.hpp	/^    void setAlgorithm(int value);$/;"	p	struct:cv::flann::IndexParams	access:public	signature:(int value)
cv::flann::IndexParams::setBool	flann/miniflann.hpp	/^    void setBool(const std::string& key, bool value);$/;"	p	struct:cv::flann::IndexParams	access:public	signature:(const std::string& key, bool value)
cv::flann::IndexParams::setDouble	flann/miniflann.hpp	/^    void setDouble(const std::string& key, double value);$/;"	p	struct:cv::flann::IndexParams	access:public	signature:(const std::string& key, double value)
cv::flann::IndexParams::setFloat	flann/miniflann.hpp	/^    void setFloat(const std::string& key, float value);$/;"	p	struct:cv::flann::IndexParams	access:public	signature:(const std::string& key, float value)
cv::flann::IndexParams::setInt	flann/miniflann.hpp	/^    void setInt(const std::string& key, int value);$/;"	p	struct:cv::flann::IndexParams	access:public	signature:(const std::string& key, int value)
cv::flann::IndexParams::setString	flann/miniflann.hpp	/^    void setString(const std::string& key, const std::string& value);$/;"	p	struct:cv::flann::IndexParams	access:public	signature:(const std::string& key, const std::string& value)
cv::flann::IndexParams::~IndexParams	flann/miniflann.hpp	/^    ~IndexParams();$/;"	p	struct:cv::flann::IndexParams	access:public	signature:()
cv::flann::Index_	flann/flann.hpp	/^class FLANN_DEPRECATED Index_ {$/;"	c	namespace:cv::flann
cv::flann::Index_::DistanceType	flann/flann.hpp	/^        typedef typename L2<T>::ResultType DistanceType;$/;"	t	class:cv::flann::Index_	access:public
cv::flann::Index_::ElementType	flann/flann.hpp	/^        typedef typename L2<T>::ElementType ElementType;$/;"	t	class:cv::flann::Index_	access:public
cv::flann::Index_::Index_	flann/flann.hpp	/^	Index_(const Mat& features, const ::cvflann::IndexParams& params);$/;"	p	class:cv::flann::Index_	access:public	signature:(const Mat& features, const ::cvflann::IndexParams& params)
cv::flann::Index_::Index_	flann/flann.hpp	/^Index_<T>::Index_(const Mat& dataset, const ::cvflann::IndexParams& params)$/;"	f	class:cv::flann::Index_	signature:(const Mat& dataset, const ::cvflann::IndexParams& params)
cv::flann::Index_::getIndexParameters	flann/flann.hpp	/^        FLANN_DEPRECATED const ::cvflann::IndexParams* getIndexParameters() $/;"	f	class:cv::flann::Index_	access:public	signature:()
cv::flann::Index_::getParameters	flann/flann.hpp	/^        ::cvflann::IndexParams getParameters() $/;"	f	class:cv::flann::Index_	access:public	signature:()
cv::flann::Index_::knnSearch	flann/flann.hpp	/^	void knnSearch(const Mat& queries, Mat& indices, Mat& dists, int knn, const ::cvflann::SearchParams& params);$/;"	p	class:cv::flann::Index_	access:public	signature:(const Mat& queries, Mat& indices, Mat& dists, int knn, const ::cvflann::SearchParams& params)
cv::flann::Index_::knnSearch	flann/flann.hpp	/^	void knnSearch(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, int knn, const ::cvflann::SearchParams& params);$/;"	p	class:cv::flann::Index_	access:public	signature:(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, int knn, const ::cvflann::SearchParams& params)
cv::flann::Index_::knnSearch	flann/flann.hpp	/^void Index_<T>::knnSearch(const Mat& queries, Mat& indices, Mat& dists, int knn, const ::cvflann::SearchParams& searchParams)$/;"	f	class:cv::flann::Index_	signature:(const Mat& queries, Mat& indices, Mat& dists, int knn, const ::cvflann::SearchParams& searchParams)
cv::flann::Index_::knnSearch	flann/flann.hpp	/^void Index_<T>::knnSearch(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, int knn, const ::cvflann::SearchParams& searchParams)$/;"	f	class:cv::flann::Index_	signature:(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, int knn, const ::cvflann::SearchParams& searchParams)
cv::flann::Index_::nnIndex_L1	flann/flann.hpp	/^        ::cvflann::Index< L1<ElementType> >* nnIndex_L1;$/;"	m	class:cv::flann::Index_	access:private
cv::flann::Index_::nnIndex_L2	flann/flann.hpp	/^        ::cvflann::Index< L2<ElementType> >* nnIndex_L2;$/;"	m	class:cv::flann::Index_	access:private
cv::flann::Index_::radiusSearch	flann/flann.hpp	/^	int radiusSearch(const Mat& query, Mat& indices, Mat& dists, DistanceType radius, const ::cvflann::SearchParams& params);$/;"	p	class:cv::flann::Index_	access:public	signature:(const Mat& query, Mat& indices, Mat& dists, DistanceType radius, const ::cvflann::SearchParams& params)
cv::flann::Index_::radiusSearch	flann/flann.hpp	/^	int radiusSearch(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, DistanceType radius, const ::cvflann::SearchParams& params);$/;"	p	class:cv::flann::Index_	access:public	signature:(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, DistanceType radius, const ::cvflann::SearchParams& params)
cv::flann::Index_::radiusSearch	flann/flann.hpp	/^int Index_<T>::radiusSearch(const Mat& query, Mat& indices, Mat& dists, DistanceType radius, const ::cvflann::SearchParams& searchParams)$/;"	f	class:cv::flann::Index_	signature:(const Mat& query, Mat& indices, Mat& dists, DistanceType radius, const ::cvflann::SearchParams& searchParams)
cv::flann::Index_::radiusSearch	flann/flann.hpp	/^int Index_<T>::radiusSearch(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, DistanceType radius, const ::cvflann::SearchParams& searchParams)$/;"	f	class:cv::flann::Index_	signature:(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, DistanceType radius, const ::cvflann::SearchParams& searchParams)
cv::flann::Index_::save	flann/flann.hpp	/^	void save(std::string filename) $/;"	f	class:cv::flann::Index_	access:public	signature:(std::string filename)
cv::flann::Index_::size	flann/flann.hpp	/^	int size() const $/;"	f	class:cv::flann::Index_	access:public	signature:() const
cv::flann::Index_::veclen	flann/flann.hpp	/^	int veclen() const $/;"	f	class:cv::flann::Index_	access:public	signature:() const
cv::flann::Index_::~Index_	flann/flann.hpp	/^	~Index_();$/;"	p	class:cv::flann::Index_	access:public	signature:()
cv::flann::Index_::~Index_	flann/flann.hpp	/^Index_<T>::~Index_()$/;"	f	class:cv::flann::Index_	signature:()
cv::flann::KDTreeIndexParams	flann/miniflann.hpp	/^struct CV_EXPORTS KDTreeIndexParams : public IndexParams$/;"	s	namespace:cv::flann	inherits:IndexParams
cv::flann::KDTreeIndexParams::KDTreeIndexParams	flann/miniflann.hpp	/^    KDTreeIndexParams(int trees=4);$/;"	p	struct:cv::flann::KDTreeIndexParams	access:public	signature:(int trees=4)
cv::flann::KMeansIndexParams	flann/miniflann.hpp	/^struct CV_EXPORTS KMeansIndexParams : public IndexParams$/;"	s	namespace:cv::flann	inherits:IndexParams
cv::flann::KMeansIndexParams::KMeansIndexParams	flann/miniflann.hpp	/^    KMeansIndexParams(int branching = 32, int iterations = 11,$/;"	p	struct:cv::flann::KMeansIndexParams	access:public	signature:(int branching = 32, int iterations = 11, cvflann::flann_centers_init_t centers_init = cvflann::FLANN_CENTERS_RANDOM, float cb_index = 0.2 )
cv::flann::LinearIndexParams	flann/miniflann.hpp	/^struct CV_EXPORTS LinearIndexParams : public IndexParams$/;"	s	namespace:cv::flann	inherits:IndexParams
cv::flann::LinearIndexParams::LinearIndexParams	flann/miniflann.hpp	/^    LinearIndexParams();$/;"	p	struct:cv::flann::LinearIndexParams	access:public	signature:()
cv::flann::LshIndexParams	flann/miniflann.hpp	/^struct CV_EXPORTS LshIndexParams : public IndexParams$/;"	s	namespace:cv::flann	inherits:IndexParams
cv::flann::LshIndexParams::LshIndexParams	flann/miniflann.hpp	/^    LshIndexParams(int table_number, int key_size, int multi_probe_level);$/;"	p	struct:cv::flann::LshIndexParams	access:public	signature:(int table_number, int key_size, int multi_probe_level)
cv::flann::SavedIndexParams	flann/miniflann.hpp	/^struct CV_EXPORTS SavedIndexParams : public IndexParams$/;"	s	namespace:cv::flann	inherits:IndexParams
cv::flann::SavedIndexParams::SavedIndexParams	flann/miniflann.hpp	/^    SavedIndexParams(const std::string& filename);$/;"	p	struct:cv::flann::SavedIndexParams	access:public	signature:(const std::string& filename)
cv::flann::SearchParams	flann/miniflann.hpp	/^struct CV_EXPORTS SearchParams : public IndexParams$/;"	s	namespace:cv::flann	inherits:IndexParams
cv::flann::SearchParams::SearchParams	flann/miniflann.hpp	/^    SearchParams( int checks = 32, float eps = 0, bool sorted = true );$/;"	p	struct:cv::flann::SearchParams	access:public	signature:( int checks = 32, float eps = 0, bool sorted = true )
cv::flann::hierarchicalClustering	flann/flann.hpp	/^FLANN_DEPRECATED int hierarchicalClustering(const Mat& features, Mat& centers, const ::cvflann::IndexParams& params)$/;"	f	namespace:cv::flann	signature:(const Mat& features, Mat& centers, const ::cvflann::IndexParams& params)
cv::flann::hierarchicalClustering	flann/flann.hpp	/^int hierarchicalClustering(const Mat& features, Mat& centers, const ::cvflann::IndexParams& params,$/;"	f	namespace:cv::flann	signature:(const Mat& features, Mat& centers, const ::cvflann::IndexParams& params, Distance d = Distance())
cv::flip	core/core.hpp	/^CV_EXPORTS_W void flip(InputArray src, OutputArray dst, int flipCode);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, int flipCode)
cv::floodFill	imgproc/imgproc.hpp	/^CV_EXPORTS int floodFill( InputOutputArray image,$/;"	p	namespace:cv	signature:( InputOutputArray image, Point seedPoint, Scalar newVal, CV_OUT Rect* rect=0, Scalar loDiff=Scalar(), Scalar upDiff=Scalar(), int flags=4 )
cv::floodFill	imgproc/imgproc.hpp	/^CV_EXPORTS_W int floodFill( InputOutputArray image, InputOutputArray mask,$/;"	p	namespace:cv	signature:( InputOutputArray image, InputOutputArray mask, Point seedPoint, Scalar newVal, CV_OUT Rect* rect=0, Scalar loDiff=Scalar(), Scalar upDiff=Scalar(), int flags=4 )
cv::fontQt	highgui/highgui.hpp	/^CV_EXPORTS CvFont fontQt(const string& nameFont, int pointSize=-1,$/;"	p	namespace:cv	signature:(const string& nameFont, int pointSize=-1, Scalar color=Scalar::all(0), int weight=CV_FONT_NORMAL, int style=CV_STYLE_NORMAL, int spacing=0)
cv::format	core/core.hpp	/^CV_EXPORTS string format( const char* fmt, ... );$/;"	p	namespace:cv	signature:( const char* fmt, ... )
cv::format	core/operations.hpp	/^static inline Formatted format(const Mat& mtx, const char* fmt,$/;"	f	namespace:cv	signature:(const Mat& mtx, const char* fmt, const vector<int>& params=vector<int>())
cv::format	core/operations.hpp	/^template<typename _Tp> static inline Formatted format(const vector<Point3_<_Tp> >& vec,$/;"	f	namespace:cv	signature:(const vector<Point3_<_Tp> >& vec, const char* fmt, const vector<int>& params=vector<int>())
cv::format	core/operations.hpp	/^template<typename _Tp> static inline Formatted format(const vector<Point_<_Tp> >& vec,$/;"	f	namespace:cv	signature:(const vector<Point_<_Tp> >& vec, const char* fmt, const vector<int>& params=vector<int>())
cv::fromUtf16	core/core.hpp	/^CV_EXPORTS string fromUtf16(const WString& str);$/;"	p	namespace:cv	signature:(const WString& str)
cv::gcd	core/operations.hpp	/^template<typename _Tp> static inline _Tp gcd(_Tp a, _Tp b)$/;"	f	namespace:cv	signature:(_Tp a, _Tp b)
cv::gemm	core/core.hpp	/^CV_EXPORTS_W void gemm(InputArray src1, InputArray src2, double alpha,$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, double alpha, InputArray src3, double gamma, OutputArray dst, int flags=0)
cv::getAffineTransform	imgproc/imgproc.hpp	/^CV_EXPORTS Mat getAffineTransform( const Point2f src[], const Point2f dst[] );$/;"	p	namespace:cv	signature:( const Point2f src[], const Point2f dst[] )
cv::getAffineTransform	imgproc/imgproc.hpp	/^CV_EXPORTS_W Mat getAffineTransform( InputArray src, InputArray dst );$/;"	p	namespace:cv	signature:( InputArray src, InputArray dst )
cv::getCPUTickCount	core/core.hpp	/^CV_EXPORTS_W int64 getCPUTickCount();$/;"	p	namespace:cv	signature:()
cv::getColumnSumFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseColumnFilter> getColumnSumFilter( int sumType, int dstType,$/;"	p	namespace:cv	signature:( int sumType, int dstType, int ksize, int anchor=-1, double scale=1)
cv::getConvertElem	core/core.hpp	/^CV_EXPORTS ConvertData getConvertElem(int fromType, int toType);$/;"	p	namespace:cv	signature:(int fromType, int toType)
cv::getConvertScaleElem	core/core.hpp	/^CV_EXPORTS ConvertScaleData getConvertScaleElem(int fromType, int toType);$/;"	p	namespace:cv	signature:(int fromType, int toType)
cv::getData	features2d/features2d.hpp	/^inline uchar* getData(IplImage* image)$/;"	f	namespace:cv	signature:(IplImage* image)
cv::getDefaultNewCameraMatrix	imgproc/imgproc.hpp	/^CV_EXPORTS_W Mat getDefaultNewCameraMatrix( InputArray cameraMatrix, Size imgsize=Size(),$/;"	p	namespace:cv	signature:( InputArray cameraMatrix, Size imgsize=Size(), bool centerPrincipalPoint=false )
cv::getDerivKernels	imgproc/imgproc.hpp	/^CV_EXPORTS_W void getDerivKernels( OutputArray kx, OutputArray ky,$/;"	p	namespace:cv	signature:( OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize=false, int ktype=CV_32F )
cv::getElemSize	core/core.hpp	/^static inline size_t getElemSize(int type) { return CV_ELEM_SIZE(type); }$/;"	f	namespace:cv	signature:(int type)
cv::getGaussianKernel	imgproc/imgproc.hpp	/^CV_EXPORTS_W Mat getGaussianKernel( int ksize, double sigma, int ktype=CV_64F );$/;"	p	namespace:cv	signature:( int ksize, double sigma, int ktype=CV_64F )
cv::getKernelType	imgproc/imgproc.hpp	/^CV_EXPORTS int getKernelType(InputArray kernel, Point anchor);$/;"	p	namespace:cv	signature:(InputArray kernel, Point anchor)
cv::getLinearColumnFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseColumnFilter> getLinearColumnFilter(int bufType, int dstType,$/;"	p	namespace:cv	signature:(int bufType, int dstType, InputArray kernel, int anchor, int symmetryType, double delta=0, int bits=0)
cv::getLinearFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseFilter> getLinearFilter(int srcType, int dstType,$/;"	p	namespace:cv	signature:(int srcType, int dstType, InputArray kernel, Point anchor=Point(-1,-1), double delta=0, int bits=0)
cv::getLinearRowFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseRowFilter> getLinearRowFilter(int srcType, int bufType,$/;"	p	namespace:cv	signature:(int srcType, int bufType, InputArray kernel, int anchor, int symmetryType)
cv::getMorphologyColumnFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseColumnFilter> getMorphologyColumnFilter(int op, int type, int ksize, int anchor=-1);$/;"	p	namespace:cv	signature:(int op, int type, int ksize, int anchor=-1)
cv::getMorphologyFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseFilter> getMorphologyFilter(int op, int type, InputArray kernel,$/;"	p	namespace:cv	signature:(int op, int type, InputArray kernel, Point anchor=Point(-1,-1))
cv::getMorphologyRowFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseRowFilter> getMorphologyRowFilter(int op, int type, int ksize, int anchor=-1);$/;"	p	namespace:cv	signature:(int op, int type, int ksize, int anchor=-1)
cv::getNearestPoint	features2d/features2d.hpp	/^CV_EXPORTS int getNearestPoint( const vector<Point2f>& recallPrecisionCurve, float l_precision );$/;"	p	namespace:cv	signature:( const vector<Point2f>& recallPrecisionCurve, float l_precision )
cv::getNumThreads	core/core.hpp	/^CV_EXPORTS int getNumThreads();$/;"	p	namespace:cv	signature:()
cv::getNumberOfCPUs	core/core.hpp	/^CV_EXPORTS_W int getNumberOfCPUs();$/;"	p	namespace:cv	signature:()
cv::getOptimalDFTSize	core/core.hpp	/^CV_EXPORTS_W int getOptimalDFTSize(int vecsize);$/;"	p	namespace:cv	signature:(int vecsize)
cv::getOptimalNewCameraMatrix	calib3d/calib3d.hpp	/^CV_EXPORTS_W Mat getOptimalNewCameraMatrix( InputArray cameraMatrix, InputArray distCoeffs,$/;"	p	namespace:cv	signature:( InputArray cameraMatrix, InputArray distCoeffs, Size imageSize, double alpha, Size newImgSize=Size(), CV_OUT Rect* validPixROI=0, bool centerPrincipalPoint=false)
cv::getPerspectiveTransform	imgproc/imgproc.hpp	/^CV_EXPORTS Mat getPerspectiveTransform( const Point2f src[], const Point2f dst[] );$/;"	p	namespace:cv	signature:( const Point2f src[], const Point2f dst[] )
cv::getPerspectiveTransform	imgproc/imgproc.hpp	/^CV_EXPORTS_W Mat getPerspectiveTransform( InputArray src, InputArray dst );$/;"	p	namespace:cv	signature:( InputArray src, InputArray dst )
cv::getRecall	features2d/features2d.hpp	/^CV_EXPORTS float getRecall( const vector<Point2f>& recallPrecisionCurve, float l_precision );$/;"	p	namespace:cv	signature:( const vector<Point2f>& recallPrecisionCurve, float l_precision )
cv::getRectSubPix	imgproc/imgproc.hpp	/^CV_EXPORTS_W void getRectSubPix( InputArray image, Size patchSize,$/;"	p	namespace:cv	signature:( InputArray image, Size patchSize, Point2f center, OutputArray patch, int patchType=-1 )
cv::getRotationMatrix2D	imgproc/imgproc.hpp	/^CV_EXPORTS_W Mat getRotationMatrix2D( Point2f center, double angle, double scale );$/;"	p	namespace:cv	signature:( Point2f center, double angle, double scale )
cv::getRowSumFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseRowFilter> getRowSumFilter(int srcType, int sumType,$/;"	p	namespace:cv	signature:(int srcType, int sumType, int ksize, int anchor=-1)
cv::getSeqElem	core/operations.hpp	/^CV_EXPORTS schar*  getSeqElem( const CvSeq* seq, int index );$/;"	p	namespace:cv	signature:( const CvSeq* seq, int index )
cv::getStructuringElement	imgproc/imgproc.hpp	/^CV_EXPORTS_W Mat getStructuringElement(int shape, Size ksize, Point anchor=Point(-1,-1));$/;"	p	namespace:cv	signature:(int shape, Size ksize, Point anchor=Point(-1,-1))
cv::getTextSize	core/core.hpp	/^CV_EXPORTS_W Size getTextSize(const string& text, int fontFace,$/;"	p	namespace:cv	signature:(const string& text, int fontFace, double fontScale, int thickness, CV_OUT int* baseLine)
cv::getThreadNum	core/core.hpp	/^CV_EXPORTS int getThreadNum();$/;"	p	namespace:cv	signature:()
cv::getTickCount	core/core.hpp	/^CV_EXPORTS_W int64 getTickCount();$/;"	p	namespace:cv	signature:()
cv::getTickFrequency	core/core.hpp	/^CV_EXPORTS_W double getTickFrequency();$/;"	p	namespace:cv	signature:()
cv::getTrackbarPos	highgui/highgui.hpp	/^CV_EXPORTS_W int getTrackbarPos( const string& trackbarname, const string& winname );$/;"	p	namespace:cv	signature:( const string& trackbarname, const string& winname )
cv::getValidDisparityROI	calib3d/calib3d.hpp	/^CV_EXPORTS_W Rect getValidDisparityROI( Rect roi1, Rect roi2,$/;"	p	namespace:cv	signature:( Rect roi1, Rect roi2, int minDisparity, int numberOfDisparities, int SADWindowSize )
cv::getWindowProperty	highgui/highgui.hpp	/^CV_EXPORTS_W double getWindowProperty(const string& winname, int prop_id);\/\/YV$/;"	p	namespace:cv	signature:(const string& winname, int prop_id)
cv::goodFeaturesToTrack	imgproc/imgproc.hpp	/^CV_EXPORTS_W void goodFeaturesToTrack( InputArray image, OutputArray corners,$/;"	p	namespace:cv	signature:( InputArray image, OutputArray corners, int maxCorners, double qualityLevel, double minDistance, InputArray mask=noArray(), int blockSize=3, bool useHarrisDetector=false, double k=0.04 )
cv::gpu	gpu/devmem2d.hpp	/^    namespace gpu$/;"	n	namespace:cv
cv::gpu	gpu/gpu.hpp	/^    namespace gpu$/;"	n	namespace:cv
cv::gpu	gpu/gpumat.hpp	/^namespace cv { namespace gpu$/;"	n	namespace:cv
cv::gpu	gpu/matrix_operations.hpp	/^namespace gpu$/;"	n	namespace:cv
cv::gpu	gpu/stream_accessor.hpp	/^    namespace gpu$/;"	n	namespace:cv
cv::gpu::BaseColumnFilter_GPU	gpu/gpu.hpp	/^        class CV_EXPORTS BaseColumnFilter_GPU$/;"	c	namespace:cv::gpu
cv::gpu::BaseColumnFilter_GPU::BaseColumnFilter_GPU	gpu/gpu.hpp	/^            BaseColumnFilter_GPU(int ksize_, int anchor_) : ksize(ksize_), anchor(anchor_) {}$/;"	f	class:cv::gpu::BaseColumnFilter_GPU	access:public	signature:(int ksize_, int anchor_)
cv::gpu::BaseColumnFilter_GPU::anchor	gpu/gpu.hpp	/^            int ksize, anchor;$/;"	m	class:cv::gpu::BaseColumnFilter_GPU	access:public
cv::gpu::BaseColumnFilter_GPU::ksize	gpu/gpu.hpp	/^            int ksize, anchor;$/;"	m	class:cv::gpu::BaseColumnFilter_GPU	access:public
cv::gpu::BaseColumnFilter_GPU::operator ()	gpu/gpu.hpp	/^            virtual void operator()(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null()) = 0;$/;"	p	class:cv::gpu::BaseColumnFilter_GPU	access:public	signature:(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null())
cv::gpu::BaseColumnFilter_GPU::~BaseColumnFilter_GPU	gpu/gpu.hpp	/^            virtual ~BaseColumnFilter_GPU() {}$/;"	f	class:cv::gpu::BaseColumnFilter_GPU	access:public	signature:()
cv::gpu::BaseFilter_GPU	gpu/gpu.hpp	/^        class CV_EXPORTS BaseFilter_GPU$/;"	c	namespace:cv::gpu
cv::gpu::BaseFilter_GPU::BaseFilter_GPU	gpu/gpu.hpp	/^            BaseFilter_GPU(const Size& ksize_, const Point& anchor_) : ksize(ksize_), anchor(anchor_) {}$/;"	f	class:cv::gpu::BaseFilter_GPU	access:public	signature:(const Size& ksize_, const Point& anchor_)
cv::gpu::BaseFilter_GPU::anchor	gpu/gpu.hpp	/^            Point anchor;$/;"	m	class:cv::gpu::BaseFilter_GPU	access:public
cv::gpu::BaseFilter_GPU::ksize	gpu/gpu.hpp	/^            Size ksize;$/;"	m	class:cv::gpu::BaseFilter_GPU	access:public
cv::gpu::BaseFilter_GPU::operator ()	gpu/gpu.hpp	/^            virtual void operator()(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null()) = 0;$/;"	p	class:cv::gpu::BaseFilter_GPU	access:public	signature:(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null())
cv::gpu::BaseFilter_GPU::~BaseFilter_GPU	gpu/gpu.hpp	/^            virtual ~BaseFilter_GPU() {}$/;"	f	class:cv::gpu::BaseFilter_GPU	access:public	signature:()
cv::gpu::BaseRowFilter_GPU	gpu/gpu.hpp	/^        class CV_EXPORTS BaseRowFilter_GPU$/;"	c	namespace:cv::gpu
cv::gpu::BaseRowFilter_GPU::BaseRowFilter_GPU	gpu/gpu.hpp	/^            BaseRowFilter_GPU(int ksize_, int anchor_) : ksize(ksize_), anchor(anchor_) {}$/;"	f	class:cv::gpu::BaseRowFilter_GPU	access:public	signature:(int ksize_, int anchor_)
cv::gpu::BaseRowFilter_GPU::anchor	gpu/gpu.hpp	/^            int ksize, anchor;$/;"	m	class:cv::gpu::BaseRowFilter_GPU	access:public
cv::gpu::BaseRowFilter_GPU::ksize	gpu/gpu.hpp	/^            int ksize, anchor;$/;"	m	class:cv::gpu::BaseRowFilter_GPU	access:public
cv::gpu::BaseRowFilter_GPU::operator ()	gpu/gpu.hpp	/^            virtual void operator()(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null()) = 0;$/;"	p	class:cv::gpu::BaseRowFilter_GPU	access:public	signature:(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null())
cv::gpu::BaseRowFilter_GPU::~BaseRowFilter_GPU	gpu/gpu.hpp	/^            virtual ~BaseRowFilter_GPU() {}$/;"	f	class:cv::gpu::BaseRowFilter_GPU	access:public	signature:()
cv::gpu::BruteForceMatcher_GPU	gpu/gpu.hpp	/^        class CV_EXPORTS BruteForceMatcher_GPU;$/;"	m	namespace:cv::gpu	typeref:class:cv::gpu::CV_EXPORTS
cv::gpu::BruteForceMatcher_GPU	gpu/gpu.hpp	/^        class CV_EXPORTS BruteForceMatcher_GPU< L1<T> > : public BruteForceMatcher_GPU_base$/;"	c	namespace:cv::gpu	inherits:BruteForceMatcher_GPU_base
cv::gpu::BruteForceMatcher_GPU	gpu/gpu.hpp	/^        class CV_EXPORTS BruteForceMatcher_GPU< L2<T> > : public BruteForceMatcher_GPU_base$/;"	c	namespace:cv::gpu	inherits:BruteForceMatcher_GPU_base
cv::gpu::BruteForceMatcher_GPU	gpu/gpu.hpp	/^        template <> class CV_EXPORTS BruteForceMatcher_GPU< Hamming > : public BruteForceMatcher_GPU_base$/;"	c	namespace:cv::gpu	inherits:BruteForceMatcher_GPU_base
cv::gpu::BruteForceMatcher_GPU	gpu/gpu.hpp	/^        template <> class CV_EXPORTS BruteForceMatcher_GPU< HammingLUT > : public BruteForceMatcher_GPU_base$/;"	c	namespace:cv::gpu	inherits:BruteForceMatcher_GPU_base
cv::gpu::BruteForceMatcher_GPU::BruteForceMatcher_GPU	gpu/gpu.hpp	/^            explicit BruteForceMatcher_GPU() : BruteForceMatcher_GPU_base(HammingDist) {}$/;"	f	class:cv::gpu::BruteForceMatcher_GPU	access:public	signature:()
cv::gpu::BruteForceMatcher_GPU::BruteForceMatcher_GPU	gpu/gpu.hpp	/^            explicit BruteForceMatcher_GPU() : BruteForceMatcher_GPU_base(L1Dist) {}$/;"	f	class:cv::gpu::BruteForceMatcher_GPU	access:public	signature:()
cv::gpu::BruteForceMatcher_GPU::BruteForceMatcher_GPU	gpu/gpu.hpp	/^            explicit BruteForceMatcher_GPU() : BruteForceMatcher_GPU_base(L2Dist) {}$/;"	f	class:cv::gpu::BruteForceMatcher_GPU	access:public	signature:()
cv::gpu::BruteForceMatcher_GPU::BruteForceMatcher_GPU	gpu/gpu.hpp	/^            explicit BruteForceMatcher_GPU(Hamming \/*d*\/) : BruteForceMatcher_GPU_base(HammingDist) {}$/;"	f	class:cv::gpu::BruteForceMatcher_GPU	access:public	signature:(Hamming )
cv::gpu::BruteForceMatcher_GPU::BruteForceMatcher_GPU	gpu/gpu.hpp	/^            explicit BruteForceMatcher_GPU(HammingLUT \/*d*\/) : BruteForceMatcher_GPU_base(HammingDist) {}$/;"	f	class:cv::gpu::BruteForceMatcher_GPU	access:public	signature:(HammingLUT )
cv::gpu::BruteForceMatcher_GPU::BruteForceMatcher_GPU	gpu/gpu.hpp	/^            explicit BruteForceMatcher_GPU(L1<T> \/*d*\/) : BruteForceMatcher_GPU_base(L1Dist) {}$/;"	f	class:cv::gpu::BruteForceMatcher_GPU	access:public	signature:(L1<T> )
cv::gpu::BruteForceMatcher_GPU::BruteForceMatcher_GPU	gpu/gpu.hpp	/^            explicit BruteForceMatcher_GPU(L2<T> \/*d*\/) : BruteForceMatcher_GPU_base(L2Dist) {}$/;"	f	class:cv::gpu::BruteForceMatcher_GPU	access:public	signature:(L2<T> )
cv::gpu::BruteForceMatcher_GPU_base	gpu/gpu.hpp	/^        class CV_EXPORTS BruteForceMatcher_GPU_base$/;"	c	namespace:cv::gpu
cv::gpu::BruteForceMatcher_GPU_base::BruteForceMatcher_GPU_base	gpu/gpu.hpp	/^            explicit BruteForceMatcher_GPU_base(DistType distType = L2Dist);$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(DistType distType = L2Dist)
cv::gpu::BruteForceMatcher_GPU_base::DistType	gpu/gpu.hpp	/^            enum DistType {L1Dist = 0, L2Dist, HammingDist};$/;"	g	class:cv::gpu::BruteForceMatcher_GPU_base	access:public
cv::gpu::BruteForceMatcher_GPU_base::HammingDist	gpu/gpu.hpp	/^            enum DistType {L1Dist = 0, L2Dist, HammingDist};$/;"	e	enum:cv::gpu::BruteForceMatcher_GPU_base::DistType
cv::gpu::BruteForceMatcher_GPU_base::L1Dist	gpu/gpu.hpp	/^            enum DistType {L1Dist = 0, L2Dist, HammingDist};$/;"	e	enum:cv::gpu::BruteForceMatcher_GPU_base::DistType
cv::gpu::BruteForceMatcher_GPU_base::L2Dist	gpu/gpu.hpp	/^            enum DistType {L1Dist = 0, L2Dist, HammingDist};$/;"	e	enum:cv::gpu::BruteForceMatcher_GPU_base::DistType
cv::gpu::BruteForceMatcher_GPU_base::add	gpu/gpu.hpp	/^            void add(const std::vector<GpuMat>& descCollection);$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const std::vector<GpuMat>& descCollection)
cv::gpu::BruteForceMatcher_GPU_base::clear	gpu/gpu.hpp	/^            void clear();$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:()
cv::gpu::BruteForceMatcher_GPU_base::distType	gpu/gpu.hpp	/^            DistType distType;$/;"	m	class:cv::gpu::BruteForceMatcher_GPU_base	access:public
cv::gpu::BruteForceMatcher_GPU_base::empty	gpu/gpu.hpp	/^            bool empty() const;$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:() const
cv::gpu::BruteForceMatcher_GPU_base::getTrainDescriptors	gpu/gpu.hpp	/^            const std::vector<GpuMat>& getTrainDescriptors() const;$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:() const
cv::gpu::BruteForceMatcher_GPU_base::isMaskSupported	gpu/gpu.hpp	/^            bool isMaskSupported() const;$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:() const
cv::gpu::BruteForceMatcher_GPU_base::knnMatch	gpu/gpu.hpp	/^            void knnMatch(const GpuMat& queryDescs, const GpuMat& trainDescs,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& queryDescs, const GpuMat& trainDescs, GpuMat& trainIdx, GpuMat& distance, GpuMat& allDist, int k, const GpuMat& mask = GpuMat(), Stream& stream = Stream::Null())
cv::gpu::BruteForceMatcher_GPU_base::knnMatch	gpu/gpu.hpp	/^            void knnMatch(const GpuMat& queryDescs, const GpuMat& trainDescs,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& queryDescs, const GpuMat& trainDescs, std::vector< std::vector<DMatch> >& matches, int k, const GpuMat& mask = GpuMat(), bool compactResult = false)
cv::gpu::BruteForceMatcher_GPU_base::knnMatch	gpu/gpu.hpp	/^            void knnMatch(const GpuMat& queryDescs, std::vector< std::vector<DMatch> >& matches, int knn,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& queryDescs, std::vector< std::vector<DMatch> >& matches, int knn, const std::vector<GpuMat>& masks = std::vector<GpuMat>(), bool compactResult = false )
cv::gpu::BruteForceMatcher_GPU_base::knnMatchConvert	gpu/gpu.hpp	/^            static void knnMatchConvert(const Mat& trainIdx, const Mat& distance,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const Mat& trainIdx, const Mat& distance, std::vector< std::vector<DMatch> >& matches, bool compactResult = false)
cv::gpu::BruteForceMatcher_GPU_base::knnMatchDownload	gpu/gpu.hpp	/^            static void knnMatchDownload(const GpuMat& trainIdx, const GpuMat& distance,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& trainIdx, const GpuMat& distance, std::vector< std::vector<DMatch> >& matches, bool compactResult = false)
cv::gpu::BruteForceMatcher_GPU_base::makeGpuCollection	gpu/gpu.hpp	/^            void makeGpuCollection(GpuMat& trainCollection, GpuMat& maskCollection,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(GpuMat& trainCollection, GpuMat& maskCollection, const vector<GpuMat>& masks = std::vector<GpuMat>())
cv::gpu::BruteForceMatcher_GPU_base::match	gpu/gpu.hpp	/^            void match(const GpuMat& queryDescs, const GpuMat& trainDescs, std::vector<DMatch>& matches,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& queryDescs, const GpuMat& trainDescs, std::vector<DMatch>& matches, const GpuMat& mask = GpuMat())
cv::gpu::BruteForceMatcher_GPU_base::match	gpu/gpu.hpp	/^            void match(const GpuMat& queryDescs, std::vector<DMatch>& matches, const std::vector<GpuMat>& masks = std::vector<GpuMat>());$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& queryDescs, std::vector<DMatch>& matches, const std::vector<GpuMat>& masks = std::vector<GpuMat>())
cv::gpu::BruteForceMatcher_GPU_base::matchCollection	gpu/gpu.hpp	/^            void matchCollection(const GpuMat& queryDescs, const GpuMat& trainCollection,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& queryDescs, const GpuMat& trainCollection, GpuMat& trainIdx, GpuMat& imgIdx, GpuMat& distance, const GpuMat& maskCollection, Stream& stream = Stream::Null())
cv::gpu::BruteForceMatcher_GPU_base::matchConvert	gpu/gpu.hpp	/^            static void matchConvert(const Mat& trainIdx, const Mat& distance, std::vector<DMatch>& matches);$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const Mat& trainIdx, const Mat& distance, std::vector<DMatch>& matches)
cv::gpu::BruteForceMatcher_GPU_base::matchConvert	gpu/gpu.hpp	/^            static void matchConvert(const Mat& trainIdx, const Mat& imgIdx, const Mat& distance, std::vector<DMatch>& matches);$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const Mat& trainIdx, const Mat& imgIdx, const Mat& distance, std::vector<DMatch>& matches)
cv::gpu::BruteForceMatcher_GPU_base::matchDownload	gpu/gpu.hpp	/^            static void matchDownload(const GpuMat& trainIdx, const GpuMat& distance, std::vector<DMatch>& matches);$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& trainIdx, const GpuMat& distance, std::vector<DMatch>& matches)
cv::gpu::BruteForceMatcher_GPU_base::matchDownload	gpu/gpu.hpp	/^            static void matchDownload(const GpuMat& trainIdx, const GpuMat& imgIdx, const GpuMat& distance, std::vector<DMatch>& matches);$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& trainIdx, const GpuMat& imgIdx, const GpuMat& distance, std::vector<DMatch>& matches)
cv::gpu::BruteForceMatcher_GPU_base::matchSingle	gpu/gpu.hpp	/^            void matchSingle(const GpuMat& queryDescs, const GpuMat& trainDescs,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& queryDescs, const GpuMat& trainDescs, GpuMat& trainIdx, GpuMat& distance, const GpuMat& mask = GpuMat(), Stream& stream = Stream::Null())
cv::gpu::BruteForceMatcher_GPU_base::radiusMatch	gpu/gpu.hpp	/^            void radiusMatch(const GpuMat& queryDescs, const GpuMat& trainDescs,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& queryDescs, const GpuMat& trainDescs, GpuMat& trainIdx, GpuMat& nMatches, GpuMat& distance, float maxDistance, const GpuMat& mask = GpuMat(), Stream& stream = Stream::Null())
cv::gpu::BruteForceMatcher_GPU_base::radiusMatch	gpu/gpu.hpp	/^            void radiusMatch(const GpuMat& queryDescs, const GpuMat& trainDescs,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& queryDescs, const GpuMat& trainDescs, std::vector< std::vector<DMatch> >& matches, float maxDistance, const GpuMat& mask = GpuMat(), bool compactResult = false)
cv::gpu::BruteForceMatcher_GPU_base::radiusMatch	gpu/gpu.hpp	/^            void radiusMatch(const GpuMat& queryDescs, std::vector< std::vector<DMatch> >& matches, float maxDistance,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& queryDescs, std::vector< std::vector<DMatch> >& matches, float maxDistance, const std::vector<GpuMat>& masks = std::vector<GpuMat>(), bool compactResult = false)
cv::gpu::BruteForceMatcher_GPU_base::radiusMatchConvert	gpu/gpu.hpp	/^            static void radiusMatchConvert(const Mat& trainIdx, const Mat& nMatches, const Mat& distance,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const Mat& trainIdx, const Mat& nMatches, const Mat& distance, std::vector< std::vector<DMatch> >& matches, bool compactResult = false)
cv::gpu::BruteForceMatcher_GPU_base::radiusMatchDownload	gpu/gpu.hpp	/^            static void radiusMatchDownload(const GpuMat& trainIdx, const GpuMat& nMatches, const GpuMat& distance,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& trainIdx, const GpuMat& nMatches, const GpuMat& distance, std::vector< std::vector<DMatch> >& matches, bool compactResult = false)
cv::gpu::BruteForceMatcher_GPU_base::trainDescCollection	gpu/gpu.hpp	/^            std::vector<GpuMat> trainDescCollection;$/;"	m	class:cv::gpu::BruteForceMatcher_GPU_base	access:private
cv::gpu::Canny	gpu/gpu.hpp	/^        CV_EXPORTS void Canny(const GpuMat& dx, const GpuMat& dy, CannyBuf& buf, GpuMat& edges, double low_thresh, double high_thresh, bool L2gradient = false);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& dx, const GpuMat& dy, CannyBuf& buf, GpuMat& edges, double low_thresh, double high_thresh, bool L2gradient = false)
cv::gpu::Canny	gpu/gpu.hpp	/^        CV_EXPORTS void Canny(const GpuMat& dx, const GpuMat& dy, GpuMat& edges, double low_thresh, double high_thresh, bool L2gradient = false);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& dx, const GpuMat& dy, GpuMat& edges, double low_thresh, double high_thresh, bool L2gradient = false)
cv::gpu::Canny	gpu/gpu.hpp	/^        CV_EXPORTS void Canny(const GpuMat& image, CannyBuf& buf, GpuMat& edges, double low_thresh, double high_thresh, int apperture_size = 3, bool L2gradient = false);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& image, CannyBuf& buf, GpuMat& edges, double low_thresh, double high_thresh, int apperture_size = 3, bool L2gradient = false)
cv::gpu::Canny	gpu/gpu.hpp	/^        CV_EXPORTS void Canny(const GpuMat& image, GpuMat& edges, double low_thresh, double high_thresh, int apperture_size = 3, bool L2gradient = false);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& image, GpuMat& edges, double low_thresh, double high_thresh, int apperture_size = 3, bool L2gradient = false)
cv::gpu::CannyBuf	gpu/gpu.hpp	/^        struct CV_EXPORTS CannyBuf$/;"	s	namespace:cv::gpu
cv::gpu::CannyBuf	gpu/gpu.hpp	/^        struct CV_EXPORTS CannyBuf;$/;"	m	namespace:cv::gpu	typeref:struct:cv::gpu::CV_EXPORTS
cv::gpu::CannyBuf::CannyBuf	gpu/gpu.hpp	/^            CannyBuf() {}$/;"	f	struct:cv::gpu::CannyBuf	access:public	signature:()
cv::gpu::CannyBuf::CannyBuf	gpu/gpu.hpp	/^            CannyBuf(const GpuMat& dx_, const GpuMat& dy_);$/;"	p	struct:cv::gpu::CannyBuf	access:public	signature:(const GpuMat& dx_, const GpuMat& dy_)
cv::gpu::CannyBuf::CannyBuf	gpu/gpu.hpp	/^            explicit CannyBuf(const Size& image_size, int apperture_size = 3) {create(image_size, apperture_size);}$/;"	f	struct:cv::gpu::CannyBuf	access:public	signature:(const Size& image_size, int apperture_size = 3)
cv::gpu::CannyBuf::create	gpu/gpu.hpp	/^            void create(const Size& image_size, int apperture_size = 3);$/;"	p	struct:cv::gpu::CannyBuf	access:public	signature:(const Size& image_size, int apperture_size = 3)
cv::gpu::CannyBuf::dx	gpu/gpu.hpp	/^            GpuMat dx, dy;$/;"	m	struct:cv::gpu::CannyBuf	access:public
cv::gpu::CannyBuf::dx_buf	gpu/gpu.hpp	/^            GpuMat dx_buf, dy_buf;$/;"	m	struct:cv::gpu::CannyBuf	access:public
cv::gpu::CannyBuf::dy	gpu/gpu.hpp	/^            GpuMat dx, dy;$/;"	m	struct:cv::gpu::CannyBuf	access:public
cv::gpu::CannyBuf::dy_buf	gpu/gpu.hpp	/^            GpuMat dx_buf, dy_buf;$/;"	m	struct:cv::gpu::CannyBuf	access:public
cv::gpu::CannyBuf::edgeBuf	gpu/gpu.hpp	/^            GpuMat edgeBuf;$/;"	m	struct:cv::gpu::CannyBuf	access:public
cv::gpu::CannyBuf::filterDX	gpu/gpu.hpp	/^            Ptr<FilterEngine_GPU> filterDX, filterDY;$/;"	m	struct:cv::gpu::CannyBuf	access:public
cv::gpu::CannyBuf::filterDY	gpu/gpu.hpp	/^            Ptr<FilterEngine_GPU> filterDX, filterDY;$/;"	m	struct:cv::gpu::CannyBuf	access:public
cv::gpu::CannyBuf::release	gpu/gpu.hpp	/^            void release();$/;"	p	struct:cv::gpu::CannyBuf	access:public	signature:()
cv::gpu::CannyBuf::trackBuf1	gpu/gpu.hpp	/^            GpuMat trackBuf1, trackBuf2;$/;"	m	struct:cv::gpu::CannyBuf	access:public
cv::gpu::CannyBuf::trackBuf2	gpu/gpu.hpp	/^            GpuMat trackBuf1, trackBuf2;$/;"	m	struct:cv::gpu::CannyBuf	access:public
cv::gpu::CascadeClassifier_GPU	gpu/gpu.hpp	/^        class CV_EXPORTS CascadeClassifier_GPU$/;"	c	namespace:cv::gpu
cv::gpu::CascadeClassifier_GPU::CascadeClassifier_GPU	gpu/gpu.hpp	/^            CascadeClassifier_GPU();$/;"	p	class:cv::gpu::CascadeClassifier_GPU	access:public	signature:()
cv::gpu::CascadeClassifier_GPU::CascadeClassifier_GPU	gpu/gpu.hpp	/^            CascadeClassifier_GPU(const string& filename);$/;"	p	class:cv::gpu::CascadeClassifier_GPU	access:public	signature:(const string& filename)
cv::gpu::CascadeClassifier_GPU::detectMultiScale	gpu/gpu.hpp	/^            int detectMultiScale( const GpuMat& image, GpuMat& objectsBuf, double scaleFactor=1.2, int minNeighbors=4, Size minSize=Size());$/;"	p	class:cv::gpu::CascadeClassifier_GPU	access:public	signature:( const GpuMat& image, GpuMat& objectsBuf, double scaleFactor=1.2, int minNeighbors=4, Size minSize=Size())
cv::gpu::CascadeClassifier_GPU::empty	gpu/gpu.hpp	/^            bool empty() const;$/;"	p	class:cv::gpu::CascadeClassifier_GPU	access:public	signature:() const
cv::gpu::CascadeClassifier_GPU::findLargestObject	gpu/gpu.hpp	/^            bool findLargestObject;$/;"	m	class:cv::gpu::CascadeClassifier_GPU	access:public
cv::gpu::CascadeClassifier_GPU::getClassifierSize	gpu/gpu.hpp	/^            Size getClassifierSize() const;$/;"	p	class:cv::gpu::CascadeClassifier_GPU	access:public	signature:() const
cv::gpu::CascadeClassifier_GPU::impl	gpu/gpu.hpp	/^            CascadeClassifierImpl* impl;$/;"	m	class:cv::gpu::CascadeClassifier_GPU	access:private
cv::gpu::CascadeClassifier_GPU::load	gpu/gpu.hpp	/^            bool load(const string& filename);$/;"	p	class:cv::gpu::CascadeClassifier_GPU	access:public	signature:(const string& filename)
cv::gpu::CascadeClassifier_GPU::release	gpu/gpu.hpp	/^            void release();$/;"	p	class:cv::gpu::CascadeClassifier_GPU	access:public	signature:()
cv::gpu::CascadeClassifier_GPU::visualizeInPlace	gpu/gpu.hpp	/^            bool visualizeInPlace;$/;"	m	class:cv::gpu::CascadeClassifier_GPU	access:public
cv::gpu::CascadeClassifier_GPU::~CascadeClassifier_GPU	gpu/gpu.hpp	/^            ~CascadeClassifier_GPU();$/;"	p	class:cv::gpu::CascadeClassifier_GPU	access:public	signature:()
cv::gpu::ConvolveBuf	gpu/gpu.hpp	/^        struct CV_EXPORTS ConvolveBuf$/;"	s	namespace:cv::gpu
cv::gpu::ConvolveBuf	gpu/gpu.hpp	/^        struct CV_EXPORTS ConvolveBuf;$/;"	m	namespace:cv::gpu	typeref:struct:cv::gpu::CV_EXPORTS
cv::gpu::ConvolveBuf::ConvolveBuf	gpu/gpu.hpp	/^            ConvolveBuf() {}$/;"	f	struct:cv::gpu::ConvolveBuf	access:public	signature:()
cv::gpu::ConvolveBuf::ConvolveBuf	gpu/gpu.hpp	/^            ConvolveBuf(Size image_size, Size templ_size) $/;"	f	struct:cv::gpu::ConvolveBuf	access:public	signature:(Size image_size, Size templ_size)
cv::gpu::ConvolveBuf::block_size	gpu/gpu.hpp	/^            Size block_size;$/;"	m	struct:cv::gpu::ConvolveBuf	access:private
cv::gpu::ConvolveBuf::convolve	gpu/gpu.hpp	/^            friend void convolve(const GpuMat&, const GpuMat&, GpuMat&, bool, ConvolveBuf&);$/;"	p	struct:cv::gpu::ConvolveBuf	access:friend	signature:(const GpuMat&, const GpuMat&, GpuMat&, bool, ConvolveBuf&)
cv::gpu::ConvolveBuf::create	gpu/gpu.hpp	/^            void create(Size image_size, Size templ_size);$/;"	p	struct:cv::gpu::ConvolveBuf	access:public	signature:(Size image_size, Size templ_size)
cv::gpu::ConvolveBuf::dft_size	gpu/gpu.hpp	/^            Size dft_size;$/;"	m	struct:cv::gpu::ConvolveBuf	access:private
cv::gpu::ConvolveBuf::estimateBlockSize	gpu/gpu.hpp	/^            static Size estimateBlockSize(Size result_size, Size templ_size);$/;"	p	struct:cv::gpu::ConvolveBuf	access:private	signature:(Size result_size, Size templ_size)
cv::gpu::ConvolveBuf::image_block	gpu/gpu.hpp	/^            GpuMat image_block, templ_block, result_data;$/;"	m	struct:cv::gpu::ConvolveBuf	access:private
cv::gpu::ConvolveBuf::image_spect	gpu/gpu.hpp	/^            GpuMat image_spect, templ_spect, result_spect;$/;"	m	struct:cv::gpu::ConvolveBuf	access:private
cv::gpu::ConvolveBuf::result_data	gpu/gpu.hpp	/^            GpuMat image_block, templ_block, result_data;$/;"	m	struct:cv::gpu::ConvolveBuf	access:private
cv::gpu::ConvolveBuf::result_size	gpu/gpu.hpp	/^            Size result_size;$/;"	m	struct:cv::gpu::ConvolveBuf	access:private
cv::gpu::ConvolveBuf::result_spect	gpu/gpu.hpp	/^            GpuMat image_spect, templ_spect, result_spect;$/;"	m	struct:cv::gpu::ConvolveBuf	access:private
cv::gpu::ConvolveBuf::spect_len	gpu/gpu.hpp	/^            int spect_len;$/;"	m	struct:cv::gpu::ConvolveBuf	access:private
cv::gpu::ConvolveBuf::templ_block	gpu/gpu.hpp	/^            GpuMat image_block, templ_block, result_data;$/;"	m	struct:cv::gpu::ConvolveBuf	access:private
cv::gpu::ConvolveBuf::templ_spect	gpu/gpu.hpp	/^            GpuMat image_spect, templ_spect, result_spect;$/;"	m	struct:cv::gpu::ConvolveBuf	access:private
cv::gpu::CudaMem	gpu/gpu.hpp	/^        class CV_EXPORTS CudaMem$/;"	c	namespace:cv::gpu
cv::gpu::CudaMem::ALLOC_PAGE_LOCKED	gpu/gpu.hpp	/^            enum  { ALLOC_PAGE_LOCKED = 1, ALLOC_ZEROCOPY = 2, ALLOC_WRITE_COMBINED = 4 };$/;"	e	enum:cv::gpu::CudaMem::__anon54
cv::gpu::CudaMem::ALLOC_WRITE_COMBINED	gpu/gpu.hpp	/^            enum  { ALLOC_PAGE_LOCKED = 1, ALLOC_ZEROCOPY = 2, ALLOC_WRITE_COMBINED = 4 };$/;"	e	enum:cv::gpu::CudaMem::__anon54
cv::gpu::CudaMem::ALLOC_ZEROCOPY	gpu/gpu.hpp	/^            enum  { ALLOC_PAGE_LOCKED = 1, ALLOC_ZEROCOPY = 2, ALLOC_WRITE_COMBINED = 4 };$/;"	e	enum:cv::gpu::CudaMem::__anon54
cv::gpu::CudaMem::CudaMem	gpu/gpu.hpp	/^            CudaMem();$/;"	p	class:cv::gpu::CudaMem	access:public	signature:()
cv::gpu::CudaMem::CudaMem	gpu/gpu.hpp	/^            CudaMem(Size size, int type, int alloc_type = ALLOC_PAGE_LOCKED);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(Size size, int type, int alloc_type = ALLOC_PAGE_LOCKED)
cv::gpu::CudaMem::CudaMem	gpu/gpu.hpp	/^            CudaMem(const CudaMem& m);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(const CudaMem& m)
cv::gpu::CudaMem::CudaMem	gpu/gpu.hpp	/^            CudaMem(int rows, int cols, int type, int _alloc_type = ALLOC_PAGE_LOCKED);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(int rows, int cols, int type, int _alloc_type = ALLOC_PAGE_LOCKED)
cv::gpu::CudaMem::CudaMem	gpu/gpu.hpp	/^            explicit CudaMem(const Mat& m, int alloc_type = ALLOC_PAGE_LOCKED);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(const Mat& m, int alloc_type = ALLOC_PAGE_LOCKED)
cv::gpu::CudaMem::CudaMem	gpu/matrix_operations.hpp	/^inline CudaMem::CudaMem()  : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0), alloc_type(0) {}$/;"	f	class:cv::gpu::CudaMem	signature:()
cv::gpu::CudaMem::CudaMem	gpu/matrix_operations.hpp	/^inline CudaMem::CudaMem(Size _size, int _type, int _alloc_type) : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0), alloc_type(0)$/;"	f	class:cv::gpu::CudaMem	signature:(Size _size, int _type, int _alloc_type)
cv::gpu::CudaMem::CudaMem	gpu/matrix_operations.hpp	/^inline CudaMem::CudaMem(const CudaMem& m) : flags(m.flags), rows(m.rows), cols(m.cols), step(m.step), data(m.data), refcount(m.refcount), datastart(m.datastart), dataend(m.dataend), alloc_type(m.alloc_type)$/;"	f	class:cv::gpu::CudaMem	signature:(const CudaMem& m)
cv::gpu::CudaMem::CudaMem	gpu/matrix_operations.hpp	/^inline CudaMem::CudaMem(const Mat& m, int _alloc_type) : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0), alloc_type(0)$/;"	f	class:cv::gpu::CudaMem	signature:(const Mat& m, int _alloc_type)
cv::gpu::CudaMem::CudaMem	gpu/matrix_operations.hpp	/^inline CudaMem::CudaMem(int _rows, int _cols, int _type, int _alloc_type) : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0), alloc_type(0)$/;"	f	class:cv::gpu::CudaMem	signature:(int _rows, int _cols, int _type, int _alloc_type)
cv::gpu::CudaMem::alloc_type	gpu/gpu.hpp	/^            int alloc_type;$/;"	m	class:cv::gpu::CudaMem	access:public
cv::gpu::CudaMem::canMapHostMemory	gpu/gpu.hpp	/^            static bool canMapHostMemory();$/;"	p	class:cv::gpu::CudaMem	access:public	signature:()
cv::gpu::CudaMem::channels	gpu/gpu.hpp	/^            int channels() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::channels	gpu/matrix_operations.hpp	/^inline int CudaMem::channels() const { return CV_MAT_CN(flags); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::clone	gpu/gpu.hpp	/^            CudaMem clone() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::clone	gpu/matrix_operations.hpp	/^inline CudaMem CudaMem::clone() const$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::cols	gpu/gpu.hpp	/^            int rows, cols;$/;"	m	class:cv::gpu::CudaMem	access:public
cv::gpu::CudaMem::create	gpu/gpu.hpp	/^            void create(Size size, int type, int alloc_type = ALLOC_PAGE_LOCKED);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(Size size, int type, int alloc_type = ALLOC_PAGE_LOCKED)
cv::gpu::CudaMem::create	gpu/gpu.hpp	/^            void create(int rows, int cols, int type, int alloc_type = ALLOC_PAGE_LOCKED);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(int rows, int cols, int type, int alloc_type = ALLOC_PAGE_LOCKED)
cv::gpu::CudaMem::create	gpu/matrix_operations.hpp	/^inline void CudaMem::create(Size _size, int _type, int _alloc_type) { create(_size.height, _size.width, _type, _alloc_type); }$/;"	f	class:cv::gpu::CudaMem	signature:(Size _size, int _type, int _alloc_type)
cv::gpu::CudaMem::createGpuMatHeader	gpu/gpu.hpp	/^            GpuMat createGpuMatHeader() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::createMatHeader	gpu/gpu.hpp	/^            Mat createMatHeader() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::createMatHeader	gpu/matrix_operations.hpp	/^inline Mat CudaMem::createMatHeader() const { return Mat(size(), type(), data); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::data	gpu/gpu.hpp	/^            uchar* data;$/;"	m	class:cv::gpu::CudaMem	access:public
cv::gpu::CudaMem::dataend	gpu/gpu.hpp	/^            uchar* dataend;$/;"	m	class:cv::gpu::CudaMem	access:public
cv::gpu::CudaMem::datastart	gpu/gpu.hpp	/^            uchar* datastart;$/;"	m	class:cv::gpu::CudaMem	access:public
cv::gpu::CudaMem::depth	gpu/gpu.hpp	/^            int depth() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::depth	gpu/matrix_operations.hpp	/^inline int CudaMem::depth() const { return CV_MAT_DEPTH(flags); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::elemSize	gpu/gpu.hpp	/^            size_t elemSize() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::elemSize	gpu/matrix_operations.hpp	/^inline size_t CudaMem::elemSize() const { return CV_ELEM_SIZE(flags); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::elemSize1	gpu/gpu.hpp	/^            size_t elemSize1() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::elemSize1	gpu/matrix_operations.hpp	/^inline size_t CudaMem::elemSize1() const { return CV_ELEM_SIZE1(flags); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::empty	gpu/gpu.hpp	/^            bool empty() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::empty	gpu/matrix_operations.hpp	/^inline bool CudaMem::empty() const { return data == 0; }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::flags	gpu/gpu.hpp	/^            int flags;$/;"	m	class:cv::gpu::CudaMem	access:public
cv::gpu::CudaMem::isContinuous	gpu/gpu.hpp	/^            bool isContinuous() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::isContinuous	gpu/matrix_operations.hpp	/^inline bool CudaMem::isContinuous() const { return (flags & Mat::CONTINUOUS_FLAG) != 0; }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::operator =	gpu/gpu.hpp	/^            CudaMem& operator = (const CudaMem& m);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(const CudaMem& m)
cv::gpu::CudaMem::operator =	gpu/matrix_operations.hpp	/^inline CudaMem& CudaMem::operator = (const CudaMem& m)$/;"	f	class:cv::gpu::CudaMem	signature:(const CudaMem& m)
cv::gpu::CudaMem::operator GpuMat	gpu/gpu.hpp	/^            operator GpuMat() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::operator GpuMat	gpu/matrix_operations.hpp	/^inline CudaMem::operator GpuMat() const { return createGpuMatHeader(); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::operator Mat	gpu/gpu.hpp	/^            operator Mat() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::operator Mat	gpu/matrix_operations.hpp	/^inline CudaMem::operator Mat() const { return createMatHeader(); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::refcount	gpu/gpu.hpp	/^            int* refcount;$/;"	m	class:cv::gpu::CudaMem	access:public
cv::gpu::CudaMem::release	gpu/gpu.hpp	/^            void release();$/;"	p	class:cv::gpu::CudaMem	access:public	signature:()
cv::gpu::CudaMem::rows	gpu/gpu.hpp	/^            int rows, cols;$/;"	m	class:cv::gpu::CudaMem	access:public
cv::gpu::CudaMem::size	gpu/gpu.hpp	/^            Size size() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::size	gpu/matrix_operations.hpp	/^inline Size CudaMem::size() const { return Size(cols, rows); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::step	gpu/gpu.hpp	/^            size_t step;$/;"	m	class:cv::gpu::CudaMem	access:public
cv::gpu::CudaMem::step1	gpu/gpu.hpp	/^            size_t step1() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::step1	gpu/matrix_operations.hpp	/^inline size_t CudaMem::step1() const { return step\/elemSize1(); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::type	gpu/gpu.hpp	/^            int type() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
cv::gpu::CudaMem::type	gpu/matrix_operations.hpp	/^inline int CudaMem::type() const { return CV_MAT_TYPE(flags); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
cv::gpu::CudaMem::~CudaMem	gpu/gpu.hpp	/^            ~CudaMem();$/;"	p	class:cv::gpu::CudaMem	access:public	signature:()
cv::gpu::CudaMem::~CudaMem	gpu/matrix_operations.hpp	/^inline CudaMem::~CudaMem()$/;"	f	class:cv::gpu::CudaMem	signature:()
cv::gpu::DevMem2D	gpu/devmem2d.hpp	/^        typedef DevMem2D_<unsigned char> DevMem2D;$/;"	t	namespace:cv::gpu
cv::gpu::DevMem2D_	gpu/devmem2d.hpp	/^        template <typename T> struct DevMem2D_$/;"	s	namespace:cv::gpu
cv::gpu::DevMem2D_::DevMem2D_	gpu/devmem2d.hpp	/^            DevMem2D_() : cols(0), rows(0), data(0), step(0) {}$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:()
cv::gpu::DevMem2D_::DevMem2D_	gpu/devmem2d.hpp	/^            DevMem2D_(int rows_, int cols_, T *data_, size_t step_)$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:(int rows_, int cols_, T *data_, size_t step_)
cv::gpu::DevMem2D_::DevMem2D_	gpu/devmem2d.hpp	/^            explicit DevMem2D_(const DevMem2D_<U>& d)$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:(const DevMem2D_<U>& d)
cv::gpu::DevMem2D_::begin	gpu/devmem2d.hpp	/^            thrust::device_ptr<T> begin() const { return thrust::device_ptr<T>(data); }$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:() const
cv::gpu::DevMem2D_::cols	gpu/devmem2d.hpp	/^            int cols;$/;"	m	struct:cv::gpu::DevMem2D_	access:public
cv::gpu::DevMem2D_::data	gpu/devmem2d.hpp	/^            T* data;$/;"	m	struct:cv::gpu::DevMem2D_	access:public
cv::gpu::DevMem2D_::elemSize	gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ size_t elemSize() const { return elem_size; }$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:() const
cv::gpu::DevMem2D_::elem_size	gpu/devmem2d.hpp	/^            enum { elem_size = sizeof(elem_type) };$/;"	e	enum:cv::gpu::DevMem2D_::__anon52
cv::gpu::DevMem2D_::elem_type	gpu/devmem2d.hpp	/^            typedef T elem_type;$/;"	t	struct:cv::gpu::DevMem2D_	access:public
cv::gpu::DevMem2D_::end	gpu/devmem2d.hpp	/^            thrust::device_ptr<T> end() const { return thrust::device_ptr<T>(data) + cols * rows; }$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:() const
cv::gpu::DevMem2D_::operator T*	gpu/devmem2d.hpp	/^			__CV_GPU_HOST_DEVICE__ operator T*() const { return data; }$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:() const
cv::gpu::DevMem2D_::ptr	gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ T* ptr(int y = 0) { return (T*)( (char*)data + y * step ); }$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:(int y = 0)
cv::gpu::DevMem2D_::ptr	gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ const T* ptr(int y = 0) const { return (const T*)( (const char*)data + y * step ); }            $/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:(int y = 0) const
cv::gpu::DevMem2D_::rows	gpu/devmem2d.hpp	/^            int rows;$/;"	m	struct:cv::gpu::DevMem2D_	access:public
cv::gpu::DevMem2D_::step	gpu/devmem2d.hpp	/^            size_t step;$/;"	m	struct:cv::gpu::DevMem2D_	access:public
cv::gpu::DevMem2Df	gpu/devmem2d.hpp	/^        typedef DevMem2D_<float> DevMem2Df;$/;"	t	namespace:cv::gpu
cv::gpu::DevMem2Di	gpu/devmem2d.hpp	/^        typedef DevMem2D_<int> DevMem2Di;$/;"	t	namespace:cv::gpu
cv::gpu::DeviceInfo	gpu/gpu.hpp	/^        class CV_EXPORTS DeviceInfo$/;"	c	namespace:cv::gpu
cv::gpu::DeviceInfo::DeviceInfo	gpu/gpu.hpp	/^            DeviceInfo() : device_id_(getDevice()) { query(); }$/;"	f	class:cv::gpu::DeviceInfo	access:public	signature:()
cv::gpu::DeviceInfo::DeviceInfo	gpu/gpu.hpp	/^            DeviceInfo(int device_id) : device_id_(device_id) { query(); }$/;"	f	class:cv::gpu::DeviceInfo	access:public	signature:(int device_id)
cv::gpu::DeviceInfo::deviceID	gpu/gpu.hpp	/^            int deviceID() const { return device_id_; }$/;"	f	class:cv::gpu::DeviceInfo	access:public	signature:() const
cv::gpu::DeviceInfo::device_id_	gpu/gpu.hpp	/^            int device_id_;$/;"	m	class:cv::gpu::DeviceInfo	access:private
cv::gpu::DeviceInfo::freeMemory	gpu/gpu.hpp	/^            size_t freeMemory() const;$/;"	p	class:cv::gpu::DeviceInfo	access:public	signature:() const
cv::gpu::DeviceInfo::isCompatible	gpu/gpu.hpp	/^            bool isCompatible() const;$/;"	p	class:cv::gpu::DeviceInfo	access:public	signature:() const
cv::gpu::DeviceInfo::majorVersion	gpu/gpu.hpp	/^            int majorVersion() const { return majorVersion_; }$/;"	f	class:cv::gpu::DeviceInfo	access:public	signature:() const
cv::gpu::DeviceInfo::majorVersion_	gpu/gpu.hpp	/^            int majorVersion_;$/;"	m	class:cv::gpu::DeviceInfo	access:private
cv::gpu::DeviceInfo::minorVersion	gpu/gpu.hpp	/^            int minorVersion() const { return minorVersion_; }$/;"	f	class:cv::gpu::DeviceInfo	access:public	signature:() const
cv::gpu::DeviceInfo::minorVersion_	gpu/gpu.hpp	/^            int minorVersion_;$/;"	m	class:cv::gpu::DeviceInfo	access:private
cv::gpu::DeviceInfo::multiProcessorCount	gpu/gpu.hpp	/^            int multiProcessorCount() const { return multi_processor_count_; }$/;"	f	class:cv::gpu::DeviceInfo	access:public	signature:() const
cv::gpu::DeviceInfo::multi_processor_count_	gpu/gpu.hpp	/^            int multi_processor_count_;$/;"	m	class:cv::gpu::DeviceInfo	access:private
cv::gpu::DeviceInfo::name	gpu/gpu.hpp	/^            string name() const { return name_; }$/;"	f	class:cv::gpu::DeviceInfo	access:public	signature:() const
cv::gpu::DeviceInfo::name_	gpu/gpu.hpp	/^            string name_;$/;"	m	class:cv::gpu::DeviceInfo	access:private
cv::gpu::DeviceInfo::query	gpu/gpu.hpp	/^            void query();$/;"	p	class:cv::gpu::DeviceInfo	access:private	signature:()
cv::gpu::DeviceInfo::queryMemory	gpu/gpu.hpp	/^            void queryMemory(size_t& free_memory, size_t& total_memory) const;$/;"	p	class:cv::gpu::DeviceInfo	access:private	signature:(size_t& free_memory, size_t& total_memory) const
cv::gpu::DeviceInfo::supports	gpu/gpu.hpp	/^            bool supports(FeatureSet feature_set) const;$/;"	p	class:cv::gpu::DeviceInfo	access:public	signature:(FeatureSet feature_set) const
cv::gpu::DeviceInfo::totalMemory	gpu/gpu.hpp	/^            size_t totalMemory() const;$/;"	p	class:cv::gpu::DeviceInfo	access:public	signature:() const
cv::gpu::DisparityBilateralFilter	gpu/gpu.hpp	/^        class CV_EXPORTS DisparityBilateralFilter$/;"	c	namespace:cv::gpu
cv::gpu::DisparityBilateralFilter::DEFAULT_ITERS	gpu/gpu.hpp	/^            enum { DEFAULT_ITERS  = 1 };$/;"	e	enum:cv::gpu::DisparityBilateralFilter::__anon66
cv::gpu::DisparityBilateralFilter::DEFAULT_NDISP	gpu/gpu.hpp	/^            enum { DEFAULT_NDISP  = 64 };$/;"	e	enum:cv::gpu::DisparityBilateralFilter::__anon64
cv::gpu::DisparityBilateralFilter::DEFAULT_RADIUS	gpu/gpu.hpp	/^            enum { DEFAULT_RADIUS = 3 };$/;"	e	enum:cv::gpu::DisparityBilateralFilter::__anon65
cv::gpu::DisparityBilateralFilter::DisparityBilateralFilter	gpu/gpu.hpp	/^            DisparityBilateralFilter(int ndisp, int radius, int iters, float edge_threshold, float max_disc_threshold, float sigma_range);$/;"	p	class:cv::gpu::DisparityBilateralFilter	access:public	signature:(int ndisp, int radius, int iters, float edge_threshold, float max_disc_threshold, float sigma_range)
cv::gpu::DisparityBilateralFilter::DisparityBilateralFilter	gpu/gpu.hpp	/^            explicit DisparityBilateralFilter(int ndisp = DEFAULT_NDISP, int radius = DEFAULT_RADIUS, int iters = DEFAULT_ITERS);$/;"	p	class:cv::gpu::DisparityBilateralFilter	access:public	signature:(int ndisp = DEFAULT_NDISP, int radius = DEFAULT_RADIUS, int iters = DEFAULT_ITERS)
cv::gpu::DisparityBilateralFilter::edge_threshold	gpu/gpu.hpp	/^            float edge_threshold;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
cv::gpu::DisparityBilateralFilter::iters	gpu/gpu.hpp	/^            int iters;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
cv::gpu::DisparityBilateralFilter::max_disc_threshold	gpu/gpu.hpp	/^            float max_disc_threshold;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
cv::gpu::DisparityBilateralFilter::ndisp	gpu/gpu.hpp	/^            int ndisp;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
cv::gpu::DisparityBilateralFilter::operator ()	gpu/gpu.hpp	/^            void operator()(const GpuMat& disparity, const GpuMat& image, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	class:cv::gpu::DisparityBilateralFilter	access:public	signature:(const GpuMat& disparity, const GpuMat& image, GpuMat& dst, Stream& stream = Stream::Null())
cv::gpu::DisparityBilateralFilter::radius	gpu/gpu.hpp	/^            int radius;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
cv::gpu::DisparityBilateralFilter::sigma_range	gpu/gpu.hpp	/^            float sigma_range;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
cv::gpu::DisparityBilateralFilter::table_color	gpu/gpu.hpp	/^            GpuMat table_color;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
cv::gpu::DisparityBilateralFilter::table_space	gpu/gpu.hpp	/^            GpuMat table_space;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
cv::gpu::FEATURE_SET_COMPUTE_10	gpu/gpu.hpp	/^            FEATURE_SET_COMPUTE_10 = 10,$/;"	e	enum:cv::gpu::FeatureSet
cv::gpu::FEATURE_SET_COMPUTE_11	gpu/gpu.hpp	/^            FEATURE_SET_COMPUTE_11 = 11,$/;"	e	enum:cv::gpu::FeatureSet
cv::gpu::FEATURE_SET_COMPUTE_12	gpu/gpu.hpp	/^            FEATURE_SET_COMPUTE_12 = 12,$/;"	e	enum:cv::gpu::FeatureSet
cv::gpu::FEATURE_SET_COMPUTE_13	gpu/gpu.hpp	/^            FEATURE_SET_COMPUTE_13 = 13,$/;"	e	enum:cv::gpu::FeatureSet
cv::gpu::FEATURE_SET_COMPUTE_20	gpu/gpu.hpp	/^            FEATURE_SET_COMPUTE_20 = 20,$/;"	e	enum:cv::gpu::FeatureSet
cv::gpu::FEATURE_SET_COMPUTE_21	gpu/gpu.hpp	/^            FEATURE_SET_COMPUTE_21 = 21,$/;"	e	enum:cv::gpu::FeatureSet
cv::gpu::FeatureSet	gpu/gpu.hpp	/^        enum FeatureSet$/;"	g	namespace:cv::gpu
cv::gpu::FilterEngine_GPU	gpu/gpu.hpp	/^        class CV_EXPORTS FilterEngine_GPU$/;"	c	namespace:cv::gpu
cv::gpu::FilterEngine_GPU::apply	gpu/gpu.hpp	/^            virtual void apply(const GpuMat& src, GpuMat& dst, Rect roi = Rect(0,0,-1,-1), Stream& stream = Stream::Null()) = 0;$/;"	p	class:cv::gpu::FilterEngine_GPU	access:public	signature:(const GpuMat& src, GpuMat& dst, Rect roi = Rect(0,0,-1,-1), Stream& stream = Stream::Null())
cv::gpu::FilterEngine_GPU::~FilterEngine_GPU	gpu/gpu.hpp	/^            virtual ~FilterEngine_GPU() {}$/;"	f	class:cv::gpu::FilterEngine_GPU	access:public	signature:()
cv::gpu::GLOBAL_ATOMICS	gpu/gpu.hpp	/^            GLOBAL_ATOMICS = FEATURE_SET_COMPUTE_11,$/;"	e	enum:cv::gpu::FeatureSet
cv::gpu::GaussianBlur	gpu/gpu.hpp	/^        CV_EXPORTS void GaussianBlur(const GpuMat& src, GpuMat& dst, Size ksize, double sigma1, double sigma2 = 0,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Size ksize, double sigma1, double sigma2 = 0, int rowBorderType = BORDER_DEFAULT, int columnBorderType = -1, Stream& stream = Stream::Null())
cv::gpu::GpuMat	gpu/gpumat.hpp	/^    class CV_EXPORTS GpuMat$/;"	c	namespace:cv::gpu
cv::gpu::GpuMat::GpuMat	gpu/gpumat.hpp	/^        GpuMat();$/;"	p	class:cv::gpu::GpuMat	access:public	signature:()
cv::gpu::GpuMat::GpuMat	gpu/gpumat.hpp	/^        GpuMat(Size size, int type);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(Size size, int type)
cv::gpu::GpuMat::GpuMat	gpu/gpumat.hpp	/^        GpuMat(Size size, int type, const Scalar& s);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(Size size, int type, const Scalar& s)
cv::gpu::GpuMat::GpuMat	gpu/gpumat.hpp	/^        GpuMat(Size size, int type, void* data, size_t step = Mat::AUTO_STEP);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(Size size, int type, void* data, size_t step = Mat::AUTO_STEP)
cv::gpu::GpuMat::GpuMat	gpu/gpumat.hpp	/^        GpuMat(const GpuMat& m);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const GpuMat& m)
cv::gpu::GpuMat::GpuMat	gpu/gpumat.hpp	/^        GpuMat(const GpuMat& m, const Range& rowRange, const Range& colRange);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const GpuMat& m, const Range& rowRange, const Range& colRange)
cv::gpu::GpuMat::GpuMat	gpu/gpumat.hpp	/^        GpuMat(const GpuMat& m, const Rect& roi);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const GpuMat& m, const Rect& roi)
cv::gpu::GpuMat::GpuMat	gpu/gpumat.hpp	/^        GpuMat(int rows, int cols, int type);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int rows, int cols, int type)
cv::gpu::GpuMat::GpuMat	gpu/gpumat.hpp	/^        GpuMat(int rows, int cols, int type, const Scalar& s);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int rows, int cols, int type, const Scalar& s)
cv::gpu::GpuMat::GpuMat	gpu/gpumat.hpp	/^        GpuMat(int rows, int cols, int type, void* data, size_t step = Mat::AUTO_STEP);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int rows, int cols, int type, void* data, size_t step = Mat::AUTO_STEP)
cv::gpu::GpuMat::GpuMat	gpu/gpumat.hpp	/^        explicit GpuMat (const Mat& m);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Mat& m)
cv::gpu::GpuMat::GpuMat	gpu/gpumat.hpp	/^    inline GpuMat::GpuMat() : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0) {}$/;"	f	class:cv::gpu::GpuMat	signature:()
cv::gpu::GpuMat::GpuMat	gpu/gpumat.hpp	/^    inline GpuMat::GpuMat(int rows_, int cols_, int type_) : flags(0), rows(0), cols(0), step(0), data(0), refcount(0), datastart(0), dataend(0)$/;"	f	class:cv::gpu::GpuMat	signature:(int rows_, int cols_, int type_)
cv::gpu::GpuMat::adjustROI	gpu/gpumat.hpp	/^        GpuMat& adjustROI( int dtop, int dbottom, int dleft, int dright );$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( int dtop, int dbottom, int dleft, int dright )
cv::gpu::GpuMat::assignTo	gpu/gpumat.hpp	/^        void assignTo( GpuMat& m, int type=-1 ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( GpuMat& m, int type=-1 ) const
cv::gpu::GpuMat::assignTo	gpu/gpumat.hpp	/^    inline void GpuMat::assignTo(GpuMat& m, int type) const$/;"	f	class:cv::gpu::GpuMat	signature:(GpuMat& m, int type) const
cv::gpu::GpuMat::channels	gpu/gpumat.hpp	/^        int channels() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::clone	gpu/gpumat.hpp	/^        GpuMat clone() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::clone	gpu/gpumat.hpp	/^    inline GpuMat GpuMat::clone() const$/;"	f	class:cv::gpu::GpuMat	signature:() const
cv::gpu::GpuMat::col	gpu/gpumat.hpp	/^        GpuMat col(int x) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int x) const
cv::gpu::GpuMat::colRange	gpu/gpumat.hpp	/^        GpuMat colRange(const Range& r) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Range& r) const
cv::gpu::GpuMat::colRange	gpu/gpumat.hpp	/^        GpuMat colRange(int startcol, int endcol) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int startcol, int endcol) const
cv::gpu::GpuMat::cols	gpu/gpumat.hpp	/^        int rows, cols;$/;"	m	class:cv::gpu::GpuMat	access:public
cv::gpu::GpuMat::convertTo	gpu/gpumat.hpp	/^        void convertTo( GpuMat& m, int rtype, double alpha=1, double beta=0 ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( GpuMat& m, int rtype, double alpha=1, double beta=0 ) const
cv::gpu::GpuMat::copyTo	gpu/gpumat.hpp	/^        void copyTo( GpuMat& m ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( GpuMat& m ) const
cv::gpu::GpuMat::copyTo	gpu/gpumat.hpp	/^        void copyTo( GpuMat& m, const GpuMat& mask ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( GpuMat& m, const GpuMat& mask ) const
cv::gpu::GpuMat::create	gpu/gpumat.hpp	/^        void create(Size size, int type);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(Size size, int type)
cv::gpu::GpuMat::create	gpu/gpumat.hpp	/^        void create(int rows, int cols, int type);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int rows, int cols, int type)
cv::gpu::GpuMat::data	gpu/gpumat.hpp	/^        uchar* data;$/;"	m	class:cv::gpu::GpuMat	access:public
cv::gpu::GpuMat::dataend	gpu/gpumat.hpp	/^        uchar* dataend;$/;"	m	class:cv::gpu::GpuMat	access:public
cv::gpu::GpuMat::datastart	gpu/gpumat.hpp	/^        uchar* datastart;$/;"	m	class:cv::gpu::GpuMat	access:public
cv::gpu::GpuMat::depth	gpu/gpumat.hpp	/^        int depth() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::download	gpu/gpumat.hpp	/^        void download(CudaMem& m, Stream& stream) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(CudaMem& m, Stream& stream) const
cv::gpu::GpuMat::download	gpu/gpumat.hpp	/^        void download(cv::Mat& m) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(cv::Mat& m) const
cv::gpu::GpuMat::elemSize	gpu/gpumat.hpp	/^        size_t elemSize() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::elemSize1	gpu/gpumat.hpp	/^        size_t elemSize1() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::empty	gpu/gpumat.hpp	/^        bool empty() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::empty	gpu/gpumat.hpp	/^    inline bool GpuMat::empty() const { return data == 0; }$/;"	f	class:cv::gpu::GpuMat	signature:() const
cv::gpu::GpuMat::flags	gpu/gpumat.hpp	/^        int flags;$/;"	m	class:cv::gpu::GpuMat	access:public
cv::gpu::GpuMat::isContinuous	gpu/gpumat.hpp	/^        bool isContinuous() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::locateROI	gpu/gpumat.hpp	/^        void locateROI( Size& wholeSize, Point& ofs ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( Size& wholeSize, Point& ofs ) const
cv::gpu::GpuMat::operator ()	gpu/gpumat.hpp	/^        GpuMat operator()( Range rowRange, Range colRange ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( Range rowRange, Range colRange ) const
cv::gpu::GpuMat::operator ()	gpu/gpumat.hpp	/^        GpuMat operator()( const Rect& roi ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( const Rect& roi ) const
cv::gpu::GpuMat::operator =	gpu/gpumat.hpp	/^        GpuMat& operator = (const GpuMat& m);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const GpuMat& m)
cv::gpu::GpuMat::operator =	gpu/gpumat.hpp	/^        GpuMat& operator = (const Mat& m);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Mat& m)
cv::gpu::GpuMat::operator =	gpu/gpumat.hpp	/^        GpuMat& operator = (const Scalar& s);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Scalar& s)
cv::gpu::GpuMat::operator DevMem2D_<T>	gpu/gpumat.hpp	/^        template <class T> operator DevMem2D_<T>() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::operator DevMem2D_<T>	gpu/gpumat.hpp	/^    template <class T> inline GpuMat::operator DevMem2D_<T>() const { return DevMem2D_<T>(rows, cols, (T*)data, step); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
cv::gpu::GpuMat::operator Mat	gpu/gpumat.hpp	/^        operator Mat() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::operator PtrStep_<T>	gpu/gpumat.hpp	/^        template <class T> operator PtrStep_<T>() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::operator PtrStep_<T>	gpu/gpumat.hpp	/^    template <class T> inline GpuMat::operator PtrStep_<T>() const { return PtrStep_<T>(static_cast< DevMem2D_<T> >(*this)); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
cv::gpu::GpuMat::ptr	gpu/gpumat.hpp	/^        const uchar* ptr(int y = 0) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int y = 0) const
cv::gpu::GpuMat::ptr	gpu/gpumat.hpp	/^        template<typename _Tp> _Tp* ptr(int y = 0);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int y = 0)
cv::gpu::GpuMat::ptr	gpu/gpumat.hpp	/^        template<typename _Tp> const _Tp* ptr(int y = 0) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int y = 0) const
cv::gpu::GpuMat::ptr	gpu/gpumat.hpp	/^        uchar* ptr(int y = 0);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int y = 0)
cv::gpu::GpuMat::ptr	gpu/gpumat.hpp	/^    template<typename _Tp> inline _Tp* GpuMat::ptr(int y)$/;"	f	class:cv::gpu::GpuMat	signature:(int y)
cv::gpu::GpuMat::ptr	gpu/gpumat.hpp	/^    template<typename _Tp> inline const _Tp* GpuMat::ptr(int y) const$/;"	f	class:cv::gpu::GpuMat	signature:(int y) const
cv::gpu::GpuMat::refcount	gpu/gpumat.hpp	/^        int* refcount;$/;"	m	class:cv::gpu::GpuMat	access:public
cv::gpu::GpuMat::release	gpu/gpumat.hpp	/^        void release();$/;"	p	class:cv::gpu::GpuMat	access:public	signature:()
cv::gpu::GpuMat::reshape	gpu/gpumat.hpp	/^        GpuMat reshape(int cn, int rows = 0) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int cn, int rows = 0) const
cv::gpu::GpuMat::row	gpu/gpumat.hpp	/^        GpuMat row(int y) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int y) const
cv::gpu::GpuMat::rowRange	gpu/gpumat.hpp	/^        GpuMat rowRange(const Range& r) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Range& r) const
cv::gpu::GpuMat::rowRange	gpu/gpumat.hpp	/^        GpuMat rowRange(int startrow, int endrow) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int startrow, int endrow) const
cv::gpu::GpuMat::rows	gpu/gpumat.hpp	/^        int rows, cols;$/;"	m	class:cv::gpu::GpuMat	access:public
cv::gpu::GpuMat::setTo	gpu/gpumat.hpp	/^        GpuMat& setTo(const Scalar& s, const GpuMat& mask = GpuMat());$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Scalar& s, const GpuMat& mask = GpuMat())
cv::gpu::GpuMat::size	gpu/gpumat.hpp	/^        Size size() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::step	gpu/gpumat.hpp	/^        size_t step;$/;"	m	class:cv::gpu::GpuMat	access:public
cv::gpu::GpuMat::step1	gpu/gpumat.hpp	/^        size_t step1() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::step1	gpu/gpumat.hpp	/^    inline size_t GpuMat::step1() const { return step\/elemSize1(); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
cv::gpu::GpuMat::swap	gpu/gpumat.hpp	/^        void swap(GpuMat& mat);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(GpuMat& mat)
cv::gpu::GpuMat::t	gpu/gpumat.hpp	/^        GpuMat t() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::type	gpu/gpumat.hpp	/^        int type() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
cv::gpu::GpuMat::upload	gpu/gpumat.hpp	/^        void upload(const CudaMem& m, Stream& stream);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const CudaMem& m, Stream& stream)
cv::gpu::GpuMat::upload	gpu/gpumat.hpp	/^        void upload(const cv::Mat& m);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const cv::Mat& m)
cv::gpu::GpuMat::~GpuMat	gpu/gpumat.hpp	/^        ~GpuMat();$/;"	p	class:cv::gpu::GpuMat	access:public	signature:()
cv::gpu::GpuMat::~GpuMat	gpu/gpumat.hpp	/^    inline GpuMat::~GpuMat() { release(); }$/;"	f	class:cv::gpu::GpuMat	signature:()
cv::gpu::HOGDescriptor	gpu/gpu.hpp	/^        struct CV_EXPORTS HOGDescriptor$/;"	s	namespace:cv::gpu
cv::gpu::HOGDescriptor::DEFAULT_NLEVELS	gpu/gpu.hpp	/^            enum { DEFAULT_NLEVELS = 64 };$/;"	e	enum:cv::gpu::HOGDescriptor::__anon68
cv::gpu::HOGDescriptor::DEFAULT_WIN_SIGMA	gpu/gpu.hpp	/^            enum { DEFAULT_WIN_SIGMA = -1 };$/;"	e	enum:cv::gpu::HOGDescriptor::__anon67
cv::gpu::HOGDescriptor::DESCR_FORMAT_COL_BY_COL	gpu/gpu.hpp	/^            enum { DESCR_FORMAT_ROW_BY_ROW, DESCR_FORMAT_COL_BY_COL };$/;"	e	enum:cv::gpu::HOGDescriptor::__anon69
cv::gpu::HOGDescriptor::DESCR_FORMAT_ROW_BY_ROW	gpu/gpu.hpp	/^            enum { DESCR_FORMAT_ROW_BY_ROW, DESCR_FORMAT_COL_BY_COL };$/;"	e	enum:cv::gpu::HOGDescriptor::__anon69
cv::gpu::HOGDescriptor::HOGDescriptor	gpu/gpu.hpp	/^            HOGDescriptor(Size win_size=Size(64, 128), Size block_size=Size(16, 16),$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:(Size win_size=Size(64, 128), Size block_size=Size(16, 16), Size block_stride=Size(8, 8), Size cell_size=Size(8, 8), int nbins=9, double win_sigma=DEFAULT_WIN_SIGMA, double threshold_L2hys=0.2, bool gamma_correction=true, int nlevels=DEFAULT_NLEVELS)
cv::gpu::HOGDescriptor::block_hists	gpu/gpu.hpp	/^            GpuMat block_hists, block_hists_buf;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
cv::gpu::HOGDescriptor::block_hists_buf	gpu/gpu.hpp	/^            GpuMat block_hists, block_hists_buf;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
cv::gpu::HOGDescriptor::block_size	gpu/gpu.hpp	/^            Size block_size;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
cv::gpu::HOGDescriptor::block_stride	gpu/gpu.hpp	/^            Size block_stride;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
cv::gpu::HOGDescriptor::cell_size	gpu/gpu.hpp	/^            Size cell_size;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
cv::gpu::HOGDescriptor::checkDetectorSize	gpu/gpu.hpp	/^            bool checkDetectorSize() const;$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:() const
cv::gpu::HOGDescriptor::computeBlockHistograms	gpu/gpu.hpp	/^            void computeBlockHistograms(const GpuMat& img);$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:(const GpuMat& img)
cv::gpu::HOGDescriptor::computeGradient	gpu/gpu.hpp	/^            void computeGradient(const GpuMat& img, GpuMat& grad, GpuMat& qangle);$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:(const GpuMat& img, GpuMat& grad, GpuMat& qangle)
cv::gpu::HOGDescriptor::detect	gpu/gpu.hpp	/^            void detect(const GpuMat& img, vector<Point>& found_locations, $/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:(const GpuMat& img, vector<Point>& found_locations, double hit_threshold=0, Size win_stride=Size(), Size padding=Size())
cv::gpu::HOGDescriptor::detectMultiScale	gpu/gpu.hpp	/^            void detectMultiScale(const GpuMat& img, vector<Rect>& found_locations,$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:(const GpuMat& img, vector<Rect>& found_locations, double hit_threshold=0, Size win_stride=Size(), Size padding=Size(), double scale0=1.05, int group_threshold=2)
cv::gpu::HOGDescriptor::detector	gpu/gpu.hpp	/^            GpuMat detector;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
cv::gpu::HOGDescriptor::free_coef	gpu/gpu.hpp	/^            float free_coef;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
cv::gpu::HOGDescriptor::gamma_correction	gpu/gpu.hpp	/^            bool gamma_correction;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
cv::gpu::HOGDescriptor::getBlockHistogramSize	gpu/gpu.hpp	/^            size_t getBlockHistogramSize() const;$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:() const
cv::gpu::HOGDescriptor::getBuffer	gpu/gpu.hpp	/^			static GpuMat getBuffer(const Size& sz, int type, GpuMat& buf);$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:(const Size& sz, int type, GpuMat& buf)
cv::gpu::HOGDescriptor::getBuffer	gpu/gpu.hpp	/^			static GpuMat getBuffer(int rows, int cols, int type, GpuMat& buf);$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:(int rows, int cols, int type, GpuMat& buf)
cv::gpu::HOGDescriptor::getDefaultPeopleDetector	gpu/gpu.hpp	/^            static vector<float> getDefaultPeopleDetector();$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:()
cv::gpu::HOGDescriptor::getDescriptorSize	gpu/gpu.hpp	/^            size_t getDescriptorSize() const;$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:() const
cv::gpu::HOGDescriptor::getDescriptors	gpu/gpu.hpp	/^            void getDescriptors(const GpuMat& img, Size win_stride, $/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:(const GpuMat& img, Size win_stride, GpuMat& descriptors, int descr_format=DESCR_FORMAT_COL_BY_COL)
cv::gpu::HOGDescriptor::getPeopleDetector48x96	gpu/gpu.hpp	/^            static vector<float> getPeopleDetector48x96();$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:()
cv::gpu::HOGDescriptor::getPeopleDetector64x128	gpu/gpu.hpp	/^            static vector<float> getPeopleDetector64x128();$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:()
cv::gpu::HOGDescriptor::getWinSigma	gpu/gpu.hpp	/^            double getWinSigma() const;$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:() const
cv::gpu::HOGDescriptor::grad	gpu/gpu.hpp	/^            GpuMat grad, qangle, grad_buf, qangle_buf;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
cv::gpu::HOGDescriptor::grad_buf	gpu/gpu.hpp	/^            GpuMat grad, qangle, grad_buf, qangle_buf;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
cv::gpu::HOGDescriptor::image_scales	gpu/gpu.hpp	/^			std::vector<GpuMat> image_scales;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
cv::gpu::HOGDescriptor::labels	gpu/gpu.hpp	/^            GpuMat labels, labels_buf;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
cv::gpu::HOGDescriptor::labels_buf	gpu/gpu.hpp	/^            GpuMat labels, labels_buf;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
cv::gpu::HOGDescriptor::labels_host	gpu/gpu.hpp	/^            Mat labels_host;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
cv::gpu::HOGDescriptor::nbins	gpu/gpu.hpp	/^            int nbins;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
cv::gpu::HOGDescriptor::nlevels	gpu/gpu.hpp	/^            int nlevels;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
cv::gpu::HOGDescriptor::numPartsWithin	gpu/gpu.hpp	/^            static Size numPartsWithin(Size size, Size part_size, Size stride);$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:(Size size, Size part_size, Size stride)
cv::gpu::HOGDescriptor::numPartsWithin	gpu/gpu.hpp	/^            static int numPartsWithin(int size, int part_size, int stride);$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:(int size, int part_size, int stride)
cv::gpu::HOGDescriptor::qangle	gpu/gpu.hpp	/^            GpuMat grad, qangle, grad_buf, qangle_buf;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
cv::gpu::HOGDescriptor::qangle_buf	gpu/gpu.hpp	/^            GpuMat grad, qangle, grad_buf, qangle_buf;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
cv::gpu::HOGDescriptor::setSVMDetector	gpu/gpu.hpp	/^            void setSVMDetector(const vector<float>& detector);$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:(const vector<float>& detector)
cv::gpu::HOGDescriptor::threshold_L2hys	gpu/gpu.hpp	/^            double threshold_L2hys;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
cv::gpu::HOGDescriptor::win_sigma	gpu/gpu.hpp	/^            double win_sigma;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
cv::gpu::HOGDescriptor::win_size	gpu/gpu.hpp	/^            Size win_size;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
cv::gpu::LUT	gpu/gpu.hpp	/^        CV_EXPORTS void LUT(const GpuMat& src, const Mat& lut, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, const Mat& lut, GpuMat& dst, Stream& stream = Stream::Null())
cv::gpu::Laplacian	gpu/gpu.hpp	/^        CV_EXPORTS void Laplacian(const GpuMat& src, GpuMat& dst, int ddepth, int ksize = 1, double scale = 1, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, int ksize = 1, double scale = 1, Stream& stream = Stream::Null())
cv::gpu::NATIVE_DOUBLE	gpu/gpu.hpp	/^            NATIVE_DOUBLE = FEATURE_SET_COMPUTE_13$/;"	e	enum:cv::gpu::FeatureSet
cv::gpu::PtrElemStep	gpu/devmem2d.hpp	/^        typedef PtrElemStep_<unsigned char> PtrElemStep;$/;"	t	namespace:cv::gpu
cv::gpu::PtrElemStep_	gpu/devmem2d.hpp	/^        template<typename T> struct PtrElemStep_ : public PtrStep_<T>$/;"	s	namespace:cv::gpu	inherits:PtrStep_
cv::gpu::PtrElemStep_::PtrElemStep_	gpu/devmem2d.hpp	/^            PtrElemStep_(const DevMem2D_<T>& mem) : PtrStep_<T>(mem) $/;"	f	struct:cv::gpu::PtrElemStep_	access:public	signature:(const DevMem2D_<T>& mem)
cv::gpu::PtrElemStep_::ptr	gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ T* ptr(int y = 0) { return PtrStep_<T>::data + y * PtrStep_<T>::step; }$/;"	f	struct:cv::gpu::PtrElemStep_	access:public	signature:(int y = 0)
cv::gpu::PtrElemStep_::ptr	gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ const T* ptr(int y = 0) const { return PtrStep_<T>::data + y * PtrStep_<T>::step; }                    $/;"	f	struct:cv::gpu::PtrElemStep_	access:public	signature:(int y = 0) const
cv::gpu::PtrElemStepf	gpu/devmem2d.hpp	/^        typedef PtrElemStep_<float> PtrElemStepf;$/;"	t	namespace:cv::gpu
cv::gpu::PtrElemStepi	gpu/devmem2d.hpp	/^        typedef PtrElemStep_<int> PtrElemStepi;$/;"	t	namespace:cv::gpu
cv::gpu::PtrStep	gpu/devmem2d.hpp	/^        typedef PtrStep_<unsigned char> PtrStep;$/;"	t	namespace:cv::gpu
cv::gpu::PtrStep_	gpu/devmem2d.hpp	/^        template<typename T> struct PtrStep_$/;"	s	namespace:cv::gpu
cv::gpu::PtrStep_::PtrStep_	gpu/devmem2d.hpp	/^            PtrStep_() : data(0), step(0) {}            $/;"	f	struct:cv::gpu::PtrStep_	access:public	signature:()
cv::gpu::PtrStep_::PtrStep_	gpu/devmem2d.hpp	/^            PtrStep_(const DevMem2D_<T>& mem) : data(mem.data), step(mem.step) {}$/;"	f	struct:cv::gpu::PtrStep_	access:public	signature:(const DevMem2D_<T>& mem)
cv::gpu::PtrStep_::begin	gpu/devmem2d.hpp	/^            thrust::device_ptr<T> begin() const { return thrust::device_ptr<T>(data); }$/;"	f	struct:cv::gpu::PtrStep_	access:public	signature:() const
cv::gpu::PtrStep_::data	gpu/devmem2d.hpp	/^            T* data;$/;"	m	struct:cv::gpu::PtrStep_	access:public
cv::gpu::PtrStep_::elemSize	gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ size_t elemSize() const { return elem_size; }$/;"	f	struct:cv::gpu::PtrStep_	access:public	signature:() const
cv::gpu::PtrStep_::elem_size	gpu/devmem2d.hpp	/^            enum { elem_size = sizeof(elem_type) };$/;"	e	enum:cv::gpu::PtrStep_::__anon53
cv::gpu::PtrStep_::elem_type	gpu/devmem2d.hpp	/^            typedef T elem_type;$/;"	t	struct:cv::gpu::PtrStep_	access:public
cv::gpu::PtrStep_::ptr	gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ T* ptr(int y = 0) { return (T*)( (char*)data + y * step); }$/;"	f	struct:cv::gpu::PtrStep_	access:public	signature:(int y = 0)
cv::gpu::PtrStep_::ptr	gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ const T* ptr(int y = 0) const { return (const T*)( (const char*)data + y * step); }$/;"	f	struct:cv::gpu::PtrStep_	access:public	signature:(int y = 0) const
cv::gpu::PtrStep_::step	gpu/devmem2d.hpp	/^            size_t step;$/;"	m	struct:cv::gpu::PtrStep_	access:public
cv::gpu::PtrStepf	gpu/devmem2d.hpp	/^        typedef PtrStep_<float> PtrStepf;$/;"	t	namespace:cv::gpu
cv::gpu::PtrStepi	gpu/devmem2d.hpp	/^        typedef PtrStep_<int> PtrStepi;$/;"	t	namespace:cv::gpu
cv::gpu::PyrDownBuf	gpu/gpu.hpp	/^        struct CV_EXPORTS PyrDownBuf$/;"	s	namespace:cv::gpu
cv::gpu::PyrDownBuf	gpu/gpu.hpp	/^        struct CV_EXPORTS PyrDownBuf;$/;"	m	namespace:cv::gpu	typeref:struct:cv::gpu::CV_EXPORTS
cv::gpu::PyrDownBuf::PyrDownBuf	gpu/gpu.hpp	/^            PyrDownBuf() : image_type(-1) {}$/;"	f	struct:cv::gpu::PyrDownBuf	access:public	signature:()
cv::gpu::PyrDownBuf::PyrDownBuf	gpu/gpu.hpp	/^            PyrDownBuf(Size image_size, int image_type_) : image_type(-1) { create(image_size, image_type_); }$/;"	f	struct:cv::gpu::PyrDownBuf	access:public	signature:(Size image_size, int image_type_)
cv::gpu::PyrDownBuf::buf	gpu/gpu.hpp	/^            GpuMat buf;$/;"	m	struct:cv::gpu::PyrDownBuf	access:private
cv::gpu::PyrDownBuf::create	gpu/gpu.hpp	/^            void create(Size image_size, int image_type_);$/;"	p	struct:cv::gpu::PyrDownBuf	access:public	signature:(Size image_size, int image_type_)
cv::gpu::PyrDownBuf::filter	gpu/gpu.hpp	/^            Ptr<FilterEngine_GPU> filter;$/;"	m	struct:cv::gpu::PyrDownBuf	access:private
cv::gpu::PyrDownBuf::image_type	gpu/gpu.hpp	/^            int image_type;$/;"	m	struct:cv::gpu::PyrDownBuf	access:private
cv::gpu::PyrDownBuf::ker	gpu/gpu.hpp	/^            static Mat ker;$/;"	m	struct:cv::gpu::PyrDownBuf	access:private
cv::gpu::PyrDownBuf::pyrDown	gpu/gpu.hpp	/^            friend void pyrDown(const GpuMat&, GpuMat&, PyrDownBuf&, Stream& stream);$/;"	p	struct:cv::gpu::PyrDownBuf	access:friend	signature:(const GpuMat&, GpuMat&, PyrDownBuf&, Stream& stream)
cv::gpu::PyrUpBuf	gpu/gpu.hpp	/^        struct CV_EXPORTS PyrUpBuf$/;"	s	namespace:cv::gpu
cv::gpu::PyrUpBuf	gpu/gpu.hpp	/^        struct CV_EXPORTS PyrUpBuf;$/;"	m	namespace:cv::gpu	typeref:struct:cv::gpu::CV_EXPORTS
cv::gpu::PyrUpBuf::PyrUpBuf	gpu/gpu.hpp	/^            PyrUpBuf() : image_type(-1) {}$/;"	f	struct:cv::gpu::PyrUpBuf	access:public	signature:()
cv::gpu::PyrUpBuf::PyrUpBuf	gpu/gpu.hpp	/^            PyrUpBuf(Size image_size, int image_type_) : image_type(-1) { create(image_size, image_type_); }$/;"	f	struct:cv::gpu::PyrUpBuf	access:public	signature:(Size image_size, int image_type_)
cv::gpu::PyrUpBuf::buf	gpu/gpu.hpp	/^            GpuMat buf;$/;"	m	struct:cv::gpu::PyrUpBuf	access:private
cv::gpu::PyrUpBuf::create	gpu/gpu.hpp	/^            void create(Size image_size, int image_type_);$/;"	p	struct:cv::gpu::PyrUpBuf	access:public	signature:(Size image_size, int image_type_)
cv::gpu::PyrUpBuf::filter	gpu/gpu.hpp	/^            Ptr<FilterEngine_GPU> filter;$/;"	m	struct:cv::gpu::PyrUpBuf	access:private
cv::gpu::PyrUpBuf::image_type	gpu/gpu.hpp	/^            int image_type;$/;"	m	struct:cv::gpu::PyrUpBuf	access:private
cv::gpu::PyrUpBuf::ker	gpu/gpu.hpp	/^            static Mat ker;$/;"	m	struct:cv::gpu::PyrUpBuf	access:private
cv::gpu::PyrUpBuf::pyrUp	gpu/gpu.hpp	/^            friend void pyrUp(const GpuMat&, GpuMat&, PyrUpBuf&, Stream& stream);$/;"	p	struct:cv::gpu::PyrUpBuf	access:friend	signature:(const GpuMat&, GpuMat&, PyrUpBuf&, Stream& stream)
cv::gpu::SURF_GPU	gpu/gpu.hpp	/^        class CV_EXPORTS SURF_GPU : public CvSURFParams$/;"	c	namespace:cv::gpu	inherits:CvSURFParams
cv::gpu::SURF_GPU::KeypointLayout	gpu/gpu.hpp	/^            enum KeypointLayout $/;"	g	class:cv::gpu::SURF_GPU	access:public
cv::gpu::SURF_GPU::SF_DIR	gpu/gpu.hpp	/^                SF_DIR,$/;"	e	enum:cv::gpu::SURF_GPU::KeypointLayout
cv::gpu::SURF_GPU::SF_FEATURE_STRIDE	gpu/gpu.hpp	/^                SF_FEATURE_STRIDE$/;"	e	enum:cv::gpu::SURF_GPU::KeypointLayout
cv::gpu::SURF_GPU::SF_HESSIAN	gpu/gpu.hpp	/^                SF_HESSIAN,$/;"	e	enum:cv::gpu::SURF_GPU::KeypointLayout
cv::gpu::SURF_GPU::SF_LAPLACIAN	gpu/gpu.hpp	/^                SF_LAPLACIAN,$/;"	e	enum:cv::gpu::SURF_GPU::KeypointLayout
cv::gpu::SURF_GPU::SF_SIZE	gpu/gpu.hpp	/^                SF_SIZE,$/;"	e	enum:cv::gpu::SURF_GPU::KeypointLayout
cv::gpu::SURF_GPU::SF_X	gpu/gpu.hpp	/^                SF_X = 0,$/;"	e	enum:cv::gpu::SURF_GPU::KeypointLayout
cv::gpu::SURF_GPU::SF_Y	gpu/gpu.hpp	/^                SF_Y,$/;"	e	enum:cv::gpu::SURF_GPU::KeypointLayout
cv::gpu::SURF_GPU::SURF_GPU	gpu/gpu.hpp	/^            SURF_GPU();$/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:()
cv::gpu::SURF_GPU::SURF_GPU	gpu/gpu.hpp	/^            explicit SURF_GPU(double _hessianThreshold, int _nOctaves=4,$/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:(double _hessianThreshold, int _nOctaves=4, int _nOctaveLayers=2, bool _extended=false, float _keypointsRatio=0.01f, bool _upright = false)
cv::gpu::SURF_GPU::descriptorSize	gpu/gpu.hpp	/^            int descriptorSize() const;$/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:() const
cv::gpu::SURF_GPU::det	gpu/gpu.hpp	/^            GpuMat det, trace;$/;"	m	class:cv::gpu::SURF_GPU	access:public
cv::gpu::SURF_GPU::downloadDescriptors	gpu/gpu.hpp	/^            void downloadDescriptors(const GpuMat& descriptorsGPU, vector<float>& descriptors);$/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:(const GpuMat& descriptorsGPU, vector<float>& descriptors)
cv::gpu::SURF_GPU::downloadKeypoints	gpu/gpu.hpp	/^            void downloadKeypoints(const GpuMat& keypointsGPU, vector<KeyPoint>& keypoints);$/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:(const GpuMat& keypointsGPU, vector<KeyPoint>& keypoints)
cv::gpu::SURF_GPU::intBuffer	gpu/gpu.hpp	/^            GpuMat sum, mask1, maskSum, intBuffer;$/;"	m	class:cv::gpu::SURF_GPU	access:public
cv::gpu::SURF_GPU::keypointsRatio	gpu/gpu.hpp	/^            float keypointsRatio;$/;"	m	class:cv::gpu::SURF_GPU	access:public
cv::gpu::SURF_GPU::mask1	gpu/gpu.hpp	/^            GpuMat sum, mask1, maskSum, intBuffer;$/;"	m	class:cv::gpu::SURF_GPU	access:public
cv::gpu::SURF_GPU::maskSum	gpu/gpu.hpp	/^            GpuMat sum, mask1, maskSum, intBuffer;$/;"	m	class:cv::gpu::SURF_GPU	access:public
cv::gpu::SURF_GPU::maxPosBuffer	gpu/gpu.hpp	/^            GpuMat maxPosBuffer;$/;"	m	class:cv::gpu::SURF_GPU	access:public
cv::gpu::SURF_GPU::operator ()	gpu/gpu.hpp	/^            void operator()(const GpuMat& img, const GpuMat& mask, GpuMat& keypoints);$/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:(const GpuMat& img, const GpuMat& mask, GpuMat& keypoints)
cv::gpu::SURF_GPU::operator ()	gpu/gpu.hpp	/^            void operator()(const GpuMat& img, const GpuMat& mask, GpuMat& keypoints, GpuMat& descriptors, $/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:(const GpuMat& img, const GpuMat& mask, GpuMat& keypoints, GpuMat& descriptors, bool useProvidedKeypoints = false)
cv::gpu::SURF_GPU::operator ()	gpu/gpu.hpp	/^            void operator()(const GpuMat& img, const GpuMat& mask, std::vector<KeyPoint>& keypoints);$/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:(const GpuMat& img, const GpuMat& mask, std::vector<KeyPoint>& keypoints)
cv::gpu::SURF_GPU::operator ()	gpu/gpu.hpp	/^            void operator()(const GpuMat& img, const GpuMat& mask, std::vector<KeyPoint>& keypoints, GpuMat& descriptors, $/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:(const GpuMat& img, const GpuMat& mask, std::vector<KeyPoint>& keypoints, GpuMat& descriptors, bool useProvidedKeypoints = false)
cv::gpu::SURF_GPU::operator ()	gpu/gpu.hpp	/^            void operator()(const GpuMat& img, const GpuMat& mask, std::vector<KeyPoint>& keypoints, std::vector<float>& descriptors, $/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:(const GpuMat& img, const GpuMat& mask, std::vector<KeyPoint>& keypoints, std::vector<float>& descriptors, bool useProvidedKeypoints = false)
cv::gpu::SURF_GPU::releaseMemory	gpu/gpu.hpp	/^            void releaseMemory();$/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:()
cv::gpu::SURF_GPU::sum	gpu/gpu.hpp	/^            GpuMat sum, mask1, maskSum, intBuffer;$/;"	m	class:cv::gpu::SURF_GPU	access:public
cv::gpu::SURF_GPU::trace	gpu/gpu.hpp	/^            GpuMat det, trace;$/;"	m	class:cv::gpu::SURF_GPU	access:public
cv::gpu::SURF_GPU::uploadKeypoints	gpu/gpu.hpp	/^            void uploadKeypoints(const vector<KeyPoint>& keypoints, GpuMat& keypointsGPU);$/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:(const vector<KeyPoint>& keypoints, GpuMat& keypointsGPU)
cv::gpu::Scharr	gpu/gpu.hpp	/^        CV_EXPORTS void Scharr(const GpuMat& src, GpuMat& dst, int ddepth, int dx, int dy, double scale = 1,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, int dx, int dy, double scale = 1, int rowBorderType = BORDER_DEFAULT, int columnBorderType = -1, Stream& stream = Stream::Null())
cv::gpu::Sobel	gpu/gpu.hpp	/^        CV_EXPORTS void Sobel(const GpuMat& src, GpuMat& dst, int ddepth, int dx, int dy, int ksize = 3, double scale = 1,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, int dx, int dy, int ksize = 3, double scale = 1, int rowBorderType = BORDER_DEFAULT, int columnBorderType = -1, Stream& stream = Stream::Null())
cv::gpu::StaticAssert	gpu/devmem2d.hpp	/^        template <> struct StaticAssert<true> {static __CV_GPU_HOST_DEVICE__ void check(){}};        $/;"	s	namespace:cv::gpu
cv::gpu::StaticAssert::check	gpu/devmem2d.hpp	/^        template <> struct StaticAssert<true> {static __CV_GPU_HOST_DEVICE__ void check(){}};        $/;"	f	struct:cv::gpu::StaticAssert	access:public	signature:()
cv::gpu::StereoBM_GPU	gpu/gpu.hpp	/^        class CV_EXPORTS StereoBM_GPU$/;"	c	namespace:cv::gpu
cv::gpu::StereoBM_GPU::BASIC_PRESET	gpu/gpu.hpp	/^            enum { BASIC_PRESET = 0, PREFILTER_XSOBEL = 1 };$/;"	e	enum:cv::gpu::StereoBM_GPU::__anon55
cv::gpu::StereoBM_GPU::DEFAULT_NDISP	gpu/gpu.hpp	/^            enum { DEFAULT_NDISP = 64, DEFAULT_WINSZ = 19 };$/;"	e	enum:cv::gpu::StereoBM_GPU::__anon56
cv::gpu::StereoBM_GPU::DEFAULT_WINSZ	gpu/gpu.hpp	/^            enum { DEFAULT_NDISP = 64, DEFAULT_WINSZ = 19 };$/;"	e	enum:cv::gpu::StereoBM_GPU::__anon56
cv::gpu::StereoBM_GPU::PREFILTER_XSOBEL	gpu/gpu.hpp	/^            enum { BASIC_PRESET = 0, PREFILTER_XSOBEL = 1 };$/;"	e	enum:cv::gpu::StereoBM_GPU::__anon55
cv::gpu::StereoBM_GPU::StereoBM_GPU	gpu/gpu.hpp	/^            StereoBM_GPU();$/;"	p	class:cv::gpu::StereoBM_GPU	access:public	signature:()
cv::gpu::StereoBM_GPU::StereoBM_GPU	gpu/gpu.hpp	/^            StereoBM_GPU(int preset, int ndisparities = DEFAULT_NDISP, int winSize = DEFAULT_WINSZ);$/;"	p	class:cv::gpu::StereoBM_GPU	access:public	signature:(int preset, int ndisparities = DEFAULT_NDISP, int winSize = DEFAULT_WINSZ)
cv::gpu::StereoBM_GPU::avergeTexThreshold	gpu/gpu.hpp	/^            float avergeTexThreshold;$/;"	m	class:cv::gpu::StereoBM_GPU	access:public
cv::gpu::StereoBM_GPU::checkIfGpuCallReasonable	gpu/gpu.hpp	/^            static bool checkIfGpuCallReasonable();$/;"	p	class:cv::gpu::StereoBM_GPU	access:public	signature:()
cv::gpu::StereoBM_GPU::leBuf	gpu/gpu.hpp	/^            GpuMat minSSD, leBuf, riBuf;$/;"	m	class:cv::gpu::StereoBM_GPU	access:private
cv::gpu::StereoBM_GPU::minSSD	gpu/gpu.hpp	/^            GpuMat minSSD, leBuf, riBuf;$/;"	m	class:cv::gpu::StereoBM_GPU	access:private
cv::gpu::StereoBM_GPU::ndisp	gpu/gpu.hpp	/^            int ndisp;$/;"	m	class:cv::gpu::StereoBM_GPU	access:public
cv::gpu::StereoBM_GPU::operator ()	gpu/gpu.hpp	/^            void operator() ( const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream = Stream::Null());$/;"	p	class:cv::gpu::StereoBM_GPU	access:public	signature:( const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream = Stream::Null())
cv::gpu::StereoBM_GPU::preset	gpu/gpu.hpp	/^            int preset;$/;"	m	class:cv::gpu::StereoBM_GPU	access:public
cv::gpu::StereoBM_GPU::riBuf	gpu/gpu.hpp	/^            GpuMat minSSD, leBuf, riBuf;$/;"	m	class:cv::gpu::StereoBM_GPU	access:private
cv::gpu::StereoBM_GPU::winSize	gpu/gpu.hpp	/^            int winSize;$/;"	m	class:cv::gpu::StereoBM_GPU	access:public
cv::gpu::StereoBeliefPropagation	gpu/gpu.hpp	/^        class CV_EXPORTS StereoBeliefPropagation$/;"	c	namespace:cv::gpu
cv::gpu::StereoBeliefPropagation::DEFAULT_ITERS	gpu/gpu.hpp	/^            enum { DEFAULT_ITERS  = 5  };$/;"	e	enum:cv::gpu::StereoBeliefPropagation::__anon58
cv::gpu::StereoBeliefPropagation::DEFAULT_LEVELS	gpu/gpu.hpp	/^            enum { DEFAULT_LEVELS = 5  };$/;"	e	enum:cv::gpu::StereoBeliefPropagation::__anon59
cv::gpu::StereoBeliefPropagation::DEFAULT_NDISP	gpu/gpu.hpp	/^            enum { DEFAULT_NDISP  = 64 };$/;"	e	enum:cv::gpu::StereoBeliefPropagation::__anon57
cv::gpu::StereoBeliefPropagation::StereoBeliefPropagation	gpu/gpu.hpp	/^            StereoBeliefPropagation(int ndisp, int iters, int levels,$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(int ndisp, int iters, int levels, float max_data_term, float data_weight, float max_disc_term, float disc_single_jump, int msg_type = CV_32F)
cv::gpu::StereoBeliefPropagation::StereoBeliefPropagation	gpu/gpu.hpp	/^            explicit StereoBeliefPropagation(int ndisp  = DEFAULT_NDISP,$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(int ndisp = DEFAULT_NDISP, int iters = DEFAULT_ITERS, int levels = DEFAULT_LEVELS, int msg_type = CV_32F)
cv::gpu::StereoBeliefPropagation::d	gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
cv::gpu::StereoBeliefPropagation::d2	gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
cv::gpu::StereoBeliefPropagation::data_weight	gpu/gpu.hpp	/^            float data_weight;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
cv::gpu::StereoBeliefPropagation::datas	gpu/gpu.hpp	/^            std::vector<GpuMat> datas;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
cv::gpu::StereoBeliefPropagation::disc_single_jump	gpu/gpu.hpp	/^            float disc_single_jump;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
cv::gpu::StereoBeliefPropagation::estimateRecommendedParams	gpu/gpu.hpp	/^            static void estimateRecommendedParams(int width, int height, int& ndisp, int& iters, int& levels);$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(int width, int height, int& ndisp, int& iters, int& levels)
cv::gpu::StereoBeliefPropagation::iters	gpu/gpu.hpp	/^            int iters;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
cv::gpu::StereoBeliefPropagation::l	gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
cv::gpu::StereoBeliefPropagation::l2	gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
cv::gpu::StereoBeliefPropagation::levels	gpu/gpu.hpp	/^            int levels;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
cv::gpu::StereoBeliefPropagation::max_data_term	gpu/gpu.hpp	/^            float max_data_term;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
cv::gpu::StereoBeliefPropagation::max_disc_term	gpu/gpu.hpp	/^            float max_disc_term;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
cv::gpu::StereoBeliefPropagation::msg_type	gpu/gpu.hpp	/^            int msg_type;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
cv::gpu::StereoBeliefPropagation::ndisp	gpu/gpu.hpp	/^            int ndisp;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
cv::gpu::StereoBeliefPropagation::operator ()	gpu/gpu.hpp	/^            void operator()(const GpuMat& data, GpuMat& disparity, Stream& stream = Stream::Null());$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(const GpuMat& data, GpuMat& disparity, Stream& stream = Stream::Null())
cv::gpu::StereoBeliefPropagation::operator ()	gpu/gpu.hpp	/^            void operator()(const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream = Stream::Null());$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream = Stream::Null())
cv::gpu::StereoBeliefPropagation::out	gpu/gpu.hpp	/^            GpuMat out;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
cv::gpu::StereoBeliefPropagation::r	gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
cv::gpu::StereoBeliefPropagation::r2	gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
cv::gpu::StereoBeliefPropagation::u	gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
cv::gpu::StereoBeliefPropagation::u2	gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
cv::gpu::StereoConstantSpaceBP	gpu/gpu.hpp	/^        class CV_EXPORTS StereoConstantSpaceBP$/;"	c	namespace:cv::gpu
cv::gpu::StereoConstantSpaceBP::DEFAULT_ITERS	gpu/gpu.hpp	/^            enum { DEFAULT_ITERS    = 8   };$/;"	e	enum:cv::gpu::StereoConstantSpaceBP::__anon61
cv::gpu::StereoConstantSpaceBP::DEFAULT_LEVELS	gpu/gpu.hpp	/^            enum { DEFAULT_LEVELS   = 4   };$/;"	e	enum:cv::gpu::StereoConstantSpaceBP::__anon62
cv::gpu::StereoConstantSpaceBP::DEFAULT_NDISP	gpu/gpu.hpp	/^            enum { DEFAULT_NDISP    = 128 };$/;"	e	enum:cv::gpu::StereoConstantSpaceBP::__anon60
cv::gpu::StereoConstantSpaceBP::DEFAULT_NR_PLANE	gpu/gpu.hpp	/^            enum { DEFAULT_NR_PLANE = 4   };$/;"	e	enum:cv::gpu::StereoConstantSpaceBP::__anon63
cv::gpu::StereoConstantSpaceBP::StereoConstantSpaceBP	gpu/gpu.hpp	/^            StereoConstantSpaceBP(int ndisp, int iters, int levels, int nr_plane,$/;"	p	class:cv::gpu::StereoConstantSpaceBP	access:public	signature:(int ndisp, int iters, int levels, int nr_plane, float max_data_term, float data_weight, float max_disc_term, float disc_single_jump, int min_disp_th = 0, int msg_type = CV_32F)
cv::gpu::StereoConstantSpaceBP::StereoConstantSpaceBP	gpu/gpu.hpp	/^            explicit StereoConstantSpaceBP(int ndisp    = DEFAULT_NDISP,$/;"	p	class:cv::gpu::StereoConstantSpaceBP	access:public	signature:(int ndisp = DEFAULT_NDISP, int iters = DEFAULT_ITERS, int levels = DEFAULT_LEVELS, int nr_plane = DEFAULT_NR_PLANE, int msg_type = CV_32F)
cv::gpu::StereoConstantSpaceBP::d	gpu/gpu.hpp	/^            GpuMat u[2], d[2], l[2], r[2];$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
cv::gpu::StereoConstantSpaceBP::data_cost	gpu/gpu.hpp	/^            GpuMat data_cost;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
cv::gpu::StereoConstantSpaceBP::data_cost_selected	gpu/gpu.hpp	/^            GpuMat data_cost_selected;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
cv::gpu::StereoConstantSpaceBP::data_weight	gpu/gpu.hpp	/^            float data_weight;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
cv::gpu::StereoConstantSpaceBP::disc_single_jump	gpu/gpu.hpp	/^            float disc_single_jump;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
cv::gpu::StereoConstantSpaceBP::disp_selected_pyr	gpu/gpu.hpp	/^            GpuMat disp_selected_pyr[2];$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
cv::gpu::StereoConstantSpaceBP::estimateRecommendedParams	gpu/gpu.hpp	/^            static void estimateRecommendedParams(int width, int height, int& ndisp, int& iters, int& levels, int& nr_plane);$/;"	p	class:cv::gpu::StereoConstantSpaceBP	access:public	signature:(int width, int height, int& ndisp, int& iters, int& levels, int& nr_plane)
cv::gpu::StereoConstantSpaceBP::iters	gpu/gpu.hpp	/^            int iters;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
cv::gpu::StereoConstantSpaceBP::l	gpu/gpu.hpp	/^            GpuMat u[2], d[2], l[2], r[2];$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
cv::gpu::StereoConstantSpaceBP::levels	gpu/gpu.hpp	/^            int levels;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
cv::gpu::StereoConstantSpaceBP::max_data_term	gpu/gpu.hpp	/^            float max_data_term;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
cv::gpu::StereoConstantSpaceBP::max_disc_term	gpu/gpu.hpp	/^            float max_disc_term;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
cv::gpu::StereoConstantSpaceBP::min_disp_th	gpu/gpu.hpp	/^            int min_disp_th;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
cv::gpu::StereoConstantSpaceBP::msg_type	gpu/gpu.hpp	/^            int msg_type;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
cv::gpu::StereoConstantSpaceBP::ndisp	gpu/gpu.hpp	/^            int ndisp;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
cv::gpu::StereoConstantSpaceBP::nr_plane	gpu/gpu.hpp	/^            int nr_plane;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
cv::gpu::StereoConstantSpaceBP::operator ()	gpu/gpu.hpp	/^            void operator()(const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream = Stream::Null());$/;"	p	class:cv::gpu::StereoConstantSpaceBP	access:public	signature:(const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream = Stream::Null())
cv::gpu::StereoConstantSpaceBP::out	gpu/gpu.hpp	/^            GpuMat out;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
cv::gpu::StereoConstantSpaceBP::r	gpu/gpu.hpp	/^            GpuMat u[2], d[2], l[2], r[2];$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
cv::gpu::StereoConstantSpaceBP::temp	gpu/gpu.hpp	/^            GpuMat temp;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
cv::gpu::StereoConstantSpaceBP::u	gpu/gpu.hpp	/^            GpuMat u[2], d[2], l[2], r[2];$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
cv::gpu::StereoConstantSpaceBP::use_local_init_data_cost	gpu/gpu.hpp	/^            bool use_local_init_data_cost;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
cv::gpu::Stream	gpu/gpu.hpp	/^        class CV_EXPORTS Stream$/;"	c	namespace:cv::gpu
cv::gpu::Stream::Null	gpu/gpu.hpp	/^            static Stream& Null();$/;"	p	class:cv::gpu::Stream	access:public	signature:()
cv::gpu::Stream::Stream	gpu/gpu.hpp	/^            Stream();$/;"	p	class:cv::gpu::Stream	access:public	signature:()
cv::gpu::Stream::Stream	gpu/gpu.hpp	/^            Stream(const Stream&);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const Stream&)
cv::gpu::Stream::Stream	gpu/gpu.hpp	/^            explicit Stream(Impl* impl);$/;"	p	class:cv::gpu::Stream	access:private	signature:(Impl* impl)
cv::gpu::Stream::create	gpu/gpu.hpp	/^            void create();$/;"	p	class:cv::gpu::Stream	access:private	signature:()
cv::gpu::Stream::enqueueConvert	gpu/gpu.hpp	/^            void enqueueConvert(const GpuMat& src, GpuMat& dst, int type, double a = 1, double b = 0);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const GpuMat& src, GpuMat& dst, int type, double a = 1, double b = 0)
cv::gpu::Stream::enqueueCopy	gpu/gpu.hpp	/^            void enqueueCopy(const GpuMat& src, GpuMat& dst);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const GpuMat& src, GpuMat& dst)
cv::gpu::Stream::enqueueDownload	gpu/gpu.hpp	/^            void enqueueDownload(const GpuMat& src, CudaMem& dst);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const GpuMat& src, CudaMem& dst)
cv::gpu::Stream::enqueueDownload	gpu/gpu.hpp	/^            void enqueueDownload(const GpuMat& src, Mat& dst);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const GpuMat& src, Mat& dst)
cv::gpu::Stream::enqueueMemSet	gpu/gpu.hpp	/^            void enqueueMemSet(GpuMat& src, Scalar val);$/;"	p	class:cv::gpu::Stream	access:public	signature:(GpuMat& src, Scalar val)
cv::gpu::Stream::enqueueMemSet	gpu/gpu.hpp	/^            void enqueueMemSet(GpuMat& src, Scalar val, const GpuMat& mask);$/;"	p	class:cv::gpu::Stream	access:public	signature:(GpuMat& src, Scalar val, const GpuMat& mask)
cv::gpu::Stream::enqueueUpload	gpu/gpu.hpp	/^            void enqueueUpload(const CudaMem& src, GpuMat& dst);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const CudaMem& src, GpuMat& dst)
cv::gpu::Stream::enqueueUpload	gpu/gpu.hpp	/^            void enqueueUpload(const Mat& src, GpuMat& dst);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const Mat& src, GpuMat& dst)
cv::gpu::Stream::impl	gpu/gpu.hpp	/^            Impl *impl;$/;"	m	class:cv::gpu::Stream	access:private
cv::gpu::Stream::operator =	gpu/gpu.hpp	/^            Stream& operator=(const Stream&);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const Stream&)
cv::gpu::Stream::operator bool	gpu/gpu.hpp	/^            operator bool() const;$/;"	p	class:cv::gpu::Stream	access:public	signature:() const
cv::gpu::Stream::queryIfComplete	gpu/gpu.hpp	/^            bool queryIfComplete();$/;"	p	class:cv::gpu::Stream	access:public	signature:()
cv::gpu::Stream::release	gpu/gpu.hpp	/^            void release();$/;"	p	class:cv::gpu::Stream	access:private	signature:()
cv::gpu::Stream::waitForCompletion	gpu/gpu.hpp	/^            void waitForCompletion();$/;"	p	class:cv::gpu::Stream	access:public	signature:()
cv::gpu::Stream::~Stream	gpu/gpu.hpp	/^            ~Stream();$/;"	p	class:cv::gpu::Stream	access:public	signature:()
cv::gpu::StreamAccessor	gpu/stream_accessor.hpp	/^        struct StreamAccessor$/;"	s	namespace:cv::gpu
cv::gpu::StreamAccessor::getStream	gpu/stream_accessor.hpp	/^            CV_EXPORTS static cudaStream_t getStream(const Stream& stream);$/;"	p	struct:cv::gpu::StreamAccessor	access:public	signature:(const Stream& stream)
cv::gpu::TargetArchs	gpu/gpu.hpp	/^        class CV_EXPORTS TargetArchs$/;"	c	namespace:cv::gpu
cv::gpu::TargetArchs::TargetArchs	gpu/gpu.hpp	/^            TargetArchs();$/;"	p	class:cv::gpu::TargetArchs	access:private	signature:()
cv::gpu::TargetArchs::builtWith	gpu/gpu.hpp	/^            static bool builtWith(FeatureSet feature_set);$/;"	p	class:cv::gpu::TargetArchs	access:public	signature:(FeatureSet feature_set)
cv::gpu::TargetArchs::has	gpu/gpu.hpp	/^            static bool has(int major, int minor);$/;"	p	class:cv::gpu::TargetArchs	access:public	signature:(int major, int minor)
cv::gpu::TargetArchs::hasBin	gpu/gpu.hpp	/^            static bool hasBin(int major, int minor);$/;"	p	class:cv::gpu::TargetArchs	access:public	signature:(int major, int minor)
cv::gpu::TargetArchs::hasEqualOrGreater	gpu/gpu.hpp	/^            static bool hasEqualOrGreater(int major, int minor);$/;"	p	class:cv::gpu::TargetArchs	access:public	signature:(int major, int minor)
cv::gpu::TargetArchs::hasEqualOrGreaterBin	gpu/gpu.hpp	/^            static bool hasEqualOrGreaterBin(int major, int minor);$/;"	p	class:cv::gpu::TargetArchs	access:public	signature:(int major, int minor)
cv::gpu::TargetArchs::hasEqualOrGreaterPtx	gpu/gpu.hpp	/^            static bool hasEqualOrGreaterPtx(int major, int minor);$/;"	p	class:cv::gpu::TargetArchs	access:public	signature:(int major, int minor)
cv::gpu::TargetArchs::hasEqualOrLessPtx	gpu/gpu.hpp	/^            static bool hasEqualOrLessPtx(int major, int minor);$/;"	p	class:cv::gpu::TargetArchs	access:public	signature:(int major, int minor)
cv::gpu::TargetArchs::hasPtx	gpu/gpu.hpp	/^            static bool hasPtx(int major, int minor);$/;"	p	class:cv::gpu::TargetArchs	access:public	signature:(int major, int minor)
cv::gpu::absSum	gpu/gpu.hpp	/^        CV_EXPORTS Scalar absSum(const GpuMat& src);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src)
cv::gpu::absSum	gpu/gpu.hpp	/^        CV_EXPORTS Scalar absSum(const GpuMat& src, GpuMat& buf);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& buf)
cv::gpu::absdiff	gpu/gpu.hpp	/^        CV_EXPORTS void absdiff(const GpuMat& a, const GpuMat& b, GpuMat& c, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c, Stream& stream = Stream::Null())
cv::gpu::absdiff	gpu/gpu.hpp	/^        CV_EXPORTS void absdiff(const GpuMat& a, const Scalar& s, GpuMat& c, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const Scalar& s, GpuMat& c, Stream& stream = Stream::Null())
cv::gpu::add	gpu/gpu.hpp	/^        CV_EXPORTS void add(const GpuMat& a, const GpuMat& b, GpuMat& c, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c, Stream& stream = Stream::Null())
cv::gpu::add	gpu/gpu.hpp	/^        CV_EXPORTS void add(const GpuMat& a, const Scalar& sc, GpuMat& c, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const Scalar& sc, GpuMat& c, Stream& stream = Stream::Null())
cv::gpu::bitwise_and	gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_and(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat(), Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat(), Stream& stream = Stream::Null())
cv::gpu::bitwise_not	gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_not(const GpuMat& src, GpuMat& dst, const GpuMat& mask=GpuMat(), Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, const GpuMat& mask=GpuMat(), Stream& stream = Stream::Null())
cv::gpu::bitwise_or	gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_or(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat(), Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat(), Stream& stream = Stream::Null())
cv::gpu::bitwise_xor	gpu/gpu.hpp	/^        CV_EXPORTS void bitwise_xor(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat(), Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, const GpuMat& mask=GpuMat(), Stream& stream = Stream::Null())
cv::gpu::blendLinear	gpu/gpu.hpp	/^        CV_EXPORTS void blendLinear(const GpuMat& img1, const GpuMat& img2, const GpuMat& weights1, const GpuMat& weights2, $/;"	p	namespace:cv::gpu	signature:(const GpuMat& img1, const GpuMat& img2, const GpuMat& weights1, const GpuMat& weights2, GpuMat& result, Stream& stream = Stream::Null())
cv::gpu::blur	gpu/gpu.hpp	/^        static inline void blur(const GpuMat& src, GpuMat& dst, Size ksize, Point anchor = Point(-1,-1), Stream& stream = Stream::Null()) { boxFilter(src, dst, -1, ksize, anchor, stream); }$/;"	f	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Size ksize, Point anchor = Point(-1,-1), Stream& stream = Stream::Null())
cv::gpu::boxFilter	gpu/gpu.hpp	/^        CV_EXPORTS void boxFilter(const GpuMat& src, GpuMat& dst, int ddepth, Size ksize, Point anchor = Point(-1,-1), Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, Size ksize, Point anchor = Point(-1,-1), Stream& stream = Stream::Null())
cv::gpu::buildWarpCylindricalMaps	gpu/gpu.hpp	/^        CV_EXPORTS void buildWarpCylindricalMaps(Size src_size, Rect dst_roi, const Mat& R, double f, double s,$/;"	p	namespace:cv::gpu	signature:(Size src_size, Rect dst_roi, const Mat& R, double f, double s, GpuMat& map_x, GpuMat& map_y, Stream& stream = Stream::Null())
cv::gpu::buildWarpPlaneMaps	gpu/gpu.hpp	/^        CV_EXPORTS void buildWarpPlaneMaps(Size src_size, Rect dst_roi, const Mat& R, double f, double s, double dist,$/;"	p	namespace:cv::gpu	signature:(Size src_size, Rect dst_roi, const Mat& R, double f, double s, double dist, GpuMat& map_x, GpuMat& map_y, Stream& stream = Stream::Null())
cv::gpu::buildWarpSphericalMaps	gpu/gpu.hpp	/^        CV_EXPORTS void buildWarpSphericalMaps(Size src_size, Rect dst_roi, const Mat& R, double f, double s,$/;"	p	namespace:cv::gpu	signature:(Size src_size, Rect dst_roi, const Mat& R, double f, double s, GpuMat& map_x, GpuMat& map_y, Stream& stream = Stream::Null())
cv::gpu::calcHist	gpu/gpu.hpp	/^        CV_EXPORTS void calcHist(const GpuMat& src, GpuMat& hist, GpuMat& buf, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& hist, GpuMat& buf, Stream& stream = Stream::Null())
cv::gpu::calcHist	gpu/gpu.hpp	/^        CV_EXPORTS void calcHist(const GpuMat& src, GpuMat& hist, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& hist, Stream& stream = Stream::Null())
cv::gpu::cartToPolar	gpu/gpu.hpp	/^        CV_EXPORTS void cartToPolar(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, GpuMat& angle, bool angleInDegrees = false, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, GpuMat& angle, bool angleInDegrees = false, Stream& stream = Stream::Null())
cv::gpu::columnSum	gpu/gpu.hpp	/^        CV_EXPORTS void columnSum(const GpuMat& src, GpuMat& sum);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& sum)
cv::gpu::compare	gpu/gpu.hpp	/^        CV_EXPORTS void compare(const GpuMat& a, const GpuMat& b, GpuMat& c, int cmpop, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c, int cmpop, Stream& stream = Stream::Null())
cv::gpu::convolve	gpu/gpu.hpp	/^        CV_EXPORTS void convolve(const GpuMat& image, const GpuMat& templ, GpuMat& result, $/;"	p	namespace:cv::gpu	signature:(const GpuMat& image, const GpuMat& templ, GpuMat& result, bool ccorr, ConvolveBuf& buf)
cv::gpu::convolve	gpu/gpu.hpp	/^        CV_EXPORTS void convolve(const GpuMat& image, const GpuMat& templ, GpuMat& result, $/;"	p	namespace:cv::gpu	signature:(const GpuMat& image, const GpuMat& templ, GpuMat& result, bool ccorr=false)
cv::gpu::copyMakeBorder	gpu/gpu.hpp	/^        CV_EXPORTS void copyMakeBorder(const GpuMat& src, GpuMat& dst, int top, int bottom, int left, int right, const Scalar& value = Scalar(), Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int top, int bottom, int left, int right, const Scalar& value = Scalar(), Stream& stream = Stream::Null())
cv::gpu::cornerHarris	gpu/gpu.hpp	/^        CV_EXPORTS void cornerHarris(const GpuMat& src, GpuMat& dst, GpuMat& Dx, GpuMat& Dy, int blockSize, int ksize, double k, int borderType=BORDER_REFLECT101);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, GpuMat& Dx, GpuMat& Dy, int blockSize, int ksize, double k, int borderType=BORDER_REFLECT101)
cv::gpu::cornerHarris	gpu/gpu.hpp	/^        CV_EXPORTS void cornerHarris(const GpuMat& src, GpuMat& dst, int blockSize, int ksize, double k, int borderType=BORDER_REFLECT101);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int blockSize, int ksize, double k, int borderType=BORDER_REFLECT101)
cv::gpu::cornerMinEigenVal	gpu/gpu.hpp	/^        CV_EXPORTS void cornerMinEigenVal(const GpuMat& src, GpuMat& dst, GpuMat& Dx, GpuMat& Dy, int blockSize, int ksize, int borderType=BORDER_REFLECT101);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, GpuMat& Dx, GpuMat& Dy, int blockSize, int ksize, int borderType=BORDER_REFLECT101)
cv::gpu::cornerMinEigenVal	gpu/gpu.hpp	/^        CV_EXPORTS void cornerMinEigenVal(const GpuMat& src, GpuMat& dst, int blockSize, int ksize, int borderType=BORDER_REFLECT101);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int blockSize, int ksize, int borderType=BORDER_REFLECT101)
cv::gpu::countNonZero	gpu/gpu.hpp	/^        CV_EXPORTS int countNonZero(const GpuMat& src);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src)
cv::gpu::countNonZero	gpu/gpu.hpp	/^        CV_EXPORTS int countNonZero(const GpuMat& src, GpuMat& buf);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& buf)
cv::gpu::createBoxFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createBoxFilter_GPU(int srcType, int dstType, const Size& ksize,$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Size& ksize, const Point& anchor = Point(-1,-1))
cv::gpu::createContinuous	gpu/gpumat.hpp	/^    CV_EXPORTS GpuMat createContinuous(Size size, int type);$/;"	p	namespace:cv::gpu	signature:(Size size, int type)
cv::gpu::createContinuous	gpu/gpumat.hpp	/^    CV_EXPORTS GpuMat createContinuous(int rows, int cols, int type);$/;"	p	namespace:cv::gpu	signature:(int rows, int cols, int type)
cv::gpu::createContinuous	gpu/gpumat.hpp	/^    CV_EXPORTS void createContinuous(Size size, int type, GpuMat& m);$/;"	p	namespace:cv::gpu	signature:(Size size, int type, GpuMat& m)
cv::gpu::createContinuous	gpu/gpumat.hpp	/^    CV_EXPORTS void createContinuous(int rows, int cols, int type, GpuMat& m);$/;"	p	namespace:cv::gpu	signature:(int rows, int cols, int type, GpuMat& m)
cv::gpu::createDerivFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createDerivFilter_GPU(int srcType, int dstType, int dx, int dy, int ksize,$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, int dx, int dy, int ksize, int rowBorderType = BORDER_DEFAULT, int columnBorderType = -1)
cv::gpu::createFilter2D_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createFilter2D_GPU(const Ptr<BaseFilter_GPU>& filter2D, int srcType, int dstType);$/;"	p	namespace:cv::gpu	signature:(const Ptr<BaseFilter_GPU>& filter2D, int srcType, int dstType)
cv::gpu::createGaussianFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createGaussianFilter_GPU(int type, Size ksize, double sigma1, double sigma2 = 0,$/;"	p	namespace:cv::gpu	signature:(int type, Size ksize, double sigma1, double sigma2 = 0, int rowBorderType = BORDER_DEFAULT, int columnBorderType = -1)
cv::gpu::createLinearFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createLinearFilter_GPU(int srcType, int dstType, const Mat& kernel,$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Mat& kernel, const Point& anchor = Point(-1,-1))
cv::gpu::createMorphologyFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createMorphologyFilter_GPU(int op, int type, const Mat& kernel,$/;"	p	namespace:cv::gpu	signature:(int op, int type, const Mat& kernel, const Point& anchor = Point(-1,-1), int iterations = 1)
cv::gpu::createSeparableFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createSeparableFilter_GPU(const Ptr<BaseRowFilter_GPU>& rowFilter,$/;"	p	namespace:cv::gpu	signature:(const Ptr<BaseRowFilter_GPU>& rowFilter, const Ptr<BaseColumnFilter_GPU>& columnFilter, int srcType, int bufType, int dstType)
cv::gpu::createSeparableLinearFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<FilterEngine_GPU> createSeparableLinearFilter_GPU(int srcType, int dstType, const Mat& rowKernel,$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Mat& rowKernel, const Mat& columnKernel, const Point& anchor = Point(-1,-1), int rowBorderType = BORDER_DEFAULT, int columnBorderType = -1)
cv::gpu::cvtColor	gpu/gpu.hpp	/^        CV_EXPORTS void cvtColor(const GpuMat& src, GpuMat& dst, int code, int dcn = 0, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int code, int dcn = 0, Stream& stream = Stream::Null())
cv::gpu::dft	gpu/gpu.hpp	/^        CV_EXPORTS void dft(const GpuMat& src, GpuMat& dst, Size dft_size, int flags=0);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Size dft_size, int flags=0)
cv::gpu::dilate	gpu/gpu.hpp	/^        CV_EXPORTS void dilate( const GpuMat& src, GpuMat& dst, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:( const GpuMat& src, GpuMat& dst, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1, Stream& stream = Stream::Null())
cv::gpu::divide	gpu/gpu.hpp	/^        CV_EXPORTS void divide(const GpuMat& a, const GpuMat& b, GpuMat& c, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c, Stream& stream = Stream::Null())
cv::gpu::divide	gpu/gpu.hpp	/^        CV_EXPORTS void divide(const GpuMat& a, const Scalar& sc, GpuMat& c, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const Scalar& sc, GpuMat& c, Stream& stream = Stream::Null())
cv::gpu::downsample	gpu/gpu.hpp	/^        CV_EXPORTS void downsample(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null())
cv::gpu::drawColorDisp	gpu/gpu.hpp	/^        CV_EXPORTS void drawColorDisp(const GpuMat& src_disp, GpuMat& dst_disp, int ndisp, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src_disp, GpuMat& dst_disp, int ndisp, Stream& stream = Stream::Null())
cv::gpu::ensureSizeIsEnough	gpu/gpumat.hpp	/^    CV_EXPORTS void ensureSizeIsEnough(Size size, int type, GpuMat& m);$/;"	p	namespace:cv::gpu	signature:(Size size, int type, GpuMat& m)
cv::gpu::ensureSizeIsEnough	gpu/gpumat.hpp	/^    CV_EXPORTS void ensureSizeIsEnough(int rows, int cols, int type, GpuMat& m);$/;"	p	namespace:cv::gpu	signature:(int rows, int cols, int type, GpuMat& m)
cv::gpu::equalizeHist	gpu/gpu.hpp	/^        CV_EXPORTS void equalizeHist(const GpuMat& src, GpuMat& dst, GpuMat& hist, GpuMat& buf, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, GpuMat& hist, GpuMat& buf, Stream& stream = Stream::Null())
cv::gpu::equalizeHist	gpu/gpu.hpp	/^        CV_EXPORTS void equalizeHist(const GpuMat& src, GpuMat& dst, GpuMat& hist, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, GpuMat& hist, Stream& stream = Stream::Null())
cv::gpu::equalizeHist	gpu/gpu.hpp	/^        CV_EXPORTS void equalizeHist(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null())
cv::gpu::erode	gpu/gpu.hpp	/^        CV_EXPORTS void erode( const GpuMat& src, GpuMat& dst, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:( const GpuMat& src, GpuMat& dst, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1, Stream& stream = Stream::Null())
cv::gpu::error	gpu/gpu.hpp	/^        CV_EXPORTS void error(const char *error_string, const char *file, const int line, const char *func);$/;"	p	namespace:cv::gpu	signature:(const char *error_string, const char *file, const int line, const char *func)
cv::gpu::evenLevels	gpu/gpu.hpp	/^        CV_EXPORTS void evenLevels(GpuMat& levels, int nLevels, int lowerLevel, int upperLevel);$/;"	p	namespace:cv::gpu	signature:(GpuMat& levels, int nLevels, int lowerLevel, int upperLevel)
cv::gpu::exp	gpu/gpu.hpp	/^        CV_EXPORTS void exp(const GpuMat& a, GpuMat& b, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, GpuMat& b, Stream& stream = Stream::Null())
cv::gpu::filter2D	gpu/gpu.hpp	/^        CV_EXPORTS void filter2D(const GpuMat& src, GpuMat& dst, int ddepth, const Mat& kernel, Point anchor=Point(-1,-1), Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, const Mat& kernel, Point anchor=Point(-1,-1), Stream& stream = Stream::Null())
cv::gpu::flip	gpu/gpu.hpp	/^        CV_EXPORTS void flip(const GpuMat& a, GpuMat& b, int flipCode, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, GpuMat& b, int flipCode, Stream& stream = Stream::Null())
cv::gpu::getBoxFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseFilter_GPU> getBoxFilter_GPU(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1, -1));$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1, -1))
cv::gpu::getColumnSumFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseColumnFilter_GPU> getColumnSumFilter_GPU(int sumType, int dstType, int ksize, int anchor = -1);$/;"	p	namespace:cv::gpu	signature:(int sumType, int dstType, int ksize, int anchor = -1)
cv::gpu::getCudaEnabledDeviceCount	gpu/gpu.hpp	/^        CV_EXPORTS int getCudaEnabledDeviceCount();$/;"	p	namespace:cv::gpu	signature:()
cv::gpu::getDevice	gpu/gpu.hpp	/^        CV_EXPORTS int getDevice();$/;"	p	namespace:cv::gpu	signature:()
cv::gpu::getLinearColumnFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseColumnFilter_GPU> getLinearColumnFilter_GPU(int bufType, int dstType, const Mat& columnKernel,$/;"	p	namespace:cv::gpu	signature:(int bufType, int dstType, const Mat& columnKernel, int anchor = -1, int borderType = BORDER_CONSTANT)
cv::gpu::getLinearFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseFilter_GPU> getLinearFilter_GPU(int srcType, int dstType, const Mat& kernel, const Size& ksize,$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Mat& kernel, const Size& ksize, Point anchor = Point(-1, -1))
cv::gpu::getLinearRowFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseRowFilter_GPU> getLinearRowFilter_GPU(int srcType, int bufType, const Mat& rowKernel,$/;"	p	namespace:cv::gpu	signature:(int srcType, int bufType, const Mat& rowKernel, int anchor = -1, int borderType = BORDER_CONSTANT)
cv::gpu::getMaxFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseFilter_GPU> getMaxFilter_GPU(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1,-1));$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1,-1))
cv::gpu::getMinFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseFilter_GPU> getMinFilter_GPU(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1,-1));$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1,-1))
cv::gpu::getMorphologyFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseFilter_GPU> getMorphologyFilter_GPU(int op, int type, const Mat& kernel, const Size& ksize,$/;"	p	namespace:cv::gpu	signature:(int op, int type, const Mat& kernel, const Size& ksize, Point anchor=Point(-1,-1))
cv::gpu::getRowSumFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseRowFilter_GPU> getRowSumFilter_GPU(int srcType, int sumType, int ksize, int anchor = -1);$/;"	p	namespace:cv::gpu	signature:(int srcType, int sumType, int ksize, int anchor = -1)
cv::gpu::graphcut	gpu/gpu.hpp	/^        CV_EXPORTS void graphcut(GpuMat& terminals, GpuMat& leftTransp, GpuMat& rightTransp, GpuMat& top, GpuMat& bottom, GpuMat& labels, GpuMat& buf, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(GpuMat& terminals, GpuMat& leftTransp, GpuMat& rightTransp, GpuMat& top, GpuMat& bottom, GpuMat& labels, GpuMat& buf, Stream& stream = Stream::Null())
cv::gpu::histEven	gpu/gpu.hpp	/^        CV_EXPORTS void histEven(const GpuMat& src, GpuMat hist[4], GpuMat& buf, int histSize[4], int lowerLevel[4], int upperLevel[4], Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat hist[4], GpuMat& buf, int histSize[4], int lowerLevel[4], int upperLevel[4], Stream& stream = Stream::Null())
cv::gpu::histEven	gpu/gpu.hpp	/^        CV_EXPORTS void histEven(const GpuMat& src, GpuMat hist[4], int histSize[4], int lowerLevel[4], int upperLevel[4], Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat hist[4], int histSize[4], int lowerLevel[4], int upperLevel[4], Stream& stream = Stream::Null())
cv::gpu::histEven	gpu/gpu.hpp	/^        CV_EXPORTS void histEven(const GpuMat& src, GpuMat& hist, GpuMat& buf, int histSize, int lowerLevel, int upperLevel, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& hist, GpuMat& buf, int histSize, int lowerLevel, int upperLevel, Stream& stream = Stream::Null())
cv::gpu::histEven	gpu/gpu.hpp	/^        CV_EXPORTS void histEven(const GpuMat& src, GpuMat& hist, int histSize, int lowerLevel, int upperLevel, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& hist, int histSize, int lowerLevel, int upperLevel, Stream& stream = Stream::Null())
cv::gpu::histRange	gpu/gpu.hpp	/^        CV_EXPORTS void histRange(const GpuMat& src, GpuMat hist[4], const GpuMat levels[4], GpuMat& buf, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat hist[4], const GpuMat levels[4], GpuMat& buf, Stream& stream = Stream::Null())
cv::gpu::histRange	gpu/gpu.hpp	/^        CV_EXPORTS void histRange(const GpuMat& src, GpuMat hist[4], const GpuMat levels[4], Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat hist[4], const GpuMat levels[4], Stream& stream = Stream::Null())
cv::gpu::histRange	gpu/gpu.hpp	/^        CV_EXPORTS void histRange(const GpuMat& src, GpuMat& hist, const GpuMat& levels, GpuMat& buf, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& hist, const GpuMat& levels, GpuMat& buf, Stream& stream = Stream::Null())
cv::gpu::histRange	gpu/gpu.hpp	/^        CV_EXPORTS void histRange(const GpuMat& src, GpuMat& hist, const GpuMat& levels, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& hist, const GpuMat& levels, Stream& stream = Stream::Null())
cv::gpu::integral	gpu/gpu.hpp	/^        CV_EXPORTS void integral(const GpuMat& src, GpuMat& sum, GpuMat& sqsum, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& sum, GpuMat& sqsum, Stream& stream = Stream::Null())
cv::gpu::integral	gpu/gpu.hpp	/^        CV_EXPORTS void integral(const GpuMat& src, GpuMat& sum, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& sum, Stream& stream = Stream::Null())
cv::gpu::integralBuffered	gpu/gpu.hpp	/^        CV_EXPORTS void integralBuffered(const GpuMat& src, GpuMat& sum, GpuMat& buffer, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& sum, GpuMat& buffer, Stream& stream = Stream::Null())
cv::gpu::log	gpu/gpu.hpp	/^        CV_EXPORTS void log(const GpuMat& a, GpuMat& b, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, GpuMat& b, Stream& stream = Stream::Null())
cv::gpu::magnitude	gpu/gpu.hpp	/^        CV_EXPORTS void magnitude(const GpuMat& x, GpuMat& magnitude, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, GpuMat& magnitude, Stream& stream = Stream::Null())
cv::gpu::magnitude	gpu/gpu.hpp	/^        CV_EXPORTS void magnitude(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, Stream& stream = Stream::Null())
cv::gpu::magnitudeSqr	gpu/gpu.hpp	/^        CV_EXPORTS void magnitudeSqr(const GpuMat& x, GpuMat& magnitude, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, GpuMat& magnitude, Stream& stream = Stream::Null())
cv::gpu::magnitudeSqr	gpu/gpu.hpp	/^        CV_EXPORTS void magnitudeSqr(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, Stream& stream = Stream::Null())
cv::gpu::matchTemplate	gpu/gpu.hpp	/^        CV_EXPORTS void matchTemplate(const GpuMat& image, const GpuMat& templ, GpuMat& result, int method);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& image, const GpuMat& templ, GpuMat& result, int method)
cv::gpu::max	gpu/gpu.hpp	/^        CV_EXPORTS void max(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, Stream& stream = Stream::Null())
cv::gpu::max	gpu/gpu.hpp	/^        CV_EXPORTS void max(const GpuMat& src1, double src2, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, double src2, GpuMat& dst, Stream& stream = Stream::Null())
cv::gpu::meanShiftFiltering	gpu/gpu.hpp	/^        CV_EXPORTS void meanShiftFiltering(const GpuMat& src, GpuMat& dst, int sp, int sr,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int sp, int sr, TermCriteria criteria = TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 5, 1))
cv::gpu::meanShiftProc	gpu/gpu.hpp	/^        CV_EXPORTS void meanShiftProc(const GpuMat& src, GpuMat& dstr, GpuMat& dstsp, int sp, int sr,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dstr, GpuMat& dstsp, int sp, int sr, TermCriteria criteria = TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 5, 1))
cv::gpu::meanShiftSegmentation	gpu/gpu.hpp	/^        CV_EXPORTS void meanShiftSegmentation(const GpuMat& src, Mat& dst, int sp, int sr, int minsize,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, Mat& dst, int sp, int sr, int minsize, TermCriteria criteria = TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 5, 1))
cv::gpu::meanStdDev	gpu/gpu.hpp	/^        CV_EXPORTS void meanStdDev(const GpuMat& mtx, Scalar& mean, Scalar& stddev);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& mtx, Scalar& mean, Scalar& stddev)
cv::gpu::merge	gpu/gpu.hpp	/^        CV_EXPORTS void merge(const GpuMat* src, size_t n, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat* src, size_t n, GpuMat& dst, Stream& stream = Stream::Null())
cv::gpu::merge	gpu/gpu.hpp	/^        CV_EXPORTS void merge(const vector<GpuMat>& src, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const vector<GpuMat>& src, GpuMat& dst, Stream& stream = Stream::Null())
cv::gpu::min	gpu/gpu.hpp	/^        CV_EXPORTS void min(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, Stream& stream = Stream::Null())
cv::gpu::min	gpu/gpu.hpp	/^        CV_EXPORTS void min(const GpuMat& src1, double src2, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, double src2, GpuMat& dst, Stream& stream = Stream::Null())
cv::gpu::minMax	gpu/gpu.hpp	/^        CV_EXPORTS void minMax(const GpuMat& src, double* minVal, double* maxVal, const GpuMat& mask, GpuMat& buf);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, double* minVal, double* maxVal, const GpuMat& mask, GpuMat& buf)
cv::gpu::minMax	gpu/gpu.hpp	/^        CV_EXPORTS void minMax(const GpuMat& src, double* minVal, double* maxVal=0, const GpuMat& mask=GpuMat());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, double* minVal, double* maxVal=0, const GpuMat& mask=GpuMat())
cv::gpu::minMaxLoc	gpu/gpu.hpp	/^        CV_EXPORTS void minMaxLoc(const GpuMat& src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, const GpuMat& mask, GpuMat& valbuf, GpuMat& locbuf)
cv::gpu::minMaxLoc	gpu/gpu.hpp	/^        CV_EXPORTS void minMaxLoc(const GpuMat& src, double* minVal, double* maxVal=0, Point* minLoc=0, Point* maxLoc=0,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, double* minVal, double* maxVal=0, Point* minLoc=0, Point* maxLoc=0, const GpuMat& mask=GpuMat())
cv::gpu::morphologyEx	gpu/gpu.hpp	/^        CV_EXPORTS void morphologyEx( const GpuMat& src, GpuMat& dst, int op, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:( const GpuMat& src, GpuMat& dst, int op, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1, Stream& stream = Stream::Null())
cv::gpu::mulAndScaleSpectrums	gpu/gpu.hpp	/^        CV_EXPORTS void mulAndScaleSpectrums(const GpuMat& a, const GpuMat& b, GpuMat& c, int flags, $/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c, int flags, float scale, bool conjB=false)
cv::gpu::mulSpectrums	gpu/gpu.hpp	/^        CV_EXPORTS void mulSpectrums(const GpuMat& a, const GpuMat& b, GpuMat& c, int flags, bool conjB=false);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c, int flags, bool conjB=false)
cv::gpu::multiply	gpu/gpu.hpp	/^        CV_EXPORTS void multiply(const GpuMat& a, const GpuMat& b, GpuMat& c, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c, Stream& stream = Stream::Null())
cv::gpu::multiply	gpu/gpu.hpp	/^        CV_EXPORTS void multiply(const GpuMat& a, const Scalar& sc, GpuMat& c, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const Scalar& sc, GpuMat& c, Stream& stream = Stream::Null())
cv::gpu::norm	gpu/gpu.hpp	/^        CV_EXPORTS double norm(const GpuMat& src1, const GpuMat& src2, int normType=NORM_L2);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, int normType=NORM_L2)
cv::gpu::norm	gpu/gpu.hpp	/^        CV_EXPORTS double norm(const GpuMat& src1, int normType, GpuMat& buf);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, int normType, GpuMat& buf)
cv::gpu::norm	gpu/gpu.hpp	/^        CV_EXPORTS double norm(const GpuMat& src1, int normType=NORM_L2);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, int normType=NORM_L2)
cv::gpu::nppError	gpu/gpu.hpp	/^        CV_EXPORTS void nppError( int err, const char *file, const int line, const char *func);$/;"	p	namespace:cv::gpu	signature:( int err, const char *file, const int line, const char *func)
cv::gpu::phase	gpu/gpu.hpp	/^        CV_EXPORTS void phase(const GpuMat& x, const GpuMat& y, GpuMat& angle, bool angleInDegrees = false, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& angle, bool angleInDegrees = false, Stream& stream = Stream::Null())
cv::gpu::polarToCart	gpu/gpu.hpp	/^        CV_EXPORTS void polarToCart(const GpuMat& magnitude, const GpuMat& angle, GpuMat& x, GpuMat& y, bool angleInDegrees = false, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& magnitude, const GpuMat& angle, GpuMat& x, GpuMat& y, bool angleInDegrees = false, Stream& stream = Stream::Null())
cv::gpu::pow	gpu/gpu.hpp	/^        CV_EXPORTS void pow(const GpuMat& src, double power, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, double power, GpuMat& dst, Stream& stream = Stream::Null())
cv::gpu::projectPoints	gpu/gpu.hpp	/^        CV_EXPORTS void projectPoints(const GpuMat& src, const Mat& rvec, const Mat& tvec,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, const Mat& rvec, const Mat& tvec, const Mat& camera_mat, const Mat& dist_coef, GpuMat& dst, Stream& stream = Stream::Null())
cv::gpu::pyrDown	gpu/gpu.hpp	/^        CV_EXPORTS void pyrDown(const GpuMat& src, GpuMat& dst, PyrDownBuf& buf, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, PyrDownBuf& buf, Stream& stream = Stream::Null())
cv::gpu::pyrDown	gpu/gpu.hpp	/^        CV_EXPORTS void pyrDown(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null())
cv::gpu::pyrUp	gpu/gpu.hpp	/^        CV_EXPORTS void pyrUp(const GpuMat& src, GpuMat& dst, PyrUpBuf& buf, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, PyrUpBuf& buf, Stream& stream = Stream::Null())
cv::gpu::pyrUp	gpu/gpu.hpp	/^        CV_EXPORTS void pyrUp(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null())
cv::gpu::rectStdDev	gpu/gpu.hpp	/^        CV_EXPORTS void rectStdDev(const GpuMat& src, const GpuMat& sqr, GpuMat& dst, const Rect& rect, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, const GpuMat& sqr, GpuMat& dst, const Rect& rect, Stream& stream = Stream::Null())
cv::gpu::registerPageLocked	gpu/gpu.hpp	/^        CV_EXPORTS void registerPageLocked(Mat& m);$/;"	p	namespace:cv::gpu	signature:(Mat& m)
cv::gpu::remap	gpu/gpu.hpp	/^        CV_EXPORTS void remap(const GpuMat& src, GpuMat& dst, const GpuMat& xmap, const GpuMat& ymap);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, const GpuMat& xmap, const GpuMat& ymap)
cv::gpu::reprojectImageTo3D	gpu/gpu.hpp	/^        CV_EXPORTS void reprojectImageTo3D(const GpuMat& disp, GpuMat& xyzw, const Mat& Q, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& disp, GpuMat& xyzw, const Mat& Q, Stream& stream = Stream::Null())
cv::gpu::resetDevice	gpu/gpu.hpp	/^        CV_EXPORTS void resetDevice();$/;"	p	namespace:cv::gpu	signature:()
cv::gpu::resize	gpu/gpu.hpp	/^        CV_EXPORTS void resize(const GpuMat& src, GpuMat& dst, Size dsize, double fx=0, double fy=0, int interpolation = INTER_LINEAR, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Size dsize, double fx=0, double fy=0, int interpolation = INTER_LINEAR, Stream& stream = Stream::Null())
cv::gpu::rotate	gpu/gpu.hpp	/^        CV_EXPORTS void rotate(const GpuMat& src, GpuMat& dst, Size dsize, double angle, double xShift = 0, double yShift = 0, int interpolation = INTER_LINEAR, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Size dsize, double angle, double xShift = 0, double yShift = 0, int interpolation = INTER_LINEAR, Stream& stream = Stream::Null())
cv::gpu::sepFilter2D	gpu/gpu.hpp	/^        CV_EXPORTS void sepFilter2D(const GpuMat& src, GpuMat& dst, int ddepth, const Mat& kernelX, const Mat& kernelY,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, const Mat& kernelX, const Mat& kernelY, Point anchor = Point(-1,-1), int rowBorderType = BORDER_DEFAULT, int columnBorderType = -1, Stream& stream = Stream::Null())
cv::gpu::setDevice	gpu/gpu.hpp	/^        CV_EXPORTS void setDevice(int device);$/;"	p	namespace:cv::gpu	signature:(int device)
cv::gpu::solvePnPRansac	gpu/gpu.hpp	/^        CV_EXPORTS void solvePnPRansac(const Mat& object, const Mat& image, const Mat& camera_mat,$/;"	p	namespace:cv::gpu	signature:(const Mat& object, const Mat& image, const Mat& camera_mat, const Mat& dist_coef, Mat& rvec, Mat& tvec, bool use_extrinsic_guess=false, int num_iters=100, float max_dist=8.0, int min_inlier_count=100, vector<int>* inliers=NULL)
cv::gpu::split	gpu/gpu.hpp	/^        CV_EXPORTS void split(const GpuMat& src, GpuMat* dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat* dst, Stream& stream = Stream::Null())
cv::gpu::split	gpu/gpu.hpp	/^        CV_EXPORTS void split(const GpuMat& src, vector<GpuMat>& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, vector<GpuMat>& dst, Stream& stream = Stream::Null())
cv::gpu::sqrIntegral	gpu/gpu.hpp	/^        CV_EXPORTS void sqrIntegral(const GpuMat& src, GpuMat& sqsum, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& sqsum, Stream& stream = Stream::Null())
cv::gpu::sqrSum	gpu/gpu.hpp	/^        CV_EXPORTS Scalar sqrSum(const GpuMat& src);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src)
cv::gpu::sqrSum	gpu/gpu.hpp	/^        CV_EXPORTS Scalar sqrSum(const GpuMat& src, GpuMat& buf);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& buf)
cv::gpu::subtract	gpu/gpu.hpp	/^        CV_EXPORTS void subtract(const GpuMat& a, const GpuMat& b, GpuMat& c, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c, Stream& stream = Stream::Null())
cv::gpu::subtract	gpu/gpu.hpp	/^        CV_EXPORTS void subtract(const GpuMat& a, const Scalar& sc, GpuMat& c, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const Scalar& sc, GpuMat& c, Stream& stream = Stream::Null())
cv::gpu::sum	gpu/gpu.hpp	/^        CV_EXPORTS Scalar sum(const GpuMat& src);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src)
cv::gpu::sum	gpu/gpu.hpp	/^        CV_EXPORTS Scalar sum(const GpuMat& src, GpuMat& buf);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& buf)
cv::gpu::swap	gpu/gpumat.hpp	/^    inline void swap(GpuMat& a, GpuMat& b) { a.swap(b); }$/;"	f	namespace:cv::gpu	signature:(GpuMat& a, GpuMat& b)
cv::gpu::threshold	gpu/gpu.hpp	/^        CV_EXPORTS double threshold(const GpuMat& src, GpuMat& dst, double thresh, double maxval, int type, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, double thresh, double maxval, int type, Stream& stream = Stream::Null())
cv::gpu::transformPoints	gpu/gpu.hpp	/^        CV_EXPORTS void transformPoints(const GpuMat& src, const Mat& rvec, const Mat& tvec,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, const Mat& rvec, const Mat& tvec, GpuMat& dst, Stream& stream = Stream::Null())
cv::gpu::transpose	gpu/gpu.hpp	/^        CV_EXPORTS void transpose(const GpuMat& src1, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, GpuMat& dst, Stream& stream = Stream::Null())
cv::gpu::unregisterPageLocked	gpu/gpu.hpp	/^        CV_EXPORTS void unregisterPageLocked(Mat& m);$/;"	p	namespace:cv::gpu	signature:(Mat& m)
cv::gpu::upsample	gpu/gpu.hpp	/^        CV_EXPORTS void upsample(const GpuMat& src, GpuMat &dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat &dst, Stream& stream = Stream::Null())
cv::gpu::warpAffine	gpu/gpu.hpp	/^        CV_EXPORTS void warpAffine(const GpuMat& src, GpuMat& dst, const Mat& M, Size dsize, int flags = INTER_LINEAR, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, const Mat& M, Size dsize, int flags = INTER_LINEAR, Stream& stream = Stream::Null())
cv::gpu::warpPerspective	gpu/gpu.hpp	/^        CV_EXPORTS void warpPerspective(const GpuMat& src, GpuMat& dst, const Mat& M, Size dsize, int flags = INTER_LINEAR, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, const Mat& M, Size dsize, int flags = INTER_LINEAR, Stream& stream = Stream::Null())
cv::grabCut	imgproc/imgproc.hpp	/^CV_EXPORTS_W void grabCut( InputArray img, InputOutputArray mask, Rect rect, $/;"	p	namespace:cv	signature:( InputArray img, InputOutputArray mask, Rect rect, InputOutputArray bgdModel, InputOutputArray fgdModel, int iterCount, int mode = GC_EVAL )
cv::groupRectangles	objdetect/objdetect.hpp	/^CV_EXPORTS void groupRectangles( vector<Rect>& rectList, int groupThreshold, double eps, vector<int>* weights, vector<double>* levelWeights );$/;"	p	namespace:cv	signature:( vector<Rect>& rectList, int groupThreshold, double eps, vector<int>* weights, vector<double>* levelWeights )
cv::groupRectangles	objdetect/objdetect.hpp	/^CV_EXPORTS void groupRectangles(CV_OUT CV_IN_OUT vector<Rect>& rectList, int groupThreshold, double eps=0.2);$/;"	p	namespace:cv	signature:(CV_OUT CV_IN_OUT vector<Rect>& rectList, int groupThreshold, double eps=0.2)
cv::groupRectangles	objdetect/objdetect.hpp	/^CV_EXPORTS void groupRectangles(vector<Rect>& rectList, vector<int>& rejectLevels, $/;"	p	namespace:cv	signature:(vector<Rect>& rectList, vector<int>& rejectLevels, vector<double>& levelWeights, int groupThreshold, double eps=0.2)
cv::groupRectangles	objdetect/objdetect.hpp	/^CV_EXPORTS_W void groupRectangles(CV_OUT CV_IN_OUT vector<Rect>& rectList, CV_OUT vector<int>& weights, int groupThreshold, double eps=0.2);$/;"	p	namespace:cv	signature:(CV_OUT CV_IN_OUT vector<Rect>& rectList, CV_OUT vector<int>& weights, int groupThreshold, double eps=0.2)
cv::groupRectangles_meanshift	objdetect/objdetect.hpp	/^CV_EXPORTS void groupRectangles_meanshift(vector<Rect>& rectList, vector<double>& foundWeights, vector<double>& foundScales, $/;"	p	namespace:cv	signature:(vector<Rect>& rectList, vector<double>& foundWeights, vector<double>& foundScales, double detectThreshold = 0.0, Size winDetSize = Size(64, 128))
cv::hconcat	core/core.hpp	/^CV_EXPORTS void hconcat(InputArray src1, InputArray src2, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst)
cv::hconcat	core/core.hpp	/^CV_EXPORTS void hconcat(const Mat* src, size_t nsrc, OutputArray dst);$/;"	p	namespace:cv	signature:(const Mat* src, size_t nsrc, OutputArray dst)
cv::hconcat	core/core.hpp	/^CV_EXPORTS_W void hconcat(InputArray src, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst)
cv::idct	core/core.hpp	/^CV_EXPORTS_W void idct(InputArray src, OutputArray dst, int flags=0);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, int flags=0)
cv::idft	core/core.hpp	/^CV_EXPORTS_W void idft(InputArray src, OutputArray dst, int flags=0, int nonzeroRows=0);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, int flags=0, int nonzeroRows=0)
cv::imdecode	highgui/highgui.hpp	/^CV_EXPORTS_W Mat imdecode( InputArray buf, int flags );$/;"	p	namespace:cv	signature:( InputArray buf, int flags )
cv::imencode	highgui/highgui.hpp	/^CV_EXPORTS_W bool imencode( const string& ext, InputArray img,$/;"	p	namespace:cv	signature:( const string& ext, InputArray img, vector<uchar>& buf, const vector<int>& params=vector<int>())
cv::imread	highgui/highgui.hpp	/^CV_EXPORTS_W Mat imread( const string& filename, int flags=1 );$/;"	p	namespace:cv	signature:( const string& filename, int flags=1 )
cv::imshow	highgui/highgui.hpp	/^CV_EXPORTS_W void imshow( const string& winname, InputArray mat );$/;"	p	namespace:cv	signature:( const string& winname, InputArray mat )
cv::imwrite	highgui/highgui.hpp	/^CV_EXPORTS_W bool imwrite( const string& filename, InputArray img,$/;"	p	namespace:cv	signature:( const string& filename, InputArray img, const vector<int>& params=vector<int>())
cv::inRange	core/core.hpp	/^CV_EXPORTS_W void inRange(InputArray src, InputArray lowerb,$/;"	p	namespace:cv	signature:(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst)
cv::initCameraMatrix2D	calib3d/calib3d.hpp	/^CV_EXPORTS_W Mat initCameraMatrix2D( InputArrayOfArrays objectPoints,$/;"	p	namespace:cv	signature:( InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, double aspectRatio=1. )
cv::initUndistortRectifyMap	imgproc/imgproc.hpp	/^CV_EXPORTS_W void initUndistortRectifyMap( InputArray cameraMatrix, InputArray distCoeffs,$/;"	p	namespace:cv	signature:( InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2 )
cv::initWideAngleProjMap	imgproc/imgproc.hpp	/^CV_EXPORTS_W float initWideAngleProjMap( InputArray cameraMatrix, InputArray distCoeffs,$/;"	p	namespace:cv	signature:( InputArray cameraMatrix, InputArray distCoeffs, Size imageSize, int destImageWidth, int m1type, OutputArray map1, OutputArray map2, int projType=PROJ_SPHERICAL_EQRECT, double alpha=0)
cv::inpaint	imgproc/imgproc.hpp	/^CV_EXPORTS_W void inpaint( InputArray src, InputArray inpaintMask,$/;"	p	namespace:cv	signature:( InputArray src, InputArray inpaintMask, OutputArray dst, double inpaintRange, int flags )
cv::insertChannel	core/core.hpp	/^CV_EXPORTS_W void insertChannel(InputArray src, InputOutputArray dst, int coi);$/;"	p	namespace:cv	signature:(InputArray src, InputOutputArray dst, int coi)
cv::insertImageCOI	core/core.hpp	/^CV_EXPORTS void insertImageCOI(InputArray coiimg, CvArr* arr, int coi=-1);  $/;"	p	namespace:cv	signature:(InputArray coiimg, CvArr* arr, int coi=-1)
cv::integral	imgproc/imgproc.hpp	/^CV_EXPORTS_AS(integral2) void integral( InputArray src, OutputArray sum,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray sum, OutputArray sqsum, int sdepth=-1 )
cv::integral	imgproc/imgproc.hpp	/^CV_EXPORTS_AS(integral3) void integral( InputArray src, OutputArray sum,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray sum, OutputArray sqsum, OutputArray tilted, int sdepth=-1 )
cv::integral	imgproc/imgproc.hpp	/^CV_EXPORTS_W void integral( InputArray src, OutputArray sum, int sdepth=-1 );$/;"	p	namespace:cv	signature:( InputArray src, OutputArray sum, int sdepth=-1 )
cv::invert	core/core.hpp	/^CV_EXPORTS_W double invert(InputArray src, OutputArray dst, int flags=DECOMP_LU);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, int flags=DECOMP_LU)
cv::invertAffineTransform	imgproc/imgproc.hpp	/^CV_EXPORTS_W void invertAffineTransform( InputArray M, OutputArray iM );$/;"	p	namespace:cv	signature:( InputArray M, OutputArray iM )
cv::isContourConvex	imgproc/imgproc.hpp	/^CV_EXPORTS_W bool isContourConvex( InputArray contour );$/;"	p	namespace:cv	signature:( InputArray contour )
cv::kmeans	core/core.hpp	/^CV_EXPORTS_W double kmeans( InputArray data, int K, CV_OUT InputOutputArray bestLabels,$/;"	p	namespace:cv	signature:( InputArray data, int K, CV_OUT InputOutputArray bestLabels, TermCriteria criteria, int attempts, int flags, OutputArray centers=noArray() )
cv::line	core/core.hpp	/^CV_EXPORTS_W void line(Mat& img, Point pt1, Point pt2, const Scalar& color,$/;"	p	namespace:cv	signature:(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness=1, int lineType=8, int shift=0)
cv::loadWindowParameters	highgui/highgui.hpp	/^CV_EXPORTS void loadWindowParameters(const string& windowName);$/;"	p	namespace:cv	signature:(const string& windowName)
cv::log	core/core.hpp	/^CV_EXPORTS_W void log(InputArray src, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst)
cv::magnitude	core/core.hpp	/^CV_EXPORTS_W void magnitude(InputArray x, InputArray y, OutputArray magnitude);$/;"	p	namespace:cv	signature:(InputArray x, InputArray y, OutputArray magnitude)
cv::matMulDeriv	calib3d/calib3d.hpp	/^CV_EXPORTS_W void matMulDeriv( InputArray A, InputArray B,$/;"	p	namespace:cv	signature:( InputArray A, InputArray B, OutputArray dABdA, OutputArray dABdB )
cv::matchShapes	imgproc/imgproc.hpp	/^CV_EXPORTS_W double matchShapes( InputArray contour1, InputArray contour2,$/;"	p	namespace:cv	signature:( InputArray contour1, InputArray contour2, int method, double parameter )
cv::matchTemplate	imgproc/imgproc.hpp	/^CV_EXPORTS_W void matchTemplate( InputArray image, InputArray templ,$/;"	p	namespace:cv	signature:( InputArray image, InputArray templ, OutputArray result, int method )
cv::max	core/core.hpp	/^CV_EXPORTS void max(const Mat& src1, const Mat& src2, Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, Mat& dst)
cv::max	core/core.hpp	/^CV_EXPORTS void max(const Mat& src1, double src2, Mat& dst);    $/;"	p	namespace:cv	signature:(const Mat& src1, double src2, Mat& dst)
cv::max	core/core.hpp	/^CV_EXPORTS_W void max(InputArray src1, InputArray src2, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst)
cv::max	core/mat.hpp	/^CV_EXPORTS MatExpr max(const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::max	core/mat.hpp	/^CV_EXPORTS MatExpr max(const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
cv::max	core/mat.hpp	/^CV_EXPORTS MatExpr max(double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
cv::max	core/mat.hpp	/^template<typename _Tp> static inline MatExpr max(const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
cv::max	core/mat.hpp	/^template<typename _Tp> static inline MatExpr max(const Mat_<_Tp>& a, double s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, double s)
cv::max	core/mat.hpp	/^template<typename _Tp> static inline MatExpr max(double s, const Mat_<_Tp>& a)$/;"	f	namespace:cv	signature:(double s, const Mat_<_Tp>& a)
cv::max	core/mat.hpp	/^template<typename _Tp> static inline void max(const Mat_<_Tp>& a, const Mat_<_Tp>& b, Mat_<_Tp>& c)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b, Mat_<_Tp>& c)
cv::max	core/mat.hpp	/^template<typename _Tp> static inline void max(const Mat_<_Tp>& a, double s, Mat_<_Tp>& c)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, double s, Mat_<_Tp>& c)
cv::max	core/mat.hpp	/^template<typename _Tp> static inline void max(double s, const Mat_<_Tp>& a, Mat_<_Tp>& c)$/;"	f	namespace:cv	signature:(double s, const Mat_<_Tp>& a, Mat_<_Tp>& c)
cv::mean	core/core.hpp	/^CV_EXPORTS_W Scalar mean(InputArray src, InputArray mask=noArray());$/;"	p	namespace:cv	signature:(InputArray src, InputArray mask=noArray())
cv::meanShift	video/tracking.hpp	/^CV_EXPORTS_W int meanShift( InputArray probImage, CV_OUT CV_IN_OUT Rect& window,$/;"	p	namespace:cv	signature:( InputArray probImage, CV_OUT CV_IN_OUT Rect& window, TermCriteria criteria )
cv::meanStdDev	core/core.hpp	/^CV_EXPORTS_W void meanStdDev(InputArray src, OutputArray mean, OutputArray stddev,$/;"	p	namespace:cv	signature:(InputArray src, OutputArray mean, OutputArray stddev, InputArray mask=noArray())
cv::medianBlur	imgproc/imgproc.hpp	/^CV_EXPORTS_W void medianBlur( InputArray src, OutputArray dst, int ksize );$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int ksize )
cv::merge	core/core.hpp	/^CV_EXPORTS void merge(const Mat* mv, size_t count, OutputArray dst);$/;"	p	namespace:cv	signature:(const Mat* mv, size_t count, OutputArray dst)
cv::merge	core/core.hpp	/^CV_EXPORTS_W void merge(const vector<Mat>& mv, OutputArray dst);$/;"	p	namespace:cv	signature:(const vector<Mat>& mv, OutputArray dst)
cv::min	core/core.hpp	/^CV_EXPORTS void min(const Mat& src1, const Mat& src2, Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, Mat& dst)
cv::min	core/core.hpp	/^CV_EXPORTS void min(const Mat& src1, double src2, Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, double src2, Mat& dst)
cv::min	core/core.hpp	/^CV_EXPORTS_W void min(InputArray src1, InputArray src2, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst)
cv::min	core/mat.hpp	/^CV_EXPORTS MatExpr min(const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::min	core/mat.hpp	/^CV_EXPORTS MatExpr min(const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
cv::min	core/mat.hpp	/^CV_EXPORTS MatExpr min(double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
cv::min	core/mat.hpp	/^template<typename _Tp> static inline MatExpr min(const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
cv::min	core/mat.hpp	/^template<typename _Tp> static inline MatExpr min(const Mat_<_Tp>& a, double s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, double s)
cv::min	core/mat.hpp	/^template<typename _Tp> static inline MatExpr min(double s, const Mat_<_Tp>& a)$/;"	f	namespace:cv	signature:(double s, const Mat_<_Tp>& a)
cv::min	core/mat.hpp	/^template<typename _Tp> static inline void min(const Mat_<_Tp>& a, const Mat_<_Tp>& b, Mat_<_Tp>& c)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b, Mat_<_Tp>& c)
cv::min	core/mat.hpp	/^template<typename _Tp> static inline void min(const Mat_<_Tp>& a, double s, Mat_<_Tp>& c)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, double s, Mat_<_Tp>& c)
cv::min	core/mat.hpp	/^template<typename _Tp> static inline void min(double s, const Mat_<_Tp>& a, Mat_<_Tp>& c)$/;"	f	namespace:cv	signature:(double s, const Mat_<_Tp>& a, Mat_<_Tp>& c)
cv::minAreaRect	imgproc/imgproc.hpp	/^CV_EXPORTS_W RotatedRect minAreaRect( InputArray points );$/;"	p	namespace:cv	signature:( InputArray points )
cv::minEnclosingCircle	imgproc/imgproc.hpp	/^CV_EXPORTS_W void minEnclosingCircle( InputArray points,$/;"	p	namespace:cv	signature:( InputArray points, CV_OUT Point2f& center, CV_OUT float& radius )
cv::minMaxIdx	core/core.hpp	/^CV_EXPORTS void minMaxIdx(InputArray src, double* minVal, double* maxVal,$/;"	p	namespace:cv	signature:(InputArray src, double* minVal, double* maxVal, int* minIdx=0, int* maxIdx=0, InputArray mask=noArray())
cv::minMaxLoc	core/core.hpp	/^CV_EXPORTS void minMaxLoc(const SparseMat& a, double* minVal,$/;"	p	namespace:cv	signature:(const SparseMat& a, double* minVal, double* maxVal, int* minIdx=0, int* maxIdx=0)
cv::minMaxLoc	core/core.hpp	/^CV_EXPORTS_W void minMaxLoc(InputArray src, CV_OUT double* minVal,$/;"	p	namespace:cv	signature:(InputArray src, CV_OUT double* minVal, CV_OUT double* maxVal=0, CV_OUT Point* minLoc=0, CV_OUT Point* maxLoc=0, InputArray mask=noArray())
cv::mixChannels	core/core.hpp	/^CV_EXPORTS void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts,$/;"	p	namespace:cv	signature:(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)
cv::mixChannels	core/core.hpp	/^CV_EXPORTS void mixChannels(const vector<Mat>& src, vector<Mat>& dst,$/;"	p	namespace:cv	signature:(const vector<Mat>& src, vector<Mat>& dst, const int* fromTo, size_t npairs)
cv::mixChannels	core/core.hpp	/^CV_EXPORTS_W void mixChannels(InputArrayOfArrays src, InputArrayOfArrays dst,$/;"	p	namespace:cv	signature:(InputArrayOfArrays src, InputArrayOfArrays dst, const vector<int>& fromTo)
cv::moments	imgproc/imgproc.hpp	/^CV_EXPORTS_W Moments moments( InputArray array, bool binaryImage=false );$/;"	p	namespace:cv	signature:( InputArray array, bool binaryImage=false )
cv::morphologyDefaultBorderValue	imgproc/imgproc.hpp	/^static inline Scalar morphologyDefaultBorderValue() { return Scalar::all(DBL_MAX); }$/;"	f	namespace:cv	signature:()
cv::morphologyEx	imgproc/imgproc.hpp	/^CV_EXPORTS_W void morphologyEx( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor=Point(-1,-1), int iterations=1, int borderType=BORDER_CONSTANT, const Scalar& borderValue=morphologyDefaultBorderValue() )
cv::mulSpectrums	core/core.hpp	/^CV_EXPORTS_W void mulSpectrums(InputArray a, InputArray b, OutputArray c,$/;"	p	namespace:cv	signature:(InputArray a, InputArray b, OutputArray c, int flags, bool conjB=false)
cv::mulTransposed	core/core.hpp	/^CV_EXPORTS_W void mulTransposed( InputArray src, OutputArray dst, bool aTa,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, bool aTa, InputArray delta=noArray(), double scale=1, int dtype=-1 )
cv::multiply	core/core.hpp	/^CV_EXPORTS_W void multiply(InputArray src1, InputArray src2,$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst, double scale=1, int dtype=-1)
cv::namedWindow	highgui/highgui.hpp	/^CV_EXPORTS_W void namedWindow( const string& winname, int flags=WINDOW_AUTOSIZE );$/;"	p	namespace:cv	signature:( const string& winname, int flags=WINDOW_AUTOSIZE )
cv::noArray	core/core.hpp	/^CV_EXPORTS OutputArray noArray();$/;"	p	namespace:cv	signature:()
cv::norm	core/core.hpp	/^CV_EXPORTS double norm( const SparseMat& src, int normType );$/;"	p	namespace:cv	signature:( const SparseMat& src, int normType )
cv::norm	core/core.hpp	/^CV_EXPORTS_W double norm(InputArray src1, InputArray src2,$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, int normType=NORM_L2, InputArray mask=noArray())
cv::norm	core/core.hpp	/^CV_EXPORTS_W double norm(InputArray src1, int normType=NORM_L2, InputArray mask=noArray());$/;"	p	namespace:cv	signature:(InputArray src1, int normType=NORM_L2, InputArray mask=noArray())
cv::norm	core/operations.hpp	/^double norm(const Matx<_Tp, m, n>& M)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& M)
cv::norm	core/operations.hpp	/^double norm(const Matx<_Tp, m, n>& M, int normType)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& M, int normType)
cv::norm	core/operations.hpp	/^template<typename _Tp> static inline double norm(const Point3_<_Tp>& pt)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& pt)
cv::norm	core/operations.hpp	/^template<typename _Tp> static inline double norm(const Point_<_Tp>& pt)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& pt)
cv::normalize	core/core.hpp	/^CV_EXPORTS void normalize( const SparseMat& src, SparseMat& dst, double alpha, int normType );$/;"	p	namespace:cv	signature:( const SparseMat& src, SparseMat& dst, double alpha, int normType )
cv::normalize	core/core.hpp	/^CV_EXPORTS_W void normalize( InputArray src, OutputArray dst, double alpha=1, double beta=0,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, double alpha=1, double beta=0, int norm_type=NORM_L2, int dtype=-1, InputArray mask=noArray())
cv::operator !	core/operations.hpp	/^static inline bool operator !(const Range& r)$/;"	f	namespace:cv	signature:(const Range& r)
cv::operator !=	core/mat.hpp	/^CV_EXPORTS MatExpr operator != (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator !=	core/mat.hpp	/^CV_EXPORTS MatExpr operator != (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
cv::operator !=	core/mat.hpp	/^CV_EXPORTS MatExpr operator != (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
cv::operator !=	core/mat.hpp	/^operator != (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
cv::operator !=	core/mat.hpp	/^operator != (const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)$/;"	f	namespace:cv	signature:(const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)
cv::operator !=	core/mat.hpp	/^operator != (const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)$/;"	f	namespace:cv	signature:(const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)
cv::operator !=	core/mat.hpp	/^static inline bool operator != (const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)$/;"	f	namespace:cv	signature:(const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)
cv::operator !=	core/operations.hpp	/^bool operator != (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
cv::operator !=	core/operations.hpp	/^bool operator != (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
cv::operator !=	core/operations.hpp	/^static inline bool operator != (const FileNodeIterator& it1, const FileNodeIterator& it2)$/;"	f	namespace:cv	signature:(const FileNodeIterator& it1, const FileNodeIterator& it2)
cv::operator !=	core/operations.hpp	/^static inline bool operator != (const Range& r1, const Range& r2)$/;"	f	namespace:cv	signature:(const Range& r1, const Range& r2)
cv::operator !=	core/operations.hpp	/^template<typename _Tp> inline bool operator != (const SeqIterator<_Tp>& a,$/;"	f	namespace:cv	signature:(const SeqIterator<_Tp>& a, const SeqIterator<_Tp>& b)
cv::operator !=	core/operations.hpp	/^template<typename _Tp> static inline bool operator != ( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )$/;"	f	namespace:cv	signature:( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )
cv::operator !=	core/operations.hpp	/^template<typename _Tp> static inline bool operator != (const Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, const Point3_<_Tp>& b)
cv::operator !=	core/operations.hpp	/^template<typename _Tp> static inline bool operator != (const Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, const Point_<_Tp>& b)
cv::operator !=	core/operations.hpp	/^template<typename _Tp> static inline bool operator != (const Rect_<_Tp>& a, const Rect_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Rect_<_Tp>& b)
cv::operator !=	core/operations.hpp	/^template<typename _Tp> static inline bool operator != (const Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Size_<_Tp>& a, const Size_<_Tp>& b)
cv::operator &	core/mat.hpp	/^CV_EXPORTS MatExpr operator & (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator &	core/mat.hpp	/^CV_EXPORTS MatExpr operator & (const Mat& a, const Scalar& s);$/;"	p	namespace:cv	signature:(const Mat& a, const Scalar& s)
cv::operator &	core/mat.hpp	/^CV_EXPORTS MatExpr operator & (const Scalar& s, const Mat& a);$/;"	p	namespace:cv	signature:(const Scalar& s, const Mat& a)
cv::operator &	core/operations.hpp	/^static inline Range operator & (const Range& r1, const Range& r2)$/;"	f	namespace:cv	signature:(const Range& r1, const Range& r2)
cv::operator &	core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp> operator & (const Rect_<_Tp>& a, const Rect_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Rect_<_Tp>& b)
cv::operator &=	core/mat.hpp	/^operator &= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
cv::operator &=	core/mat.hpp	/^operator &= (const Mat_<_Tp>& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Scalar& s)
cv::operator &=	core/mat.hpp	/^static inline Mat& operator &= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator &=	core/mat.hpp	/^static inline Mat& operator &= (const Mat& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat& a, const Scalar& s)
cv::operator &=	core/operations.hpp	/^static inline Range& operator &= (Range& r1, const Range& r2)$/;"	f	namespace:cv	signature:(Range& r1, const Range& r2)
cv::operator &=	core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator &= ( Rect_<_Tp>& a, const Rect_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Rect_<_Tp>& b )
cv::operator *	core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator *	core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
cv::operator *	core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const Mat& m, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Mat& m, const MatExpr& e)
cv::operator *	core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const MatExpr& e, const Mat& m);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Mat& m)
cv::operator *	core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const MatExpr& e, double s);$/;"	p	namespace:cv	signature:(const MatExpr& e, double s)
cv::operator *	core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const MatExpr& e1, const MatExpr& e2);$/;"	p	namespace:cv	signature:(const MatExpr& e1, const MatExpr& e2)
cv::operator *	core/mat.hpp	/^CV_EXPORTS MatExpr operator * (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
cv::operator *	core/mat.hpp	/^CV_EXPORTS MatExpr operator * (double s, const MatExpr& e);$/;"	p	namespace:cv	signature:(double s, const MatExpr& e)
cv::operator *	core/operations.hpp	/^Complex<_Tp> operator * (_Tp b, const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(_Tp b, const Complex<_Tp>& a)
cv::operator *	core/operations.hpp	/^Complex<_Tp> operator * (const Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, _Tp b)
cv::operator *	core/operations.hpp	/^Complex<_Tp> operator * (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
cv::operator *	core/operations.hpp	/^Matx<_Tp, 4, 1> operator * (const Matx<_Tp, 4, 4>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, 4, 4>& a, const Point3_<_Tp>& b)
cv::operator *	core/operations.hpp	/^Matx<_Tp, m, n> operator * (const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b)
cv::operator *	core/operations.hpp	/^Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, double alpha)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, double alpha)
cv::operator *	core/operations.hpp	/^Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, float alpha)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, float alpha)
cv::operator *	core/operations.hpp	/^Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, int alpha)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, int alpha)
cv::operator *	core/operations.hpp	/^Matx<_Tp, m, n> operator * (double alpha, const Matx<_Tp, m, n>& a)$/;"	f	namespace:cv	signature:(double alpha, const Matx<_Tp, m, n>& a)
cv::operator *	core/operations.hpp	/^Matx<_Tp, m, n> operator * (float alpha, const Matx<_Tp, m, n>& a)$/;"	f	namespace:cv	signature:(float alpha, const Matx<_Tp, m, n>& a)
cv::operator *	core/operations.hpp	/^Matx<_Tp, m, n> operator * (int alpha, const Matx<_Tp, m, n>& a)$/;"	f	namespace:cv	signature:(int alpha, const Matx<_Tp, m, n>& a)
cv::operator *	core/operations.hpp	/^Point3_<_Tp> operator * (const Matx<_Tp, 3, 3>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, 3, 3>& a, const Point3_<_Tp>& b)
cv::operator *	core/operations.hpp	/^Point3_<_Tp> operator * (const Matx<_Tp, 3, 3>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, 3, 3>& a, const Point_<_Tp>& b)
cv::operator *	core/operations.hpp	/^Point_<_Tp> operator * (const Matx<_Tp, 2, 2>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, 2, 2>& a, const Point_<_Tp>& b)
cv::operator *	core/operations.hpp	/^Scalar operator * (const Matx<_Tp, 4, 4>& a, const Scalar& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, 4, 4>& a, const Scalar& b)
cv::operator *	core/operations.hpp	/^operator * (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
cv::operator *	core/operations.hpp	/^operator * (const Vec<_Tp, cn>& a, double alpha)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& a, double alpha)
cv::operator *	core/operations.hpp	/^operator * (const Vec<_Tp, cn>& a, float alpha)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& a, float alpha)
cv::operator *	core/operations.hpp	/^operator * (const Vec<_Tp, cn>& a, int alpha)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& a, int alpha)
cv::operator *	core/operations.hpp	/^operator * (double alpha, const Vec<_Tp, cn>& a)$/;"	f	namespace:cv	signature:(double alpha, const Vec<_Tp, cn>& a)
cv::operator *	core/operations.hpp	/^operator * (float alpha, const Vec<_Tp, cn>& a)$/;"	f	namespace:cv	signature:(float alpha, const Vec<_Tp, cn>& a)
cv::operator *	core/operations.hpp	/^operator * (int alpha, const Vec<_Tp, cn>& a)$/;"	f	namespace:cv	signature:(int alpha, const Vec<_Tp, cn>& a)
cv::operator *	core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (const Point3_<_Tp>& a, double b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, double b)
cv::operator *	core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (const Point3_<_Tp>& a, float b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, float b)
cv::operator *	core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (const Point3_<_Tp>& a, int b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, int b)
cv::operator *	core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (double a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(double a, const Point3_<_Tp>& b)
cv::operator *	core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (float a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(float a, const Point3_<_Tp>& b)
cv::operator *	core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (int a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(int a, const Point3_<_Tp>& b)
cv::operator *	core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (const Point_<_Tp>& a, double b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, double b)
cv::operator *	core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (const Point_<_Tp>& a, float b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, float b)
cv::operator *	core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (const Point_<_Tp>& a, int b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, int b)
cv::operator *	core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (double a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(double a, const Point_<_Tp>& b)
cv::operator *	core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (float a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(float a, const Point_<_Tp>& b)
cv::operator *	core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (int a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(int a, const Point_<_Tp>& b)
cv::operator *	core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp> operator * (_Tp alpha, const Scalar_<_Tp>& a)$/;"	f	namespace:cv	signature:(_Tp alpha, const Scalar_<_Tp>& a)
cv::operator *	core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp> operator * (const Scalar_<_Tp>& a, _Tp alpha)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, _Tp alpha)
cv::operator *	core/operations.hpp	/^template<typename _Tp> static inline Size_<_Tp> operator * (const Size_<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Size_<_Tp>& a, _Tp b)
cv::operator *=	core/mat.hpp	/^Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const MatExpr& b)
cv::operator *=	core/mat.hpp	/^Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
cv::operator *=	core/mat.hpp	/^Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, double s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, double s)
cv::operator *=	core/mat.hpp	/^static inline Mat& operator *= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator *=	core/mat.hpp	/^static inline Mat& operator *= (const Mat& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat& a, const MatExpr& b)
cv::operator *=	core/mat.hpp	/^static inline Mat& operator *= (const Mat& a, double s)$/;"	f	namespace:cv	signature:(const Mat& a, double s)
cv::operator *=	core/operations.hpp	/^Complex<_Tp>& operator *= (Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, _Tp b)
cv::operator *=	core/operations.hpp	/^Matx<_Tp, m, n>& operator *= (Matx<_Tp, m, n>& a, double alpha)$/;"	f	namespace:cv	signature:(Matx<_Tp, m, n>& a, double alpha)
cv::operator *=	core/operations.hpp	/^Matx<_Tp, m, n>& operator *= (Matx<_Tp, m, n>& a, float alpha)$/;"	f	namespace:cv	signature:(Matx<_Tp, m, n>& a, float alpha)
cv::operator *=	core/operations.hpp	/^Matx<_Tp, m, n>& operator *= (Matx<_Tp, m, n>& a, int alpha)$/;"	f	namespace:cv	signature:(Matx<_Tp, m, n>& a, int alpha)
cv::operator *=	core/operations.hpp	/^Vec<_Tp, cn>& operator *= (Vec<_Tp, cn>& a, double alpha)$/;"	f	namespace:cv	signature:(Vec<_Tp, cn>& a, double alpha)
cv::operator *=	core/operations.hpp	/^Vec<_Tp, cn>& operator *= (Vec<_Tp, cn>& a, float alpha)$/;"	f	namespace:cv	signature:(Vec<_Tp, cn>& a, float alpha)
cv::operator *=	core/operations.hpp	/^Vec<_Tp, cn>& operator *= (Vec<_Tp, cn>& a, int alpha)$/;"	f	namespace:cv	signature:(Vec<_Tp, cn>& a, int alpha)
cv::operator *=	core/operations.hpp	/^operator *= (Point3_<_Tp>& a, double b)$/;"	f	namespace:cv	signature:(Point3_<_Tp>& a, double b)
cv::operator *=	core/operations.hpp	/^operator *= (Point3_<_Tp>& a, float b)$/;"	f	namespace:cv	signature:(Point3_<_Tp>& a, float b)
cv::operator *=	core/operations.hpp	/^operator *= (Point3_<_Tp>& a, int b)$/;"	f	namespace:cv	signature:(Point3_<_Tp>& a, int b)
cv::operator *=	core/operations.hpp	/^operator *= (Point_<_Tp>& a, double b)$/;"	f	namespace:cv	signature:(Point_<_Tp>& a, double b)
cv::operator *=	core/operations.hpp	/^operator *= (Point_<_Tp>& a, float b)$/;"	f	namespace:cv	signature:(Point_<_Tp>& a, float b)
cv::operator *=	core/operations.hpp	/^operator *= (Point_<_Tp>& a, int b)$/;"	f	namespace:cv	signature:(Point_<_Tp>& a, int b)
cv::operator *=	core/operations.hpp	/^operator *= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
cv::operator *=	core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp>& operator *= ( Scalar_<_Tp>& a, _Tp v )$/;"	f	namespace:cv	signature:( Scalar_<_Tp>& a, _Tp v )
cv::operator +	core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator +	core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const Mat& a, const Scalar& s);$/;"	p	namespace:cv	signature:(const Mat& a, const Scalar& s)
cv::operator +	core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const Mat& m, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Mat& m, const MatExpr& e)
cv::operator +	core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const MatExpr& e, const Mat& m);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Mat& m)
cv::operator +	core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const MatExpr& e, const Scalar& s);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Scalar& s)
cv::operator +	core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const MatExpr& e1, const MatExpr& e2);$/;"	p	namespace:cv	signature:(const MatExpr& e1, const MatExpr& e2)
cv::operator +	core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const Scalar& s, const Mat& a);$/;"	p	namespace:cv	signature:(const Scalar& s, const Mat& a)
cv::operator +	core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const Scalar& s, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Scalar& s, const MatExpr& e)
cv::operator +	core/mat.hpp	/^operator + (const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)
cv::operator +	core/mat.hpp	/^operator + (const MatIterator_<_Tp>& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatIterator_<_Tp>& a, ptrdiff_t ofs)
cv::operator +	core/mat.hpp	/^operator + (ptrdiff_t ofs, const MatConstIterator_<_Tp>& a)$/;"	f	namespace:cv	signature:(ptrdiff_t ofs, const MatConstIterator_<_Tp>& a)
cv::operator +	core/mat.hpp	/^operator + (ptrdiff_t ofs, const MatIterator_<_Tp>& a)$/;"	f	namespace:cv	signature:(ptrdiff_t ofs, const MatIterator_<_Tp>& a)
cv::operator +	core/mat.hpp	/^static inline MatConstIterator operator + (const MatConstIterator& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, ptrdiff_t ofs)
cv::operator +	core/mat.hpp	/^static inline MatConstIterator operator + (ptrdiff_t ofs, const MatConstIterator& a)$/;"	f	namespace:cv	signature:(ptrdiff_t ofs, const MatConstIterator& a)
cv::operator +	core/operations.hpp	/^Complex<_Tp> operator + (_Tp b, const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(_Tp b, const Complex<_Tp>& a)
cv::operator +	core/operations.hpp	/^Complex<_Tp> operator + (const Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, _Tp b)
cv::operator +	core/operations.hpp	/^Complex<_Tp> operator + (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
cv::operator +	core/operations.hpp	/^Matx<_Tp, m, n> operator + (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
cv::operator +	core/operations.hpp	/^operator + (const Vec<_Tp, cn>& a, const Vec<_Tp, cn>& b)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& a, const Vec<_Tp, cn>& b)
cv::operator +	core/operations.hpp	/^static inline Range operator + (const Range& r1, int delta)$/;"	f	namespace:cv	signature:(const Range& r1, int delta)
cv::operator +	core/operations.hpp	/^static inline Range operator + (int delta, const Range& r1)$/;"	f	namespace:cv	signature:(int delta, const Range& r1)
cv::operator +	core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator + (const Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, const Point3_<_Tp>& b)
cv::operator +	core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator + (const Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, const Point_<_Tp>& b)
cv::operator +	core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp> operator + (const Rect_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Point_<_Tp>& b)
cv::operator +	core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp> operator + (const Rect_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Size_<_Tp>& b)
cv::operator +	core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp> operator + (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
cv::operator +	core/operations.hpp	/^template<typename _Tp> static inline Size_<_Tp> operator + (const Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Size_<_Tp>& a, const Size_<_Tp>& b)
cv::operator +=	core/mat.hpp	/^Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const MatExpr& b)
cv::operator +=	core/mat.hpp	/^Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
cv::operator +=	core/mat.hpp	/^Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Scalar& s)
cv::operator +=	core/mat.hpp	/^static inline Mat& operator += (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator +=	core/mat.hpp	/^static inline Mat& operator += (const Mat& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat& a, const MatExpr& b)
cv::operator +=	core/mat.hpp	/^static inline Mat& operator += (const Mat& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat& a, const Scalar& s)
cv::operator +=	core/operations.hpp	/^Complex<_Tp>& operator += (Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, _Tp b)
cv::operator +=	core/operations.hpp	/^Complex<_Tp>& operator += (Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, const Complex<_Tp>& b)
cv::operator +=	core/operations.hpp	/^Matx<_Tp1, m, n>& operator += (Matx<_Tp1, m, n>& a, const Matx<_Tp2, m, n>& b)$/;"	f	namespace:cv	signature:(Matx<_Tp1, m, n>& a, const Matx<_Tp2, m, n>& b)
cv::operator +=	core/operations.hpp	/^Vec<T1, 2>& operator += (Vec<T1, 2>& a, const Vec<T2, 2>& b)$/;"	f	namespace:cv	signature:(Vec<T1, 2>& a, const Vec<T2, 2>& b)
cv::operator +=	core/operations.hpp	/^Vec<T1, 3>& operator += (Vec<T1, 3>& a, const Vec<T2, 3>& b)$/;"	f	namespace:cv	signature:(Vec<T1, 3>& a, const Vec<T2, 3>& b)
cv::operator +=	core/operations.hpp	/^Vec<T1, 4>& operator += (Vec<T1, 4>& a, const Vec<T2, 4>& b)$/;"	f	namespace:cv	signature:(Vec<T1, 4>& a, const Vec<T2, 4>& b)
cv::operator +=	core/operations.hpp	/^operator += (Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(Point3_<_Tp>& a, const Point3_<_Tp>& b)
cv::operator +=	core/operations.hpp	/^operator += (Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(Point_<_Tp>& a, const Point_<_Tp>& b)
cv::operator +=	core/operations.hpp	/^operator += (Vec<_Tp1, cn>& a, const Vec<_Tp2, cn>& b)$/;"	f	namespace:cv	signature:(Vec<_Tp1, cn>& a, const Vec<_Tp2, cn>& b)
cv::operator +=	core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator += ( Rect_<_Tp>& a, const Point_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Point_<_Tp>& b )
cv::operator +=	core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator += ( Rect_<_Tp>& a, const Size_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Size_<_Tp>& b )
cv::operator +=	core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp>& operator += (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
cv::operator +=	core/operations.hpp	/^template<typename _Tp> static inline Size_<_Tp>& operator += (Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(Size_<_Tp>& a, const Size_<_Tp>& b)
cv::operator -	core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator -	core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Mat& a, const Scalar& s);$/;"	p	namespace:cv	signature:(const Mat& a, const Scalar& s)
cv::operator -	core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Mat& m);$/;"	p	namespace:cv	signature:(const Mat& m)
cv::operator -	core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Mat& m, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Mat& m, const MatExpr& e)
cv::operator -	core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const MatExpr& e);$/;"	p	namespace:cv	signature:(const MatExpr& e)
cv::operator -	core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const MatExpr& e, const Mat& m);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Mat& m)
cv::operator -	core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const MatExpr& e, const Scalar& s);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Scalar& s)
cv::operator -	core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const MatExpr& e1, const MatExpr& e2);$/;"	p	namespace:cv	signature:(const MatExpr& e1, const MatExpr& e2)
cv::operator -	core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Scalar& s, const Mat& a);$/;"	p	namespace:cv	signature:(const Scalar& s, const Mat& a)
cv::operator -	core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Scalar& s, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Scalar& s, const MatExpr& e)
cv::operator -	core/mat.hpp	/^CV_EXPORTS ptrdiff_t operator - (const MatConstIterator& b, const MatConstIterator& a);$/;"	p	namespace:cv	signature:(const MatConstIterator& b, const MatConstIterator& a)
cv::operator -	core/mat.hpp	/^operator - (const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)
cv::operator -	core/mat.hpp	/^operator - (const MatIterator_<_Tp>& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatIterator_<_Tp>& a, ptrdiff_t ofs)
cv::operator -	core/mat.hpp	/^static inline MatConstIterator operator - (const MatConstIterator& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, ptrdiff_t ofs)
cv::operator -	core/operations.hpp	/^Complex<_Tp> operator - (_Tp b, const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(_Tp b, const Complex<_Tp>& a)
cv::operator -	core/operations.hpp	/^Complex<_Tp> operator - (const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a)
cv::operator -	core/operations.hpp	/^Complex<_Tp> operator - (const Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, _Tp b)
cv::operator -	core/operations.hpp	/^Complex<_Tp> operator - (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
cv::operator -	core/operations.hpp	/^Matx<_Tp, m, n> operator - (const Matx<_Tp, m, n>& a)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a)
cv::operator -	core/operations.hpp	/^Matx<_Tp, m, n> operator - (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
cv::operator -	core/operations.hpp	/^operator - (const Vec<_Tp, cn>& a)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& a)
cv::operator -	core/operations.hpp	/^operator - (const Vec<_Tp, cn>& a, const Vec<_Tp, cn>& b)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& a, const Vec<_Tp, cn>& b)
cv::operator -	core/operations.hpp	/^static inline Range operator - (const Range& r1, int delta)$/;"	f	namespace:cv	signature:(const Range& r1, int delta)
cv::operator -	core/operations.hpp	/^static inline ptrdiff_t operator - (const FileNodeIterator& it1, const FileNodeIterator& it2)$/;"	f	namespace:cv	signature:(const FileNodeIterator& it1, const FileNodeIterator& it2)
cv::operator -	core/operations.hpp	/^template<typename _Tp> inline ptrdiff_t operator - (const SeqIterator<_Tp>& a,$/;"	f	namespace:cv	signature:(const SeqIterator<_Tp>& a, const SeqIterator<_Tp>& b)
cv::operator -	core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator - (const Point3_<_Tp>& a)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a)
cv::operator -	core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator - (const Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, const Point3_<_Tp>& b)
cv::operator -	core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator - (const Point_<_Tp>& a)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a)
cv::operator -	core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator - (const Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, const Point_<_Tp>& b)
cv::operator -	core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp> operator - (const Rect_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Point_<_Tp>& b)
cv::operator -	core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp> operator - (const Scalar_<_Tp>& a)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a)
cv::operator -	core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp> operator - (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
cv::operator -	core/operations.hpp	/^template<typename _Tp> static inline Size_<_Tp> operator - (const Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Size_<_Tp>& a, const Size_<_Tp>& b)
cv::operator -=	core/mat.hpp	/^Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const MatExpr& b)
cv::operator -=	core/mat.hpp	/^Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
cv::operator -=	core/mat.hpp	/^Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Scalar& s)
cv::operator -=	core/mat.hpp	/^static inline Mat& operator -= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator -=	core/mat.hpp	/^static inline Mat& operator -= (const Mat& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat& a, const MatExpr& b)
cv::operator -=	core/mat.hpp	/^static inline Mat& operator -= (const Mat& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat& a, const Scalar& s)
cv::operator -=	core/operations.hpp	/^Complex<_Tp>& operator -= (Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, _Tp b)
cv::operator -=	core/operations.hpp	/^Complex<_Tp>& operator -= (Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, const Complex<_Tp>& b)
cv::operator -=	core/operations.hpp	/^Matx<_Tp1, m, n>& operator -= (Matx<_Tp1, m, n>& a, const Matx<_Tp2, m, n>& b)$/;"	f	namespace:cv	signature:(Matx<_Tp1, m, n>& a, const Matx<_Tp2, m, n>& b)
cv::operator -=	core/operations.hpp	/^operator -= (Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(Point3_<_Tp>& a, const Point3_<_Tp>& b)
cv::operator -=	core/operations.hpp	/^operator -= (Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(Point_<_Tp>& a, const Point_<_Tp>& b)
cv::operator -=	core/operations.hpp	/^operator -= (Vec<_Tp1, cn>& a, const Vec<_Tp2, cn>& b)$/;"	f	namespace:cv	signature:(Vec<_Tp1, cn>& a, const Vec<_Tp2, cn>& b)
cv::operator -=	core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator -= ( Rect_<_Tp>& a, const Point_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Point_<_Tp>& b )
cv::operator -=	core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator -= ( Rect_<_Tp>& a, const Size_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Size_<_Tp>& b )
cv::operator -=	core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp>& operator -= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
cv::operator -=	core/operations.hpp	/^template<typename _Tp> static inline Size_<_Tp>& operator -= (Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(Size_<_Tp>& a, const Size_<_Tp>& b)
cv::operator /	core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator /	core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
cv::operator /	core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const Mat& m, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Mat& m, const MatExpr& e)
cv::operator /	core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const MatExpr& e, const Mat& m);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Mat& m)
cv::operator /	core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const MatExpr& e, double s);$/;"	p	namespace:cv	signature:(const MatExpr& e, double s)
cv::operator /	core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const MatExpr& e1, const MatExpr& e2);    $/;"	p	namespace:cv	signature:(const MatExpr& e1, const MatExpr& e2)
cv::operator /	core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
cv::operator /	core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (double s, const MatExpr& e);$/;"	p	namespace:cv	signature:(double s, const MatExpr& e)
cv::operator /	core/operations.hpp	/^Complex<_Tp> operator \/ (_Tp b, const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(_Tp b, const Complex<_Tp>& a)
cv::operator /	core/operations.hpp	/^Complex<_Tp> operator \/ (const Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, _Tp b)
cv::operator /	core/operations.hpp	/^Complex<_Tp> operator \/ (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
cv::operator /	core/operations.hpp	/^Scalar_<_Tp> operator \/ (_Tp a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(_Tp a, const Scalar_<_Tp>& b)
cv::operator /	core/operations.hpp	/^Scalar_<_Tp> operator \/ (const Scalar_<_Tp>& a, _Tp alpha)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, _Tp alpha)
cv::operator /	core/operations.hpp	/^Scalar_<_Tp> operator \/ (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
cv::operator /	core/operations.hpp	/^Scalar_<double> operator \/ (const Scalar_<double>& a, double alpha)$/;"	f	namespace:cv	signature:(const Scalar_<double>& a, double alpha)
cv::operator /	core/operations.hpp	/^Scalar_<float> operator \/ (const Scalar_<float>& a, float alpha)$/;"	f	namespace:cv	signature:(const Scalar_<float>& a, float alpha)
cv::operator /=	core/mat.hpp	/^Mat_<_Tp>& operator \/= (const Mat_<_Tp>& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const MatExpr& b)
cv::operator /=	core/mat.hpp	/^Mat_<_Tp>& operator \/= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
cv::operator /=	core/mat.hpp	/^Mat_<_Tp>& operator \/= (const Mat_<_Tp>& a, double s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, double s)
cv::operator /=	core/mat.hpp	/^static inline Mat& operator \/= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator /=	core/mat.hpp	/^static inline Mat& operator \/= (const Mat& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat& a, const MatExpr& b)
cv::operator /=	core/mat.hpp	/^static inline Mat& operator \/= (const Mat& a, double s)$/;"	f	namespace:cv	signature:(const Mat& a, double s)
cv::operator /=	core/operations.hpp	/^Complex<_Tp> operator \/= (const Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, _Tp b)
cv::operator /=	core/operations.hpp	/^Complex<_Tp>& operator \/= (Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, const Complex<_Tp>& b)
cv::operator /=	core/operations.hpp	/^Scalar_<_Tp>& operator \/= (Scalar_<_Tp>& a, _Tp alpha)$/;"	f	namespace:cv	signature:(Scalar_<_Tp>& a, _Tp alpha)
cv::operator /=	core/operations.hpp	/^Scalar_<_Tp>& operator \/= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
cv::operator <	core/mat.hpp	/^CV_EXPORTS MatExpr operator < (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator <	core/mat.hpp	/^CV_EXPORTS MatExpr operator < (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
cv::operator <	core/mat.hpp	/^CV_EXPORTS MatExpr operator < (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
cv::operator <	core/mat.hpp	/^operator < (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
cv::operator <	core/operations.hpp	/^static inline bool operator < (const FileNodeIterator& it1, const FileNodeIterator& it2)$/;"	f	namespace:cv	signature:(const FileNodeIterator& it1, const FileNodeIterator& it2)
cv::operator <<	contrib/contrib.hpp	/^    CV_EXPORTS std::ostream& operator<<(std::ostream& out, const TickMeter& tm);$/;"	p	namespace:cv	signature:(std::ostream& out, const TickMeter& tm)
cv::operator <<	core/mat.hpp	/^operator << (const Mat_<_Tp>& m, T2 val)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& m, T2 val)
cv::operator <<	core/operations.hpp	/^CV_EXPORTS FileStorage& operator << (FileStorage& fs, const string& str);$/;"	p	namespace:cv	signature:(FileStorage& fs, const string& str)
cv::operator <<	core/operations.hpp	/^MatxCommaInitializer<_Tp, m, n> operator << (const Matx<_Tp, m, n>& mtx, _T2 val)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& mtx, _T2 val)
cv::operator <<	core/operations.hpp	/^VecCommaInitializer<_Tp, cn> operator << (const Vec<_Tp, cn>& vec, _T2 val)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& vec, _T2 val)
cv::operator <<	core/operations.hpp	/^operator << ( FileStorage& fs, const vector<_Tp>& vec )$/;"	f	namespace:cv	signature:( FileStorage& fs, const vector<_Tp>& vec )
cv::operator <<	core/operations.hpp	/^static inline FileStorage& operator << (FileStorage& fs, const char* str)$/;"	f	namespace:cv	signature:(FileStorage& fs, const char* str)
cv::operator <<	core/operations.hpp	/^static inline std::ostream& operator << (std::ostream& out, const Formatted& fmtd)$/;"	f	namespace:cv	signature:(std::ostream& out, const Formatted& fmtd)
cv::operator <<	core/operations.hpp	/^static inline std::ostream& operator << (std::ostream& out, const Mat& mtx)$/;"	f	namespace:cv	signature:(std::ostream& out, const Mat& mtx)
cv::operator <<	core/operations.hpp	/^template<typename _Tp> inline std::ostream& operator<<(std::ostream& out, const Point3_<_Tp>& p)$/;"	f	namespace:cv	signature:(std::ostream& out, const Point3_<_Tp>& p)
cv::operator <<	core/operations.hpp	/^template<typename _Tp> inline std::ostream& operator<<(std::ostream& out, const Point_<_Tp>& p)$/;"	f	namespace:cv	signature:(std::ostream& out, const Point_<_Tp>& p)
cv::operator <<	core/operations.hpp	/^template<typename _Tp> static inline FileStorage& operator << (FileStorage& fs, const _Tp& value)$/;"	f	namespace:cv	signature:(FileStorage& fs, const _Tp& value)
cv::operator <<	core/operations.hpp	/^template<typename _Tp> static inline std::ostream& operator << (std::ostream& out,$/;"	f	namespace:cv	signature:(std::ostream& out, const vector<Point3_<_Tp> >& vec)
cv::operator <<	core/operations.hpp	/^template<typename _Tp> static inline std::ostream& operator << (std::ostream& out,$/;"	f	namespace:cv	signature:(std::ostream& out, const vector<Point_<_Tp> >& vec)
cv::operator <=	core/mat.hpp	/^CV_EXPORTS MatExpr operator <= (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator <=	core/mat.hpp	/^CV_EXPORTS MatExpr operator <= (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
cv::operator <=	core/mat.hpp	/^CV_EXPORTS MatExpr operator <= (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
cv::operator <=	core/mat.hpp	/^operator <= (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
cv::operator ==	core/mat.hpp	/^CV_EXPORTS MatExpr operator == (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator ==	core/mat.hpp	/^CV_EXPORTS MatExpr operator == (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
cv::operator ==	core/mat.hpp	/^CV_EXPORTS MatExpr operator == (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
cv::operator ==	core/mat.hpp	/^operator == (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
cv::operator ==	core/mat.hpp	/^operator == (const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)$/;"	f	namespace:cv	signature:(const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)
cv::operator ==	core/mat.hpp	/^operator == (const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)$/;"	f	namespace:cv	signature:(const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)
cv::operator ==	core/mat.hpp	/^static inline bool operator == (const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)$/;"	f	namespace:cv	signature:(const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)
cv::operator ==	core/operations.hpp	/^bool operator == (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
cv::operator ==	core/operations.hpp	/^bool operator == (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
cv::operator ==	core/operations.hpp	/^static inline bool operator == (const FileNodeIterator& it1, const FileNodeIterator& it2)$/;"	f	namespace:cv	signature:(const FileNodeIterator& it1, const FileNodeIterator& it2)
cv::operator ==	core/operations.hpp	/^static inline bool operator == (const Range& r1, const Range& r2)$/;"	f	namespace:cv	signature:(const Range& r1, const Range& r2)
cv::operator ==	core/operations.hpp	/^template<typename _Tp> inline bool operator == (const SeqIterator<_Tp>& a,$/;"	f	namespace:cv	signature:(const SeqIterator<_Tp>& a, const SeqIterator<_Tp>& b)
cv::operator ==	core/operations.hpp	/^template<typename _Tp> static inline bool operator == ( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )$/;"	f	namespace:cv	signature:( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )
cv::operator ==	core/operations.hpp	/^template<typename _Tp> static inline bool operator == (const Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, const Point3_<_Tp>& b)
cv::operator ==	core/operations.hpp	/^template<typename _Tp> static inline bool operator == (const Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, const Point_<_Tp>& b)
cv::operator ==	core/operations.hpp	/^template<typename _Tp> static inline bool operator == (const Rect_<_Tp>& a, const Rect_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Rect_<_Tp>& b)
cv::operator ==	core/operations.hpp	/^template<typename _Tp> static inline bool operator == (const Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Size_<_Tp>& a, const Size_<_Tp>& b)
cv::operator >	core/mat.hpp	/^CV_EXPORTS MatExpr operator > (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator >	core/mat.hpp	/^CV_EXPORTS MatExpr operator > (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
cv::operator >	core/mat.hpp	/^CV_EXPORTS MatExpr operator > (double s, const Mat& a);    $/;"	p	namespace:cv	signature:(double s, const Mat& a)
cv::operator >	core/mat.hpp	/^operator > (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
cv::operator >=	core/mat.hpp	/^CV_EXPORTS MatExpr operator >= (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator >=	core/mat.hpp	/^CV_EXPORTS MatExpr operator >= (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
cv::operator >=	core/mat.hpp	/^CV_EXPORTS MatExpr operator >= (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
cv::operator >=	core/mat.hpp	/^operator >= (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
cv::operator >>	core/operations.hpp	/^FileNodeIterator& operator >> (FileNodeIterator& it, vector<_Tp>& vec)$/;"	f	namespace:cv	signature:(FileNodeIterator& it, vector<_Tp>& vec)
cv::operator >>	core/operations.hpp	/^template<typename _Tp> static inline FileNodeIterator& operator >> (FileNodeIterator& it, _Tp& value)$/;"	f	namespace:cv	signature:(FileNodeIterator& it, _Tp& value)
cv::operator >>	core/operations.hpp	/^template<typename _Tp> static inline void operator >> (const FileNode& n, _Tp& value)$/;"	f	namespace:cv	signature:(const FileNode& n, _Tp& value)
cv::operator >>	core/operations.hpp	/^template<typename _Tp> static inline void operator >> (const FileNode& n, vector<_Tp>& vec)$/;"	f	namespace:cv	signature:(const FileNode& n, vector<_Tp>& vec)
cv::operator ^	core/mat.hpp	/^CV_EXPORTS MatExpr operator ^ (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator ^	core/mat.hpp	/^CV_EXPORTS MatExpr operator ^ (const Mat& a, const Scalar& s);$/;"	p	namespace:cv	signature:(const Mat& a, const Scalar& s)
cv::operator ^	core/mat.hpp	/^CV_EXPORTS MatExpr operator ^ (const Scalar& s, const Mat& a);$/;"	p	namespace:cv	signature:(const Scalar& s, const Mat& a)
cv::operator ^=	core/mat.hpp	/^operator ^= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
cv::operator ^=	core/mat.hpp	/^operator ^= (const Mat_<_Tp>& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Scalar& s)
cv::operator ^=	core/mat.hpp	/^static inline Mat& operator ^= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator ^=	core/mat.hpp	/^static inline Mat& operator ^= (const Mat& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat& a, const Scalar& s)
cv::operator |	core/mat.hpp	/^CV_EXPORTS MatExpr operator | (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator |	core/mat.hpp	/^CV_EXPORTS MatExpr operator | (const Mat& a, const Scalar& s);$/;"	p	namespace:cv	signature:(const Mat& a, const Scalar& s)
cv::operator |	core/mat.hpp	/^CV_EXPORTS MatExpr operator | (const Scalar& s, const Mat& a);$/;"	p	namespace:cv	signature:(const Scalar& s, const Mat& a)
cv::operator |	core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp> operator | (const Rect_<_Tp>& a, const Rect_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Rect_<_Tp>& b)
cv::operator |=	core/mat.hpp	/^operator |= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
cv::operator |=	core/mat.hpp	/^operator |= (const Mat_<_Tp>& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Scalar& s)
cv::operator |=	core/mat.hpp	/^static inline Mat& operator |= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
cv::operator |=	core/mat.hpp	/^static inline Mat& operator |= (const Mat& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat& a, const Scalar& s)
cv::operator |=	core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator |= ( Rect_<_Tp>& a, const Rect_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Rect_<_Tp>& b )
cv::operator ~	core/mat.hpp	/^CV_EXPORTS MatExpr operator ~(const Mat& m);$/;"	p	namespace:cv	signature:(const Mat& m)
cv::parallel_do	core/internal.hpp	/^        void parallel_do( Iterator first, Iterator last, const Body& body )$/;"	f	namespace:cv	signature:( Iterator first, Iterator last, const Body& body )
cv::parallel_for	core/internal.hpp	/^        void parallel_for( const BlockedRange& range, const Body& body )$/;"	f	namespace:cv	signature:( const BlockedRange& range, const Body& body )
cv::parallel_reduce	core/internal.hpp	/^        void parallel_reduce( const BlockedRange& range, Body& body )$/;"	f	namespace:cv	signature:( const BlockedRange& range, Body& body )
cv::partition	core/operations.hpp	/^partition( const vector<_Tp>& _vec, vector<int>& labels,$/;"	f	namespace:cv	signature:( const vector<_Tp>& _vec, vector<int>& labels, _EqPredicate predicate=_EqPredicate())
cv::perspectiveTransform	core/core.hpp	/^CV_EXPORTS_W void perspectiveTransform(InputArray src, OutputArray dst, InputArray m );$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, InputArray m )
cv::phase	core/core.hpp	/^CV_EXPORTS_W void phase(InputArray x, InputArray y, OutputArray angle,$/;"	p	namespace:cv	signature:(InputArray x, InputArray y, OutputArray angle, bool angleInDegrees=false)
cv::pointPolygonTest	imgproc/imgproc.hpp	/^CV_EXPORTS_W double pointPolygonTest( InputArray contour, Point2f pt, bool measureDist );$/;"	p	namespace:cv	signature:( InputArray contour, Point2f pt, bool measureDist )
cv::polarToCart	core/core.hpp	/^CV_EXPORTS_W void polarToCart(InputArray magnitude, InputArray angle,$/;"	p	namespace:cv	signature:(InputArray magnitude, InputArray angle, OutputArray x, OutputArray y, bool angleInDegrees=false)
cv::polyfit	contrib/contrib.hpp	/^    CV_EXPORTS void polyfit(const Mat& srcx, const Mat& srcy, Mat& dst, int order);$/;"	p	namespace:cv	signature:(const Mat& srcx, const Mat& srcy, Mat& dst, int order)
cv::polylines	core/core.hpp	/^CV_EXPORTS void polylines(Mat& img, const Point** pts, const int* npts,$/;"	p	namespace:cv	signature:(Mat& img, const Point** pts, const int* npts, int ncontours, bool isClosed, const Scalar& color, int thickness=1, int lineType=8, int shift=0 )
cv::polylines	core/core.hpp	/^CV_EXPORTS_W void polylines(InputOutputArray img, InputArrayOfArrays pts,$/;"	p	namespace:cv	signature:(InputOutputArray img, InputArrayOfArrays pts, bool isClosed, const Scalar& color, int thickness=1, int lineType=8, int shift=0 )
cv::pow	core/core.hpp	/^CV_EXPORTS_W void pow(InputArray src, double power, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src, double power, OutputArray dst)
cv::preCornerDetect	imgproc/imgproc.hpp	/^CV_EXPORTS_W void preCornerDetect( InputArray src, OutputArray dst, int ksize,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int ksize, int borderType=BORDER_DEFAULT )
cv::process	core/mat.hpp	/^process( const Mat_<T1>& m1, Mat_<T2>& m2, Op op )$/;"	f	namespace:cv	signature:( const Mat_<T1>& m1, Mat_<T2>& m2, Op op )
cv::process	core/mat.hpp	/^process( const Mat_<T1>& m1, const Mat_<T2>& m2, Mat_<T3>& m3, Op op )$/;"	f	namespace:cv	signature:( const Mat_<T1>& m1, const Mat_<T2>& m2, Mat_<T3>& m3, Op op )
cv::projectPoints	calib3d/calib3d.hpp	/^CV_EXPORTS_W void projectPoints( InputArray objectPoints,$/;"	p	namespace:cv	signature:( InputArray objectPoints, InputArray rvec, InputArray tvec, InputArray cameraMatrix, InputArray distCoeffs, OutputArray imagePoints, OutputArray jacobian=noArray(), double aspectRatio=0 )
cv::putText	core/core.hpp	/^CV_EXPORTS_W void putText( Mat& img, const string& text, Point org,$/;"	p	namespace:cv	signature:( Mat& img, const string& text, Point org, int fontFace, double fontScale, Scalar color, int thickness=1, int linetype=8, bool bottomLeftOrigin=false )
cv::pyrDown	imgproc/imgproc.hpp	/^CV_EXPORTS_W void pyrDown( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, const Size& dstsize=Size())
cv::pyrMeanShiftFiltering	imgproc/imgproc.hpp	/^CV_EXPORTS_W void pyrMeanShiftFiltering( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, double sp, double sr, int maxLevel=1, TermCriteria termcrit=TermCriteria( TermCriteria::MAX_ITER+TermCriteria::EPS,5,1) )
cv::pyrUp	imgproc/imgproc.hpp	/^CV_EXPORTS_W void pyrUp( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, const Size& dstsize=Size())
cv::randShuffle	core/core.hpp	/^CV_EXPORTS void randShuffle(InputOutputArray dst, double iterFactor=1., RNG* rng=0);$/;"	p	namespace:cv	signature:(InputOutputArray dst, double iterFactor=1., RNG* rng=0)
cv::randShuffle_	core/core.hpp	/^CV_EXPORTS_AS(randShuffle) void randShuffle_(InputOutputArray dst, double iterFactor=1.);$/;"	p	namespace:cv	signature:(InputOutputArray dst, double iterFactor=1.)
cv::randn	core/core.hpp	/^CV_EXPORTS_W void randn(InputOutputArray dst, InputArray mean, InputArray stddev);$/;"	p	namespace:cv	signature:(InputOutputArray dst, InputArray mean, InputArray stddev)
cv::randu	core/core.hpp	/^CV_EXPORTS_W void randu(InputOutputArray dst, InputArray low, InputArray high);$/;"	p	namespace:cv	signature:(InputOutputArray dst, InputArray low, InputArray high)
cv::randu	core/core.hpp	/^template<typename _Tp> static inline _Tp randu() { return (_Tp)theRNG(); }$/;"	f	namespace:cv	signature:()
cv::read	core/operations.hpp	/^CV_EXPORTS void read(const FileNode& node, SparseMat& mat, const SparseMat& default_mat=SparseMat() );    $/;"	p	namespace:cv	signature:(const FileNode& node, SparseMat& mat, const SparseMat& default_mat=SparseMat() )
cv::read	core/operations.hpp	/^CV_EXPORTS_W void read(const FileNode& node, Mat& mat, const Mat& default_mat=Mat() );$/;"	p	namespace:cv	signature:(const FileNode& node, Mat& mat, const Mat& default_mat=Mat() )
cv::read	core/operations.hpp	/^read( FileNode& node, vector<_Tp>& vec, const vector<_Tp>& default_value=vector<_Tp>() )$/;"	f	namespace:cv	signature:( FileNode& node, vector<_Tp>& vec, const vector<_Tp>& default_value=vector<_Tp>() )
cv::read	core/operations.hpp	/^read( FileNodeIterator& it, vector<_Tp>& vec, size_t maxCount=(size_t)INT_MAX )$/;"	f	namespace:cv	signature:( FileNodeIterator& it, vector<_Tp>& vec, size_t maxCount=(size_t)INT_MAX )
cv::read	core/operations.hpp	/^static inline void read(const FileNode& node, bool& value, bool default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, bool& value, bool default_value)
cv::read	core/operations.hpp	/^static inline void read(const FileNode& node, double& value, double default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, double& value, double default_value)
cv::read	core/operations.hpp	/^static inline void read(const FileNode& node, float& value, float default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, float& value, float default_value)
cv::read	core/operations.hpp	/^static inline void read(const FileNode& node, int& value, int default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, int& value, int default_value)
cv::read	core/operations.hpp	/^static inline void read(const FileNode& node, schar& value, schar default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, schar& value, schar default_value)
cv::read	core/operations.hpp	/^static inline void read(const FileNode& node, short& value, short default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, short& value, short default_value)
cv::read	core/operations.hpp	/^static inline void read(const FileNode& node, string& value, const string& default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, string& value, const string& default_value)
cv::read	core/operations.hpp	/^static inline void read(const FileNode& node, uchar& value, uchar default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, uchar& value, uchar default_value)
cv::read	core/operations.hpp	/^static inline void read(const FileNode& node, ushort& value, ushort default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, ushort& value, ushort default_value)
cv::read	features2d/features2d.hpp	/^CV_EXPORTS void read(const FileNode& node, CV_OUT vector<KeyPoint>& keypoints);    $/;"	p	namespace:cv	signature:(const FileNode& node, CV_OUT vector<KeyPoint>& keypoints)
cv::rectangle	core/core.hpp	/^CV_EXPORTS void rectangle(Mat& img, Rect rec,$/;"	p	namespace:cv	signature:(Mat& img, Rect rec, const Scalar& color, int thickness=1, int lineType=8, int shift=0)
cv::rectangle	core/core.hpp	/^CV_EXPORTS_W void rectangle(Mat& img, Point pt1, Point pt2,$/;"	p	namespace:cv	signature:(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness=1, int lineType=8, int shift=0)
cv::rectify3Collinear	calib3d/calib3d.hpp	/^CV_EXPORTS_W float rectify3Collinear( InputArray cameraMatrix1, InputArray distCoeffs1,$/;"	p	namespace:cv	signature:( InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, InputArray cameraMatrix3, InputArray distCoeffs3, InputArrayOfArrays imgpt1, InputArrayOfArrays imgpt3, Size imageSize, InputArray R12, InputArray T12, InputArray R13, InputArray T13, OutputArray R1, OutputArray R2, OutputArray R3, OutputArray P1, OutputArray P2, OutputArray P3, OutputArray Q, double alpha, Size newImgSize, CV_OUT Rect* roi1, CV_OUT Rect* roi2, int flags )
cv::redirectError	core/core.hpp	/^CV_EXPORTS ErrorCallback redirectError( ErrorCallback errCallback,$/;"	p	namespace:cv	signature:( ErrorCallback errCallback, void* userdata=0, void** prevUserdata=0)
cv::reduce	core/core.hpp	/^CV_EXPORTS_W void reduce(InputArray src, OutputArray dst, int dim, int rtype, int dtype=-1);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, int dim, int rtype, int dtype=-1)
cv::remap	imgproc/imgproc.hpp	/^CV_EXPORTS_W void remap( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode=BORDER_CONSTANT, const Scalar& borderValue=Scalar())
cv::repeat	core/core.hpp	/^CV_EXPORTS Mat repeat(const Mat& src, int ny, int nx);$/;"	p	namespace:cv	signature:(const Mat& src, int ny, int nx)
cv::repeat	core/core.hpp	/^CV_EXPORTS_W void repeat(InputArray src, int ny, int nx, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src, int ny, int nx, OutputArray dst)
cv::reprojectImageTo3D	calib3d/calib3d.hpp	/^CV_EXPORTS_W void reprojectImageTo3D( InputArray disparity,$/;"	p	namespace:cv	signature:( InputArray disparity, OutputArray _3dImage, InputArray Q, bool handleMissingValues=false, int ddepth=-1 )
cv::resize	imgproc/imgproc.hpp	/^CV_EXPORTS_W void resize( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, Size dsize, double fx=0, double fy=0, int interpolation=INTER_LINEAR )
cv::saturate_cast	core/operations.hpp	/^template<> inline int saturate_cast<int>(double v) { return cvRound(v); }$/;"	f	namespace:cv	signature:(double v)
cv::saturate_cast	core/operations.hpp	/^template<> inline int saturate_cast<int>(float v) { return cvRound(v); }$/;"	f	namespace:cv	signature:(float v)
cv::saturate_cast	core/operations.hpp	/^template<> inline schar saturate_cast<schar>(double v)$/;"	f	namespace:cv	signature:(double v)
cv::saturate_cast	core/operations.hpp	/^template<> inline schar saturate_cast<schar>(float v)$/;"	f	namespace:cv	signature:(float v)
cv::saturate_cast	core/operations.hpp	/^template<> inline schar saturate_cast<schar>(int v)$/;"	f	namespace:cv	signature:(int v)
cv::saturate_cast	core/operations.hpp	/^template<> inline schar saturate_cast<schar>(short v)$/;"	f	namespace:cv	signature:(short v)
cv::saturate_cast	core/operations.hpp	/^template<> inline schar saturate_cast<schar>(uchar v)$/;"	f	namespace:cv	signature:(uchar v)
cv::saturate_cast	core/operations.hpp	/^template<> inline schar saturate_cast<schar>(unsigned v)$/;"	f	namespace:cv	signature:(unsigned v)
cv::saturate_cast	core/operations.hpp	/^template<> inline schar saturate_cast<schar>(ushort v)$/;"	f	namespace:cv	signature:(ushort v)
cv::saturate_cast	core/operations.hpp	/^template<> inline short saturate_cast<short>(double v)$/;"	f	namespace:cv	signature:(double v)
cv::saturate_cast	core/operations.hpp	/^template<> inline short saturate_cast<short>(float v)$/;"	f	namespace:cv	signature:(float v)
cv::saturate_cast	core/operations.hpp	/^template<> inline short saturate_cast<short>(int v)$/;"	f	namespace:cv	signature:(int v)
cv::saturate_cast	core/operations.hpp	/^template<> inline short saturate_cast<short>(unsigned v)$/;"	f	namespace:cv	signature:(unsigned v)
cv::saturate_cast	core/operations.hpp	/^template<> inline short saturate_cast<short>(ushort v)$/;"	f	namespace:cv	signature:(ushort v)
cv::saturate_cast	core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(double v)$/;"	f	namespace:cv	signature:(double v)
cv::saturate_cast	core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(float v)$/;"	f	namespace:cv	signature:(float v)
cv::saturate_cast	core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(int v)$/;"	f	namespace:cv	signature:(int v)
cv::saturate_cast	core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(schar v)$/;"	f	namespace:cv	signature:(schar v)
cv::saturate_cast	core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(short v)$/;"	f	namespace:cv	signature:(short v)
cv::saturate_cast	core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(unsigned v)$/;"	f	namespace:cv	signature:(unsigned v)
cv::saturate_cast	core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(ushort v)$/;"	f	namespace:cv	signature:(ushort v)
cv::saturate_cast	core/operations.hpp	/^template<> inline unsigned saturate_cast<unsigned>(double v) { return cvRound(v); }$/;"	f	namespace:cv	signature:(double v)
cv::saturate_cast	core/operations.hpp	/^template<> inline unsigned saturate_cast<unsigned>(float v){ return cvRound(v); }$/;"	f	namespace:cv	signature:(float v)
cv::saturate_cast	core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(double v)$/;"	f	namespace:cv	signature:(double v)
cv::saturate_cast	core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(float v)$/;"	f	namespace:cv	signature:(float v)
cv::saturate_cast	core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(int v)$/;"	f	namespace:cv	signature:(int v)
cv::saturate_cast	core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(schar v)$/;"	f	namespace:cv	signature:(schar v)
cv::saturate_cast	core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(short v)$/;"	f	namespace:cv	signature:(short v)
cv::saturate_cast	core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(unsigned v)$/;"	f	namespace:cv	signature:(unsigned v)
cv::saturate_cast	core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(double v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(double v)
cv::saturate_cast	core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(float v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(float v)
cv::saturate_cast	core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(int v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(int v)
cv::saturate_cast	core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(schar v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(schar v)
cv::saturate_cast	core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(short v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(short v)
cv::saturate_cast	core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(uchar v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(uchar v)
cv::saturate_cast	core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(unsigned v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(unsigned v)
cv::saturate_cast	core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(ushort v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(ushort v)
cv::saveWindowParameters	highgui/highgui.hpp	/^CV_EXPORTS void saveWindowParameters(const string& windowName);$/;"	p	namespace:cv	signature:(const string& windowName)
cv::scalarToRawData	core/core.hpp	/^CV_EXPORTS void scalarToRawData(const Scalar& s, void* buf, int type, int unroll_to=0);$/;"	p	namespace:cv	signature:(const Scalar& s, void* buf, int type, int unroll_to=0)
cv::scaleAdd	core/core.hpp	/^CV_EXPORTS_W void scaleAdd(InputArray src1, double alpha, InputArray src2, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src1, double alpha, InputArray src2, OutputArray dst)
cv::segmentMotion	video/tracking.hpp	/^CV_EXPORTS_W void segmentMotion(InputArray mhi, OutputArray segmask,$/;"	p	namespace:cv	signature:(InputArray mhi, OutputArray segmask, CV_OUT vector<Rect>& boundingRects, double timestamp, double segThresh)
cv::sepFilter2D	imgproc/imgproc.hpp	/^CV_EXPORTS_W void sepFilter2D( InputArray src, OutputArray dst, int ddepth,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor=Point(-1,-1), double delta=0, int borderType=BORDER_DEFAULT )
cv::seqInsertSlice	core/operations.hpp	/^CV_EXPORTS void  seqInsertSlice( CvSeq* seq, int before_index, const CvArr* from_arr );    $/;"	p	namespace:cv	signature:( CvSeq* seq, int before_index, const CvArr* from_arr )
cv::seqPop	core/operations.hpp	/^CV_EXPORTS void  seqPop( CvSeq* seq, void* element=0);$/;"	p	namespace:cv	signature:( CvSeq* seq, void* element=0)
cv::seqPopFront	core/operations.hpp	/^CV_EXPORTS void  seqPopFront( CvSeq* seq, void* element=0);$/;"	p	namespace:cv	signature:( CvSeq* seq, void* element=0)
cv::seqPopMulti	core/operations.hpp	/^CV_EXPORTS void  seqPopMulti( CvSeq* seq, void* elements,$/;"	p	namespace:cv	signature:( CvSeq* seq, void* elements, int count, int in_front=0 )
cv::seqPush	core/operations.hpp	/^CV_EXPORTS schar*  seqPush( CvSeq* seq, const void* element=0);$/;"	p	namespace:cv	signature:( CvSeq* seq, const void* element=0)
cv::seqPushFront	core/operations.hpp	/^CV_EXPORTS schar*  seqPushFront( CvSeq* seq, const void* element=0);$/;"	p	namespace:cv	signature:( CvSeq* seq, const void* element=0)
cv::seqRemove	core/operations.hpp	/^CV_EXPORTS void  seqRemove( CvSeq* seq, int index );$/;"	p	namespace:cv	signature:( CvSeq* seq, int index )
cv::seqRemoveSlice	core/operations.hpp	/^CV_EXPORTS void  seqRemoveSlice( CvSeq* seq, CvSlice slice );$/;"	p	namespace:cv	signature:( CvSeq* seq, CvSlice slice )
cv::setBreakOnError	core/core.hpp	/^CV_EXPORTS bool setBreakOnError(bool flag);$/;"	p	namespace:cv	signature:(bool flag)
cv::setIdentity	core/core.hpp	/^CV_EXPORTS_W void setIdentity(InputOutputArray mtx, const Scalar& s=Scalar(1));$/;"	p	namespace:cv	signature:(InputOutputArray mtx, const Scalar& s=Scalar(1))
cv::setMouseCallback	highgui/highgui.hpp	/^CV_EXPORTS void setMouseCallback( const string& windowName, MouseCallback onMouse, void* param=0);$/;"	p	namespace:cv	signature:( const string& windowName, MouseCallback onMouse, void* param=0)
cv::setNumThreads	core/core.hpp	/^CV_EXPORTS void setNumThreads(int nthreads);$/;"	p	namespace:cv	signature:(int nthreads)
cv::setTrackbarPos	highgui/highgui.hpp	/^CV_EXPORTS_W void setTrackbarPos( const string& trackbarname, const string& winname, int pos );$/;"	p	namespace:cv	signature:( const string& trackbarname, const string& winname, int pos )
cv::setUseOptimized	core/core.hpp	/^CV_EXPORTS_W void setUseOptimized(bool onoff);$/;"	p	namespace:cv	signature:(bool onoff)
cv::setWindowProperty	highgui/highgui.hpp	/^CV_EXPORTS_W void setWindowProperty(const string& winname, int prop_id, double prop_value);\/\/YV$/;"	p	namespace:cv	signature:(const string& winname, int prop_id, double prop_value)
cv::solve	core/core.hpp	/^CV_EXPORTS_W bool solve(InputArray src1, InputArray src2,$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst, int flags=DECOMP_LU)
cv::solveCubic	core/core.hpp	/^CV_EXPORTS_W int solveCubic(InputArray coeffs, OutputArray roots);$/;"	p	namespace:cv	signature:(InputArray coeffs, OutputArray roots)
cv::solvePnP	calib3d/calib3d.hpp	/^CV_EXPORTS_W void solvePnP( InputArray objectPoints, InputArray imagePoints,$/;"	p	namespace:cv	signature:( InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess=false )
cv::solvePnPRansac	calib3d/calib3d.hpp	/^CV_EXPORTS_W void solvePnPRansac( InputArray objectPoints,$/;"	p	namespace:cv	signature:( InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess = false, int iterationsCount = 100, float reprojectionError = 8.0, int minInliersCount = 100, OutputArray inliers = noArray() )
cv::solvePoly	core/core.hpp	/^CV_EXPORTS_W double solvePoly(InputArray coeffs, OutputArray roots, int maxIters=300);$/;"	p	namespace:cv	signature:(InputArray coeffs, OutputArray roots, int maxIters=300)
cv::sort	core/core.hpp	/^CV_EXPORTS_W void sort(InputArray src, OutputArray dst, int flags);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, int flags)
cv::sort	core/operations.hpp	/^template<typename _Tp, class _LT> void sort( vector<_Tp>& vec, _LT LT=_LT() )$/;"	f	namespace:cv	signature:( vector<_Tp>& vec, _LT LT=_LT() )
cv::sortIdx	core/core.hpp	/^CV_EXPORTS_W void sortIdx(InputArray src, OutputArray dst, int flags);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, int flags)
cv::split	core/core.hpp	/^CV_EXPORTS void split(const Mat& src, Mat* mvbegin);$/;"	p	namespace:cv	signature:(const Mat& src, Mat* mvbegin)
cv::split	core/core.hpp	/^CV_EXPORTS_W void split(const Mat& m, CV_OUT vector<Mat>& mv);$/;"	p	namespace:cv	signature:(const Mat& m, CV_OUT vector<Mat>& mv)
cv::split	core/mat.hpp	/^template<typename _Tp> void split(const Mat& src, vector<Mat_<_Tp> >& mv)$/;"	f	namespace:cv	signature:(const Mat& src, vector<Mat_<_Tp> >& mv)
cv::sqrt	core/core.hpp	/^CV_EXPORTS_W void sqrt(InputArray src, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst)
cv::startLoop	highgui/highgui.hpp	/^CV_EXPORTS  int startLoop(int (*pt2Func)(int argc, char *argv[]), int argc, char* argv[]);$/;"	p	namespace:cv	signature:(int (*pt2Func)(int argc, char *argv[]), int argc, char* argv[])
cv::startWindowThread	highgui/highgui.hpp	/^CV_EXPORTS_W int startWindowThread();$/;"	p	namespace:cv	signature:()
cv::stereoCalibrate	calib3d/calib3d.hpp	/^CV_EXPORTS_W double stereoCalibrate( InputArrayOfArrays objectPoints,$/;"	p	namespace:cv	signature:( InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, CV_OUT InputOutputArray cameraMatrix1, CV_OUT InputOutputArray distCoeffs1, CV_OUT InputOutputArray cameraMatrix2, CV_OUT InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, TermCriteria criteria = TermCriteria(TermCriteria::COUNT+ TermCriteria::EPS, 30, 1e-6), int flags=CALIB_FIX_INTRINSIC )
cv::stereoRectify	calib3d/calib3d.hpp	/^CV_EXPORTS void stereoRectify( InputArray cameraMatrix1, InputArray distCoeffs1,$/;"	p	namespace:cv	signature:( InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags=CALIB_ZERO_DISPARITY, double alpha=-1, Size newImageSize=Size(), CV_OUT Rect* validPixROI1=0, CV_OUT Rect* validPixROI2=0 )
cv::stereoRectifyUncalibrated	calib3d/calib3d.hpp	/^CV_EXPORTS_W bool stereoRectifyUncalibrated( InputArray points1, InputArray points2,$/;"	p	namespace:cv	signature:( InputArray points1, InputArray points2, InputArray F, Size imgSize, OutputArray H1, OutputArray H2, double threshold=5 )
cv::stopLoop	highgui/highgui.hpp	/^CV_EXPORTS  void stopLoop();$/;"	p	namespace:cv	signature:()
cv::subtract	core/core.hpp	/^CV_EXPORTS_W void subtract(InputArray src1, InputArray src2, OutputArray dst,$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst, InputArray mask=noArray(), int dtype=-1)
cv::sum	core/core.hpp	/^CV_EXPORTS_AS(sumElems) Scalar sum(InputArray src); $/;"	p	namespace:cv	signature:(InputArray src)
cv::swap	core/core.hpp	/^CV_EXPORTS void swap(Mat& a, Mat& b);$/;"	p	namespace:cv	signature:(Mat& a, Mat& b)
cv::tempfile	core/core.hpp	/^CV_EXPORTS string tempfile( const char* suffix CV_DEFAULT(0));$/;"	p	namespace:cv	signature:( const char* suffix CV_DEFAULT(0))
cv::theRNG	core/core.hpp	/^CV_EXPORTS RNG& theRNG();$/;"	p	namespace:cv	signature:()
cv::threshold	imgproc/imgproc.hpp	/^CV_EXPORTS_W double threshold( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, double thresh, double maxval, int type )
cv::toUtf16	core/core.hpp	/^CV_EXPORTS WString toUtf16(const string& str);$/;"	p	namespace:cv	signature:(const string& str)
cv::trace	core/core.hpp	/^CV_EXPORTS_W Scalar trace(InputArray mtx);$/;"	p	namespace:cv	signature:(InputArray mtx)
cv::trace	core/operations.hpp	/^double trace(const Matx<_Tp, m, n>& a)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a)
cv::transform	core/core.hpp	/^CV_EXPORTS_W void transform(InputArray src, OutputArray dst, InputArray m );$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, InputArray m )
cv::transpose	core/core.hpp	/^CV_EXPORTS_W void transpose(InputArray src, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst)
cv::undistort	imgproc/imgproc.hpp	/^CV_EXPORTS_W void undistort( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray newCameraMatrix=noArray() )
cv::undistortPoints	imgproc/imgproc.hpp	/^CV_EXPORTS void undistortPoints( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray R=noArray(), InputArray P=noArray())
cv::updateMotionHistory	video/tracking.hpp	/^CV_EXPORTS_W void updateMotionHistory( InputArray silhouette, InputOutputArray mhi,$/;"	p	namespace:cv	signature:( InputArray silhouette, InputOutputArray mhi, double timestamp, double duration )
cv::useOptimized	core/core.hpp	/^CV_EXPORTS_W bool useOptimized();$/;"	p	namespace:cv	signature:()
cv::validateDisparity	calib3d/calib3d.hpp	/^CV_EXPORTS_W void validateDisparity( InputOutputArray disparity, InputArray cost,$/;"	p	namespace:cv	signature:( InputOutputArray disparity, InputArray cost, int minDisparity, int numberOfDisparities, int disp12MaxDisp=1 )
cv::vconcat	core/core.hpp	/^CV_EXPORTS void vconcat(InputArray src1, InputArray src2, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst)
cv::vconcat	core/core.hpp	/^CV_EXPORTS void vconcat(const Mat* src, size_t nsrc, OutputArray dst);$/;"	p	namespace:cv	signature:(const Mat* src, size_t nsrc, OutputArray dst)
cv::vconcat	core/core.hpp	/^CV_EXPORTS_W void vconcat(InputArray src, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst)
cv::waitKey	highgui/highgui.hpp	/^CV_EXPORTS_W int waitKey(int delay=0);$/;"	p	namespace:cv	signature:(int delay=0)
cv::warpAffine	imgproc/imgproc.hpp	/^CV_EXPORTS_W void warpAffine( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, InputArray M, Size dsize, int flags=INTER_LINEAR, int borderMode=BORDER_CONSTANT, const Scalar& borderValue=Scalar())
cv::warpPerspective	imgproc/imgproc.hpp	/^CV_EXPORTS_W void warpPerspective( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, InputArray M, Size dsize, int flags=INTER_LINEAR, int borderMode=BORDER_CONSTANT, const Scalar& borderValue=Scalar())
cv::watershed	imgproc/imgproc.hpp	/^CV_EXPORTS_W void watershed( InputArray image, InputOutputArray markers );$/;"	p	namespace:cv	signature:( InputArray image, InputOutputArray markers )
cv::windowedMatchingMask	features2d/features2d.hpp	/^CV_EXPORTS Mat windowedMatchingMask( const vector<KeyPoint>& keypoints1, const vector<KeyPoint>& keypoints2,$/;"	p	namespace:cv	signature:( const vector<KeyPoint>& keypoints1, const vector<KeyPoint>& keypoints2, float maxDeltaX, float maxDeltaY )
cv::write	core/operations.hpp	/^CV_EXPORTS void write( FileStorage& fs, const string& name, const SparseMat& value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, const SparseMat& value )
cv::write	core/operations.hpp	/^CV_EXPORTS_W void write( FileStorage& fs, const string& name, const Mat& value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, const Mat& value )
cv::write	core/operations.hpp	/^CV_EXPORTS_W void write( FileStorage& fs, const string& name, const string& value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, const string& value )
cv::write	core/operations.hpp	/^CV_EXPORTS_W void write( FileStorage& fs, const string& name, double value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, double value )
cv::write	core/operations.hpp	/^CV_EXPORTS_W void write( FileStorage& fs, const string& name, float value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, float value )
cv::write	core/operations.hpp	/^CV_EXPORTS_W void write( FileStorage& fs, const string& name, int value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, int value )
cv::write	core/operations.hpp	/^inline void write(FileStorage& fs, const Range& r )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Range& r )
cv::write	core/operations.hpp	/^inline void write(FileStorage& fs, const string& name, const Range& r )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Range& r )
cv::write	core/operations.hpp	/^template<> inline void write( FileStorage& fs, const double& value )$/;"	f	namespace:cv	signature:( FileStorage& fs, const double& value )
cv::write	core/operations.hpp	/^template<> inline void write( FileStorage& fs, const float& value )$/;"	f	namespace:cv	signature:( FileStorage& fs, const float& value )
cv::write	core/operations.hpp	/^template<> inline void write( FileStorage& fs, const int& value )$/;"	f	namespace:cv	signature:( FileStorage& fs, const int& value )
cv::write	core/operations.hpp	/^template<> inline void write( FileStorage& fs, const string& value )$/;"	f	namespace:cv	signature:( FileStorage& fs, const string& value )
cv::write	core/operations.hpp	/^template<typename _Tp, int cn> inline void write(FileStorage& fs, const Vec<_Tp, cn>& v )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Vec<_Tp, cn>& v )
cv::write	core/operations.hpp	/^template<typename _Tp, int cn> inline void write(FileStorage& fs, const string& name, const Vec<_Tp, cn>& v )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Vec<_Tp, cn>& v )
cv::write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Complex<_Tp>& c )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Complex<_Tp>& c )
cv::write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Point3_<_Tp>& pt )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Point3_<_Tp>& pt )
cv::write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Point_<_Tp>& pt )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Point_<_Tp>& pt )
cv::write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Rect_<_Tp>& r )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Rect_<_Tp>& r )
cv::write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Scalar_<_Tp>& s )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Scalar_<_Tp>& s )
cv::write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Size_<_Tp>& sz )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Size_<_Tp>& sz )
cv::write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const _Tp& value)$/;"	f	namespace:cv	signature:(FileStorage& fs, const _Tp& value)
cv::write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Complex<_Tp>& c )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Complex<_Tp>& c )
cv::write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Point3_<_Tp>& pt )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Point3_<_Tp>& pt )
cv::write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Point_<_Tp>& pt )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Point_<_Tp>& pt )
cv::write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Rect_<_Tp>& r )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Rect_<_Tp>& r )
cv::write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Scalar_<_Tp>& s )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Scalar_<_Tp>& s )
cv::write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Size_<_Tp>& sz )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Size_<_Tp>& sz )
cv::write	core/operations.hpp	/^template<typename _Tp> static inline void write( FileStorage& fs, const vector<_Tp>& vec )$/;"	f	namespace:cv	signature:( FileStorage& fs, const vector<_Tp>& vec )
cv::write	features2d/features2d.hpp	/^CV_EXPORTS void write(FileStorage& fs, const string& name, const vector<KeyPoint>& keypoints);$/;"	p	namespace:cv	signature:(FileStorage& fs, const string& name, const vector<KeyPoint>& keypoints)
cv::writeScalar	core/operations.hpp	/^CV_EXPORTS void writeScalar( FileStorage& fs, const string& value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& value )
cv::writeScalar	core/operations.hpp	/^CV_EXPORTS void writeScalar( FileStorage& fs, double value );$/;"	p	namespace:cv	signature:( FileStorage& fs, double value )
cv::writeScalar	core/operations.hpp	/^CV_EXPORTS void writeScalar( FileStorage& fs, float value );$/;"	p	namespace:cv	signature:( FileStorage& fs, float value )
cv::writeScalar	core/operations.hpp	/^CV_EXPORTS void writeScalar( FileStorage& fs, int value );$/;"	p	namespace:cv	signature:( FileStorage& fs, int value )
cvAXPY	core/core_c.h	520;"	d
cvAbs	core/core_c.h	598;"	d
cvAccMask	legacy/compat.hpp	124;"	d
cvAddSearchPath	highgui/highgui_c.h	476;"	d
cvAlign	core/internal.hpp	/^CV_INLINE int cvAlign( int size, int align )$/;"	f	signature:( int size, int align )
cvAlignPtr	core/internal.hpp	/^CV_INLINE void* cvAlignPtr( const void* ptr, int align CV_DEFAULT(32) )$/;"	f	signature:( const void* ptr, int align CV_DEFAULT(32) )
cvAttrList	core/types_c.h	/^CV_INLINE CvAttrList cvAttrList( const char** attr CV_DEFAULT(NULL),$/;"	f	signature:( const char** attr CV_DEFAULT(NULL), CvAttrList* next CV_DEFAULT(NULL) )
cvBlob	legacy/blobtrack.hpp	/^inline CvBlob cvBlob(float x,float y, float w, float h)$/;"	f	signature:(float x,float y, float w, float h)
cvCalcBackProject	imgproc/imgproc_c.h	602;"	d
cvCalcBackProjectPatch	imgproc/imgproc_c.h	610;"	d
cvCalcContoursCorrespondence	legacy/legacy.hpp	/^CvSeq* cvCalcContoursCorrespondence( const CvSeq* contour1,$/;"	p	signature:( const CvSeq* contour1, const CvSeq* contour2, CvMemStorage* storage)
cvCalcEMD	legacy/compat.hpp	/^CV_EXPORTS  float  cvCalcEMD( const float* signature1, int size1,$/;"	p	signature:( const float* signature1, int size1, const float* signature2, int size2, int dims, int dist_type CV_DEFAULT(CV_DIST_L2), CvDistanceFunction dist_func CV_DEFAULT(0), float* lower_bound CV_DEFAULT(0), void* user_param CV_DEFAULT(0))
cvCalcHist	imgproc/imgproc_c.h	/^CV_INLINE  void  cvCalcHist( IplImage** image, CvHistogram* hist,$/;"	f	signature:( IplImage** image, CvHistogram* hist, int accumulate CV_DEFAULT(0), const CvArr* mask CV_DEFAULT(NULL) )
cvCalcHistMask	legacy/compat.hpp	130;"	d
cvCalibrateCamera	legacy/compat.hpp	/^CV_EXPORTS void cvCalibrateCamera( int image_count, int* _point_counts,$/;"	p	signature:( int image_count, int* _point_counts, CvSize image_size, CvPoint2D32f* _image_points, CvPoint3D32f* _object_points, float* _distortion_coeffs, float* _camera_matrix, float* _translation_vectors, float* _rotation_matrices, int flags )
cvCalibrateCamera_64d	legacy/compat.hpp	/^CV_EXPORTS void cvCalibrateCamera_64d( int image_count, int* _point_counts,$/;"	p	signature:( int image_count, int* _point_counts, CvSize image_size, CvPoint2D64f* _image_points, CvPoint3D64f* _object_points, double* _distortion_coeffs, double* _camera_matrix, double* _translation_vectors, double* _rotation_matrices, int flags )
cvCaptureFromAVI	highgui/highgui_c.h	473;"	d
cvCaptureFromCAM	highgui/highgui_c.h	472;"	d
cvCaptureFromFile	highgui/highgui_c.h	471;"	d
cvCeil	core/types_c.h	/^CV_INLINE  int  cvCeil( double value )$/;"	f	signature:( double value )
cvCheckArray	core/core_c.h	645;"	d
cvCircleAA	legacy/compat.hpp	/^CV_EXPORTS void  cvCircleAA( CvArr* img, CvPoint center, int radius,$/;"	p	signature:( CvArr* img, CvPoint center, int radius, double color, int scale CV_DEFAULT(0) )
cvCloneSeq	core/core_c.h	/^CV_INLINE CvSeq* cvCloneSeq( const CvSeq* seq, CvMemStorage* storage CV_DEFAULT(NULL))$/;"	f	signature:( const CvSeq* seq, CvMemStorage* storage CV_DEFAULT(NULL))
cvContourBoundingRect	legacy/compat.hpp	/^CV_EXPORTS CvRect  cvContourBoundingRect( void* point_set, int update CV_DEFAULT(0));$/;"	p	signature:( void* point_set, int update CV_DEFAULT(0))
cvContourMoments	legacy/compat.hpp	179;"	d
cvContourPerimeter	imgproc/imgproc_c.h	/^CV_INLINE double cvContourPerimeter( const void* contour )$/;"	f	signature:( const void* contour )
cvConvert	core/core_c.h	456;"	d
cvConvertPointsHomogenious	legacy/compat.hpp	601;"	d
cvConvexHull	legacy/compat.hpp	/^CV_EXPORTS void cvConvexHull( CvPoint* points, int num_points,$/;"	p	signature:( CvPoint* points, int num_points, CvRect* bound_rect, int orientation, int* hull, int* hullsize )
cvCopyImage	legacy/compat.hpp	212;"	d
cvCreateAVIWriter	highgui/highgui_c.h	474;"	d
cvCreateBlobDetectorCC	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobDetector* cvCreateBlobDetectorCC();$/;"	p	signature:()
cvCreateBlobDetectorSimple	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobDetector* cvCreateBlobDetectorSimple();$/;"	p	signature:()
cvCreateBlobTrackerAuto	legacy/blobtrack.hpp	/^inline CvBlobTrackerAuto* cvCreateBlobTrackerAuto(int type, void* param)$/;"	f	signature:(int type, void* param)
cvCreateBlobTrackerAuto1	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackerAuto* cvCreateBlobTrackerAuto1(CvBlobTrackerAutoParam1* param = NULL);$/;"	p	signature:(CvBlobTrackerAutoParam1* param = NULL)
cvCreateBlobTrackerCC	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerCC();$/;"	p	signature:()
cvCreateBlobTrackerCCMSPF	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerCCMSPF();$/;"	p	signature:()
cvCreateBlobTrackerLHR	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerLHR(CvBlobTrackerParamLH* \/*param*\/ = NULL);$/;"	p	signature:(CvBlobTrackerParamLH* = NULL)
cvCreateBlobTrackerLHRS	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerLHRS(CvBlobTrackerParamLH* \/*param*\/ = NULL);$/;"	p	signature:(CvBlobTrackerParamLH* = NULL)
cvCreateBlobTrackerMS	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerMS();$/;"	p	signature:()
cvCreateBlobTrackerMS1	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerMS1(CvBlobTrackerParamMS* param);$/;"	p	signature:(CvBlobTrackerParamMS* param)
cvCreateBlobTrackerMS1ByList	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerMS1ByList();$/;"	p	signature:()
cvCreateBlobTrackerMS2	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerMS2(CvBlobTrackerParamMS* param);$/;"	p	signature:(CvBlobTrackerParamMS* param)
cvCreateBlobTrackerMSFG	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerMSFG();$/;"	p	signature:()
cvCreateBlobTrackerMSFGS	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerMSFGS();$/;"	p	signature:()
cvCreateBlobTrackerMSPF	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTracker* cvCreateBlobTrackerMSPF();$/;"	p	signature:()
cvCreateFGDetectorBase	legacy/blobtrack.hpp	/^CV_EXPORTS CvFGDetector* cvCreateFGDetectorBase(int type, void *param);$/;"	p	signature:(int type, void *param)
cvCreateImageData	legacy/compat.hpp	106;"	d
cvCreateModuleBlobTrackAnalysisHistP	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackAnalysis* cvCreateModuleBlobTrackAnalysisHistP();$/;"	p	signature:()
cvCreateModuleBlobTrackAnalysisHistPV	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackAnalysis* cvCreateModuleBlobTrackAnalysisHistPV();$/;"	p	signature:()
cvCreateModuleBlobTrackAnalysisHistPVS	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackAnalysis* cvCreateModuleBlobTrackAnalysisHistPVS();$/;"	p	signature:()
cvCreateModuleBlobTrackAnalysisHistSS	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackAnalysis* cvCreateModuleBlobTrackAnalysisHistSS();$/;"	p	signature:()
cvCreateModuleBlobTrackAnalysisIOR	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackAnalysis* cvCreateModuleBlobTrackAnalysisIOR();$/;"	p	signature:()
cvCreateModuleBlobTrackAnalysisTrackDist	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackAnalysis* cvCreateModuleBlobTrackAnalysisTrackDist();$/;"	p	signature:()
cvCreateModuleBlobTrackGen1	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackGen* cvCreateModuleBlobTrackGen1();$/;"	p	signature:()
cvCreateModuleBlobTrackGenYML	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackGen* cvCreateModuleBlobTrackGenYML();$/;"	p	signature:()
cvCreateModuleBlobTrackPostProcKalman	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackPostProc* cvCreateModuleBlobTrackPostProcKalman();$/;"	p	signature:()
cvCreateModuleBlobTrackPostProcTimeAverExp	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackPostProc* cvCreateModuleBlobTrackPostProcTimeAverExp();$/;"	p	signature:()
cvCreateModuleBlobTrackPostProcTimeAverRect	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackPostProc* cvCreateModuleBlobTrackPostProcTimeAverRect();$/;"	p	signature:()
cvCreateModuleBlobTrackPredictKalman	legacy/blobtrack.hpp	/^CV_EXPORTS CvBlobTrackPredictor* cvCreateModuleBlobTrackPredictKalman();$/;"	p	signature:()
cvCreateProb	legacy/blobtrack.hpp	/^inline CvProb* cvCreateProb(int type, int dim, CvSize size = cvSize(1,1), void* \/*param*\/ = NULL)$/;"	f	signature:(int type, int dim, CvSize size = cvSize(1,1), void* = NULL)
cvCreateProbHist	legacy/blobtrack.hpp	/^CV_EXPORTS CvProb* cvCreateProbHist(int dim, CvSize size);$/;"	p	signature:(int dim, CvSize size)
cvCreateProbMG	legacy/blobtrack.hpp	/^CV_EXPORTS CvProb* cvCreateProbMG(int dim, CvSize size, int sample_num);$/;"	p	signature:(int dim, CvSize size, int sample_num)
cvCreateProbMG2	legacy/blobtrack.hpp	/^CV_EXPORTS CvProb* cvCreateProbMG2(int dim, CvSize size, int sample_num);$/;"	p	signature:(int dim, CvSize size, int sample_num)
cvCreateProbS	legacy/blobtrack.hpp	/^CV_EXPORTS CvProb* cvCreateProbS(int dim, CvSize size, int sample_num);$/;"	p	signature:(int dim, CvSize size, int sample_num)
cvCreateSubdivDelaunay2D	imgproc/imgproc_c.h	/^CV_INLINE  CvSubdiv2D* cvCreateSubdivDelaunay2D( CvRect rect, CvMemStorage* storage )$/;"	f	signature:( CvRect rect, CvMemStorage* storage )
cvCreateTestSeq	legacy/blobtrack.hpp	/^CV_EXPORTS CvTestSeq* cvCreateTestSeq(char* pConfigfile, char** videos, int numvideo, float Scale = 1, int noise_type = CV_NOISE_NONE, double noise_ampl = 0);$/;"	p	signature:(char* pConfigfile, char** videos, int numvideo, float Scale = 1, int noise_type = CV_NOISE_NONE, double noise_ampl = 0)
cvCreateTracks_AreaErr	legacy/blobtrack.hpp	/^CV_EXPORTS void cvCreateTracks_AreaErr(CvBlobTrackSeq *TS1, CvBlobTrackSeq *TS2, int addW, int addH);$/;"	p	signature:(CvBlobTrackSeq *TS1, CvBlobTrackSeq *TS2, int addW, int addH)
cvCreateTracks_One	legacy/blobtrack.hpp	/^CV_EXPORTS void cvCreateTracks_One(CvBlobTrackSeq *TS);$/;"	p	signature:(CvBlobTrackSeq *TS)
cvCreateTracks_Same	legacy/blobtrack.hpp	/^CV_EXPORTS void cvCreateTracks_Same(CvBlobTrackSeq *TS1, CvBlobTrackSeq *TS2);$/;"	p	signature:(CvBlobTrackSeq *TS1, CvBlobTrackSeq *TS2)
cvCvtPixToPlane	legacy/compat.hpp	140;"	d
cvCvtPlaneToPix	legacy/compat.hpp	141;"	d
cvCvtScale	core/core_c.h	454;"	d
cvCvtScaleAbs	core/core_c.h	467;"	d
cvDecRefData	core/core_c.h	/^CV_INLINE  void  cvDecRefData( CvArr* arr )$/;"	f	signature:( CvArr* arr )
cvDetectedBlob	legacy/blobtrack.hpp	/^CV_INLINE CvDetectedBlob cvDetectedBlob( float x, float y, float w, float h, int ID = 0, float response = 0.0F )$/;"	f	signature:( float x, float y, float w, float h, int ID = 0, float response = 0.0F )
cvDrawCircle	core/core_c.h	1330;"	d
cvDrawEllipse	core/core_c.h	1331;"	d
cvDrawLine	core/core_c.h	1329;"	d
cvDrawPolyLine	core/core_c.h	1332;"	d
cvDrawRect	core/core_c.h	1328;"	d
cvEllipseAA	legacy/compat.hpp	/^CV_EXPORTS void  cvEllipseAA( CvArr* img, CvPoint center, CvSize axes,$/;"	p	signature:( CvArr* img, CvPoint center, CvSize axes, double angle, double start_angle, double end_angle, double color, int scale CV_DEFAULT(0) )
cvEllipseBox	core/core_c.h	/^CV_INLINE  void  cvEllipseBox( CvArr* img, CvBox2D box, CvScalar color,$/;"	f	signature:( CvArr* img, CvBox2D box, CvScalar color, int thickness CV_DEFAULT(1), int line_type CV_DEFAULT(8), int shift CV_DEFAULT(0) )
cvEndScanGraph	legacy/compat.hpp	/^CV_EXPORTS  void  cvEndScanGraph( CvGraphScanner* scanner );$/;"	p	signature:( CvGraphScanner* scanner )
cvFFT	core/core_c.h	891;"	d
cvFillImage	legacy/compat.hpp	/^CV_EXPORTS void cvFillImage( CvArr* mat, double color );$/;"	p	signature:( CvArr* mat, double color )
cvFindChessBoardCornerGuesses	legacy/compat.hpp	/^CV_EXPORTS int cvFindChessBoardCornerGuesses( const void* arr, void* thresharr,$/;"	p	signature:( const void* arr, void* thresharr, CvMemStorage* storage, CvSize pattern_size, CvPoint2D32f * corners, int *corner_count )
cvFindDataMatrix	objdetect/objdetect.hpp	/^CV_EXPORTS std::deque<CvDataMatrixCode> cvFindDataMatrix(CvMat *im);$/;"	p	signature:(CvMat *im)
cvFindExtrinsicCameraParams	legacy/compat.hpp	/^CV_EXPORTS void cvFindExtrinsicCameraParams( int point_count,$/;"	p	signature:( int point_count, CvSize image_size, CvPoint2D32f* _image_points, CvPoint3D32f* _object_points, float* focal_length, CvPoint2D32f principal_point, float* _distortion_coeffs, float* _rotation_vector, float* _translation_vector )
cvFindExtrinsicCameraParams_64d	legacy/compat.hpp	/^CV_EXPORTS void cvFindExtrinsicCameraParams_64d( int point_count,$/;"	p	signature:( int point_count, CvSize image_size, CvPoint2D64f* _image_points, CvPoint3D64f* _object_points, double* focal_length, CvPoint2D64f principal_point, double* _distortion_coeffs, double* _rotation_vector, double* _translation_vector )
cvFindFace	legacy/legacy.hpp	/^CvSeq * cvFindFace(IplImage * Image,CvMemStorage* storage);$/;"	p	signature:(IplImage * Image,CvMemStorage* storage)
cvFindFundamentalMatrix	legacy/compat.hpp	/^CV_EXPORTS void  cvFindFundamentalMatrix( int* points1, int* points2,$/;"	p	signature:( int* points1, int* points2, int numpoints, int method, float* matrix )
cvFitEllipse	legacy/compat.hpp	/^CV_EXPORTS  void  cvFitEllipse( const CvPoint2D32f* points, int count, CvBox2D* box );$/;"	p	signature:( const CvPoint2D32f* points, int count, CvBox2D* box )
cvFitLine2D	legacy/compat.hpp	/^CV_EXPORTS  void  cvFitLine2D( CvPoint2D32f* points, int count, int dist,$/;"	p	signature:( CvPoint2D32f* points, int count, int dist, void *param, float reps, float aeps, float* line )
cvFitLine3D	legacy/compat.hpp	/^CV_EXPORTS  void  cvFitLine3D( CvPoint3D32f* points, int count, int dist,$/;"	p	signature:( CvPoint3D32f* points, int count, int dist, void *param, float reps, float aeps, float* line )
cvFloor	core/types_c.h	/^CV_INLINE  int  cvFloor( double value )$/;"	f	signature:( double value )
cvFont	core/core_c.h	/^CV_INLINE CvFont cvFont( double scale, int thickness CV_DEFAULT(1) )$/;"	f	signature:( double scale, int thickness CV_DEFAULT(1) )
cvFree	core/core_c.h	70;"	d
cvFuncName	core/core_c.h	1801;"	d
cvGetAt	legacy/compat.hpp	182;"	d
cvGetCol	core/core_c.h	/^CV_INLINE  CvMat*  cvGetCol( const CvArr* arr, CvMat* submat, int col )$/;"	f	signature:( const CvArr* arr, CvMat* submat, int col )
cvGetGraphVtx	core/core_c.h	1191;"	d
cvGetHistValue_1D	legacy/compat.hpp	261;"	d
cvGetHistValue_2D	legacy/compat.hpp	263;"	d
cvGetHistValue_3D	legacy/compat.hpp	265;"	d
cvGetHistValue_nD	legacy/compat.hpp	267;"	d
cvGetImageRawData	legacy/compat.hpp	109;"	d
cvGetMatSize	core/internal.hpp	/^CV_INLINE  CvSize  cvGetMatSize( const CvMat* mat )$/;"	f	signature:( const CvMat* mat )
cvGetNextSparseNode	core/core_c.h	/^CV_INLINE CvSparseNode* cvGetNextSparseNode( CvSparseMatIterator* mat_iterator )$/;"	f	signature:( CvSparseMatIterator* mat_iterator )
cvGetPtrAt	legacy/compat.hpp	181;"	d
cvGetRow	core/core_c.h	/^CV_INLINE  CvMat*  cvGetRow( const CvArr* arr, CvMat* submat, int row )$/;"	f	signature:( const CvArr* arr, CvMat* submat, int row )
cvGetSetElem	core/core_c.h	/^CV_INLINE CvSetElem* cvGetSetElem( const CvSet* set_header, int index )$/;"	f	signature:( const CvSet* set_header, int index )
cvGetSubArr	core/core_c.h	174;"	d
cvGraphEdgeIdx	core/core_c.h	1197;"	d
cvGraphFindEdge	core/core_c.h	1178;"	d
cvGraphFindEdgeByPtr	core/core_c.h	1179;"	d
cvGraphGetEdgeCount	core/core_c.h	1200;"	d
cvGraphGetVtxCount	core/core_c.h	1199;"	d
cvGraphVtxIdx	core/core_c.h	1194;"	d
cvHaarDetectObjectsForROC	objdetect/objdetect.hpp	/^CV_EXPORTS CvSeq* cvHaarDetectObjectsForROC( const CvArr* image,$/;"	p	signature:( const CvArr* image, CvHaarClassifierCascade* cascade, CvMemStorage* storage, std::vector<int>& rejectLevels, std::vector<double>& levelWeightds, double scale_factor CV_DEFAULT(1.1), int min_neighbors CV_DEFAULT(3), int flags CV_DEFAULT(0), CvSize min_size CV_DEFAULT(cvSize(0,0)), CvSize max_size CV_DEFAULT(cvSize(0,0)), bool outputRejectLevels = false )
cvHoughLines	legacy/compat.hpp	/^CV_EXPORTS  int  cvHoughLines( CvArr* image, double rho,$/;"	p	signature:( CvArr* image, double rho, double theta, int threshold, float* lines, int linesNumber )
cvHoughLinesP	legacy/compat.hpp	/^CV_EXPORTS  int  cvHoughLinesP( CvArr* image, double rho,$/;"	p	signature:( CvArr* image, double rho, double theta, int threshold, int lineLength, int lineGap, int* lines, int linesNumber )
cvHoughLinesSDiv	legacy/compat.hpp	/^CV_EXPORTS  int  cvHoughLinesSDiv( CvArr* image, double rho, int srn,$/;"	p	signature:( CvArr* image, double rho, int srn, double theta, int stn, int threshold, float* lines, int linesNumber )
cvIncRefData	core/core_c.h	/^CV_INLINE  int  cvIncRefData( CvArr* arr )$/;"	f	signature:( CvArr* arr )
cvIntegralImage	legacy/compat.hpp	116;"	d
cvInv	core/core_c.h	747;"	d
cvInvSqrt	core/types_c.h	346;"	d
cvIplDepth	core/types_c.h	/^CV_INLINE int cvIplDepth( int type )$/;"	f	signature:( int type )
cvIsInf	core/types_c.h	/^CV_INLINE int cvIsInf( double value )$/;"	f	signature:( double value )
cvIsNaN	core/types_c.h	/^CV_INLINE int cvIsNaN( double value )$/;"	f	signature:( double value )
cvKMeans	legacy/compat.hpp	/^CV_EXPORTS  void  cvKMeans( int num_clusters, float** samples,$/;"	p	signature:( int num_clusters, float** samples, int num_samples, int vec_size, CvTermCriteria termcrit, int* cluster_idx )
cvKalmanUpdateByMeasurement	video/tracking.hpp	238;"	d
cvKalmanUpdateByTime	video/tracking.hpp	237;"	d
cvLineAA	legacy/compat.hpp	/^CV_EXPORTS void  cvLineAA( CvArr* img, CvPoint pt1, CvPoint pt2,$/;"	p	signature:( CvArr* img, CvPoint pt1, CvPoint pt2, double color, int scale CV_DEFAULT(0))
cvMahalonobis	core/core_c.h	813;"	d
cvMake2DPoints	legacy/compat.hpp	596;"	d
cvMake3DPoints	legacy/compat.hpp	597;"	d
cvMat	core/types_c.h	/^CV_INLINE CvMat cvMat( int rows, int cols, int type, void* data CV_DEFAULT(NULL))$/;"	f	signature:( int rows, int cols, int type, void* data CV_DEFAULT(NULL))
cvMatArray	legacy/compat.hpp	/^CV_EXPORTS CvMat cvMatArray( int rows, int cols, int type,$/;"	p	signature:( int rows, int cols, int type, int count, void* data CV_DEFAULT(0))
cvMatMul	core/core_c.h	680;"	d
cvMatMulAdd	core/core_c.h	679;"	d
cvMatMulAddEx	core/core_c.h	690;"	d
cvMatMulAddS	core/core_c.h	697;"	d
cvMatchContours	legacy/compat.hpp	117;"	d
cvMean	legacy/compat.hpp	/^CV_EXPORTS double cvMean( const CvArr* image, const CvArr* mask CV_DEFAULT(0));$/;"	p	signature:( const CvArr* image, const CvArr* mask CV_DEFAULT(0))
cvMeanMask	legacy/compat.hpp	185;"	d
cvMean_StdDev	legacy/compat.hpp	/^CV_EXPORTS void  cvMean_StdDev( const CvArr* image, double* mean, double* sdv,$/;"	p	signature:( const CvArr* image, double* mean, double* sdv, const CvArr* mask CV_DEFAULT(0))
cvMean_StdDevMask	legacy/compat.hpp	186;"	d
cvMinAreaRect	legacy/compat.hpp	/^CV_EXPORTS void cvMinAreaRect( CvPoint* points, int n,$/;"	p	signature:( CvPoint* points, int n, int left, int bottom, int right, int top, CvPoint2D32f* anchor, CvPoint2D32f* vect1, CvPoint2D32f* vect2 )
cvMinMaxLocMask	legacy/compat.hpp	190;"	d
cvMirror	core/core_c.h	720;"	d
cvMorphContours	legacy/legacy.hpp	/^CvSeq* cvMorphContours( const CvSeq* contour1, const CvSeq* contour2,$/;"	p	signature:( const CvSeq* contour1, const CvSeq* contour2, CvSeq* corr, double alpha, CvMemStorage* storage )
cvMultiplyAccMask	legacy/compat.hpp	126;"	d
cvNormMask	legacy/compat.hpp	188;"	d
cvPoint	core/types_c.h	/^CV_INLINE  CvPoint  cvPoint( int x, int y )$/;"	f	signature:( int x, int y )
cvPoint2D32f	core/types_c.h	/^CV_INLINE  CvPoint2D32f  cvPoint2D32f( double x, double y )$/;"	f	signature:( double x, double y )
cvPoint2D64f	core/types_c.h	/^CV_INLINE  CvPoint2D64f  cvPoint2D64f( double x, double y )$/;"	f	signature:( double x, double y )
cvPoint3D32f	core/types_c.h	/^CV_INLINE  CvPoint3D32f  cvPoint3D32f( double x, double y, double z )$/;"	f	signature:( double x, double y, double z )
cvPoint3D64f	core/types_c.h	/^CV_INLINE  CvPoint3D64f  cvPoint3D64f( double x, double y, double z )$/;"	f	signature:( double x, double y, double z )
cvPointFrom32f	core/types_c.h	/^CV_INLINE  CvPoint  cvPointFrom32f( CvPoint2D32f point )$/;"	f	signature:( CvPoint2D32f point )
cvPointTo32f	core/types_c.h	/^CV_INLINE  CvPoint2D32f  cvPointTo32f( CvPoint point )$/;"	f	signature:( CvPoint point )
cvPolyLineAA	legacy/compat.hpp	/^CV_EXPORTS void  cvPolyLineAA( CvArr* img, CvPoint** pts, int* npts, int contours,$/;"	p	signature:( CvArr* img, CvPoint** pts, int* npts, int contours, int is_closed, double color, int scale CV_DEFAULT(0) )
cvPostBoostingFindFace	legacy/legacy.hpp	/^CvSeq * cvPostBoostingFindFace(IplImage * Image,CvMemStorage* storage);$/;"	p	signature:(IplImage * Image,CvMemStorage* storage)
cvProject3D	legacy/compat.hpp	/^CV_EXPORTS  void  cvProject3D( CvPoint3D32f* points3D, int count,$/;"	p	signature:( CvPoint3D32f* points3D, int count, CvPoint2D32f* points2D, int xIndx CV_DEFAULT(0), int yIndx CV_DEFAULT(1))
cvProjectPoints	legacy/compat.hpp	/^CV_EXPORTS void  cvProjectPoints( int point_count, CvPoint3D64f* _object_points,$/;"	p	signature:( int point_count, CvPoint3D64f* _object_points, double* _rotation_vector, double* _translation_vector, double* focal_length, CvPoint2D64f principal_point, double* _distortion, CvPoint2D64f* _image_points, double* _deriv_points_rotation_matrix, double* _deriv_points_translation_vect, double* _deriv_points_focal, double* _deriv_points_principal_point, double* _deriv_points_distortion_coeffs )
cvProjectPointsSimple	legacy/compat.hpp	/^CV_EXPORTS void  cvProjectPointsSimple( int point_count, CvPoint3D64f* _object_points,$/;"	p	signature:( int point_count, CvPoint3D64f* _object_points, double* _rotation_matrix, double* _translation_vector, double* _camera_matrix, double* _distortion, CvPoint2D64f* _image_points )
cvPseudoInv	legacy/compat.hpp	177;"	d
cvPseudoInverse	legacy/compat.hpp	/^CV_EXPORTS double cvPseudoInverse( const CvArr* src, CvArr* dst );$/;"	p	signature:( const CvArr* src, CvArr* dst )
cvQueryHistValue_1D	legacy/compat.hpp	250;"	d
cvQueryHistValue_2D	legacy/compat.hpp	252;"	d
cvQueryHistValue_3D	legacy/compat.hpp	254;"	d
cvQueryHistValue_nD	legacy/compat.hpp	256;"	d
cvROIToRect	core/types_c.h	/^CV_INLINE  CvRect  cvROIToRect( IplROI roi )$/;"	f	signature:( IplROI roi )
cvRand	legacy/compat.hpp	/^CV_EXPORTS void cvRand( CvRandState* state, CvArr* arr );$/;"	p	signature:( CvRandState* state, CvArr* arr )
cvRandInit	legacy/compat.hpp	/^CV_EXPORTS void  cvRandInit( CvRandState* state, double param1,$/;"	p	signature:( CvRandState* state, double param1, double param2, int seed, int disttype CV_DEFAULT(CV_RAND_UNI))
cvRandInt	core/types_c.h	/^CV_INLINE unsigned cvRandInt( CvRNG* rng )$/;"	f	signature:( CvRNG* rng )
cvRandNext	legacy/compat.hpp	161;"	d
cvRandReal	core/types_c.h	/^CV_INLINE double cvRandReal( CvRNG* rng )$/;"	f	signature:( CvRNG* rng )
cvRandSetRange	legacy/compat.hpp	/^CV_EXPORTS void  cvRandSetRange( CvRandState* state, double param1,$/;"	p	signature:( CvRandState* state, double param1, double param2, int index CV_DEFAULT(-1))
cvReadByName	core/core_c.h	/^CV_INLINE void* cvReadByName( CvFileStorage* fs, const CvFileNode* map,$/;"	f	signature:( CvFileStorage* fs, const CvFileNode* map, const char* name, CvAttrList* attributes CV_DEFAULT(NULL) )
cvReadInt	core/core_c.h	/^CV_INLINE int cvReadInt( const CvFileNode* node, int default_value CV_DEFAULT(0) )$/;"	f	signature:( const CvFileNode* node, int default_value CV_DEFAULT(0) )
cvReadIntByName	core/core_c.h	/^CV_INLINE int cvReadIntByName( const CvFileStorage* fs, const CvFileNode* map,$/;"	f	signature:( const CvFileStorage* fs, const CvFileNode* map, const char* name, int default_value CV_DEFAULT(0) )
cvReadReal	core/core_c.h	/^CV_INLINE double cvReadReal( const CvFileNode* node, double default_value CV_DEFAULT(0.) )$/;"	f	signature:( const CvFileNode* node, double default_value CV_DEFAULT(0.) )
cvReadRealByName	core/core_c.h	/^CV_INLINE double cvReadRealByName( const CvFileStorage* fs, const CvFileNode* map,$/;"	f	signature:( const CvFileStorage* fs, const CvFileNode* map, const char* name, double default_value CV_DEFAULT(0.) )
cvReadString	core/core_c.h	/^CV_INLINE const char* cvReadString( const CvFileNode* node,$/;"	f	signature:( const CvFileNode* node, const char* default_value CV_DEFAULT(NULL) )
cvReadStringByName	core/core_c.h	/^CV_INLINE const char* cvReadStringByName( const CvFileStorage* fs, const CvFileNode* map,$/;"	f	signature:( const CvFileStorage* fs, const CvFileNode* map, const char* name, const char* default_value CV_DEFAULT(NULL) )
cvReadStructByName	legacy/blobtrack.hpp	/^CV_EXPORTS void cvReadStructByName(CvFileStorage* fs, CvFileNode* node, const char* name, void* addr, const char* desc);$/;"	p	signature:(CvFileStorage* fs, CvFileNode* node, const char* name, void* addr, const char* desc)
cvRealScalar	core/types_c.h	/^CV_INLINE  CvScalar  cvRealScalar( double val0 )$/;"	f	signature:( double val0 )
cvRect	core/types_c.h	/^CV_INLINE  CvRect  cvRect( int x, int y, int width, int height )$/;"	f	signature:( int x, int y, int width, int height )
cvRectIntersection	legacy/blobtrack.hpp	/^CV_INLINE CvRect cvRectIntersection( const CvRect r1, const CvRect r2 )$/;"	f	signature:( const CvRect r1, const CvRect r2 )
cvRectToROI	core/types_c.h	/^CV_INLINE  IplROI  cvRectToROI( CvRect rect, int coi )$/;"	f	signature:( CvRect rect, int coi )
cvReleaseBlobDetector	legacy/blobtrack.hpp	/^CV_EXPORTS void cvReleaseBlobDetector(CvBlobDetector** ppBD);$/;"	p	signature:(CvBlobDetector** ppBD)
cvReleaseBlobTrackAnalysis	legacy/blobtrack.hpp	/^inline void cvReleaseBlobTrackAnalysis(CvBlobTrackAnalysis** pBTPP)$/;"	f	signature:(CvBlobTrackAnalysis** pBTPP)
cvReleaseBlobTrackGen	legacy/blobtrack.hpp	/^inline void cvReleaseBlobTrackGen(CvBlobTrackGen** pBTGen)$/;"	f	signature:(CvBlobTrackGen** pBTGen)
cvReleaseBlobTrackPostProc	legacy/blobtrack.hpp	/^inline void cvReleaseBlobTrackPostProc(CvBlobTrackPostProc** pBTPP)$/;"	f	signature:(CvBlobTrackPostProc** pBTPP)
cvReleaseBlobTracker	legacy/blobtrack.hpp	/^CV_EXPORTS void cvReleaseBlobTracker(CvBlobTracker**ppT );$/;"	p	signature:(CvBlobTracker**ppT )
cvReleaseBlobTrackerAuto	legacy/blobtrack.hpp	/^inline void cvReleaseBlobTrackerAuto(CvBlobTrackerAuto** ppT)$/;"	f	signature:(CvBlobTrackerAuto** ppT)
cvReleaseBlobTrackerOne	legacy/blobtrack.hpp	/^inline void cvReleaseBlobTrackerOne(CvBlobTrackerOne **ppT )$/;"	f	signature:(CvBlobTrackerOne **ppT )
cvReleaseFGDetector	legacy/blobtrack.hpp	/^CV_EXPORTS void cvReleaseFGDetector(CvFGDetector** ppT );$/;"	p	signature:(CvFGDetector** ppT )
cvReleaseImageData	legacy/compat.hpp	107;"	d
cvReleaseMatHeader	legacy/compat.hpp	213;"	d
cvReleaseMatND	core/core_c.h	/^CV_INLINE  void  cvReleaseMatND( CvMatND** mat )$/;"	f	signature:( CvMatND** mat )
cvReleaseProb	legacy/blobtrack.hpp	/^inline void cvReleaseProb(CvProb** ppProb){ppProb[0]->Release();ppProb[0]=NULL;}$/;"	f	signature:(CvProb** ppProb)
cvReleaseTestSeq	legacy/blobtrack.hpp	/^CV_EXPORTS void cvReleaseTestSeq(CvTestSeq** ppTestSeq);$/;"	p	signature:(CvTestSeq** ppTestSeq)
cvRemoveMemoryManager	legacy/compat.hpp	193;"	d
cvReshapeND	core/core_c.h	383;"	d
cvRodrigues	legacy/compat.hpp	/^CV_EXPORTS void  cvRodrigues( CvMat* rotation_matrix, CvMat* rotation_vector,$/;"	p	signature:( CvMat* rotation_matrix, CvMat* rotation_vector, CvMat* jacobian, int conv_type )
cvRound	core/types_c.h	/^CV_INLINE  int  cvRound( double value )$/;"	f	signature:( double value )
cvRunningAvgMask	legacy/compat.hpp	127;"	d
cvSURFPoint	features2d/features2d.hpp	/^CV_INLINE CvSURFPoint cvSURFPoint( CvPoint2D32f pt, int laplacian,$/;"	f	signature:( CvPoint2D32f pt, int laplacian, int size, float dir CV_DEFAULT(0), float hessian CV_DEFAULT(0))
cvScalar	core/types_c.h	/^CV_INLINE  CvScalar  cvScalar( double val0, double val1 CV_DEFAULT(0),$/;"	f	signature:( double val0, double val1 CV_DEFAULT(0), double val2 CV_DEFAULT(0), double val3 CV_DEFAULT(0))
cvScalarAll	core/types_c.h	/^CV_INLINE  CvScalar  cvScalarAll( double val0123 )$/;"	f	signature:( double val0123 )
cvScale	core/core_c.h	455;"	d
cvSetAt	legacy/compat.hpp	183;"	d
cvSetHistThresh	legacy/compat.hpp	129;"	d
cvSetImageData	legacy/compat.hpp	108;"	d
cvSetNew	core/core_c.h	/^CV_INLINE  CvSetElem* cvSetNew( CvSet* set_header )$/;"	f	signature:( CvSet* set_header )
cvSetPostprocessFuncWin32	highgui/highgui_c.h	498;"	d
cvSetPreprocessFuncWin32	highgui/highgui_c.h	497;"	d
cvSetRemoveByPtr	core/core_c.h	/^CV_INLINE  void cvSetRemoveByPtr( CvSet* set_header, void* elem )$/;"	f	signature:( CvSet* set_header, void* elem )
cvSize	core/types_c.h	/^CV_INLINE  CvSize  cvSize( int width, int height )$/;"	f	signature:( int width, int height )
cvSize2D32f	core/types_c.h	/^CV_INLINE  CvSize2D32f  cvSize2D32f( double width, double height )$/;"	f	signature:( double width, double height )
cvSlice	core/types_c.h	/^CV_INLINE  CvSlice  cvSlice( int start, int end )$/;"	f	signature:( int start, int end )
cvSqrt	core/types_c.h	347;"	d
cvSquareAccMask	legacy/compat.hpp	125;"	d
cvStackAlloc	core/internal.hpp	321;"	d
cvStarDetectorParams	features2d/features2d.hpp	/^CV_INLINE CvStarDetectorParams cvStarDetectorParams($/;"	f	signature:( int maxSize CV_DEFAULT(45), int responseThreshold CV_DEFAULT(30), int lineThresholdProjected CV_DEFAULT(10), int lineThresholdBinarized CV_DEFAULT(8), int suppressNonmaxSize CV_DEFAULT(5))
cvStarKeypoint	features2d/features2d.hpp	/^CV_INLINE CvStarKeypoint cvStarKeypoint(CvPoint pt, int size, float response)$/;"	f	signature:(CvPoint pt, int size, float response)
cvStartScanGraph	legacy/compat.hpp	/^CV_EXPORTS void  cvStartScanGraph( CvGraph* graph, CvGraphScanner* scanner,$/;"	p	signature:( CvGraph* graph, CvGraphScanner* scanner, CvGraphVtx* vtx CV_DEFAULT(NULL), int mask CV_DEFAULT(CV_GRAPH_ALL_ITEMS))
cvSubS	core/core_c.h	/^CV_INLINE  void  cvSubS( const CvArr* src, CvScalar value, CvArr* dst,$/;"	f	signature:( const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask CV_DEFAULT(NULL))
cvSubdiv2DEdgeDst	imgproc/imgproc_c.h	/^CV_INLINE  CvSubdiv2DPoint*  cvSubdiv2DEdgeDst( CvSubdiv2DEdge edge )$/;"	f	signature:( CvSubdiv2DEdge edge )
cvSubdiv2DEdgeOrg	imgproc/imgproc_c.h	/^CV_INLINE  CvSubdiv2DPoint*  cvSubdiv2DEdgeOrg( CvSubdiv2DEdge edge )$/;"	f	signature:( CvSubdiv2DEdge edge )
cvSubdiv2DGetEdge	imgproc/imgproc_c.h	/^CV_INLINE  CvSubdiv2DEdge  cvSubdiv2DGetEdge( CvSubdiv2DEdge edge, CvNextEdgeType type )$/;"	f	signature:( CvSubdiv2DEdge edge, CvNextEdgeType type )
cvSubdiv2DNextEdge	imgproc/imgproc_c.h	/^CV_INLINE  CvSubdiv2DEdge  cvSubdiv2DNextEdge( CvSubdiv2DEdge edge )$/;"	f	signature:( CvSubdiv2DEdge edge )
cvSubdiv2DRotateEdge	imgproc/imgproc_c.h	/^CV_INLINE  CvSubdiv2DEdge  cvSubdiv2DRotateEdge( CvSubdiv2DEdge edge, int rotate )$/;"	f	signature:( CvSubdiv2DEdge edge, int rotate )
cvSubdiv2DSymEdge	imgproc/imgproc_c.h	/^CV_INLINE  CvSubdiv2DEdge  cvSubdiv2DSymEdge( CvSubdiv2DEdge edge )$/;"	f	signature:( CvSubdiv2DEdge edge )
cvSumPixels	legacy/compat.hpp	/^CV_EXPORTS double cvSumPixels( const CvArr* image );$/;"	p	signature:( const CvArr* image )
cvT	core/core_c.h	710;"	d
cvTermCriteria	core/types_c.h	/^CV_INLINE  CvTermCriteria  cvTermCriteria( int type, int max_iter, double epsilon )$/;"	f	signature:( int type, int max_iter, double epsilon )
cvTestSeqAddIntensityVariation	legacy/blobtrack.hpp	/^CV_EXPORTS void cvTestSeqAddIntensityVariation(CvTestSeq* pTestSeq, float DI_per_frame, float MinI, float MaxI);$/;"	p	signature:(CvTestSeq* pTestSeq, float DI_per_frame, float MinI, float MaxI)
cvTestSeqAddNoise	legacy/blobtrack.hpp	/^CV_EXPORTS void cvTestSeqAddNoise(CvTestSeq* pTestSeq, int noise_type = CV_NOISE_NONE, double noise_ampl = 0);$/;"	p	signature:(CvTestSeq* pTestSeq, int noise_type = CV_NOISE_NONE, double noise_ampl = 0)
cvTestSeqFrameNum	legacy/blobtrack.hpp	/^CV_EXPORTS int cvTestSeqFrameNum(CvTestSeq* pTestSeq);$/;"	p	signature:(CvTestSeq* pTestSeq)
cvTestSeqGetFGMask	legacy/blobtrack.hpp	/^CV_EXPORTS IplImage* cvTestSeqGetFGMask(CvTestSeq* pTestSeq);$/;"	p	signature:(CvTestSeq* pTestSeq)
cvTestSeqGetImage	legacy/blobtrack.hpp	/^CV_EXPORTS IplImage* cvTestSeqGetImage(CvTestSeq* pTestSeq);$/;"	p	signature:(CvTestSeq* pTestSeq)
cvTestSeqGetImageSize	legacy/blobtrack.hpp	/^CV_EXPORTS CvSize cvTestSeqGetImageSize(CvTestSeq* pTestSeq);$/;"	p	signature:(CvTestSeq* pTestSeq)
cvTestSeqGetObjectNum	legacy/blobtrack.hpp	/^CV_EXPORTS int cvTestSeqGetObjectNum(CvTestSeq* pTestSeq);$/;"	p	signature:(CvTestSeq* pTestSeq)
cvTestSeqGetObjectPos	legacy/blobtrack.hpp	/^CV_EXPORTS int cvTestSeqGetObjectPos(CvTestSeq* pTestSeq, int ObjIndex, CvPoint2D32f* pPos);$/;"	p	signature:(CvTestSeq* pTestSeq, int ObjIndex, CvPoint2D32f* pPos)
cvTestSeqGetObjectSize	legacy/blobtrack.hpp	/^CV_EXPORTS int cvTestSeqGetObjectSize(CvTestSeq* pTestSeq, int ObjIndex, CvPoint2D32f* pSize);$/;"	p	signature:(CvTestSeq* pTestSeq, int ObjIndex, CvPoint2D32f* pSize)
cvTestSeqQueryFrame	legacy/blobtrack.hpp	/^CV_EXPORTS IplImage* cvTestSeqQueryFrame(CvTestSeq* pTestSeq);$/;"	p	signature:(CvTestSeq* pTestSeq)
cvTestSeqSetFrame	legacy/blobtrack.hpp	/^CV_EXPORTS void cvTestSeqSetFrame(CvTestSeq* pTestSeq, int n);$/;"	p	signature:(CvTestSeq* pTestSeq, int n)
cvTriangleArea	imgproc/imgproc_c.h	/^CV_INLINE  double  cvTriangleArea( CvPoint2D32f a, CvPoint2D32f b, CvPoint2D32f c )$/;"	f	signature:( CvPoint2D32f a, CvPoint2D32f b, CvPoint2D32f c )
cvUnDistort	legacy/compat.hpp	/^CV_EXPORTS void  cvUnDistort( const CvArr* src, CvArr* dst,$/;"	p	signature:( const CvArr* src, CvArr* dst, const CvArr* undistortion_map, int interpolate )
cvUnDistortInit	legacy/compat.hpp	/^CV_EXPORTS void cvUnDistortInit( const CvArr* src,$/;"	p	signature:( const CvArr* src, CvArr* undistortion_map, const float* A, const float* k, int interpolate )
cvUnDistortOnce	legacy/compat.hpp	/^CV_EXPORTS void cvUnDistortOnce( const CvArr* src, CvArr* dst,$/;"	p	signature:( const CvArr* src, CvArr* dst, const float* intrinsic_matrix, const float* distortion_coeffs, int interpolate )
cvUnsupportedFormat	core/internal.hpp	389;"	d
cvUpdateMHIByTime	legacy/compat.hpp	122;"	d
cvWarpPerspectiveQMatrix	legacy/compat.hpp	599;"	d
cvWriteStruct	legacy/blobtrack.hpp	/^CV_EXPORTS void cvWriteStruct(CvFileStorage* fs, const char* name, void* addr, const char* desc, int num=1);$/;"	p	signature:(CvFileStorage* fs, const char* name, void* addr, const char* desc, int num=1)
cvWriteToAVI	highgui/highgui_c.h	475;"	d
cvZero	core/core_c.h	426;"	d
cv_Tn	ml/ml.hpp	/^    int* cv_Tn;$/;"	m	struct:CvDTreeNode	access:public
cv_folds	ml/ml.hpp	/^    CV_PROP_RW int   cv_folds;$/;"	m	struct:CvDTreeParams	access:public
cv_heap	ml/ml.hpp	/^    CvSet* cv_heap;$/;"	m	struct:CvDTreeTrainData	access:public
cv_node_error	ml/ml.hpp	/^    double* cv_node_error;$/;"	m	struct:CvDTreeNode	access:public
cv_node_risk	ml/ml.hpp	/^    double* cv_node_risk;$/;"	m	struct:CvDTreeNode	access:public
cv_stricmp	legacy/blobtrack.hpp	53;"	d
cv_stricmp	legacy/blobtrack.hpp	60;"	d
cv_strnicmp	legacy/blobtrack.hpp	54;"	d
cv_strnicmp	legacy/blobtrack.hpp	61;"	d
cvarrToMat	core/core.hpp	/^CV_EXPORTS Mat cvarrToMat(const CvArr* arr, bool copyData=false,$/;"	p	namespace:cv	signature:(const CvArr* arr, bool copyData=false, bool allowND=true, int coiMode=0)
cvarrToMatND	core/mat.hpp	/^static inline Mat cvarrToMatND(const CvArr* arr, bool copyData=false, int coiMode=0)$/;"	f	namespace:cv	signature:(const CvArr* arr, bool copyData=false, int coiMode=0)
cvbCartToPolar	legacy/compat.hpp	/^CV_EXPORTS void  cvbCartToPolar( const float* y, const float* x,$/;"	p	signature:( const float* y, const float* x, float* magnitude, float* angle, int len )
cvbFastArctan	legacy/compat.hpp	/^CV_EXPORTS void  cvbFastArctan( const float* y, const float* x, float* angle, int len );$/;"	p	signature:( const float* y, const float* x, float* angle, int len )
cvbFastExp	legacy/compat.hpp	/^CV_EXPORTS void  cvbFastExp( const float* x, double* y, int len );$/;"	p	signature:( const float* x, double* y, int len )
cvbFastLog	legacy/compat.hpp	/^CV_EXPORTS void  cvbFastLog( const double* x, float* y, int len );$/;"	p	signature:( const double* x, float* y, int len )
cvbInvSqrt	legacy/compat.hpp	/^CV_EXPORTS void  cvbInvSqrt( const float* x, float* y, int len );$/;"	p	signature:( const float* x, float* y, int len )
cvbRand	legacy/compat.hpp	/^CV_EXPORTS void cvbRand( CvRandState* state, float* dst, int len );$/;"	p	signature:( CvRandState* state, float* dst, int len )
cvbReciprocal	legacy/compat.hpp	/^CV_EXPORTS void  cvbReciprocal( const float* x, float* y, int len );$/;"	p	signature:( const float* x, float* y, int len )
cvbSqrt	legacy/compat.hpp	/^CV_EXPORTS void  cvbSqrt( const float* x, float* y, int len );$/;"	p	signature:( const float* x, float* y, int len )
cvflann	flann/all_indices.h	/^namespace cvflann$/;"	n
cvflann	flann/allocator.h	/^namespace cvflann$/;"	n
cvflann	flann/autotuned_index.h	/^namespace cvflann$/;"	n
cvflann	flann/composite_index.h	/^namespace cvflann$/;"	n
cvflann	flann/defines.h	/^namespace cvflann {$/;"	n
cvflann	flann/dist.h	/^namespace cvflann$/;"	n
cvflann	flann/dummy.h	/^namespace cvflann$/;"	n
cvflann	flann/flann.hpp	/^namespace cvflann$/;"	n
cvflann	flann/flann_base.hpp	/^namespace cvflann$/;"	n
cvflann	flann/general.h	/^namespace cvflann$/;"	n
cvflann	flann/ground_truth.h	/^namespace cvflann$/;"	n
cvflann	flann/hdf5.h	/^namespace cvflann$/;"	n
cvflann	flann/heap.h	/^namespace cvflann$/;"	n
cvflann	flann/hierarchical_clustering_index.h	/^namespace cvflann$/;"	n
cvflann	flann/index_testing.h	/^namespace cvflann$/;"	n
cvflann	flann/kdtree_index.h	/^namespace cvflann$/;"	n
cvflann	flann/kdtree_single_index.h	/^namespace cvflann$/;"	n
cvflann	flann/kmeans_index.h	/^namespace cvflann$/;"	n
cvflann	flann/linear_index.h	/^namespace cvflann$/;"	n
cvflann	flann/logger.h	/^namespace cvflann$/;"	n
cvflann	flann/lsh_index.h	/^namespace cvflann$/;"	n
cvflann	flann/lsh_table.h	/^namespace cvflann$/;"	n
cvflann	flann/matrix.h	/^namespace cvflann$/;"	n
cvflann	flann/nn_index.h	/^namespace cvflann$/;"	n
cvflann	flann/object_factory.h	/^namespace cvflann$/;"	n
cvflann	flann/params.h	/^namespace cvflann$/;"	n
cvflann	flann/random.h	/^namespace cvflann$/;"	n
cvflann	flann/result_set.h	/^namespace cvflann$/;"	n
cvflann	flann/sampling.h	/^namespace cvflann$/;"	n
cvflann	flann/saving.h	/^namespace cvflann$/;"	n
cvflann	flann/simplex_downhill.h	/^namespace cvflann$/;"	n
cvflann	flann/timer.h	/^namespace cvflann$/;"	n
cvflann::AUTOTUNED	flann/defines.h	/^    AUTOTUNED = 255$/;"	e	enum:cvflann::flann_algorithm_t
cvflann::Accumulator	flann/dist.h	/^struct Accumulator { typedef T Type; };$/;"	s	namespace:cvflann
cvflann::Accumulator	flann/dist.h	/^struct Accumulator<char>   { typedef float Type; };$/;"	s	namespace:cvflann
cvflann::Accumulator	flann/dist.h	/^struct Accumulator<int> { typedef float Type; };$/;"	s	namespace:cvflann
cvflann::Accumulator	flann/dist.h	/^struct Accumulator<short>  { typedef float Type; };$/;"	s	namespace:cvflann
cvflann::Accumulator	flann/dist.h	/^struct Accumulator<unsigned char>  { typedef float Type; };$/;"	s	namespace:cvflann
cvflann::Accumulator	flann/dist.h	/^struct Accumulator<unsigned int> { typedef float Type; };$/;"	s	namespace:cvflann
cvflann::Accumulator	flann/dist.h	/^struct Accumulator<unsigned short> { typedef float Type; };$/;"	s	namespace:cvflann
cvflann::Accumulator::Type	flann/dist.h	/^struct Accumulator { typedef T Type; };$/;"	t	struct:cvflann::Accumulator	access:public
cvflann::Accumulator::Type	flann/dist.h	/^struct Accumulator<char>   { typedef float Type; };$/;"	t	struct:cvflann::Accumulator	access:public
cvflann::Accumulator::Type	flann/dist.h	/^struct Accumulator<int> { typedef float Type; };$/;"	t	struct:cvflann::Accumulator	access:public
cvflann::Accumulator::Type	flann/dist.h	/^struct Accumulator<short>  { typedef float Type; };$/;"	t	struct:cvflann::Accumulator	access:public
cvflann::Accumulator::Type	flann/dist.h	/^struct Accumulator<unsigned char>  { typedef float Type; };$/;"	t	struct:cvflann::Accumulator	access:public
cvflann::Accumulator::Type	flann/dist.h	/^struct Accumulator<unsigned int> { typedef float Type; };$/;"	t	struct:cvflann::Accumulator	access:public
cvflann::Accumulator::Type	flann/dist.h	/^struct Accumulator<unsigned short> { typedef float Type; };$/;"	t	struct:cvflann::Accumulator	access:public
cvflann::AutotunedIndex	flann/autotuned_index.h	/^class AutotunedIndex : public NNIndex<Distance>$/;"	c	namespace:cvflann	inherits:NNIndex
cvflann::AutotunedIndex::AutotunedIndex	flann/autotuned_index.h	/^    AutotunedIndex(const AutotunedIndex&);$/;"	p	class:cvflann::AutotunedIndex	access:public	signature:(const AutotunedIndex&)
cvflann::AutotunedIndex::AutotunedIndex	flann/autotuned_index.h	/^    AutotunedIndex(const Matrix<ElementType>& inputData, const IndexParams& params = AutotunedIndexParams(), Distance d = Distance()) :$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:(const Matrix<ElementType>& inputData, const IndexParams& params = AutotunedIndexParams(), Distance d = Distance())
cvflann::AutotunedIndex::CostData	flann/autotuned_index.h	/^    struct CostData$/;"	s	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::CostData::buildTimeCost	flann/autotuned_index.h	/^        float buildTimeCost;$/;"	m	struct:cvflann::AutotunedIndex::CostData	access:public
cvflann::AutotunedIndex::CostData::memoryCost	flann/autotuned_index.h	/^        float memoryCost;$/;"	m	struct:cvflann::AutotunedIndex::CostData	access:public
cvflann::AutotunedIndex::CostData::params	flann/autotuned_index.h	/^        IndexParams params;$/;"	m	struct:cvflann::AutotunedIndex::CostData	access:public
cvflann::AutotunedIndex::CostData::searchTimeCost	flann/autotuned_index.h	/^        float searchTimeCost;$/;"	m	struct:cvflann::AutotunedIndex::CostData	access:public
cvflann::AutotunedIndex::CostData::totalCost	flann/autotuned_index.h	/^        float totalCost;$/;"	m	struct:cvflann::AutotunedIndex::CostData	access:public
cvflann::AutotunedIndex::DistanceType	flann/autotuned_index.h	/^    typedef typename Distance::ResultType DistanceType;$/;"	t	class:cvflann::AutotunedIndex	access:public
cvflann::AutotunedIndex::ElementType	flann/autotuned_index.h	/^    typedef typename Distance::ElementType ElementType;$/;"	t	class:cvflann::AutotunedIndex	access:public
cvflann::AutotunedIndex::bestIndex_	flann/autotuned_index.h	/^    NNIndex<Distance>* bestIndex_;$/;"	m	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::bestParams_	flann/autotuned_index.h	/^    IndexParams bestParams_;$/;"	m	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::bestSearchParams_	flann/autotuned_index.h	/^    SearchParams bestSearchParams_;$/;"	m	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::buildIndex	flann/autotuned_index.h	/^    virtual void buildIndex()$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:()
cvflann::AutotunedIndex::build_weight_	flann/autotuned_index.h	/^    float build_weight_;$/;"	m	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::dataset_	flann/autotuned_index.h	/^    const Matrix<ElementType> dataset_;$/;"	m	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::distance_	flann/autotuned_index.h	/^    Distance distance_;$/;"	m	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::estimateBuildParams	flann/autotuned_index.h	/^    IndexParams estimateBuildParams()$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:()
cvflann::AutotunedIndex::estimateSearchParams	flann/autotuned_index.h	/^    float estimateSearchParams(SearchParams& searchParams)$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:(SearchParams& searchParams)
cvflann::AutotunedIndex::evaluate_kdtree	flann/autotuned_index.h	/^    void evaluate_kdtree(CostData& cost)$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:(CostData& cost)
cvflann::AutotunedIndex::evaluate_kmeans	flann/autotuned_index.h	/^    void evaluate_kmeans(CostData& cost)$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:(CostData& cost)
cvflann::AutotunedIndex::findNeighbors	flann/autotuned_index.h	/^    virtual void findNeighbors(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)
cvflann::AutotunedIndex::getParameters	flann/autotuned_index.h	/^    IndexParams getParameters() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
cvflann::AutotunedIndex::getSearchParameters	flann/autotuned_index.h	/^    SearchParams getSearchParameters() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
cvflann::AutotunedIndex::getSpeedup	flann/autotuned_index.h	/^    float getSpeedup() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
cvflann::AutotunedIndex::getType	flann/autotuned_index.h	/^    virtual flann_algorithm_t getType() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
cvflann::AutotunedIndex::gt_matches_	flann/autotuned_index.h	/^    Matrix<int> gt_matches_;$/;"	m	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::loadIndex	flann/autotuned_index.h	/^    virtual void loadIndex(FILE* stream)$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:(FILE* stream)
cvflann::AutotunedIndex::memory_weight_	flann/autotuned_index.h	/^    float memory_weight_;$/;"	m	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::operator =	flann/autotuned_index.h	/^    AutotunedIndex& operator=(const AutotunedIndex&);$/;"	p	class:cvflann::AutotunedIndex	access:public	signature:(const AutotunedIndex&)
cvflann::AutotunedIndex::optimizeKDTree	flann/autotuned_index.h	/^    void optimizeKDTree(std::vector<CostData>& costs)$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:(std::vector<CostData>& costs)
cvflann::AutotunedIndex::optimizeKMeans	flann/autotuned_index.h	/^    void optimizeKMeans(std::vector<CostData>& costs)$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:(std::vector<CostData>& costs)
cvflann::AutotunedIndex::sample_fraction_	flann/autotuned_index.h	/^    float sample_fraction_;$/;"	m	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::sampledDataset_	flann/autotuned_index.h	/^    Matrix<ElementType> sampledDataset_;$/;"	m	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::saveIndex	flann/autotuned_index.h	/^    virtual void saveIndex(FILE* stream)$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:(FILE* stream)
cvflann::AutotunedIndex::size	flann/autotuned_index.h	/^    virtual size_t size() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
cvflann::AutotunedIndex::speedup_	flann/autotuned_index.h	/^    float speedup_;$/;"	m	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::target_precision_	flann/autotuned_index.h	/^    float target_precision_;$/;"	m	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::testDataset_	flann/autotuned_index.h	/^    Matrix<ElementType> testDataset_;$/;"	m	class:cvflann::AutotunedIndex	access:private
cvflann::AutotunedIndex::usedMemory	flann/autotuned_index.h	/^    virtual int usedMemory() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
cvflann::AutotunedIndex::veclen	flann/autotuned_index.h	/^    virtual size_t veclen() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
cvflann::AutotunedIndex::~AutotunedIndex	flann/autotuned_index.h	/^    virtual ~AutotunedIndex()$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:()
cvflann::AutotunedIndexParams	flann/autotuned_index.h	/^struct AutotunedIndexParams : public IndexParams$/;"	s	namespace:cvflann	inherits:IndexParams
cvflann::AutotunedIndexParams::AutotunedIndexParams	flann/autotuned_index.h	/^    AutotunedIndexParams(float target_precision = 0.8, float build_weight = 0.01, float memory_weight = 0, float sample_fraction = 0.1)$/;"	f	struct:cvflann::AutotunedIndexParams	access:public	signature:(float target_precision = 0.8, float build_weight = 0.01, float memory_weight = 0, float sample_fraction = 0.1)
cvflann::BLOCKSIZE	flann/allocator.h	/^const  size_t     BLOCKSIZE=8192;$/;"	m	namespace:cvflann
cvflann::BranchStruct	flann/result_set.h	/^struct BranchStruct$/;"	s	namespace:cvflann
cvflann::BranchStruct::BranchStruct	flann/result_set.h	/^    BranchStruct() {}$/;"	f	struct:cvflann::BranchStruct	access:public	signature:()
cvflann::BranchStruct::BranchStruct	flann/result_set.h	/^    BranchStruct(const T& aNode, DistanceType dist) : node(aNode), mindist(dist) {}$/;"	f	struct:cvflann::BranchStruct	access:public	signature:(const T& aNode, DistanceType dist)
cvflann::BranchStruct::mindist	flann/result_set.h	/^    DistanceType mindist;     \/* Minimum distance to query for all nodes below. *\/$/;"	m	struct:cvflann::BranchStruct	access:public
cvflann::BranchStruct::node	flann/result_set.h	/^    T node;           \/* Tree node at which search resumes *\/$/;"	m	struct:cvflann::BranchStruct	access:public
cvflann::BranchStruct::operator <	flann/result_set.h	/^    bool operator<(const BranchStruct<T, DistanceType>& rhs) const$/;"	f	struct:cvflann::BranchStruct	access:public	signature:(const BranchStruct<T, DistanceType>& rhs) const
cvflann::CENTERS_GONZALES	flann/defines.h	/^    CENTERS_GONZALES = 1,$/;"	e	enum:cvflann::flann_centers_init_t
cvflann::CENTERS_KMEANSPP	flann/defines.h	/^    CENTERS_KMEANSPP = 2$/;"	e	enum:cvflann::flann_centers_init_t
cvflann::CENTERS_RANDOM	flann/defines.h	/^    CENTERS_RANDOM = 0,$/;"	e	enum:cvflann::flann_centers_init_t
cvflann::COMPOSITE	flann/defines.h	/^    COMPOSITE = 3,$/;"	e	enum:cvflann::flann_algorithm_t
cvflann::CS	flann/defines.h	/^    CS         = 7,$/;"	e	enum:cvflann::flann_distance_t
cvflann::ChiSquareDistance	flann/dist.h	/^struct ChiSquareDistance$/;"	s	namespace:cvflann
cvflann::ChiSquareDistance::ElementType	flann/dist.h	/^    typedef T ElementType;$/;"	t	struct:cvflann::ChiSquareDistance	access:public
cvflann::ChiSquareDistance::ResultType	flann/dist.h	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cvflann::ChiSquareDistance	access:public
cvflann::ChiSquareDistance::accum_dist	flann/dist.h	/^    inline ResultType accum_dist(const U& a, const V& b, int) const$/;"	f	struct:cvflann::ChiSquareDistance	access:public	signature:(const U& a, const V& b, int) const
cvflann::ChiSquareDistance::is_kdtree_distance	flann/dist.h	/^    typedef True is_kdtree_distance;$/;"	t	struct:cvflann::ChiSquareDistance	access:public
cvflann::ChiSquareDistance::is_vector_space_distance	flann/dist.h	/^    typedef True is_vector_space_distance;$/;"	t	struct:cvflann::ChiSquareDistance	access:public
cvflann::ChiSquareDistance::operator ()	flann/dist.h	/^    ResultType operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const$/;"	f	struct:cvflann::ChiSquareDistance	access:public	signature:(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const
cvflann::CompositeIndex	flann/composite_index.h	/^class CompositeIndex : public NNIndex<Distance>$/;"	c	namespace:cvflann	inherits:NNIndex
cvflann::CompositeIndex::CompositeIndex	flann/composite_index.h	/^    CompositeIndex(const CompositeIndex&);$/;"	p	class:cvflann::CompositeIndex	access:public	signature:(const CompositeIndex&)
cvflann::CompositeIndex::CompositeIndex	flann/composite_index.h	/^    CompositeIndex(const Matrix<ElementType>& inputData, const IndexParams& params = CompositeIndexParams(),$/;"	f	class:cvflann::CompositeIndex	access:public	signature:(const Matrix<ElementType>& inputData, const IndexParams& params = CompositeIndexParams(), Distance d = Distance())
cvflann::CompositeIndex::DistanceType	flann/composite_index.h	/^    typedef typename Distance::ResultType DistanceType;$/;"	t	class:cvflann::CompositeIndex	access:public
cvflann::CompositeIndex::ElementType	flann/composite_index.h	/^    typedef typename Distance::ElementType ElementType;$/;"	t	class:cvflann::CompositeIndex	access:public
cvflann::CompositeIndex::buildIndex	flann/composite_index.h	/^    void buildIndex()$/;"	f	class:cvflann::CompositeIndex	access:public	signature:()
cvflann::CompositeIndex::findNeighbors	flann/composite_index.h	/^    void findNeighbors(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)$/;"	f	class:cvflann::CompositeIndex	access:public	signature:(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)
cvflann::CompositeIndex::getParameters	flann/composite_index.h	/^    IndexParams getParameters() const$/;"	f	class:cvflann::CompositeIndex	access:public	signature:() const
cvflann::CompositeIndex::getType	flann/composite_index.h	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::CompositeIndex	access:public	signature:() const
cvflann::CompositeIndex::index_params_	flann/composite_index.h	/^    const IndexParams index_params_;$/;"	m	class:cvflann::CompositeIndex	access:private
cvflann::CompositeIndex::kdtree_index_	flann/composite_index.h	/^    KDTreeIndex<Distance>* kdtree_index_;$/;"	m	class:cvflann::CompositeIndex	access:private
cvflann::CompositeIndex::kmeans_index_	flann/composite_index.h	/^    KMeansIndex<Distance>* kmeans_index_;$/;"	m	class:cvflann::CompositeIndex	access:private
cvflann::CompositeIndex::loadIndex	flann/composite_index.h	/^    void loadIndex(FILE* stream)$/;"	f	class:cvflann::CompositeIndex	access:public	signature:(FILE* stream)
cvflann::CompositeIndex::operator =	flann/composite_index.h	/^    CompositeIndex& operator=(const CompositeIndex&);$/;"	p	class:cvflann::CompositeIndex	access:public	signature:(const CompositeIndex&)
cvflann::CompositeIndex::saveIndex	flann/composite_index.h	/^    void saveIndex(FILE* stream)$/;"	f	class:cvflann::CompositeIndex	access:public	signature:(FILE* stream)
cvflann::CompositeIndex::size	flann/composite_index.h	/^    size_t size() const$/;"	f	class:cvflann::CompositeIndex	access:public	signature:() const
cvflann::CompositeIndex::usedMemory	flann/composite_index.h	/^    int usedMemory() const$/;"	f	class:cvflann::CompositeIndex	access:public	signature:() const
cvflann::CompositeIndex::veclen	flann/composite_index.h	/^    size_t veclen() const$/;"	f	class:cvflann::CompositeIndex	access:public	signature:() const
cvflann::CompositeIndex::~CompositeIndex	flann/composite_index.h	/^    virtual ~CompositeIndex()$/;"	f	class:cvflann::CompositeIndex	access:public	signature:()
cvflann::CompositeIndexParams	flann/composite_index.h	/^struct CompositeIndexParams : public IndexParams$/;"	s	namespace:cvflann	inherits:IndexParams
cvflann::CompositeIndexParams::CompositeIndexParams	flann/composite_index.h	/^    CompositeIndexParams(int trees = 4, int branching = 32, int iterations = 11,$/;"	f	struct:cvflann::CompositeIndexParams	access:public	signature:(int trees = 4, int branching = 32, int iterations = 11, flann_centers_init_t centers_init = FLANN_CENTERS_RANDOM, float cb_index = 0.2 )
cvflann::CreatorNotFound	flann/object_factory.h	/^class CreatorNotFound$/;"	c	namespace:cvflann
cvflann::Datatype	flann/saving.h	/^struct Datatype {};$/;"	s	namespace:cvflann
cvflann::Datatype	flann/saving.h	/^struct Datatype<char> { static flann_datatype_t type() { return FLANN_INT8; } };$/;"	s	namespace:cvflann
cvflann::Datatype	flann/saving.h	/^struct Datatype<double> { static flann_datatype_t type() { return FLANN_FLOAT64; } };$/;"	s	namespace:cvflann
cvflann::Datatype	flann/saving.h	/^struct Datatype<float> { static flann_datatype_t type() { return FLANN_FLOAT32; } };$/;"	s	namespace:cvflann
cvflann::Datatype	flann/saving.h	/^struct Datatype<int> { static flann_datatype_t type() { return FLANN_INT32; } };$/;"	s	namespace:cvflann
cvflann::Datatype	flann/saving.h	/^struct Datatype<short> { static flann_datatype_t type() { return FLANN_INT16; } };$/;"	s	namespace:cvflann
cvflann::Datatype	flann/saving.h	/^struct Datatype<unsigned char> { static flann_datatype_t type() { return FLANN_UINT8; } };$/;"	s	namespace:cvflann
cvflann::Datatype	flann/saving.h	/^struct Datatype<unsigned int> { static flann_datatype_t type() { return FLANN_UINT32; } };$/;"	s	namespace:cvflann
cvflann::Datatype	flann/saving.h	/^struct Datatype<unsigned short> { static flann_datatype_t type() { return FLANN_UINT16; } };$/;"	s	namespace:cvflann
cvflann::Datatype::type	flann/saving.h	/^struct Datatype<char> { static flann_datatype_t type() { return FLANN_INT8; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
cvflann::Datatype::type	flann/saving.h	/^struct Datatype<double> { static flann_datatype_t type() { return FLANN_FLOAT64; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
cvflann::Datatype::type	flann/saving.h	/^struct Datatype<float> { static flann_datatype_t type() { return FLANN_FLOAT32; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
cvflann::Datatype::type	flann/saving.h	/^struct Datatype<int> { static flann_datatype_t type() { return FLANN_INT32; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
cvflann::Datatype::type	flann/saving.h	/^struct Datatype<short> { static flann_datatype_t type() { return FLANN_INT16; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
cvflann::Datatype::type	flann/saving.h	/^struct Datatype<unsigned char> { static flann_datatype_t type() { return FLANN_UINT8; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
cvflann::Datatype::type	flann/saving.h	/^struct Datatype<unsigned int> { static flann_datatype_t type() { return FLANN_UINT32; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
cvflann::Datatype::type	flann/saving.h	/^struct Datatype<unsigned short> { static flann_datatype_t type() { return FLANN_UINT16; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
cvflann::EUCLIDEAN	flann/defines.h	/^    EUCLIDEAN = 1,$/;"	e	enum:cvflann::flann_distance_t
cvflann::FLANNException	flann/general.h	/^class FLANNException : public std::runtime_error$/;"	c	namespace:cvflann	inherits:std::runtime_error
cvflann::FLANNException::FLANNException	flann/general.h	/^    FLANNException(const char* message) : std::runtime_error(message) { }$/;"	f	class:cvflann::FLANNException	access:public	signature:(const char* message)
cvflann::FLANNException::FLANNException	flann/general.h	/^    FLANNException(const std::string& message) : std::runtime_error(message) { }$/;"	f	class:cvflann::FLANNException	access:public	signature:(const std::string& message)
cvflann::FLANN_CENTERS_GONZALES	flann/defines.h	/^    FLANN_CENTERS_GONZALES = 1,$/;"	e	enum:cvflann::flann_centers_init_t
cvflann::FLANN_CENTERS_KMEANSPP	flann/defines.h	/^    FLANN_CENTERS_KMEANSPP = 2,$/;"	e	enum:cvflann::flann_centers_init_t
cvflann::FLANN_CENTERS_RANDOM	flann/defines.h	/^    FLANN_CENTERS_RANDOM = 0,$/;"	e	enum:cvflann::flann_centers_init_t
cvflann::FLANN_CHECKS_AUTOTUNED	flann/defines.h	/^    FLANN_CHECKS_AUTOTUNED = -2$/;"	e	enum:cvflann::__anon205
cvflann::FLANN_CHECKS_UNLIMITED	flann/defines.h	/^    FLANN_CHECKS_UNLIMITED = -1,$/;"	e	enum:cvflann::__anon205
cvflann::FLANN_DIST_CHI_SQUARE	flann/defines.h	/^    FLANN_DIST_CHI_SQUARE = 7,$/;"	e	enum:cvflann::flann_distance_t
cvflann::FLANN_DIST_CS	flann/defines.h	/^    FLANN_DIST_CS         = 7,$/;"	e	enum:cvflann::flann_distance_t
cvflann::FLANN_DIST_EUCLIDEAN	flann/defines.h	/^    FLANN_DIST_EUCLIDEAN = 1,$/;"	e	enum:cvflann::flann_distance_t
cvflann::FLANN_DIST_HELLINGER	flann/defines.h	/^    FLANN_DIST_HELLINGER = 6,$/;"	e	enum:cvflann::flann_distance_t
cvflann::FLANN_DIST_HIST_INTERSECT	flann/defines.h	/^    FLANN_DIST_HIST_INTERSECT   = 5,$/;"	e	enum:cvflann::flann_distance_t
cvflann::FLANN_DIST_KL	flann/defines.h	/^    FLANN_DIST_KL                = 8,$/;"	e	enum:cvflann::flann_distance_t
cvflann::FLANN_DIST_KULLBACK_LEIBLER	flann/defines.h	/^    FLANN_DIST_KULLBACK_LEIBLER  = 8,$/;"	e	enum:cvflann::flann_distance_t
cvflann::FLANN_DIST_L1	flann/defines.h	/^    FLANN_DIST_L1 = 2,$/;"	e	enum:cvflann::flann_distance_t
cvflann::FLANN_DIST_L2	flann/defines.h	/^    FLANN_DIST_L2 = 1,$/;"	e	enum:cvflann::flann_distance_t
cvflann::FLANN_DIST_MANHATTAN	flann/defines.h	/^    FLANN_DIST_MANHATTAN = 2,$/;"	e	enum:cvflann::flann_distance_t
cvflann::FLANN_DIST_MAX	flann/defines.h	/^    FLANN_DIST_MAX   = 4,$/;"	e	enum:cvflann::flann_distance_t
cvflann::FLANN_DIST_MINKOWSKI	flann/defines.h	/^    FLANN_DIST_MINKOWSKI = 3,$/;"	e	enum:cvflann::flann_distance_t
cvflann::FLANN_FLOAT32	flann/defines.h	/^    FLANN_FLOAT32 = 8,$/;"	e	enum:cvflann::flann_datatype_t
cvflann::FLANN_FLOAT64	flann/defines.h	/^    FLANN_FLOAT64 = 9$/;"	e	enum:cvflann::flann_datatype_t
cvflann::FLANN_INDEX_AUTOTUNED	flann/defines.h	/^    FLANN_INDEX_AUTOTUNED = 255,$/;"	e	enum:cvflann::flann_algorithm_t
cvflann::FLANN_INDEX_COMPOSITE	flann/defines.h	/^    FLANN_INDEX_COMPOSITE = 3,$/;"	e	enum:cvflann::flann_algorithm_t
cvflann::FLANN_INDEX_HIERARCHICAL	flann/defines.h	/^    FLANN_INDEX_HIERARCHICAL = 5,$/;"	e	enum:cvflann::flann_algorithm_t
cvflann::FLANN_INDEX_KDTREE	flann/defines.h	/^    FLANN_INDEX_KDTREE = 1,$/;"	e	enum:cvflann::flann_algorithm_t
cvflann::FLANN_INDEX_KDTREE_SINGLE	flann/defines.h	/^    FLANN_INDEX_KDTREE_SINGLE = 4,$/;"	e	enum:cvflann::flann_algorithm_t
cvflann::FLANN_INDEX_KMEANS	flann/defines.h	/^    FLANN_INDEX_KMEANS = 2,$/;"	e	enum:cvflann::flann_algorithm_t
cvflann::FLANN_INDEX_LINEAR	flann/defines.h	/^    FLANN_INDEX_LINEAR = 0,$/;"	e	enum:cvflann::flann_algorithm_t
cvflann::FLANN_INDEX_LSH	flann/defines.h	/^    FLANN_INDEX_LSH = 6,$/;"	e	enum:cvflann::flann_algorithm_t
cvflann::FLANN_INDEX_SAVED	flann/defines.h	/^    FLANN_INDEX_SAVED = 254,$/;"	e	enum:cvflann::flann_algorithm_t
cvflann::FLANN_INT16	flann/defines.h	/^    FLANN_INT16 = 1,$/;"	e	enum:cvflann::flann_datatype_t
cvflann::FLANN_INT32	flann/defines.h	/^    FLANN_INT32 = 2,$/;"	e	enum:cvflann::flann_datatype_t
cvflann::FLANN_INT64	flann/defines.h	/^    FLANN_INT64 = 3,$/;"	e	enum:cvflann::flann_datatype_t
cvflann::FLANN_INT8	flann/defines.h	/^    FLANN_INT8 = 0,$/;"	e	enum:cvflann::flann_datatype_t
cvflann::FLANN_LOG_ERROR	flann/defines.h	/^    FLANN_LOG_ERROR = 2,$/;"	e	enum:cvflann::flann_log_level_t
cvflann::FLANN_LOG_FATAL	flann/defines.h	/^    FLANN_LOG_FATAL = 1,$/;"	e	enum:cvflann::flann_log_level_t
cvflann::FLANN_LOG_INFO	flann/defines.h	/^    FLANN_LOG_INFO = 4,$/;"	e	enum:cvflann::flann_log_level_t
cvflann::FLANN_LOG_NONE	flann/defines.h	/^    FLANN_LOG_NONE = 0,$/;"	e	enum:cvflann::flann_log_level_t
cvflann::FLANN_LOG_WARN	flann/defines.h	/^    FLANN_LOG_WARN = 3,$/;"	e	enum:cvflann::flann_log_level_t
cvflann::FLANN_UINT16	flann/defines.h	/^    FLANN_UINT16 = 5,$/;"	e	enum:cvflann::flann_datatype_t
cvflann::FLANN_UINT32	flann/defines.h	/^    FLANN_UINT32 = 6,$/;"	e	enum:cvflann::flann_datatype_t
cvflann::FLANN_UINT64	flann/defines.h	/^    FLANN_UINT64 = 7,$/;"	e	enum:cvflann::flann_datatype_t
cvflann::FLANN_UINT8	flann/defines.h	/^    FLANN_UINT8 = 4,$/;"	e	enum:cvflann::flann_datatype_t
cvflann::False	flann/dist.h	/^class False$/;"	c	namespace:cvflann
cvflann::HELLINGER	flann/defines.h	/^    HELLINGER = 6,$/;"	e	enum:cvflann::flann_distance_t
cvflann::HIST_INTERSECT	flann/defines.h	/^    HIST_INTERSECT   = 5,$/;"	e	enum:cvflann::flann_distance_t
cvflann::Hamming	flann/dist.h	/^struct Hamming$/;"	s	namespace:cvflann
cvflann::Hamming2	flann/dist.h	/^struct Hamming2$/;"	s	namespace:cvflann
cvflann::Hamming2::ElementType	flann/dist.h	/^    typedef T ElementType;$/;"	t	struct:cvflann::Hamming2	access:public
cvflann::Hamming2::ResultType	flann/dist.h	/^    typedef int ResultType;$/;"	t	struct:cvflann::Hamming2	access:public
cvflann::Hamming2::is_kdtree_distance	flann/dist.h	/^    typedef False is_kdtree_distance;$/;"	t	struct:cvflann::Hamming2	access:public
cvflann::Hamming2::is_vector_space_distance	flann/dist.h	/^    typedef False is_vector_space_distance;$/;"	t	struct:cvflann::Hamming2	access:public
cvflann::Hamming2::operator ()	flann/dist.h	/^    ResultType operator()(Iterator1 a, Iterator2 b, size_t size, ResultType \/*worst_dist*\/ = -1) const$/;"	f	struct:cvflann::Hamming2	access:public	signature:(Iterator1 a, Iterator2 b, size_t size, ResultType = -1) const
cvflann::Hamming2::popcnt32	flann/dist.h	/^    unsigned int popcnt32(uint32_t n) const$/;"	f	struct:cvflann::Hamming2	access:public	signature:(uint32_t n) const
cvflann::Hamming2::popcnt64	flann/dist.h	/^    unsigned int popcnt64(uint64_t n) const$/;"	f	struct:cvflann::Hamming2	access:public	signature:(uint64_t n) const
cvflann::Hamming::ElementType	flann/dist.h	/^    typedef T ElementType;$/;"	t	struct:cvflann::Hamming	access:public
cvflann::Hamming::ResultType	flann/dist.h	/^    typedef int ResultType;$/;"	t	struct:cvflann::Hamming	access:public
cvflann::Hamming::is_kdtree_distance	flann/dist.h	/^    typedef False is_kdtree_distance;$/;"	t	struct:cvflann::Hamming	access:public
cvflann::Hamming::is_vector_space_distance	flann/dist.h	/^    typedef False is_vector_space_distance;$/;"	t	struct:cvflann::Hamming	access:public
cvflann::Hamming::operator ()	flann/dist.h	/^    ResultType operator()(Iterator1 a, Iterator2 b, size_t size, ResultType \/*worst_dist*\/ = -1) const$/;"	f	struct:cvflann::Hamming	access:public	signature:(Iterator1 a, Iterator2 b, size_t size, ResultType = -1) const
cvflann::HammingLUT	flann/dist.h	/^struct HammingLUT$/;"	s	namespace:cvflann
cvflann::HammingLUT::ElementType	flann/dist.h	/^    typedef unsigned char ElementType;$/;"	t	struct:cvflann::HammingLUT	access:public
cvflann::HammingLUT::ResultType	flann/dist.h	/^    typedef int ResultType;$/;"	t	struct:cvflann::HammingLUT	access:public
cvflann::HammingLUT::byteBitsLookUp	flann/dist.h	/^    static unsigned char byteBitsLookUp(unsigned char b)$/;"	f	struct:cvflann::HammingLUT	access:public	signature:(unsigned char b)
cvflann::HammingLUT::is_kdtree_distance	flann/dist.h	/^    typedef False is_kdtree_distance;$/;"	t	struct:cvflann::HammingLUT	access:public
cvflann::HammingLUT::is_vector_space_distance	flann/dist.h	/^    typedef False is_vector_space_distance;$/;"	t	struct:cvflann::HammingLUT	access:public
cvflann::HammingLUT::operator ()	flann/dist.h	/^    ResultType operator()(const unsigned char* a, const unsigned char* b, int size) const$/;"	f	struct:cvflann::HammingLUT	access:public	signature:(const unsigned char* a, const unsigned char* b, int size) const
cvflann::Heap	flann/heap.h	/^class Heap$/;"	c	namespace:cvflann
cvflann::Heap::CompareT	flann/heap.h	/^    struct CompareT$/;"	s	class:cvflann::Heap	access:public
cvflann::Heap::CompareT::operator ()	flann/heap.h	/^        bool operator()(const T& t_1, const T& t_2) const$/;"	f	struct:cvflann::Heap::CompareT	access:public	signature:(const T& t_1, const T& t_2) const
cvflann::Heap::Heap	flann/heap.h	/^    Heap(int size)$/;"	f	class:cvflann::Heap	access:public	signature:(int size)
cvflann::Heap::clear	flann/heap.h	/^    void clear()$/;"	f	class:cvflann::Heap	access:public	signature:()
cvflann::Heap::count	flann/heap.h	/^    int count;$/;"	m	class:cvflann::Heap	access:private
cvflann::Heap::empty	flann/heap.h	/^    bool empty()$/;"	f	class:cvflann::Heap	access:public	signature:()
cvflann::Heap::heap	flann/heap.h	/^    std::vector<T> heap;$/;"	m	class:cvflann::Heap	access:private
cvflann::Heap::insert	flann/heap.h	/^    void insert(T value)$/;"	f	class:cvflann::Heap	access:public	signature:(T value)
cvflann::Heap::length	flann/heap.h	/^    int length;$/;"	m	class:cvflann::Heap	access:private
cvflann::Heap::popMin	flann/heap.h	/^    bool popMin(T& value)$/;"	f	class:cvflann::Heap	access:public	signature:(T& value)
cvflann::Heap::size	flann/heap.h	/^    int size()$/;"	f	class:cvflann::Heap	access:public	signature:()
cvflann::HellingerDistance	flann/dist.h	/^struct HellingerDistance$/;"	s	namespace:cvflann
cvflann::HellingerDistance::ElementType	flann/dist.h	/^    typedef T ElementType;$/;"	t	struct:cvflann::HellingerDistance	access:public
cvflann::HellingerDistance::ResultType	flann/dist.h	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cvflann::HellingerDistance	access:public
cvflann::HellingerDistance::accum_dist	flann/dist.h	/^    inline ResultType accum_dist(const U& a, const V& b, int) const$/;"	f	struct:cvflann::HellingerDistance	access:public	signature:(const U& a, const V& b, int) const
cvflann::HellingerDistance::is_kdtree_distance	flann/dist.h	/^    typedef True is_kdtree_distance;$/;"	t	struct:cvflann::HellingerDistance	access:public
cvflann::HellingerDistance::is_vector_space_distance	flann/dist.h	/^    typedef True is_vector_space_distance;$/;"	t	struct:cvflann::HellingerDistance	access:public
cvflann::HellingerDistance::operator ()	flann/dist.h	/^    ResultType operator()(Iterator1 a, Iterator2 b, size_t size, ResultType \/*worst_dist*\/ = -1) const$/;"	f	struct:cvflann::HellingerDistance	access:public	signature:(Iterator1 a, Iterator2 b, size_t size, ResultType = -1) const
cvflann::HierarchicalClusteringIndex	flann/hierarchical_clustering_index.h	/^class HierarchicalClusteringIndex : public NNIndex<Distance>$/;"	c	namespace:cvflann	inherits:NNIndex
cvflann::HierarchicalClusteringIndex::BranchSt	flann/hierarchical_clustering_index.h	/^    typedef BranchStruct<NodePtr, DistanceType> BranchSt;$/;"	t	class:cvflann::HierarchicalClusteringIndex	access:private
cvflann::HierarchicalClusteringIndex::DistanceType	flann/hierarchical_clustering_index.h	/^    typedef typename Distance::ResultType DistanceType;$/;"	t	class:cvflann::HierarchicalClusteringIndex	access:public
cvflann::HierarchicalClusteringIndex::ElementType	flann/hierarchical_clustering_index.h	/^    typedef typename Distance::ElementType ElementType;$/;"	t	class:cvflann::HierarchicalClusteringIndex	access:public
cvflann::HierarchicalClusteringIndex::HierarchicalClusteringIndex	flann/hierarchical_clustering_index.h	/^    HierarchicalClusteringIndex(const HierarchicalClusteringIndex&);$/;"	p	class:cvflann::HierarchicalClusteringIndex	access:public	signature:(const HierarchicalClusteringIndex&)
cvflann::HierarchicalClusteringIndex::HierarchicalClusteringIndex	flann/hierarchical_clustering_index.h	/^    HierarchicalClusteringIndex(const Matrix<ElementType>& inputData, const IndexParams& index_params = HierarchicalClusteringIndexParams(),$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:public	signature:(const Matrix<ElementType>& inputData, const IndexParams& index_params = HierarchicalClusteringIndexParams(), Distance d = Distance())
cvflann::HierarchicalClusteringIndex::Node	flann/hierarchical_clustering_index.h	/^    struct Node$/;"	s	class:cvflann::HierarchicalClusteringIndex	access:private
cvflann::HierarchicalClusteringIndex::Node::childs	flann/hierarchical_clustering_index.h	/^        Node** childs;$/;"	m	struct:cvflann::HierarchicalClusteringIndex::Node	access:public
cvflann::HierarchicalClusteringIndex::Node::indices	flann/hierarchical_clustering_index.h	/^        int* indices;$/;"	m	struct:cvflann::HierarchicalClusteringIndex::Node	access:public
cvflann::HierarchicalClusteringIndex::Node::level	flann/hierarchical_clustering_index.h	/^        int level;$/;"	m	struct:cvflann::HierarchicalClusteringIndex::Node	access:public
cvflann::HierarchicalClusteringIndex::Node::pivot	flann/hierarchical_clustering_index.h	/^        int pivot;$/;"	m	struct:cvflann::HierarchicalClusteringIndex::Node	access:public
cvflann::HierarchicalClusteringIndex::Node::size	flann/hierarchical_clustering_index.h	/^        int size;$/;"	m	struct:cvflann::HierarchicalClusteringIndex::Node	access:public
cvflann::HierarchicalClusteringIndex::NodePtr	flann/hierarchical_clustering_index.h	/^    typedef Node* NodePtr;$/;"	t	class:cvflann::HierarchicalClusteringIndex	access:private
cvflann::HierarchicalClusteringIndex::branching_	flann/hierarchical_clustering_index.h	/^    int branching_;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
cvflann::HierarchicalClusteringIndex::buildIndex	flann/hierarchical_clustering_index.h	/^    void buildIndex()$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:public	signature:()
cvflann::HierarchicalClusteringIndex::centersAlgFunction	flann/hierarchical_clustering_index.h	/^    typedef void (HierarchicalClusteringIndex::* centersAlgFunction)(int, int*, int, int*, int&);$/;"	t	class:cvflann::HierarchicalClusteringIndex	access:private
cvflann::HierarchicalClusteringIndex::centers_init_	flann/hierarchical_clustering_index.h	/^    flann_centers_init_t centers_init_;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
cvflann::HierarchicalClusteringIndex::chooseCenters	flann/hierarchical_clustering_index.h	/^    centersAlgFunction chooseCenters;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
cvflann::HierarchicalClusteringIndex::chooseCentersGonzales	flann/hierarchical_clustering_index.h	/^    void chooseCentersGonzales(int k, int* indices, int indices_length, int* centers, int& centers_length)$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:private	signature:(int k, int* indices, int indices_length, int* centers, int& centers_length)
cvflann::HierarchicalClusteringIndex::chooseCentersKMeanspp	flann/hierarchical_clustering_index.h	/^    void chooseCentersKMeanspp(int k, int* indices, int indices_length, int* centers, int& centers_length)$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:private	signature:(int k, int* indices, int indices_length, int* centers, int& centers_length)
cvflann::HierarchicalClusteringIndex::chooseCentersRandom	flann/hierarchical_clustering_index.h	/^    void chooseCentersRandom(int k, int* indices, int indices_length, int* centers, int& centers_length)$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:private	signature:(int k, int* indices, int indices_length, int* centers, int& centers_length)
cvflann::HierarchicalClusteringIndex::computeClustering	flann/hierarchical_clustering_index.h	/^    void computeClustering(NodePtr node, int* indices, int indices_length, int branching, int level)$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:private	signature:(NodePtr node, int* indices, int indices_length, int branching, int level)
cvflann::HierarchicalClusteringIndex::computeLabels	flann/hierarchical_clustering_index.h	/^    void computeLabels(int* indices, int indices_length,  int* centers, int centers_length, int* labels, DistanceType& cost)$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:private	signature:(int* indices, int indices_length, int* centers, int centers_length, int* labels, DistanceType& cost)
cvflann::HierarchicalClusteringIndex::dataset	flann/hierarchical_clustering_index.h	/^    const Matrix<ElementType> dataset;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
cvflann::HierarchicalClusteringIndex::distance	flann/hierarchical_clustering_index.h	/^    Distance distance;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
cvflann::HierarchicalClusteringIndex::findNN	flann/hierarchical_clustering_index.h	/^    void findNN(NodePtr node, ResultSet<DistanceType>& result, const ElementType* vec, int& checks, int maxChecks,$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:private	signature:(NodePtr node, ResultSet<DistanceType>& result, const ElementType* vec, int& checks, int maxChecks, Heap<BranchSt>* heap, std::vector<bool>& checked)
cvflann::HierarchicalClusteringIndex::findNeighbors	flann/hierarchical_clustering_index.h	/^    void findNeighbors(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:public	signature:(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)
cvflann::HierarchicalClusteringIndex::getParameters	flann/hierarchical_clustering_index.h	/^    IndexParams getParameters() const$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:public	signature:() const
cvflann::HierarchicalClusteringIndex::getType	flann/hierarchical_clustering_index.h	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:public	signature:() const
cvflann::HierarchicalClusteringIndex::indices	flann/hierarchical_clustering_index.h	/^    int** indices;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
cvflann::HierarchicalClusteringIndex::leaf_size_	flann/hierarchical_clustering_index.h	/^    int leaf_size_;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
cvflann::HierarchicalClusteringIndex::loadIndex	flann/hierarchical_clustering_index.h	/^    void loadIndex(FILE* stream)$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:public	signature:(FILE* stream)
cvflann::HierarchicalClusteringIndex::load_tree	flann/hierarchical_clustering_index.h	/^    void load_tree(FILE* stream, NodePtr& node, int num)$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:private	signature:(FILE* stream, NodePtr& node, int num)
cvflann::HierarchicalClusteringIndex::memoryCounter	flann/hierarchical_clustering_index.h	/^    int memoryCounter;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
cvflann::HierarchicalClusteringIndex::operator =	flann/hierarchical_clustering_index.h	/^    HierarchicalClusteringIndex& operator=(const HierarchicalClusteringIndex&);$/;"	p	class:cvflann::HierarchicalClusteringIndex	access:public	signature:(const HierarchicalClusteringIndex&)
cvflann::HierarchicalClusteringIndex::params	flann/hierarchical_clustering_index.h	/^    IndexParams params;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
cvflann::HierarchicalClusteringIndex::pool	flann/hierarchical_clustering_index.h	/^    PooledAllocator pool;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
cvflann::HierarchicalClusteringIndex::root	flann/hierarchical_clustering_index.h	/^    NodePtr* root;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
cvflann::HierarchicalClusteringIndex::saveIndex	flann/hierarchical_clustering_index.h	/^    void saveIndex(FILE* stream)$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:public	signature:(FILE* stream)
cvflann::HierarchicalClusteringIndex::save_tree	flann/hierarchical_clustering_index.h	/^    void save_tree(FILE* stream, NodePtr node, int num)$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:private	signature:(FILE* stream, NodePtr node, int num)
cvflann::HierarchicalClusteringIndex::size	flann/hierarchical_clustering_index.h	/^    size_t size() const$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:public	signature:() const
cvflann::HierarchicalClusteringIndex::size_	flann/hierarchical_clustering_index.h	/^    size_t size_;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
cvflann::HierarchicalClusteringIndex::trees_	flann/hierarchical_clustering_index.h	/^    int trees_;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
cvflann::HierarchicalClusteringIndex::usedMemory	flann/hierarchical_clustering_index.h	/^    int usedMemory() const$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:public	signature:() const
cvflann::HierarchicalClusteringIndex::veclen	flann/hierarchical_clustering_index.h	/^    size_t veclen() const$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:public	signature:() const
cvflann::HierarchicalClusteringIndex::veclen_	flann/hierarchical_clustering_index.h	/^    size_t veclen_;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
cvflann::HierarchicalClusteringIndex::~HierarchicalClusteringIndex	flann/hierarchical_clustering_index.h	/^    virtual ~HierarchicalClusteringIndex()$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:public	signature:()
cvflann::HierarchicalClusteringIndexParams	flann/hierarchical_clustering_index.h	/^struct HierarchicalClusteringIndexParams : public IndexParams$/;"	s	namespace:cvflann	inherits:IndexParams
cvflann::HierarchicalClusteringIndexParams::HierarchicalClusteringIndexParams	flann/hierarchical_clustering_index.h	/^    HierarchicalClusteringIndexParams(int branching = 32,$/;"	f	struct:cvflann::HierarchicalClusteringIndexParams	access:public	signature:(int branching = 32, flann_centers_init_t centers_init = FLANN_CENTERS_RANDOM, int trees = 4, int leaf_size = 100)
cvflann::HistIntersectionDistance	flann/dist.h	/^struct HistIntersectionDistance$/;"	s	namespace:cvflann
cvflann::HistIntersectionDistance::ElementType	flann/dist.h	/^    typedef T ElementType;$/;"	t	struct:cvflann::HistIntersectionDistance	access:public
cvflann::HistIntersectionDistance::ResultType	flann/dist.h	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cvflann::HistIntersectionDistance	access:public
cvflann::HistIntersectionDistance::accum_dist	flann/dist.h	/^    inline ResultType accum_dist(const U& a, const V& b, int) const$/;"	f	struct:cvflann::HistIntersectionDistance	access:public	signature:(const U& a, const V& b, int) const
cvflann::HistIntersectionDistance::is_kdtree_distance	flann/dist.h	/^    typedef True is_kdtree_distance;$/;"	t	struct:cvflann::HistIntersectionDistance	access:public
cvflann::HistIntersectionDistance::is_vector_space_distance	flann/dist.h	/^    typedef True is_vector_space_distance;$/;"	t	struct:cvflann::HistIntersectionDistance	access:public
cvflann::HistIntersectionDistance::operator ()	flann/dist.h	/^    ResultType operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const$/;"	f	struct:cvflann::HistIntersectionDistance	access:public	signature:(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const
cvflann::Index	flann/flann_base.hpp	/^class Index : public NNIndex<Distance>$/;"	c	namespace:cvflann	inherits:NNIndex
cvflann::Index::DistanceType	flann/flann_base.hpp	/^    typedef typename Distance::ResultType DistanceType;$/;"	t	class:cvflann::Index	access:public
cvflann::Index::ElementType	flann/flann_base.hpp	/^    typedef typename Distance::ElementType ElementType;$/;"	t	class:cvflann::Index	access:public
cvflann::Index::Index	flann/flann_base.hpp	/^    Index(const Matrix<ElementType>& features, const IndexParams& params, Distance distance = Distance() )$/;"	f	class:cvflann::Index	access:public	signature:(const Matrix<ElementType>& features, const IndexParams& params, Distance distance = Distance() )
cvflann::Index::buildIndex	flann/flann_base.hpp	/^    void buildIndex()$/;"	f	class:cvflann::Index	access:public	signature:()
cvflann::Index::findNeighbors	flann/flann_base.hpp	/^    void findNeighbors(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)$/;"	f	class:cvflann::Index	access:public	signature:(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)
cvflann::Index::getIndex	flann/flann_base.hpp	/^    FLANN_DEPRECATED NNIndex<Distance>* getIndex()$/;"	f	class:cvflann::Index	access:public	signature:()
cvflann::Index::getIndexParameters	flann/flann_base.hpp	/^    FLANN_DEPRECATED  const IndexParams* getIndexParameters()$/;"	f	class:cvflann::Index	access:public	signature:()
cvflann::Index::getParameters	flann/flann_base.hpp	/^    IndexParams getParameters() const$/;"	f	class:cvflann::Index	access:public	signature:() const
cvflann::Index::getType	flann/flann_base.hpp	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::Index	access:public	signature:() const
cvflann::Index::index_params_	flann/flann_base.hpp	/^    IndexParams index_params_;$/;"	m	class:cvflann::Index	access:private
cvflann::Index::knnSearch	flann/flann_base.hpp	/^    void knnSearch(const Matrix<ElementType>& queries, Matrix<int>& indices, Matrix<DistanceType>& dists, int knn, const SearchParams& params)$/;"	f	class:cvflann::Index	access:public	signature:(const Matrix<ElementType>& queries, Matrix<int>& indices, Matrix<DistanceType>& dists, int knn, const SearchParams& params)
cvflann::Index::loadIndex	flann/flann_base.hpp	/^    virtual void loadIndex(FILE* stream)$/;"	f	class:cvflann::Index	access:public	signature:(FILE* stream)
cvflann::Index::loaded_	flann/flann_base.hpp	/^    bool loaded_;$/;"	m	class:cvflann::Index	access:private
cvflann::Index::nnIndex_	flann/flann_base.hpp	/^    NNIndex<Distance>* nnIndex_;$/;"	m	class:cvflann::Index	access:private
cvflann::Index::radiusSearch	flann/flann_base.hpp	/^    int radiusSearch(const Matrix<ElementType>& query, Matrix<int>& indices, Matrix<DistanceType>& dists, float radius, const SearchParams& params)$/;"	f	class:cvflann::Index	access:public	signature:(const Matrix<ElementType>& query, Matrix<int>& indices, Matrix<DistanceType>& dists, float radius, const SearchParams& params)
cvflann::Index::save	flann/flann_base.hpp	/^    void save(std::string filename)$/;"	f	class:cvflann::Index	access:public	signature:(std::string filename)
cvflann::Index::saveIndex	flann/flann_base.hpp	/^    virtual void saveIndex(FILE* stream)$/;"	f	class:cvflann::Index	access:public	signature:(FILE* stream)
cvflann::Index::size	flann/flann_base.hpp	/^    size_t size() const$/;"	f	class:cvflann::Index	access:public	signature:() const
cvflann::Index::usedMemory	flann/flann_base.hpp	/^    virtual int usedMemory() const$/;"	f	class:cvflann::Index	access:public	signature:() const
cvflann::Index::veclen	flann/flann_base.hpp	/^    size_t veclen() const$/;"	f	class:cvflann::Index	access:public	signature:() const
cvflann::Index::~Index	flann/flann_base.hpp	/^    ~Index()$/;"	f	class:cvflann::Index	access:public	signature:()
cvflann::IndexHeader	flann/saving.h	/^struct IndexHeader$/;"	s	namespace:cvflann
cvflann::IndexHeader::cols	flann/saving.h	/^    size_t cols;$/;"	m	struct:cvflann::IndexHeader	access:public
cvflann::IndexHeader::data_type	flann/saving.h	/^    flann_datatype_t data_type;$/;"	m	struct:cvflann::IndexHeader	access:public
cvflann::IndexHeader::index_type	flann/saving.h	/^    flann_algorithm_t index_type;$/;"	m	struct:cvflann::IndexHeader	access:public
cvflann::IndexHeader::rows	flann/saving.h	/^    size_t rows;$/;"	m	struct:cvflann::IndexHeader	access:public
cvflann::IndexHeader::signature	flann/saving.h	/^    char signature[16];$/;"	m	struct:cvflann::IndexHeader	access:public
cvflann::IndexHeader::version	flann/saving.h	/^    char version[16];$/;"	m	struct:cvflann::IndexHeader	access:public
cvflann::IndexParams	flann/params.h	/^typedef std::map<std::string, any> IndexParams;$/;"	t	namespace:cvflann
cvflann::KDTREE	flann/defines.h	/^    KDTREE = 1,$/;"	e	enum:cvflann::flann_algorithm_t
cvflann::KDTREE_SINGLE	flann/defines.h	/^    KDTREE_SINGLE = 4,$/;"	e	enum:cvflann::flann_algorithm_t
cvflann::KDTreeIndex	flann/kdtree_index.h	/^class KDTreeIndex : public NNIndex<Distance>$/;"	c	namespace:cvflann	inherits:NNIndex
cvflann::KDTreeIndex::Branch	flann/kdtree_index.h	/^    typedef BranchSt* Branch;$/;"	t	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::BranchSt	flann/kdtree_index.h	/^    typedef BranchStruct<NodePtr, DistanceType> BranchSt;$/;"	t	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::DistanceType	flann/kdtree_index.h	/^    typedef typename Distance::ResultType DistanceType;$/;"	t	class:cvflann::KDTreeIndex	access:public
cvflann::KDTreeIndex::ElementType	flann/kdtree_index.h	/^    typedef typename Distance::ElementType ElementType;$/;"	t	class:cvflann::KDTreeIndex	access:public
cvflann::KDTreeIndex::KDTreeIndex	flann/kdtree_index.h	/^    KDTreeIndex(const KDTreeIndex&);$/;"	p	class:cvflann::KDTreeIndex	access:public	signature:(const KDTreeIndex&)
cvflann::KDTreeIndex::KDTreeIndex	flann/kdtree_index.h	/^    KDTreeIndex(const Matrix<ElementType>& inputData, const IndexParams& params = KDTreeIndexParams(),$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:(const Matrix<ElementType>& inputData, const IndexParams& params = KDTreeIndexParams(), Distance d = Distance() )
cvflann::KDTreeIndex::Node	flann/kdtree_index.h	/^    struct Node$/;"	s	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::Node::child1	flann/kdtree_index.h	/^        Node* child1, * child2;$/;"	m	struct:cvflann::KDTreeIndex::Node	access:public
cvflann::KDTreeIndex::Node::child2	flann/kdtree_index.h	/^        Node* child1, * child2;$/;"	m	struct:cvflann::KDTreeIndex::Node	access:public
cvflann::KDTreeIndex::Node::divfeat	flann/kdtree_index.h	/^        int divfeat;$/;"	m	struct:cvflann::KDTreeIndex::Node	access:public
cvflann::KDTreeIndex::Node::divval	flann/kdtree_index.h	/^        DistanceType divval;$/;"	m	struct:cvflann::KDTreeIndex::Node	access:public
cvflann::KDTreeIndex::NodePtr	flann/kdtree_index.h	/^    typedef Node* NodePtr;$/;"	t	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::RAND_DIM	flann/kdtree_index.h	/^        RAND_DIM=5$/;"	e	enum:cvflann::KDTreeIndex::__anon206
cvflann::KDTreeIndex::SAMPLE_MEAN	flann/kdtree_index.h	/^        SAMPLE_MEAN = 100,$/;"	e	enum:cvflann::KDTreeIndex::__anon206
cvflann::KDTreeIndex::buildIndex	flann/kdtree_index.h	/^    void buildIndex()$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:()
cvflann::KDTreeIndex::dataset_	flann/kdtree_index.h	/^    const Matrix<ElementType> dataset_;$/;"	m	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::distance_	flann/kdtree_index.h	/^    Distance distance_;$/;"	m	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::divideTree	flann/kdtree_index.h	/^    NodePtr divideTree(int* ind, int count)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(int* ind, int count)
cvflann::KDTreeIndex::findNeighbors	flann/kdtree_index.h	/^    void findNeighbors(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)
cvflann::KDTreeIndex::getExactNeighbors	flann/kdtree_index.h	/^    void getExactNeighbors(ResultSet<DistanceType>& result, const ElementType* vec, float epsError)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(ResultSet<DistanceType>& result, const ElementType* vec, float epsError)
cvflann::KDTreeIndex::getNeighbors	flann/kdtree_index.h	/^    void getNeighbors(ResultSet<DistanceType>& result, const ElementType* vec, int maxCheck, float epsError)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(ResultSet<DistanceType>& result, const ElementType* vec, int maxCheck, float epsError)
cvflann::KDTreeIndex::getParameters	flann/kdtree_index.h	/^    IndexParams getParameters() const$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:() const
cvflann::KDTreeIndex::getType	flann/kdtree_index.h	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:() const
cvflann::KDTreeIndex::index_params_	flann/kdtree_index.h	/^    IndexParams index_params_;$/;"	m	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::loadIndex	flann/kdtree_index.h	/^    void loadIndex(FILE* stream)$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:(FILE* stream)
cvflann::KDTreeIndex::load_tree	flann/kdtree_index.h	/^    void load_tree(FILE* stream, NodePtr& tree)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(FILE* stream, NodePtr& tree)
cvflann::KDTreeIndex::meanSplit	flann/kdtree_index.h	/^    void meanSplit(int* ind, int count, int& index, int& cutfeat, DistanceType& cutval)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(int* ind, int count, int& index, int& cutfeat, DistanceType& cutval)
cvflann::KDTreeIndex::mean_	flann/kdtree_index.h	/^    DistanceType* mean_;$/;"	m	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::operator =	flann/kdtree_index.h	/^    KDTreeIndex& operator=(const KDTreeIndex&);$/;"	p	class:cvflann::KDTreeIndex	access:public	signature:(const KDTreeIndex&)
cvflann::KDTreeIndex::planeSplit	flann/kdtree_index.h	/^    void planeSplit(int* ind, int count, int cutfeat, DistanceType cutval, int& lim1, int& lim2)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(int* ind, int count, int cutfeat, DistanceType cutval, int& lim1, int& lim2)
cvflann::KDTreeIndex::pool_	flann/kdtree_index.h	/^    PooledAllocator pool_;$/;"	m	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::saveIndex	flann/kdtree_index.h	/^    void saveIndex(FILE* stream)$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:(FILE* stream)
cvflann::KDTreeIndex::save_tree	flann/kdtree_index.h	/^    void save_tree(FILE* stream, NodePtr tree)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(FILE* stream, NodePtr tree)
cvflann::KDTreeIndex::searchLevel	flann/kdtree_index.h	/^    void searchLevel(ResultSet<DistanceType>& result_set, const ElementType* vec, NodePtr node, DistanceType mindist, int& checkCount, int maxCheck,$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(ResultSet<DistanceType>& result_set, const ElementType* vec, NodePtr node, DistanceType mindist, int& checkCount, int maxCheck, float epsError, Heap<BranchSt>* heap, DynamicBitset& checked)
cvflann::KDTreeIndex::searchLevelExact	flann/kdtree_index.h	/^    void searchLevelExact(ResultSet<DistanceType>& result_set, const ElementType* vec, const NodePtr node, DistanceType mindist, const float epsError)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(ResultSet<DistanceType>& result_set, const ElementType* vec, const NodePtr node, DistanceType mindist, const float epsError)
cvflann::KDTreeIndex::selectDivision	flann/kdtree_index.h	/^    int selectDivision(DistanceType* v)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(DistanceType* v)
cvflann::KDTreeIndex::size	flann/kdtree_index.h	/^    size_t size() const$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:() const
cvflann::KDTreeIndex::size_	flann/kdtree_index.h	/^    size_t size_;$/;"	m	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::tree_roots_	flann/kdtree_index.h	/^    NodePtr* tree_roots_;$/;"	m	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::trees_	flann/kdtree_index.h	/^    int trees_;$/;"	m	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::usedMemory	flann/kdtree_index.h	/^    int usedMemory() const$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:() const
cvflann::KDTreeIndex::var_	flann/kdtree_index.h	/^    DistanceType* var_;$/;"	m	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::veclen	flann/kdtree_index.h	/^    size_t veclen() const$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:() const
cvflann::KDTreeIndex::veclen_	flann/kdtree_index.h	/^    size_t veclen_;$/;"	m	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::vind_	flann/kdtree_index.h	/^    std::vector<int> vind_;$/;"	m	class:cvflann::KDTreeIndex	access:private
cvflann::KDTreeIndex::~KDTreeIndex	flann/kdtree_index.h	/^    ~KDTreeIndex()$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:()
cvflann::KDTreeIndexParams	flann/kdtree_index.h	/^struct KDTreeIndexParams : public IndexParams$/;"	s	namespace:cvflann	inherits:IndexParams
cvflann::KDTreeIndexParams::KDTreeIndexParams	flann/kdtree_index.h	/^    KDTreeIndexParams(int trees = 4)$/;"	f	struct:cvflann::KDTreeIndexParams	access:public	signature:(int trees = 4)
cvflann::KDTreeSingleIndex	flann/kdtree_single_index.h	/^class KDTreeSingleIndex : public NNIndex<Distance>$/;"	c	namespace:cvflann	inherits:NNIndex
cvflann::KDTreeSingleIndex::BoundingBox	flann/kdtree_single_index.h	/^    typedef std::vector<Interval> BoundingBox;$/;"	t	class:cvflann::KDTreeSingleIndex	access:private
cvflann::KDTreeSingleIndex::Branch	flann/kdtree_single_index.h	/^    typedef BranchSt* Branch;$/;"	t	class:cvflann::KDTreeSingleIndex	access:private
cvflann::KDTreeSingleIndex::BranchSt	flann/kdtree_single_index.h	/^    typedef BranchStruct<NodePtr, DistanceType> BranchSt;$/;"	t	class:cvflann::KDTreeSingleIndex	access:private
cvflann::KDTreeSingleIndex::DistanceType	flann/kdtree_single_index.h	/^    typedef typename Distance::ResultType DistanceType;$/;"	t	class:cvflann::KDTreeSingleIndex	access:public
cvflann::KDTreeSingleIndex::ElementType	flann/kdtree_single_index.h	/^    typedef typename Distance::ElementType ElementType;$/;"	t	class:cvflann::KDTreeSingleIndex	access:public
cvflann::KDTreeSingleIndex::Interval	flann/kdtree_single_index.h	/^    struct Interval$/;"	s	class:cvflann::KDTreeSingleIndex	access:private
cvflann::KDTreeSingleIndex::Interval::high	flann/kdtree_single_index.h	/^        DistanceType low, high;$/;"	m	struct:cvflann::KDTreeSingleIndex::Interval	access:public
cvflann::KDTreeSingleIndex::Interval::low	flann/kdtree_single_index.h	/^        DistanceType low, high;$/;"	m	struct:cvflann::KDTreeSingleIndex::Interval	access:public
cvflann::KDTreeSingleIndex::KDTreeSingleIndex	flann/kdtree_single_index.h	/^    KDTreeSingleIndex(const KDTreeSingleIndex&);$/;"	p	class:cvflann::KDTreeSingleIndex	access:public	signature:(const KDTreeSingleIndex&)
cvflann::KDTreeSingleIndex::KDTreeSingleIndex	flann/kdtree_single_index.h	/^    KDTreeSingleIndex(const Matrix<ElementType>& inputData, const IndexParams& params = KDTreeSingleIndexParams(),$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:(const Matrix<ElementType>& inputData, const IndexParams& params = KDTreeSingleIndexParams(), Distance d = Distance() )
cvflann::KDTreeSingleIndex::Node	flann/kdtree_single_index.h	/^    struct Node$/;"	s	class:cvflann::KDTreeSingleIndex	access:private
cvflann::KDTreeSingleIndex::Node::child1	flann/kdtree_single_index.h	/^        Node* child1, * child2;$/;"	m	struct:cvflann::KDTreeSingleIndex::Node	access:public
cvflann::KDTreeSingleIndex::Node::child2	flann/kdtree_single_index.h	/^        Node* child1, * child2;$/;"	m	struct:cvflann::KDTreeSingleIndex::Node	access:public
cvflann::KDTreeSingleIndex::Node::divfeat	flann/kdtree_single_index.h	/^    	int divfeat;$/;"	m	struct:cvflann::KDTreeSingleIndex::Node	access:public
cvflann::KDTreeSingleIndex::Node::divhigh	flann/kdtree_single_index.h	/^    	DistanceType divlow, divhigh;$/;"	m	struct:cvflann::KDTreeSingleIndex::Node	access:public
cvflann::KDTreeSingleIndex::Node::divlow	flann/kdtree_single_index.h	/^    	DistanceType divlow, divhigh;$/;"	m	struct:cvflann::KDTreeSingleIndex::Node	access:public
cvflann::KDTreeSingleIndex::Node::left	flann/kdtree_single_index.h	/^    	int left, right;$/;"	m	struct:cvflann::KDTreeSingleIndex::Node	access:public
cvflann::KDTreeSingleIndex::Node::right	flann/kdtree_single_index.h	/^    	int left, right;$/;"	m	struct:cvflann::KDTreeSingleIndex::Node	access:public
cvflann::KDTreeSingleIndex::NodePtr	flann/kdtree_single_index.h	/^    typedef Node* NodePtr;$/;"	t	class:cvflann::KDTreeSingleIndex	access:private
cvflann::KDTreeSingleIndex::buildIndex	flann/kdtree_single_index.h	/^    void buildIndex()$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:()
cvflann::KDTreeSingleIndex::computeBoundingBox	flann/kdtree_single_index.h	/^    void computeBoundingBox(BoundingBox& bbox)$/;"	f	class:cvflann::KDTreeSingleIndex	access:private	signature:(BoundingBox& bbox)
cvflann::KDTreeSingleIndex::computeInitialDistances	flann/kdtree_single_index.h	/^    DistanceType computeInitialDistances(const ElementType* vec, std::vector<DistanceType>& dists)$/;"	f	class:cvflann::KDTreeSingleIndex	access:private	signature:(const ElementType* vec, std::vector<DistanceType>& dists)
cvflann::KDTreeSingleIndex::computeMinMax	flann/kdtree_single_index.h	/^    void computeMinMax(int* ind, int count, int dim, ElementType& min_elem, ElementType& max_elem)$/;"	f	class:cvflann::KDTreeSingleIndex	access:private	signature:(int* ind, int count, int dim, ElementType& min_elem, ElementType& max_elem)
cvflann::KDTreeSingleIndex::data_	flann/kdtree_single_index.h	/^    Matrix<ElementType> data_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
cvflann::KDTreeSingleIndex::dataset_	flann/kdtree_single_index.h	/^    const Matrix<ElementType> dataset_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
cvflann::KDTreeSingleIndex::dim_	flann/kdtree_single_index.h	/^    size_t dim_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
cvflann::KDTreeSingleIndex::distance_	flann/kdtree_single_index.h	/^    Distance distance_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
cvflann::KDTreeSingleIndex::divideTree	flann/kdtree_single_index.h	/^    NodePtr divideTree(int left, int right, BoundingBox& bbox)$/;"	f	class:cvflann::KDTreeSingleIndex	access:private	signature:(int left, int right, BoundingBox& bbox)
cvflann::KDTreeSingleIndex::findNeighbors	flann/kdtree_single_index.h	/^    void findNeighbors(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)
cvflann::KDTreeSingleIndex::getParameters	flann/kdtree_single_index.h	/^    IndexParams getParameters() const$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:() const
cvflann::KDTreeSingleIndex::getType	flann/kdtree_single_index.h	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:() const
cvflann::KDTreeSingleIndex::index_params_	flann/kdtree_single_index.h	/^    IndexParams index_params_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
cvflann::KDTreeSingleIndex::knnSearch	flann/kdtree_single_index.h	/^    void knnSearch(const Matrix<ElementType>& queries, Matrix<int>& indices, Matrix<DistanceType>& dists, int knn, const SearchParams& params)$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:(const Matrix<ElementType>& queries, Matrix<int>& indices, Matrix<DistanceType>& dists, int knn, const SearchParams& params)
cvflann::KDTreeSingleIndex::leaf_max_size_	flann/kdtree_single_index.h	/^    int leaf_max_size_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
cvflann::KDTreeSingleIndex::loadIndex	flann/kdtree_single_index.h	/^    void loadIndex(FILE* stream)$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:(FILE* stream)
cvflann::KDTreeSingleIndex::load_tree	flann/kdtree_single_index.h	/^    void load_tree(FILE* stream, NodePtr& tree)$/;"	f	class:cvflann::KDTreeSingleIndex	access:private	signature:(FILE* stream, NodePtr& tree)
cvflann::KDTreeSingleIndex::middleSplit	flann/kdtree_single_index.h	/^    void middleSplit(int* ind, int count, int& index, int& cutfeat, DistanceType& cutval, const BoundingBox& bbox)$/;"	f	class:cvflann::KDTreeSingleIndex	access:private	signature:(int* ind, int count, int& index, int& cutfeat, DistanceType& cutval, const BoundingBox& bbox)
cvflann::KDTreeSingleIndex::middleSplit_	flann/kdtree_single_index.h	/^    void middleSplit_(int* ind, int count, int& index, int& cutfeat, DistanceType& cutval, const BoundingBox& bbox)$/;"	f	class:cvflann::KDTreeSingleIndex	access:private	signature:(int* ind, int count, int& index, int& cutfeat, DistanceType& cutval, const BoundingBox& bbox)
cvflann::KDTreeSingleIndex::operator =	flann/kdtree_single_index.h	/^    KDTreeSingleIndex& operator=(const KDTreeSingleIndex&);$/;"	p	class:cvflann::KDTreeSingleIndex	access:public	signature:(const KDTreeSingleIndex&)
cvflann::KDTreeSingleIndex::planeSplit	flann/kdtree_single_index.h	/^    void planeSplit(int* ind, int count, int cutfeat, DistanceType cutval, int& lim1, int& lim2)$/;"	f	class:cvflann::KDTreeSingleIndex	access:private	signature:(int* ind, int count, int cutfeat, DistanceType cutval, int& lim1, int& lim2)
cvflann::KDTreeSingleIndex::pool_	flann/kdtree_single_index.h	/^    PooledAllocator pool_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
cvflann::KDTreeSingleIndex::reorder_	flann/kdtree_single_index.h	/^    bool reorder_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
cvflann::KDTreeSingleIndex::root_bbox_	flann/kdtree_single_index.h	/^    BoundingBox root_bbox_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
cvflann::KDTreeSingleIndex::root_node_	flann/kdtree_single_index.h	/^    NodePtr root_node_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
cvflann::KDTreeSingleIndex::saveIndex	flann/kdtree_single_index.h	/^    void saveIndex(FILE* stream)$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:(FILE* stream)
cvflann::KDTreeSingleIndex::save_tree	flann/kdtree_single_index.h	/^    void save_tree(FILE* stream, NodePtr tree)$/;"	f	class:cvflann::KDTreeSingleIndex	access:private	signature:(FILE* stream, NodePtr tree)
cvflann::KDTreeSingleIndex::searchLevel	flann/kdtree_single_index.h	/^    void searchLevel(ResultSet<DistanceType>& result_set, const ElementType* vec, const NodePtr node, DistanceType mindistsq,$/;"	f	class:cvflann::KDTreeSingleIndex	access:private	signature:(ResultSet<DistanceType>& result_set, const ElementType* vec, const NodePtr node, DistanceType mindistsq, std::vector<DistanceType>& dists, const float epsError)
cvflann::KDTreeSingleIndex::size	flann/kdtree_single_index.h	/^    size_t size() const$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:() const
cvflann::KDTreeSingleIndex::size_	flann/kdtree_single_index.h	/^    size_t size_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
cvflann::KDTreeSingleIndex::usedMemory	flann/kdtree_single_index.h	/^    int usedMemory() const$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:() const
cvflann::KDTreeSingleIndex::veclen	flann/kdtree_single_index.h	/^    size_t veclen() const$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:() const
cvflann::KDTreeSingleIndex::vind_	flann/kdtree_single_index.h	/^    std::vector<int> vind_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
cvflann::KDTreeSingleIndex::~KDTreeSingleIndex	flann/kdtree_single_index.h	/^    ~KDTreeSingleIndex()$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:()
cvflann::KDTreeSingleIndexParams	flann/kdtree_single_index.h	/^struct KDTreeSingleIndexParams : public IndexParams$/;"	s	namespace:cvflann	inherits:IndexParams
cvflann::KDTreeSingleIndexParams::KDTreeSingleIndexParams	flann/kdtree_single_index.h	/^    KDTreeSingleIndexParams(int leaf_max_size = 10, bool reorder = true, int dim = -1)$/;"	f	struct:cvflann::KDTreeSingleIndexParams	access:public	signature:(int leaf_max_size = 10, bool reorder = true, int dim = -1)
cvflann::KL	flann/defines.h	/^    KL         = 8,$/;"	e	enum:cvflann::flann_distance_t
cvflann::KL_Divergence	flann/dist.h	/^struct KL_Divergence$/;"	s	namespace:cvflann
cvflann::KL_Divergence::ElementType	flann/dist.h	/^    typedef T ElementType;$/;"	t	struct:cvflann::KL_Divergence	access:public
cvflann::KL_Divergence::ResultType	flann/dist.h	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cvflann::KL_Divergence	access:public
cvflann::KL_Divergence::accum_dist	flann/dist.h	/^    inline ResultType accum_dist(const U& a, const V& b, int) const$/;"	f	struct:cvflann::KL_Divergence	access:public	signature:(const U& a, const V& b, int) const
cvflann::KL_Divergence::is_kdtree_distance	flann/dist.h	/^    typedef True is_kdtree_distance;$/;"	t	struct:cvflann::KL_Divergence	access:public
cvflann::KL_Divergence::is_vector_space_distance	flann/dist.h	/^    typedef True is_vector_space_distance;$/;"	t	struct:cvflann::KL_Divergence	access:public
cvflann::KL_Divergence::operator ()	flann/dist.h	/^    ResultType operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const$/;"	f	struct:cvflann::KL_Divergence	access:public	signature:(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const
cvflann::KMEANS	flann/defines.h	/^    KMEANS = 2,$/;"	e	enum:cvflann::flann_algorithm_t
cvflann::KMeansIndex	flann/kmeans_index.h	/^class KMeansIndex : public NNIndex<Distance>$/;"	c	namespace:cvflann	inherits:NNIndex
cvflann::KMeansIndex::BranchSt	flann/kmeans_index.h	/^    typedef BranchStruct<KMeansNodePtr, DistanceType> BranchSt;$/;"	t	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::DistanceType	flann/kmeans_index.h	/^    typedef typename Distance::ResultType DistanceType;$/;"	t	class:cvflann::KMeansIndex	access:public
cvflann::KMeansIndex::ElementType	flann/kmeans_index.h	/^    typedef typename Distance::ElementType ElementType;$/;"	t	class:cvflann::KMeansIndex	access:public
cvflann::KMeansIndex::KMeansIndex	flann/kmeans_index.h	/^    KMeansIndex(const KMeansIndex&);$/;"	p	class:cvflann::KMeansIndex	access:public	signature:(const KMeansIndex&)
cvflann::KMeansIndex::KMeansIndex	flann/kmeans_index.h	/^    KMeansIndex(const Matrix<ElementType>& inputData, const IndexParams& params = KMeansIndexParams(),$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(const Matrix<ElementType>& inputData, const IndexParams& params = KMeansIndexParams(), Distance d = Distance())
cvflann::KMeansIndex::KMeansNode	flann/kmeans_index.h	/^    struct KMeansNode$/;"	s	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::KMeansNode::childs	flann/kmeans_index.h	/^        KMeansNode** childs;$/;"	m	struct:cvflann::KMeansIndex::KMeansNode	access:public
cvflann::KMeansIndex::KMeansNode::indices	flann/kmeans_index.h	/^        int* indices;$/;"	m	struct:cvflann::KMeansIndex::KMeansNode	access:public
cvflann::KMeansIndex::KMeansNode::level	flann/kmeans_index.h	/^        int level;$/;"	m	struct:cvflann::KMeansIndex::KMeansNode	access:public
cvflann::KMeansIndex::KMeansNode::mean_radius	flann/kmeans_index.h	/^        DistanceType mean_radius;$/;"	m	struct:cvflann::KMeansIndex::KMeansNode	access:public
cvflann::KMeansIndex::KMeansNode::pivot	flann/kmeans_index.h	/^        DistanceType* pivot;$/;"	m	struct:cvflann::KMeansIndex::KMeansNode	access:public
cvflann::KMeansIndex::KMeansNode::radius	flann/kmeans_index.h	/^        DistanceType radius;$/;"	m	struct:cvflann::KMeansIndex::KMeansNode	access:public
cvflann::KMeansIndex::KMeansNode::size	flann/kmeans_index.h	/^        int size;$/;"	m	struct:cvflann::KMeansIndex::KMeansNode	access:public
cvflann::KMeansIndex::KMeansNode::variance	flann/kmeans_index.h	/^        DistanceType variance;$/;"	m	struct:cvflann::KMeansIndex::KMeansNode	access:public
cvflann::KMeansIndex::KMeansNodePtr	flann/kmeans_index.h	/^    typedef KMeansNode* KMeansNodePtr;$/;"	t	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::branching_	flann/kmeans_index.h	/^    int branching_;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::buildIndex	flann/kmeans_index.h	/^    void buildIndex()$/;"	f	class:cvflann::KMeansIndex	access:public	signature:()
cvflann::KMeansIndex::cb_index_	flann/kmeans_index.h	/^    float cb_index_;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::centersAlgFunction	flann/kmeans_index.h	/^    typedef void (KMeansIndex::* centersAlgFunction)(int, int*, int, int*, int&);$/;"	t	class:cvflann::KMeansIndex	access:public
cvflann::KMeansIndex::centers_init_	flann/kmeans_index.h	/^    flann_centers_init_t centers_init_;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::chooseCenters	flann/kmeans_index.h	/^    centersAlgFunction chooseCenters;$/;"	m	class:cvflann::KMeansIndex	access:public
cvflann::KMeansIndex::chooseCentersGonzales	flann/kmeans_index.h	/^    void chooseCentersGonzales(int k, int* indices, int indices_length, int* centers, int& centers_length)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(int k, int* indices, int indices_length, int* centers, int& centers_length)
cvflann::KMeansIndex::chooseCentersKMeanspp	flann/kmeans_index.h	/^    void chooseCentersKMeanspp(int k, int* indices, int indices_length, int* centers, int& centers_length)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(int k, int* indices, int indices_length, int* centers, int& centers_length)
cvflann::KMeansIndex::chooseCentersRandom	flann/kmeans_index.h	/^    void chooseCentersRandom(int k, int* indices, int indices_length, int* centers, int& centers_length)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(int k, int* indices, int indices_length, int* centers, int& centers_length)
cvflann::KMeansIndex::computeClustering	flann/kmeans_index.h	/^    void computeClustering(KMeansNodePtr node, int* indices, int indices_length, int branching, int level)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNodePtr node, int* indices, int indices_length, int branching, int level)
cvflann::KMeansIndex::computeNodeStatistics	flann/kmeans_index.h	/^    void computeNodeStatistics(KMeansNodePtr node, int* indices, int indices_length)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNodePtr node, int* indices, int indices_length)
cvflann::KMeansIndex::dataset_	flann/kmeans_index.h	/^    const Matrix<ElementType> dataset_;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::distance_	flann/kmeans_index.h	/^    Distance distance_;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::exploreNodeBranches	flann/kmeans_index.h	/^    int exploreNodeBranches(KMeansNodePtr node, const ElementType* q, DistanceType* domain_distances, Heap<BranchSt>* heap)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNodePtr node, const ElementType* q, DistanceType* domain_distances, Heap<BranchSt>* heap)
cvflann::KMeansIndex::findExactNN	flann/kmeans_index.h	/^    void findExactNN(KMeansNodePtr node, ResultSet<DistanceType>& result, const ElementType* vec)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNodePtr node, ResultSet<DistanceType>& result, const ElementType* vec)
cvflann::KMeansIndex::findNN	flann/kmeans_index.h	/^    void findNN(KMeansNodePtr node, ResultSet<DistanceType>& result, const ElementType* vec, int& checks, int maxChecks,$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNodePtr node, ResultSet<DistanceType>& result, const ElementType* vec, int& checks, int maxChecks, Heap<BranchSt>* heap)
cvflann::KMeansIndex::findNeighbors	flann/kmeans_index.h	/^    void findNeighbors(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)
cvflann::KMeansIndex::free_centers	flann/kmeans_index.h	/^    void free_centers(KMeansNodePtr node)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNodePtr node)
cvflann::KMeansIndex::getCenterOrdering	flann/kmeans_index.h	/^    void getCenterOrdering(KMeansNodePtr node, const ElementType* q, int* sort_indices)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNodePtr node, const ElementType* q, int* sort_indices)
cvflann::KMeansIndex::getClusterCenters	flann/kmeans_index.h	/^    int getClusterCenters(Matrix<DistanceType>& centers)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(Matrix<DistanceType>& centers)
cvflann::KMeansIndex::getDistanceToBorder	flann/kmeans_index.h	/^    DistanceType getDistanceToBorder(DistanceType* p, DistanceType* c, DistanceType* q)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(DistanceType* p, DistanceType* c, DistanceType* q)
cvflann::KMeansIndex::getMinVarianceClusters	flann/kmeans_index.h	/^    int getMinVarianceClusters(KMeansNodePtr root, KMeansNodePtr* clusters, int clusters_length, DistanceType& varianceValue)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNodePtr root, KMeansNodePtr* clusters, int clusters_length, DistanceType& varianceValue)
cvflann::KMeansIndex::getParameters	flann/kmeans_index.h	/^    IndexParams getParameters() const$/;"	f	class:cvflann::KMeansIndex	access:public	signature:() const
cvflann::KMeansIndex::getType	flann/kmeans_index.h	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::KMeansIndex	access:public	signature:() const
cvflann::KMeansIndex::index_params_	flann/kmeans_index.h	/^    IndexParams index_params_;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::indices_	flann/kmeans_index.h	/^    int* indices_;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::iterations_	flann/kmeans_index.h	/^    int iterations_;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::loadIndex	flann/kmeans_index.h	/^    void loadIndex(FILE* stream)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(FILE* stream)
cvflann::KMeansIndex::load_tree	flann/kmeans_index.h	/^    void load_tree(FILE* stream, KMeansNodePtr& node)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(FILE* stream, KMeansNodePtr& node)
cvflann::KMeansIndex::memoryCounter_	flann/kmeans_index.h	/^    int memoryCounter_;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::operator =	flann/kmeans_index.h	/^    KMeansIndex& operator=(const KMeansIndex&);$/;"	p	class:cvflann::KMeansIndex	access:public	signature:(const KMeansIndex&)
cvflann::KMeansIndex::pool_	flann/kmeans_index.h	/^    PooledAllocator pool_;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::root_	flann/kmeans_index.h	/^    KMeansNodePtr root_;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::saveIndex	flann/kmeans_index.h	/^    void saveIndex(FILE* stream)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(FILE* stream)
cvflann::KMeansIndex::save_tree	flann/kmeans_index.h	/^    void save_tree(FILE* stream, KMeansNodePtr node)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(FILE* stream, KMeansNodePtr node)
cvflann::KMeansIndex::set_cb_index	flann/kmeans_index.h	/^    void set_cb_index( float index)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:( float index)
cvflann::KMeansIndex::size	flann/kmeans_index.h	/^    size_t size() const$/;"	f	class:cvflann::KMeansIndex	access:public	signature:() const
cvflann::KMeansIndex::size_	flann/kmeans_index.h	/^    size_t size_;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::usedMemory	flann/kmeans_index.h	/^    int usedMemory() const$/;"	f	class:cvflann::KMeansIndex	access:public	signature:() const
cvflann::KMeansIndex::veclen	flann/kmeans_index.h	/^    size_t veclen() const$/;"	f	class:cvflann::KMeansIndex	access:public	signature:() const
cvflann::KMeansIndex::veclen_	flann/kmeans_index.h	/^    size_t veclen_;$/;"	m	class:cvflann::KMeansIndex	access:private
cvflann::KMeansIndex::~KMeansIndex	flann/kmeans_index.h	/^    virtual ~KMeansIndex()$/;"	f	class:cvflann::KMeansIndex	access:public	signature:()
cvflann::KMeansIndexParams	flann/kmeans_index.h	/^struct KMeansIndexParams : public IndexParams$/;"	s	namespace:cvflann	inherits:IndexParams
cvflann::KMeansIndexParams::KMeansIndexParams	flann/kmeans_index.h	/^    KMeansIndexParams(int branching = 32, int iterations = 11,$/;"	f	struct:cvflann::KMeansIndexParams	access:public	signature:(int branching = 32, int iterations = 11, flann_centers_init_t centers_init = FLANN_CENTERS_RANDOM, float cb_index = 0.2 )
cvflann::KNNRadiusUniqueResultSet	flann/result_set.h	/^class KNNRadiusUniqueResultSet : public KNNUniqueResultSet<DistanceType>$/;"	c	namespace:cvflann	inherits:KNNUniqueResultSet
cvflann::KNNRadiusUniqueResultSet::KNNRadiusUniqueResultSet	flann/result_set.h	/^    KNNRadiusUniqueResultSet(unsigned int capacity, DistanceType radius)$/;"	f	class:cvflann::KNNRadiusUniqueResultSet	access:public	signature:(unsigned int capacity, DistanceType radius)
cvflann::KNNRadiusUniqueResultSet::capacity_	flann/result_set.h	/^    unsigned int capacity_;$/;"	m	class:cvflann::KNNRadiusUniqueResultSet	access:private
cvflann::KNNRadiusUniqueResultSet::clear	flann/result_set.h	/^    void clear()$/;"	f	class:cvflann::KNNRadiusUniqueResultSet	access:public	signature:()
cvflann::KNNRadiusUniqueResultSet::radius_	flann/result_set.h	/^    DistanceType radius_;$/;"	m	class:cvflann::KNNRadiusUniqueResultSet	access:private
cvflann::KNNResultSet	flann/result_set.h	/^class KNNResultSet : public ResultSet<DistanceType>$/;"	c	namespace:cvflann	inherits:ResultSet
cvflann::KNNResultSet::KNNResultSet	flann/result_set.h	/^    KNNResultSet(int capacity_) : capacity(capacity_), count(0)$/;"	f	class:cvflann::KNNResultSet	access:public	signature:(int capacity_)
cvflann::KNNResultSet::addPoint	flann/result_set.h	/^    void addPoint(DistanceType dist, int index)$/;"	f	class:cvflann::KNNResultSet	access:public	signature:(DistanceType dist, int index)
cvflann::KNNResultSet::capacity	flann/result_set.h	/^    int capacity;$/;"	m	class:cvflann::KNNResultSet	access:private
cvflann::KNNResultSet::count	flann/result_set.h	/^    int count;$/;"	m	class:cvflann::KNNResultSet	access:private
cvflann::KNNResultSet::dists	flann/result_set.h	/^    DistanceType* dists;$/;"	m	class:cvflann::KNNResultSet	access:private
cvflann::KNNResultSet::full	flann/result_set.h	/^    bool full() const$/;"	f	class:cvflann::KNNResultSet	access:public	signature:() const
cvflann::KNNResultSet::indices	flann/result_set.h	/^    int* indices;$/;"	m	class:cvflann::KNNResultSet	access:private
cvflann::KNNResultSet::init	flann/result_set.h	/^    void init(int* indices_, DistanceType* dists_)$/;"	f	class:cvflann::KNNResultSet	access:public	signature:(int* indices_, DistanceType* dists_)
cvflann::KNNResultSet::size	flann/result_set.h	/^    size_t size() const$/;"	f	class:cvflann::KNNResultSet	access:public	signature:() const
cvflann::KNNResultSet::worstDist	flann/result_set.h	/^    DistanceType worstDist() const$/;"	f	class:cvflann::KNNResultSet	access:public	signature:() const
cvflann::KNNResultSet::worst_distance_	flann/result_set.h	/^    DistanceType worst_distance_;$/;"	m	class:cvflann::KNNResultSet	access:private
cvflann::KNNSimpleResultSet	flann/result_set.h	/^class KNNSimpleResultSet : public ResultSet<DistanceType>$/;"	c	namespace:cvflann	inherits:ResultSet
cvflann::KNNSimpleResultSet::KNNSimpleResultSet	flann/result_set.h	/^    KNNSimpleResultSet(int capacity_) : capacity(capacity_), count(0)$/;"	f	class:cvflann::KNNSimpleResultSet	access:public	signature:(int capacity_)
cvflann::KNNSimpleResultSet::addPoint	flann/result_set.h	/^    void addPoint(DistanceType dist, int index)$/;"	f	class:cvflann::KNNSimpleResultSet	access:public	signature:(DistanceType dist, int index)
cvflann::KNNSimpleResultSet::capacity	flann/result_set.h	/^    int capacity;$/;"	m	class:cvflann::KNNSimpleResultSet	access:private
cvflann::KNNSimpleResultSet::count	flann/result_set.h	/^    int count;$/;"	m	class:cvflann::KNNSimpleResultSet	access:private
cvflann::KNNSimpleResultSet::dists	flann/result_set.h	/^    DistanceType* dists;$/;"	m	class:cvflann::KNNSimpleResultSet	access:private
cvflann::KNNSimpleResultSet::full	flann/result_set.h	/^    bool full() const$/;"	f	class:cvflann::KNNSimpleResultSet	access:public	signature:() const
cvflann::KNNSimpleResultSet::indices	flann/result_set.h	/^    int* indices;$/;"	m	class:cvflann::KNNSimpleResultSet	access:private
cvflann::KNNSimpleResultSet::init	flann/result_set.h	/^    void init(int* indices_, DistanceType* dists_)$/;"	f	class:cvflann::KNNSimpleResultSet	access:public	signature:(int* indices_, DistanceType* dists_)
cvflann::KNNSimpleResultSet::size	flann/result_set.h	/^    size_t size() const$/;"	f	class:cvflann::KNNSimpleResultSet	access:public	signature:() const
cvflann::KNNSimpleResultSet::worstDist	flann/result_set.h	/^    DistanceType worstDist() const$/;"	f	class:cvflann::KNNSimpleResultSet	access:public	signature:() const
cvflann::KNNSimpleResultSet::worst_distance_	flann/result_set.h	/^    DistanceType worst_distance_;$/;"	m	class:cvflann::KNNSimpleResultSet	access:private
cvflann::KNNUniqueResultSet	flann/result_set.h	/^class KNNUniqueResultSet : public UniqueResultSet<DistanceType>$/;"	c	namespace:cvflann	inherits:UniqueResultSet
cvflann::KNNUniqueResultSet::DistIndex	flann/result_set.h	/^    typedef typename UniqueResultSet<DistanceType>::DistIndex DistIndex;$/;"	t	class:cvflann::KNNUniqueResultSet	access:protected
cvflann::KNNUniqueResultSet::KNNUniqueResultSet	flann/result_set.h	/^    KNNUniqueResultSet(unsigned int capacity) : capacity_(capacity)$/;"	f	class:cvflann::KNNUniqueResultSet	access:public	signature:(unsigned int capacity)
cvflann::KNNUniqueResultSet::addPoint	flann/result_set.h	/^    inline void addPoint(DistanceType dist, int index)$/;"	f	class:cvflann::KNNUniqueResultSet	access:public	signature:(DistanceType dist, int index)
cvflann::KNNUniqueResultSet::capacity_	flann/result_set.h	/^    unsigned int capacity_;$/;"	m	class:cvflann::KNNUniqueResultSet	access:protected
cvflann::KNNUniqueResultSet::clear	flann/result_set.h	/^    void clear()$/;"	f	class:cvflann::KNNUniqueResultSet	access:public	signature:()
cvflann::KULLBACK_LEIBLER	flann/defines.h	/^    KULLBACK_LEIBLER  = 8$/;"	e	enum:cvflann::flann_distance_t
cvflann::L1	flann/dist.h	/^struct L1$/;"	s	namespace:cvflann
cvflann::L1::ElementType	flann/dist.h	/^    typedef T ElementType;$/;"	t	struct:cvflann::L1	access:public
cvflann::L1::ResultType	flann/dist.h	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cvflann::L1	access:public
cvflann::L1::accum_dist	flann/dist.h	/^    inline ResultType accum_dist(const U& a, const V& b, int) const$/;"	f	struct:cvflann::L1	access:public	signature:(const U& a, const V& b, int) const
cvflann::L1::is_kdtree_distance	flann/dist.h	/^    typedef True is_kdtree_distance;$/;"	t	struct:cvflann::L1	access:public
cvflann::L1::is_vector_space_distance	flann/dist.h	/^    typedef True is_vector_space_distance;$/;"	t	struct:cvflann::L1	access:public
cvflann::L1::operator ()	flann/dist.h	/^    ResultType operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const$/;"	f	struct:cvflann::L1	access:public	signature:(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const
cvflann::L2	flann/dist.h	/^struct L2$/;"	s	namespace:cvflann
cvflann::L2::ElementType	flann/dist.h	/^    typedef T ElementType;$/;"	t	struct:cvflann::L2	access:public
cvflann::L2::ResultType	flann/dist.h	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cvflann::L2	access:public
cvflann::L2::accum_dist	flann/dist.h	/^    inline ResultType accum_dist(const U& a, const V& b, int) const$/;"	f	struct:cvflann::L2	access:public	signature:(const U& a, const V& b, int) const
cvflann::L2::is_kdtree_distance	flann/dist.h	/^    typedef True is_kdtree_distance;$/;"	t	struct:cvflann::L2	access:public
cvflann::L2::is_vector_space_distance	flann/dist.h	/^    typedef True is_vector_space_distance;$/;"	t	struct:cvflann::L2	access:public
cvflann::L2::operator ()	flann/dist.h	/^    ResultType operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const$/;"	f	struct:cvflann::L2	access:public	signature:(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const
cvflann::L2_Simple	flann/dist.h	/^struct L2_Simple$/;"	s	namespace:cvflann
cvflann::L2_Simple::ElementType	flann/dist.h	/^    typedef T ElementType;$/;"	t	struct:cvflann::L2_Simple	access:public
cvflann::L2_Simple::ResultType	flann/dist.h	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cvflann::L2_Simple	access:public
cvflann::L2_Simple::accum_dist	flann/dist.h	/^    inline ResultType accum_dist(const U& a, const V& b, int) const$/;"	f	struct:cvflann::L2_Simple	access:public	signature:(const U& a, const V& b, int) const
cvflann::L2_Simple::is_kdtree_distance	flann/dist.h	/^    typedef True is_kdtree_distance;$/;"	t	struct:cvflann::L2_Simple	access:public
cvflann::L2_Simple::is_vector_space_distance	flann/dist.h	/^    typedef True is_vector_space_distance;$/;"	t	struct:cvflann::L2_Simple	access:public
cvflann::L2_Simple::operator ()	flann/dist.h	/^    ResultType operator()(Iterator1 a, Iterator2 b, size_t size, ResultType \/*worst_dist*\/ = -1) const$/;"	f	struct:cvflann::L2_Simple	access:public	signature:(Iterator1 a, Iterator2 b, size_t size, ResultType = -1) const
cvflann::LINEAR	flann/defines.h	/^    LINEAR = 0,$/;"	e	enum:cvflann::flann_algorithm_t
cvflann::LinearIndex	flann/linear_index.h	/^class LinearIndex : public NNIndex<Distance>$/;"	c	namespace:cvflann	inherits:NNIndex
cvflann::LinearIndex::DistanceType	flann/linear_index.h	/^    typedef typename Distance::ResultType DistanceType;$/;"	t	class:cvflann::LinearIndex	access:public
cvflann::LinearIndex::ElementType	flann/linear_index.h	/^    typedef typename Distance::ElementType ElementType;$/;"	t	class:cvflann::LinearIndex	access:public
cvflann::LinearIndex::LinearIndex	flann/linear_index.h	/^    LinearIndex(const LinearIndex&);$/;"	p	class:cvflann::LinearIndex	access:public	signature:(const LinearIndex&)
cvflann::LinearIndex::LinearIndex	flann/linear_index.h	/^    LinearIndex(const Matrix<ElementType>& inputData, const IndexParams& params = LinearIndexParams(),$/;"	f	class:cvflann::LinearIndex	access:public	signature:(const Matrix<ElementType>& inputData, const IndexParams& params = LinearIndexParams(), Distance d = Distance())
cvflann::LinearIndex::buildIndex	flann/linear_index.h	/^    void buildIndex()$/;"	f	class:cvflann::LinearIndex	access:public	signature:()
cvflann::LinearIndex::dataset_	flann/linear_index.h	/^    const Matrix<ElementType> dataset_;$/;"	m	class:cvflann::LinearIndex	access:private
cvflann::LinearIndex::distance_	flann/linear_index.h	/^    Distance distance_;$/;"	m	class:cvflann::LinearIndex	access:private
cvflann::LinearIndex::findNeighbors	flann/linear_index.h	/^    void findNeighbors(ResultSet<DistanceType>& resultSet, const ElementType* vec, const SearchParams& \/*searchParams*\/)$/;"	f	class:cvflann::LinearIndex	access:public	signature:(ResultSet<DistanceType>& resultSet, const ElementType* vec, const SearchParams& )
cvflann::LinearIndex::getParameters	flann/linear_index.h	/^    IndexParams getParameters() const$/;"	f	class:cvflann::LinearIndex	access:public	signature:() const
cvflann::LinearIndex::getType	flann/linear_index.h	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::LinearIndex	access:public	signature:() const
cvflann::LinearIndex::index_params_	flann/linear_index.h	/^    IndexParams index_params_;$/;"	m	class:cvflann::LinearIndex	access:private
cvflann::LinearIndex::loadIndex	flann/linear_index.h	/^    void loadIndex(FILE*)$/;"	f	class:cvflann::LinearIndex	access:public	signature:(FILE*)
cvflann::LinearIndex::operator =	flann/linear_index.h	/^    LinearIndex& operator=(const LinearIndex&);$/;"	p	class:cvflann::LinearIndex	access:public	signature:(const LinearIndex&)
cvflann::LinearIndex::saveIndex	flann/linear_index.h	/^    void saveIndex(FILE*)$/;"	f	class:cvflann::LinearIndex	access:public	signature:(FILE*)
cvflann::LinearIndex::size	flann/linear_index.h	/^    size_t size() const$/;"	f	class:cvflann::LinearIndex	access:public	signature:() const
cvflann::LinearIndex::usedMemory	flann/linear_index.h	/^    int usedMemory() const$/;"	f	class:cvflann::LinearIndex	access:public	signature:() const
cvflann::LinearIndex::veclen	flann/linear_index.h	/^    size_t veclen() const$/;"	f	class:cvflann::LinearIndex	access:public	signature:() const
cvflann::LinearIndexParams	flann/linear_index.h	/^struct LinearIndexParams : public IndexParams$/;"	s	namespace:cvflann	inherits:IndexParams
cvflann::LinearIndexParams::LinearIndexParams	flann/linear_index.h	/^    LinearIndexParams()$/;"	f	struct:cvflann::LinearIndexParams	access:public	signature:()
cvflann::Logger	flann/logger.h	/^class Logger$/;"	c	namespace:cvflann
cvflann::Logger::Logger	flann/logger.h	/^    Logger() : stream(stdout), logLevel(FLANN_LOG_WARN) {}$/;"	f	class:cvflann::Logger	access:private	signature:()
cvflann::Logger::_log	flann/logger.h	/^    int _log(int level, const char* fmt, va_list arglist)$/;"	f	class:cvflann::Logger	access:private	signature:(int level, const char* fmt, va_list arglist)
cvflann::Logger::_setDestination	flann/logger.h	/^    void _setDestination(const char* name)$/;"	f	class:cvflann::Logger	access:private	signature:(const char* name)
cvflann::Logger::instance	flann/logger.h	/^    static Logger& instance()$/;"	f	class:cvflann::Logger	access:private	signature:()
cvflann::Logger::log	flann/logger.h	/^    static int log(int level, const char* fmt, ...)$/;"	f	class:cvflann::Logger	access:public	signature:(int level, const char* fmt, ...)
cvflann::Logger::logLevel	flann/logger.h	/^    int logLevel;$/;"	m	class:cvflann::Logger	access:private
cvflann::Logger::setDestination	flann/logger.h	/^    static void setDestination(const char* name) { instance()._setDestination(name); }$/;"	f	class:cvflann::Logger	access:public	signature:(const char* name)
cvflann::Logger::setLevel	flann/logger.h	/^    static void setLevel(int level) { instance().logLevel = level; }$/;"	f	class:cvflann::Logger	access:public	signature:(int level)
cvflann::Logger::stream	flann/logger.h	/^    FILE* stream;$/;"	m	class:cvflann::Logger	access:private
cvflann::Logger::~Logger	flann/logger.h	/^    ~Logger()$/;"	f	class:cvflann::Logger	access:private	signature:()
cvflann::LshIndex	flann/lsh_index.h	/^class LshIndex : public NNIndex<Distance>$/;"	c	namespace:cvflann	inherits:NNIndex
cvflann::LshIndex::DistanceType	flann/lsh_index.h	/^    typedef typename Distance::ResultType DistanceType;$/;"	t	class:cvflann::LshIndex	access:public
cvflann::LshIndex::ElementType	flann/lsh_index.h	/^    typedef typename Distance::ElementType ElementType;$/;"	t	class:cvflann::LshIndex	access:public
cvflann::LshIndex::LshIndex	flann/lsh_index.h	/^    LshIndex(const LshIndex&);$/;"	p	class:cvflann::LshIndex	access:public	signature:(const LshIndex&)
cvflann::LshIndex::LshIndex	flann/lsh_index.h	/^    LshIndex(const Matrix<ElementType>& input_data, const IndexParams& params = LshIndexParams(),$/;"	f	class:cvflann::LshIndex	access:public	signature:(const Matrix<ElementType>& input_data, const IndexParams& params = LshIndexParams(), Distance d = Distance())
cvflann::LshIndex::ScoreIndexPair	flann/lsh_index.h	/^    typedef std::pair<float, unsigned int> ScoreIndexPair;$/;"	t	class:cvflann::LshIndex	access:private
cvflann::LshIndex::SortScoreIndexPairOnSecond	flann/lsh_index.h	/^    struct SortScoreIndexPairOnSecond$/;"	s	class:cvflann::LshIndex	access:private
cvflann::LshIndex::SortScoreIndexPairOnSecond::operator ()	flann/lsh_index.h	/^        bool operator()(const ScoreIndexPair& left, const ScoreIndexPair& right) const$/;"	f	struct:cvflann::LshIndex::SortScoreIndexPairOnSecond	access:public	signature:(const ScoreIndexPair& left, const ScoreIndexPair& right) const
cvflann::LshIndex::buildIndex	flann/lsh_index.h	/^    void buildIndex()$/;"	f	class:cvflann::LshIndex	access:public	signature:()
cvflann::LshIndex::dataset_	flann/lsh_index.h	/^    Matrix<ElementType> dataset_;$/;"	m	class:cvflann::LshIndex	access:private
cvflann::LshIndex::distance_	flann/lsh_index.h	/^    Distance distance_;$/;"	m	class:cvflann::LshIndex	access:private
cvflann::LshIndex::feature_size_	flann/lsh_index.h	/^    unsigned int feature_size_;$/;"	m	class:cvflann::LshIndex	access:private
cvflann::LshIndex::fill_xor_mask	flann/lsh_index.h	/^    void fill_xor_mask(lsh::BucketKey key, int lowest_index, unsigned int level,$/;"	f	class:cvflann::LshIndex	access:private	signature:(lsh::BucketKey key, int lowest_index, unsigned int level, std::vector<lsh::BucketKey>& xor_masks)
cvflann::LshIndex::findNeighbors	flann/lsh_index.h	/^    void findNeighbors(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& \/*searchParams*\/)$/;"	f	class:cvflann::LshIndex	access:public	signature:(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& )
cvflann::LshIndex::getNeighbors	flann/lsh_index.h	/^    void getNeighbors(const ElementType* vec, ResultSet<DistanceType>& result)$/;"	f	class:cvflann::LshIndex	access:private	signature:(const ElementType* vec, ResultSet<DistanceType>& result)
cvflann::LshIndex::getNeighbors	flann/lsh_index.h	/^    void getNeighbors(const ElementType* vec, bool do_radius, float radius, bool do_k, unsigned int k_nn,$/;"	f	class:cvflann::LshIndex	access:private	signature:(const ElementType* vec, bool do_radius, float radius, bool do_k, unsigned int k_nn, float& checked_average)
cvflann::LshIndex::getParameters	flann/lsh_index.h	/^    IndexParams getParameters() const$/;"	f	class:cvflann::LshIndex	access:public	signature:() const
cvflann::LshIndex::getType	flann/lsh_index.h	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::LshIndex	access:public	signature:() const
cvflann::LshIndex::index_params_	flann/lsh_index.h	/^    IndexParams index_params_;$/;"	m	class:cvflann::LshIndex	access:private
cvflann::LshIndex::key_size_	flann/lsh_index.h	/^    unsigned int key_size_;$/;"	m	class:cvflann::LshIndex	access:private
cvflann::LshIndex::knnSearch	flann/lsh_index.h	/^    virtual void knnSearch(const Matrix<ElementType>& queries, Matrix<int>& indices, Matrix<DistanceType>& dists, int knn, const SearchParams& params)$/;"	f	class:cvflann::LshIndex	access:public	signature:(const Matrix<ElementType>& queries, Matrix<int>& indices, Matrix<DistanceType>& dists, int knn, const SearchParams& params)
cvflann::LshIndex::loadIndex	flann/lsh_index.h	/^    void loadIndex(FILE* stream)$/;"	f	class:cvflann::LshIndex	access:public	signature:(FILE* stream)
cvflann::LshIndex::multi_probe_level_	flann/lsh_index.h	/^    unsigned int multi_probe_level_;$/;"	m	class:cvflann::LshIndex	access:private
cvflann::LshIndex::operator =	flann/lsh_index.h	/^    LshIndex& operator=(const LshIndex&);$/;"	p	class:cvflann::LshIndex	access:public	signature:(const LshIndex&)
cvflann::LshIndex::saveIndex	flann/lsh_index.h	/^    void saveIndex(FILE* stream)$/;"	f	class:cvflann::LshIndex	access:public	signature:(FILE* stream)
cvflann::LshIndex::size	flann/lsh_index.h	/^    size_t size() const$/;"	f	class:cvflann::LshIndex	access:public	signature:() const
cvflann::LshIndex::table_number_	flann/lsh_index.h	/^    unsigned int table_number_;$/;"	m	class:cvflann::LshIndex	access:private
cvflann::LshIndex::tables_	flann/lsh_index.h	/^    std::vector<lsh::LshTable<ElementType> > tables_;$/;"	m	class:cvflann::LshIndex	access:private
cvflann::LshIndex::usedMemory	flann/lsh_index.h	/^    int usedMemory() const$/;"	f	class:cvflann::LshIndex	access:public	signature:() const
cvflann::LshIndex::veclen	flann/lsh_index.h	/^    size_t veclen() const$/;"	f	class:cvflann::LshIndex	access:public	signature:() const
cvflann::LshIndex::xor_masks_	flann/lsh_index.h	/^    std::vector<lsh::BucketKey> xor_masks_;$/;"	m	class:cvflann::LshIndex	access:private
cvflann::LshIndexParams	flann/lsh_index.h	/^struct LshIndexParams : public IndexParams$/;"	s	namespace:cvflann	inherits:IndexParams
cvflann::LshIndexParams::LshIndexParams	flann/lsh_index.h	/^    LshIndexParams(unsigned int table_number, unsigned int key_size, unsigned int multi_probe_level)$/;"	f	struct:cvflann::LshIndexParams	access:public	signature:(unsigned int table_number, unsigned int key_size, unsigned int multi_probe_level)
cvflann::MANHATTAN	flann/defines.h	/^    MANHATTAN = 2,$/;"	e	enum:cvflann::flann_distance_t
cvflann::MAX_DIST	flann/defines.h	/^    MAX_DIST   = 4,$/;"	e	enum:cvflann::flann_distance_t
cvflann::MINKOWSKI	flann/defines.h	/^    MINKOWSKI = 3,$/;"	e	enum:cvflann::flann_distance_t
cvflann::Matrix	flann/matrix.h	/^class Matrix$/;"	c	namespace:cvflann
cvflann::Matrix::Matrix	flann/matrix.h	/^    Matrix() : rows(0), cols(0), stride(0), data(NULL)$/;"	f	class:cvflann::Matrix	access:public	signature:()
cvflann::Matrix::Matrix	flann/matrix.h	/^    Matrix(T* data_, size_t rows_, size_t cols_, size_t stride_ = 0) :$/;"	f	class:cvflann::Matrix	access:public	signature:(T* data_, size_t rows_, size_t cols_, size_t stride_ = 0)
cvflann::Matrix::cols	flann/matrix.h	/^    size_t cols;$/;"	m	class:cvflann::Matrix	access:public
cvflann::Matrix::data	flann/matrix.h	/^    T* data;$/;"	m	class:cvflann::Matrix	access:public
cvflann::Matrix::free	flann/matrix.h	/^    FLANN_DEPRECATED void free()$/;"	f	class:cvflann::Matrix	access:public	signature:()
cvflann::Matrix::operator []	flann/matrix.h	/^    T* operator[](size_t index) const$/;"	f	class:cvflann::Matrix	access:public	signature:(size_t index) const
cvflann::Matrix::rows	flann/matrix.h	/^    size_t rows;$/;"	m	class:cvflann::Matrix	access:public
cvflann::Matrix::stride	flann/matrix.h	/^    size_t stride;$/;"	m	class:cvflann::Matrix	access:public
cvflann::Matrix::type	flann/matrix.h	/^    typedef T type;$/;"	t	class:cvflann::Matrix	access:public
cvflann::MaxDistance	flann/dist.h	/^struct MaxDistance$/;"	s	namespace:cvflann
cvflann::MaxDistance::ElementType	flann/dist.h	/^    typedef T ElementType;$/;"	t	struct:cvflann::MaxDistance	access:public
cvflann::MaxDistance::ResultType	flann/dist.h	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cvflann::MaxDistance	access:public
cvflann::MaxDistance::is_kdtree_distance	flann/dist.h	/^    typedef False is_kdtree_distance;$/;"	t	struct:cvflann::MaxDistance	access:public
cvflann::MaxDistance::is_vector_space_distance	flann/dist.h	/^    typedef True is_vector_space_distance;$/;"	t	struct:cvflann::MaxDistance	access:public
cvflann::MaxDistance::operator ()	flann/dist.h	/^    ResultType operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const$/;"	f	struct:cvflann::MaxDistance	access:public	signature:(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const
cvflann::MinkowskiDistance	flann/dist.h	/^struct MinkowskiDistance$/;"	s	namespace:cvflann
cvflann::MinkowskiDistance::ElementType	flann/dist.h	/^    typedef T ElementType;$/;"	t	struct:cvflann::MinkowskiDistance	access:public
cvflann::MinkowskiDistance::MinkowskiDistance	flann/dist.h	/^    MinkowskiDistance(int order_) : order(order_) {}$/;"	f	struct:cvflann::MinkowskiDistance	access:public	signature:(int order_)
cvflann::MinkowskiDistance::ResultType	flann/dist.h	/^    typedef typename Accumulator<T>::Type ResultType;$/;"	t	struct:cvflann::MinkowskiDistance	access:public
cvflann::MinkowskiDistance::accum_dist	flann/dist.h	/^    inline ResultType accum_dist(const U& a, const V& b, int) const$/;"	f	struct:cvflann::MinkowskiDistance	access:public	signature:(const U& a, const V& b, int) const
cvflann::MinkowskiDistance::is_kdtree_distance	flann/dist.h	/^    typedef True is_kdtree_distance;$/;"	t	struct:cvflann::MinkowskiDistance	access:public
cvflann::MinkowskiDistance::is_vector_space_distance	flann/dist.h	/^    typedef True is_vector_space_distance;$/;"	t	struct:cvflann::MinkowskiDistance	access:public
cvflann::MinkowskiDistance::operator ()	flann/dist.h	/^    ResultType operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const$/;"	f	struct:cvflann::MinkowskiDistance	access:public	signature:(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const
cvflann::MinkowskiDistance::order	flann/dist.h	/^    int order;$/;"	m	struct:cvflann::MinkowskiDistance	access:public
cvflann::NNIndex	flann/nn_index.h	/^class NNIndex$/;"	c	namespace:cvflann
cvflann::NNIndex::DistanceType	flann/nn_index.h	/^    typedef typename Distance::ResultType DistanceType;$/;"	t	class:cvflann::NNIndex	access:private
cvflann::NNIndex::ElementType	flann/nn_index.h	/^    typedef typename Distance::ElementType ElementType;$/;"	t	class:cvflann::NNIndex	access:private
cvflann::NNIndex::buildIndex	flann/nn_index.h	/^    virtual void buildIndex() = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:()
cvflann::NNIndex::findNeighbors	flann/nn_index.h	/^    virtual void findNeighbors(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams) = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)
cvflann::NNIndex::getParameters	flann/nn_index.h	/^    virtual IndexParams getParameters() const = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:() const
cvflann::NNIndex::getType	flann/nn_index.h	/^    virtual flann_algorithm_t getType() const = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:() const
cvflann::NNIndex::knnSearch	flann/nn_index.h	/^    virtual void knnSearch(const Matrix<ElementType>& queries, Matrix<int>& indices, Matrix<DistanceType>& dists, int knn, const SearchParams& params)$/;"	f	class:cvflann::NNIndex	access:public	signature:(const Matrix<ElementType>& queries, Matrix<int>& indices, Matrix<DistanceType>& dists, int knn, const SearchParams& params)
cvflann::NNIndex::loadIndex	flann/nn_index.h	/^    virtual void loadIndex(FILE* stream) = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:(FILE* stream)
cvflann::NNIndex::radiusSearch	flann/nn_index.h	/^    virtual int radiusSearch(const Matrix<ElementType>& query, Matrix<int>& indices, Matrix<DistanceType>& dists, float radius, const SearchParams& params)$/;"	f	class:cvflann::NNIndex	access:public	signature:(const Matrix<ElementType>& query, Matrix<int>& indices, Matrix<DistanceType>& dists, float radius, const SearchParams& params)
cvflann::NNIndex::saveIndex	flann/nn_index.h	/^    virtual void saveIndex(FILE* stream) = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:(FILE* stream)
cvflann::NNIndex::size	flann/nn_index.h	/^    virtual size_t size() const = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:() const
cvflann::NNIndex::usedMemory	flann/nn_index.h	/^    virtual int usedMemory() const = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:() const
cvflann::NNIndex::veclen	flann/nn_index.h	/^    virtual size_t veclen() const = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:() const
cvflann::NNIndex::~NNIndex	flann/nn_index.h	/^    virtual ~NNIndex() {}$/;"	f	class:cvflann::NNIndex	access:public	signature:()
cvflann::ObjectFactory	flann/object_factory.h	/^class ObjectFactory$/;"	c	namespace:cvflann
cvflann::ObjectFactory::ObjectFactory	flann/object_factory.h	/^    ObjectFactory() {}$/;"	f	class:cvflann::ObjectFactory	access:private	signature:()
cvflann::ObjectFactory::ObjectRegistry	flann/object_factory.h	/^    typedef std::map<UniqueIdType, ObjectCreator> ObjectRegistry;$/;"	t	class:cvflann::ObjectFactory	access:private
cvflann::ObjectFactory::ThisClass	flann/object_factory.h	/^    typedef ObjectFactory<BaseClass,UniqueIdType,ObjectCreator> ThisClass;$/;"	t	class:cvflann::ObjectFactory	access:private
cvflann::ObjectFactory::create	flann/object_factory.h	/^    ObjectCreator create(UniqueIdType id)$/;"	f	class:cvflann::ObjectFactory	access:public	signature:(UniqueIdType id)
cvflann::ObjectFactory::instance	flann/object_factory.h	/^    static ThisClass& instance()$/;"	f	class:cvflann::ObjectFactory	access:public	signature:()
cvflann::ObjectFactory::object_registry	flann/object_factory.h	/^    ObjectRegistry object_registry;$/;"	m	class:cvflann::ObjectFactory	access:private
cvflann::ObjectFactory::subscribe	flann/object_factory.h	/^    bool subscribe(UniqueIdType id, ObjectCreator creator)$/;"	f	class:cvflann::ObjectFactory	access:public	signature:(UniqueIdType id, ObjectCreator creator)
cvflann::ObjectFactory::unregister	flann/object_factory.h	/^    bool unregister(UniqueIdType id)$/;"	f	class:cvflann::ObjectFactory	access:public	signature:(UniqueIdType id)
cvflann::PooledAllocator	flann/allocator.h	/^class PooledAllocator$/;"	c	namespace:cvflann
cvflann::PooledAllocator::PooledAllocator	flann/allocator.h	/^    PooledAllocator(int blocksize = BLOCKSIZE)$/;"	f	class:cvflann::PooledAllocator	access:public	signature:(int blocksize = BLOCKSIZE)
cvflann::PooledAllocator::allocate	flann/allocator.h	/^    T* allocate(size_t count = 1)$/;"	f	class:cvflann::PooledAllocator	access:public	signature:(size_t count = 1)
cvflann::PooledAllocator::allocateMemory	flann/allocator.h	/^    void* allocateMemory(int size)$/;"	f	class:cvflann::PooledAllocator	access:public	signature:(int size)
cvflann::PooledAllocator::base	flann/allocator.h	/^    void*   base;     \/* Pointer to base of current block of storage. *\/$/;"	m	class:cvflann::PooledAllocator	access:private
cvflann::PooledAllocator::blocksize	flann/allocator.h	/^    int     blocksize;$/;"	m	class:cvflann::PooledAllocator	access:private
cvflann::PooledAllocator::loc	flann/allocator.h	/^    void*   loc;      \/* Current location in block to next allocate memory. *\/$/;"	m	class:cvflann::PooledAllocator	access:private
cvflann::PooledAllocator::remaining	flann/allocator.h	/^    int     remaining;  \/* Number of bytes left in current block of storage. *\/$/;"	m	class:cvflann::PooledAllocator	access:private
cvflann::PooledAllocator::usedMemory	flann/allocator.h	/^    int     usedMemory;$/;"	m	class:cvflann::PooledAllocator	access:public
cvflann::PooledAllocator::wastedMemory	flann/allocator.h	/^    int     wastedMemory;$/;"	m	class:cvflann::PooledAllocator	access:public
cvflann::PooledAllocator::~PooledAllocator	flann/allocator.h	/^    ~PooledAllocator()$/;"	f	class:cvflann::PooledAllocator	access:public	signature:()
cvflann::RadiusResultSet	flann/result_set.h	/^class RadiusResultSet : public ResultSet<DistanceType>$/;"	c	namespace:cvflann	inherits:ResultSet
cvflann::RadiusResultSet::RadiusResultSet	flann/result_set.h	/^    RadiusResultSet(DistanceType radius_, int* indices_, DistanceType* dists_, int capacity_) :$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:(DistanceType radius_, int* indices_, DistanceType* dists_, int capacity_)
cvflann::RadiusResultSet::addPoint	flann/result_set.h	/^    void addPoint(DistanceType dist, int index)$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:(DistanceType dist, int index)
cvflann::RadiusResultSet::capacity	flann/result_set.h	/^    size_t capacity;$/;"	m	class:cvflann::RadiusResultSet	access:private
cvflann::RadiusResultSet::count	flann/result_set.h	/^    size_t count;$/;"	m	class:cvflann::RadiusResultSet	access:private
cvflann::RadiusResultSet::dists	flann/result_set.h	/^    DistanceType* dists;$/;"	m	class:cvflann::RadiusResultSet	access:private
cvflann::RadiusResultSet::full	flann/result_set.h	/^    bool full() const$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:() const
cvflann::RadiusResultSet::indices	flann/result_set.h	/^    int* indices;$/;"	m	class:cvflann::RadiusResultSet	access:private
cvflann::RadiusResultSet::init	flann/result_set.h	/^    void init()$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:()
cvflann::RadiusResultSet::radius	flann/result_set.h	/^    DistanceType radius;$/;"	m	class:cvflann::RadiusResultSet	access:private
cvflann::RadiusResultSet::size	flann/result_set.h	/^    size_t size() const$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:() const
cvflann::RadiusResultSet::worstDist	flann/result_set.h	/^    DistanceType worstDist() const$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:() const
cvflann::RadiusResultSet::~RadiusResultSet	flann/result_set.h	/^    ~RadiusResultSet()$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:()
cvflann::RadiusUniqueResultSet	flann/result_set.h	/^class RadiusUniqueResultSet : public UniqueResultSet<DistanceType>$/;"	c	namespace:cvflann	inherits:UniqueResultSet
cvflann::RadiusUniqueResultSet::DistIndex	flann/result_set.h	/^    typedef typename UniqueResultSet<DistanceType>::DistIndex DistIndex;$/;"	t	class:cvflann::RadiusUniqueResultSet	access:private
cvflann::RadiusUniqueResultSet::RadiusUniqueResultSet	flann/result_set.h	/^    RadiusUniqueResultSet(DistanceType radius) :$/;"	f	class:cvflann::RadiusUniqueResultSet	access:public	signature:(DistanceType radius)
cvflann::RadiusUniqueResultSet::addPoint	flann/result_set.h	/^    void addPoint(DistanceType dist, int index)$/;"	f	class:cvflann::RadiusUniqueResultSet	access:public	signature:(DistanceType dist, int index)
cvflann::RadiusUniqueResultSet::clear	flann/result_set.h	/^    inline void clear()$/;"	f	class:cvflann::RadiusUniqueResultSet	access:public	signature:()
cvflann::RadiusUniqueResultSet::full	flann/result_set.h	/^    inline bool full() const$/;"	f	class:cvflann::RadiusUniqueResultSet	access:public	signature:() const
cvflann::RadiusUniqueResultSet::worstDist	flann/result_set.h	/^    inline DistanceType worstDist() const$/;"	f	class:cvflann::RadiusUniqueResultSet	access:public	signature:() const
cvflann::ResultSet	flann/result_set.h	/^class ResultSet$/;"	c	namespace:cvflann
cvflann::ResultSet::addPoint	flann/result_set.h	/^    virtual void addPoint(DistanceType dist, int index) = 0;$/;"	p	class:cvflann::ResultSet	access:public	signature:(DistanceType dist, int index)
cvflann::ResultSet::full	flann/result_set.h	/^    virtual bool full() const = 0;$/;"	p	class:cvflann::ResultSet	access:public	signature:() const
cvflann::ResultSet::worstDist	flann/result_set.h	/^    virtual DistanceType worstDist() const = 0;$/;"	p	class:cvflann::ResultSet	access:public	signature:() const
cvflann::ResultSet::~ResultSet	flann/result_set.h	/^    virtual ~ResultSet() {}$/;"	f	class:cvflann::ResultSet	access:public	signature:()
cvflann::SAVED	flann/defines.h	/^    SAVED = 254,$/;"	e	enum:cvflann::flann_algorithm_t
cvflann::SavedIndexParams	flann/flann_base.hpp	/^struct SavedIndexParams : public IndexParams$/;"	s	namespace:cvflann	inherits:IndexParams
cvflann::SavedIndexParams::SavedIndexParams	flann/flann_base.hpp	/^    SavedIndexParams(std::string filename)$/;"	f	struct:cvflann::SavedIndexParams	access:public	signature:(std::string filename)
cvflann::SearchParams	flann/params.h	/^struct SearchParams : public IndexParams$/;"	s	namespace:cvflann	inherits:IndexParams
cvflann::SearchParams::SearchParams	flann/params.h	/^    SearchParams(int checks = 32, float eps = 0, bool sorted = true )$/;"	f	struct:cvflann::SearchParams	access:public	signature:(int checks = 32, float eps = 0, bool sorted = true )
cvflann::StartStopTimer	flann/timer.h	/^class StartStopTimer$/;"	c	namespace:cvflann
cvflann::StartStopTimer::StartStopTimer	flann/timer.h	/^    StartStopTimer()$/;"	f	class:cvflann::StartStopTimer	access:public	signature:()
cvflann::StartStopTimer::reset	flann/timer.h	/^    void reset()$/;"	f	class:cvflann::StartStopTimer	access:public	signature:()
cvflann::StartStopTimer::start	flann/timer.h	/^    void start()$/;"	f	class:cvflann::StartStopTimer	access:public	signature:()
cvflann::StartStopTimer::startTime	flann/timer.h	/^    clock_t startTime;$/;"	m	class:cvflann::StartStopTimer	access:private
cvflann::StartStopTimer::stop	flann/timer.h	/^    void stop()$/;"	f	class:cvflann::StartStopTimer	access:public	signature:()
cvflann::StartStopTimer::value	flann/timer.h	/^    double value;$/;"	m	class:cvflann::StartStopTimer	access:public
cvflann::True	flann/dist.h	/^class True$/;"	c	namespace:cvflann
cvflann::UniqueRandom	flann/random.h	/^class UniqueRandom$/;"	c	namespace:cvflann
cvflann::UniqueRandom::UniqueRandom	flann/random.h	/^    UniqueRandom(int n)$/;"	f	class:cvflann::UniqueRandom	access:public	signature:(int n)
cvflann::UniqueRandom::counter_	flann/random.h	/^    int counter_;$/;"	m	class:cvflann::UniqueRandom	access:private
cvflann::UniqueRandom::init	flann/random.h	/^    void init(int n)$/;"	f	class:cvflann::UniqueRandom	access:public	signature:(int n)
cvflann::UniqueRandom::next	flann/random.h	/^    int next()$/;"	f	class:cvflann::UniqueRandom	access:public	signature:()
cvflann::UniqueRandom::size_	flann/random.h	/^    int size_;$/;"	m	class:cvflann::UniqueRandom	access:private
cvflann::UniqueRandom::vals_	flann/random.h	/^    std::vector<int> vals_;$/;"	m	class:cvflann::UniqueRandom	access:private
cvflann::UniqueResultSet	flann/result_set.h	/^class UniqueResultSet : public ResultSet<DistanceType>$/;"	c	namespace:cvflann	inherits:ResultSet
cvflann::UniqueResultSet::DistIndex	flann/result_set.h	/^    struct DistIndex$/;"	s	class:cvflann::UniqueResultSet	access:public
cvflann::UniqueResultSet::DistIndex::DistIndex	flann/result_set.h	/^        DistIndex(DistanceType dist, unsigned int index) :$/;"	f	struct:cvflann::UniqueResultSet::DistIndex	access:public	signature:(DistanceType dist, unsigned int index)
cvflann::UniqueResultSet::DistIndex::dist_	flann/result_set.h	/^        DistanceType dist_;$/;"	m	struct:cvflann::UniqueResultSet::DistIndex	access:public
cvflann::UniqueResultSet::DistIndex::index_	flann/result_set.h	/^        unsigned int index_;$/;"	m	struct:cvflann::UniqueResultSet::DistIndex	access:public
cvflann::UniqueResultSet::DistIndex::operator <	flann/result_set.h	/^        bool operator<(const DistIndex dist_index) const$/;"	f	struct:cvflann::UniqueResultSet::DistIndex	access:public	signature:(const DistIndex dist_index) const
cvflann::UniqueResultSet::UniqueResultSet	flann/result_set.h	/^    UniqueResultSet() :$/;"	f	class:cvflann::UniqueResultSet	access:public	signature:()
cvflann::UniqueResultSet::clear	flann/result_set.h	/^    virtual void clear() = 0;$/;"	p	class:cvflann::UniqueResultSet	access:public	signature:()
cvflann::UniqueResultSet::copy	flann/result_set.h	/^    virtual void copy(int* indices, DistanceType* dist, int n_neighbors = -1) const$/;"	f	class:cvflann::UniqueResultSet	access:public	signature:(int* indices, DistanceType* dist, int n_neighbors = -1) const
cvflann::UniqueResultSet::dist_indices_	flann/result_set.h	/^    std::set<DistIndex> dist_indices_;$/;"	m	class:cvflann::UniqueResultSet	access:protected
cvflann::UniqueResultSet::full	flann/result_set.h	/^    inline bool full() const$/;"	f	class:cvflann::UniqueResultSet	access:public	signature:() const
cvflann::UniqueResultSet::is_full_	flann/result_set.h	/^    bool is_full_;$/;"	m	class:cvflann::UniqueResultSet	access:protected
cvflann::UniqueResultSet::size	flann/result_set.h	/^    size_t size() const$/;"	f	class:cvflann::UniqueResultSet	access:public	signature:() const
cvflann::UniqueResultSet::sortAndCopy	flann/result_set.h	/^    virtual void sortAndCopy(int* indices, DistanceType* dist, int n_neighbors = -1) const$/;"	f	class:cvflann::UniqueResultSet	access:public	signature:(int* indices, DistanceType* dist, int n_neighbors = -1) const
cvflann::UniqueResultSet::worstDist	flann/result_set.h	/^    inline DistanceType worstDist() const$/;"	f	class:cvflann::UniqueResultSet	access:public	signature:() const
cvflann::UniqueResultSet::worst_distance_	flann/result_set.h	/^    DistanceType worst_distance_;$/;"	m	class:cvflann::UniqueResultSet	access:protected
cvflann::UntypedMatrix	flann/matrix.h	/^class UntypedMatrix$/;"	c	namespace:cvflann
cvflann::UntypedMatrix::UntypedMatrix	flann/matrix.h	/^    UntypedMatrix(void* data_, long rows_, long cols_) :$/;"	f	class:cvflann::UntypedMatrix	access:public	signature:(void* data_, long rows_, long cols_)
cvflann::UntypedMatrix::as	flann/matrix.h	/^    Matrix<T> as()$/;"	f	class:cvflann::UntypedMatrix	access:public	signature:()
cvflann::UntypedMatrix::cols	flann/matrix.h	/^    size_t cols;$/;"	m	class:cvflann::UntypedMatrix	access:public
cvflann::UntypedMatrix::data	flann/matrix.h	/^    void* data;$/;"	m	class:cvflann::UntypedMatrix	access:public
cvflann::UntypedMatrix::rows	flann/matrix.h	/^    size_t rows;$/;"	m	class:cvflann::UntypedMatrix	access:public
cvflann::UntypedMatrix::type	flann/matrix.h	/^    flann_datatype_t type;$/;"	m	class:cvflann::UntypedMatrix	access:public
cvflann::UntypedMatrix::~UntypedMatrix	flann/matrix.h	/^    ~UntypedMatrix()$/;"	f	class:cvflann::UntypedMatrix	access:public	signature:()
cvflann::WORDSIZE	flann/allocator.h	/^const size_t     WORDSIZE=16;$/;"	m	namespace:cvflann
cvflann::ZeroIterator	flann/dist.h	/^struct ZeroIterator$/;"	s	namespace:cvflann
cvflann::ZeroIterator::operator *	flann/dist.h	/^    T operator*()$/;"	f	struct:cvflann::ZeroIterator	access:public	signature:()
cvflann::ZeroIterator::operator ++	flann/dist.h	/^    ZeroIterator<T> operator ++(int)$/;"	f	struct:cvflann::ZeroIterator	access:public	signature:(int)
cvflann::ZeroIterator::operator ++	flann/dist.h	/^    const ZeroIterator<T>& operator ++()$/;"	f	struct:cvflann::ZeroIterator	access:public	signature:()
cvflann::ZeroIterator::operator +=	flann/dist.h	/^    ZeroIterator<T>& operator+=(int)$/;"	f	struct:cvflann::ZeroIterator	access:public	signature:(int)
cvflann::ZeroIterator::operator []	flann/dist.h	/^    T operator[](int)$/;"	f	struct:cvflann::ZeroIterator	access:public	signature:(int)
cvflann::__anon204::get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type()$/;"	f	namespace:cvflann::__anon204	signature:()
cvflann::__anon204::get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type<char>() { return H5T_NATIVE_CHAR; }$/;"	f	namespace:cvflann::__anon204	signature:()
cvflann::__anon204::get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type<double>() { return H5T_NATIVE_DOUBLE; }$/;"	f	namespace:cvflann::__anon204	signature:()
cvflann::__anon204::get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type<float>() { return H5T_NATIVE_FLOAT; }$/;"	f	namespace:cvflann::__anon204	signature:()
cvflann::__anon204::get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type<int>() { return H5T_NATIVE_INT; }$/;"	f	namespace:cvflann::__anon204	signature:()
cvflann::__anon204::get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type<long double>() { return H5T_NATIVE_LDOUBLE; }$/;"	f	namespace:cvflann::__anon204	signature:()
cvflann::__anon204::get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type<long>() { return H5T_NATIVE_LONG; }$/;"	f	namespace:cvflann::__anon204	signature:()
cvflann::__anon204::get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type<short int>() { return H5T_NATIVE_SHORT; }$/;"	f	namespace:cvflann::__anon204	signature:()
cvflann::__anon204::get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type<unsigned char>() { return H5T_NATIVE_UCHAR; }$/;"	f	namespace:cvflann::__anon204	signature:()
cvflann::__anon204::get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type<unsigned int>() { return H5T_NATIVE_UINT; }$/;"	f	namespace:cvflann::__anon204	signature:()
cvflann::__anon204::get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type<unsigned long>() { return H5T_NATIVE_ULONG; }$/;"	f	namespace:cvflann::__anon204	signature:()
cvflann::__anon204::get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type<unsigned short int>() { return H5T_NATIVE_USHORT; }$/;"	f	namespace:cvflann::__anon204	signature:()
cvflann::abs	flann/dist.h	/^inline T abs(T x) { return (x<0) ? -x : x; }$/;"	f	namespace:cvflann	signature:(T x)
cvflann::abs	flann/dist.h	/^inline double abs<double>(double x) { return fabs(x); }$/;"	f	namespace:cvflann	signature:(double x)
cvflann::abs	flann/dist.h	/^inline float abs<float>(float x) { return fabsf(x); }$/;"	f	namespace:cvflann	signature:(float x)
cvflann::abs	flann/dist.h	/^inline int abs<int>(int x) { return ::abs(x); }$/;"	f	namespace:cvflann	signature:(int x)
cvflann::abs	flann/dist.h	/^inline long double abs<long double>(long double x) { return fabsl(x); }$/;"	f	namespace:cvflann	signature:(long double x)
cvflann::addValue	flann/simplex_downhill.h	/^void addValue(int pos, float val, float* vals, T* point, T* points, int n)$/;"	f	namespace:cvflann	signature:(int pos, float val, float* vals, T* point, T* points, int n)
cvflann::allocate	flann/allocator.h	/^T* allocate(size_t count = 1)$/;"	f	namespace:cvflann	signature:(size_t count = 1)
cvflann::any	flann/params.h	/^typedef cdiggins::any any;$/;"	t	namespace:cvflann
cvflann::computeDistanceRaport	flann/index_testing.h	/^typename Distance::ResultType computeDistanceRaport(const Matrix<typename Distance::ElementType>& inputData, typename Distance::ElementType* target,$/;"	f	namespace:cvflann	signature:(const Matrix<typename Distance::ElementType>& inputData, typename Distance::ElementType* target, int* neighbors, int* groundTruth, int veclen, int n, const Distance& distance)
cvflann::compute_ground_truth	flann/ground_truth.h	/^void compute_ground_truth(const Matrix<typename Distance::ElementType>& dataset, const Matrix<typename Distance::ElementType>& testset, Matrix<int>& matches,$/;"	f	namespace:cvflann	signature:(const Matrix<typename Distance::ElementType>& dataset, const Matrix<typename Distance::ElementType>& testset, Matrix<int>& matches, int skip=0, Distance d = Distance())
cvflann::countCorrectMatches	flann/index_testing.h	/^inline int countCorrectMatches(int* neighbors, int* groundTruth, int n)$/;"	f	namespace:cvflann	signature:(int* neighbors, int* groundTruth, int n)
cvflann::create_index_by_type	flann/all_indices.h	/^NNIndex<Distance>* create_index_by_type(const Matrix<typename Distance::ElementType>& dataset, const IndexParams& params, const Distance& distance)$/;"	f	namespace:cvflann	signature:(const Matrix<typename Distance::ElementType>& dataset, const IndexParams& params, const Distance& distance)
cvflann::create_index_by_type	flann/autotuned_index.h	/^NNIndex<Distance>* create_index_by_type(const Matrix<typename Distance::ElementType>& dataset, const IndexParams& params, const Distance& distance);$/;"	p	namespace:cvflann	signature:(const Matrix<typename Distance::ElementType>& dataset, const IndexParams& params, const Distance& distance)
cvflann::dummyfunc	flann/dummy.h	/^void dummyfunc();$/;"	p	namespace:cvflann	signature:()
cvflann::find_nearest	flann/ground_truth.h	/^void find_nearest(const Matrix<typename Distance::ElementType>& dataset, typename Distance::ElementType* query, int* matches, int nn,$/;"	f	namespace:cvflann	signature:(const Matrix<typename Distance::ElementType>& dataset, typename Distance::ElementType* query, int* matches, int nn, int skip = 0, Distance distance = Distance())
cvflann::flann_algorithm_t	flann/defines.h	/^enum flann_algorithm_t$/;"	g	namespace:cvflann
cvflann::flann_centers_init_t	flann/defines.h	/^enum flann_centers_init_t$/;"	g	namespace:cvflann
cvflann::flann_datatype_t	flann/defines.h	/^enum flann_datatype_t$/;"	g	namespace:cvflann
cvflann::flann_distance_t	flann/defines.h	/^enum flann_distance_t$/;"	g	namespace:cvflann
cvflann::flann_distance_type	flann/flann.hpp	/^    CV_EXPORTS flann_distance_t flann_distance_type();$/;"	p	namespace:cvflann	signature:()
cvflann::flann_log_level_t	flann/defines.h	/^enum flann_log_level_t$/;"	g	namespace:cvflann
cvflann::get_param	flann/params.h	/^T get_param(const IndexParams& params, std::string name)$/;"	f	namespace:cvflann	signature:(const IndexParams& params, std::string name)
cvflann::get_param	flann/params.h	/^T get_param(const IndexParams& params, std::string name, const T& default_value)$/;"	f	namespace:cvflann	signature:(const IndexParams& params, std::string name, const T& default_value)
cvflann::hierarchicalClustering	flann/flann_base.hpp	/^int hierarchicalClustering(const Matrix<typename Distance::ElementType>& points, Matrix<typename Distance::ResultType>& centers,$/;"	f	namespace:cvflann	signature:(const Matrix<typename Distance::ElementType>& points, Matrix<typename Distance::ResultType>& centers, const KMeansIndexParams& params, Distance d = Distance())
cvflann::index_creator	flann/all_indices.h	/^struct index_creator$/;"	s	namespace:cvflann
cvflann::index_creator	flann/all_indices.h	/^struct index_creator<False,False,Distance>$/;"	s	namespace:cvflann
cvflann::index_creator	flann/all_indices.h	/^struct index_creator<False,VectorSpace,Distance>$/;"	s	namespace:cvflann
cvflann::index_creator::create	flann/all_indices.h	/^    static NNIndex<Distance>* create(const Matrix<typename Distance::ElementType>& dataset, const IndexParams& params, const Distance& distance)$/;"	f	struct:cvflann::index_creator	access:public	signature:(const Matrix<typename Distance::ElementType>& dataset, const IndexParams& params, const Distance& distance)
cvflann::load_from_file	flann/hdf5.h	/^void load_from_file(cvflann::Matrix<T>& dataset, const std::string& filename, const std::string& name)$/;"	f	namespace:cvflann	signature:(cvflann::Matrix<T>& dataset, const std::string& filename, const std::string& name)
cvflann::load_header	flann/saving.h	/^inline IndexHeader load_header(FILE* stream)$/;"	f	namespace:cvflann	signature:(FILE* stream)
cvflann::load_saved_index	flann/flann_base.hpp	/^NNIndex<Distance>* load_saved_index(const Matrix<typename Distance::ElementType>& dataset, const std::string& filename, Distance distance)$/;"	f	namespace:cvflann	signature:(const Matrix<typename Distance::ElementType>& dataset, const std::string& filename, Distance distance)
cvflann::load_value	flann/saving.h	/^void load_value(FILE* stream, T& value, size_t count = 1)$/;"	f	namespace:cvflann	signature:(FILE* stream, T& value, size_t count = 1)
cvflann::load_value	flann/saving.h	/^void load_value(FILE* stream, cvflann::Matrix<T>& value)$/;"	f	namespace:cvflann	signature:(FILE* stream, cvflann::Matrix<T>& value)
cvflann::load_value	flann/saving.h	/^void load_value(FILE* stream, std::vector<T>& value)$/;"	f	namespace:cvflann	signature:(FILE* stream, std::vector<T>& value)
cvflann::log_verbosity	flann/flann_base.hpp	/^inline void log_verbosity(int level)$/;"	f	namespace:cvflann	signature:(int level)
cvflann::lsh	flann/lsh_table.h	/^namespace lsh$/;"	n	namespace:cvflann
cvflann::lsh::Bucket	flann/lsh_table.h	/^typedef std::vector<FeatureIndex> Bucket;$/;"	t	namespace:cvflann::lsh
cvflann::lsh::BucketKey	flann/lsh_table.h	/^typedef unsigned int BucketKey;$/;"	t	namespace:cvflann::lsh
cvflann::lsh::FeatureIndex	flann/lsh_table.h	/^typedef uint32_t FeatureIndex;$/;"	t	namespace:cvflann::lsh
cvflann::lsh::LshStats	flann/lsh_table.h	/^struct LshStats$/;"	s	namespace:cvflann::lsh
cvflann::lsh::LshStats::bucket_size_max_	flann/lsh_table.h	/^    size_t bucket_size_max_;$/;"	m	struct:cvflann::lsh::LshStats	access:public
cvflann::lsh::LshStats::bucket_size_mean_	flann/lsh_table.h	/^    size_t bucket_size_mean_;$/;"	m	struct:cvflann::lsh::LshStats	access:public
cvflann::lsh::LshStats::bucket_size_median_	flann/lsh_table.h	/^    size_t bucket_size_median_;$/;"	m	struct:cvflann::lsh::LshStats	access:public
cvflann::lsh::LshStats::bucket_size_min_	flann/lsh_table.h	/^    size_t bucket_size_min_;$/;"	m	struct:cvflann::lsh::LshStats	access:public
cvflann::lsh::LshStats::bucket_size_std_dev	flann/lsh_table.h	/^    size_t bucket_size_std_dev;$/;"	m	struct:cvflann::lsh::LshStats	access:public
cvflann::lsh::LshStats::bucket_sizes_	flann/lsh_table.h	/^    std::vector<unsigned int> bucket_sizes_;$/;"	m	struct:cvflann::lsh::LshStats	access:public
cvflann::lsh::LshStats::n_buckets_	flann/lsh_table.h	/^    size_t n_buckets_;$/;"	m	struct:cvflann::lsh::LshStats	access:public
cvflann::lsh::LshStats::size_histogram_	flann/lsh_table.h	/^    std::vector<std::vector<unsigned int> > size_histogram_;$/;"	m	struct:cvflann::lsh::LshStats	access:public
cvflann::lsh::LshTable	flann/lsh_table.h	/^class LshTable$/;"	c	namespace:cvflann::lsh
cvflann::lsh::LshTable::BucketsSpace	flann/lsh_table.h	/^    typedef std::unordered_map<BucketKey, Bucket> BucketsSpace;$/;"	t	class:cvflann::lsh::LshTable	access:public
cvflann::lsh::LshTable::BucketsSpeed	flann/lsh_table.h	/^    typedef std::vector<Bucket> BucketsSpeed;$/;"	t	class:cvflann::lsh::LshTable	access:public
cvflann::lsh::LshTable::LshTable	flann/lsh_table.h	/^    LshTable()$/;"	f	class:cvflann::lsh::LshTable	access:public	signature:()
cvflann::lsh::LshTable::LshTable	flann/lsh_table.h	/^    LshTable(unsigned int \/*feature_size*\/, unsigned int \/*key_size*\/)$/;"	f	class:cvflann::lsh::LshTable	access:public	signature:(unsigned int , unsigned int )
cvflann::lsh::LshTable::LshTable	flann/lsh_table.h	/^inline LshTable<unsigned char>::LshTable(unsigned int feature_size, unsigned int subsignature_size)$/;"	f	class:cvflann::lsh::LshTable	signature:(unsigned int feature_size, unsigned int subsignature_size)
cvflann::lsh::LshTable::SpeedLevel	flann/lsh_table.h	/^    enum SpeedLevel$/;"	g	class:cvflann::lsh::LshTable	access:private
cvflann::lsh::LshTable::add	flann/lsh_table.h	/^    void add(Matrix<ElementType> dataset)$/;"	f	class:cvflann::lsh::LshTable	access:public	signature:(Matrix<ElementType> dataset)
cvflann::lsh::LshTable::add	flann/lsh_table.h	/^    void add(unsigned int value, const ElementType* feature)$/;"	f	class:cvflann::lsh::LshTable	access:public	signature:(unsigned int value, const ElementType* feature)
cvflann::lsh::LshTable::buckets_space_	flann/lsh_table.h	/^    BucketsSpace buckets_space_;$/;"	m	class:cvflann::lsh::LshTable	access:private
cvflann::lsh::LshTable::buckets_speed_	flann/lsh_table.h	/^    BucketsSpeed buckets_speed_;$/;"	m	class:cvflann::lsh::LshTable	access:private
cvflann::lsh::LshTable::getBucketFromKey	flann/lsh_table.h	/^    inline const Bucket* getBucketFromKey(BucketKey key) const$/;"	f	class:cvflann::lsh::LshTable	access:public	signature:(BucketKey key) const
cvflann::lsh::LshTable::getKey	flann/lsh_table.h	/^    size_t getKey(const ElementType* \/*feature*\/) const$/;"	f	class:cvflann::lsh::LshTable	access:public	signature:(const ElementType* ) const
cvflann::lsh::LshTable::getKey	flann/lsh_table.h	/^inline size_t LshTable<unsigned char>::getKey(const unsigned char* feature) const$/;"	f	class:cvflann::lsh::LshTable	signature:(const unsigned char* feature) const
cvflann::lsh::LshTable::getStats	flann/lsh_table.h	/^    LshStats getStats() const;$/;"	p	class:cvflann::lsh::LshTable	access:public	signature:() const
cvflann::lsh::LshTable::getStats	flann/lsh_table.h	/^inline LshStats LshTable<unsigned char>::getStats() const$/;"	f	class:cvflann::lsh::LshTable	signature:() const
cvflann::lsh::LshTable::initialize	flann/lsh_table.h	/^    void initialize(size_t key_size)$/;"	f	class:cvflann::lsh::LshTable	access:private	signature:(size_t key_size)
cvflann::lsh::LshTable::kArray	flann/lsh_table.h	/^        kArray, kBitsetHash, kHash$/;"	e	enum:cvflann::lsh::LshTable::SpeedLevel
cvflann::lsh::LshTable::kBitsetHash	flann/lsh_table.h	/^        kArray, kBitsetHash, kHash$/;"	e	enum:cvflann::lsh::LshTable::SpeedLevel
cvflann::lsh::LshTable::kHash	flann/lsh_table.h	/^        kArray, kBitsetHash, kHash$/;"	e	enum:cvflann::lsh::LshTable::SpeedLevel
cvflann::lsh::LshTable::key_bitset_	flann/lsh_table.h	/^    DynamicBitset key_bitset_;$/;"	m	class:cvflann::lsh::LshTable	access:private
cvflann::lsh::LshTable::key_size_	flann/lsh_table.h	/^    unsigned int key_size_;$/;"	m	class:cvflann::lsh::LshTable	access:private
cvflann::lsh::LshTable::mask_	flann/lsh_table.h	/^    std::vector<size_t> mask_;$/;"	m	class:cvflann::lsh::LshTable	access:private
cvflann::lsh::LshTable::optimize	flann/lsh_table.h	/^    void optimize()$/;"	f	class:cvflann::lsh::LshTable	access:private	signature:()
cvflann::lsh::LshTable::speed_level_	flann/lsh_table.h	/^    SpeedLevel speed_level_;$/;"	m	class:cvflann::lsh::LshTable	access:private
cvflann::lsh::operator <<	flann/lsh_table.h	/^inline std::ostream& operator <<(std::ostream& out, const LshStats& stats)$/;"	f	namespace:cvflann::lsh	signature:(std::ostream& out, const LshStats& stats)
cvflann::mpi	flann/hdf5.h	/^namespace mpi$/;"	n	namespace:cvflann
cvflann::mpi::load_from_file	flann/hdf5.h	/^void load_from_file(cvflann::Matrix<T>& dataset, const std::string& filename, const std::string& name)$/;"	f	namespace:cvflann::mpi	signature:(cvflann::Matrix<T>& dataset, const std::string& filename, const std::string& name)
cvflann::optimizeSimplexDownhill	flann/simplex_downhill.h	/^float optimizeSimplexDownhill(T* points, int n, F func, float* vals = NULL )$/;"	f	namespace:cvflann	signature:(T* points, int n, F func, float* vals = NULL )
cvflann::print_params	flann/params.h	/^inline void print_params(const IndexParams& params)$/;"	f	namespace:cvflann	signature:(const IndexParams& params)
cvflann::rand_double	flann/random.h	/^inline double rand_double(double high = 1.0, double low = 0)$/;"	f	namespace:cvflann	signature:(double high = 1.0, double low = 0)
cvflann::rand_int	flann/random.h	/^inline int rand_int(int high = RAND_MAX, int low = 0)$/;"	f	namespace:cvflann	signature:(int high = RAND_MAX, int low = 0)
cvflann::random_sample	flann/sampling.h	/^Matrix<T> random_sample(Matrix<T>& srcMatrix, long size, bool remove = false)$/;"	f	namespace:cvflann	signature:(Matrix<T>& srcMatrix, long size, bool remove = false)
cvflann::random_sample	flann/sampling.h	/^Matrix<T> random_sample(const Matrix<T>& srcMatrix, size_t size)$/;"	f	namespace:cvflann	signature:(const Matrix<T>& srcMatrix, size_t size)
cvflann::save_header	flann/saving.h	/^void save_header(FILE* stream, const NNIndex<Distance>& index)$/;"	f	namespace:cvflann	signature:(FILE* stream, const NNIndex<Distance>& index)
cvflann::save_to_file	flann/hdf5.h	/^void save_to_file(const cvflann::Matrix<T>& dataset, const std::string& filename, const std::string& name)$/;"	f	namespace:cvflann	signature:(const cvflann::Matrix<T>& dataset, const std::string& filename, const std::string& name)
cvflann::save_value	flann/saving.h	/^void save_value(FILE* stream, const T& value, size_t count = 1)$/;"	f	namespace:cvflann	signature:(FILE* stream, const T& value, size_t count = 1)
cvflann::save_value	flann/saving.h	/^void save_value(FILE* stream, const cvflann::Matrix<T>& value)$/;"	f	namespace:cvflann	signature:(FILE* stream, const cvflann::Matrix<T>& value)
cvflann::save_value	flann/saving.h	/^void save_value(FILE* stream, const std::vector<T>& value)$/;"	f	namespace:cvflann	signature:(FILE* stream, const std::vector<T>& value)
cvflann::search_with_ground_truth	flann/index_testing.h	/^float search_with_ground_truth(NNIndex<Distance>& index, const Matrix<typename Distance::ElementType>& inputData,$/;"	f	namespace:cvflann	signature:(NNIndex<Distance>& index, const Matrix<typename Distance::ElementType>& inputData, const Matrix<typename Distance::ElementType>& testData, const Matrix<int>& matches, int nn, int checks, float& time, typename Distance::ResultType& dist, const Distance& distance, int skipMatches)
cvflann::seed_random	flann/random.h	/^inline void seed_random(unsigned int seed)$/;"	f	namespace:cvflann	signature:(unsigned int seed)
cvflann::set_distance_type	flann/flann.hpp	/^    FLANN_DEPRECATED CV_EXPORTS void set_distance_type(flann_distance_t distance_type, int order);$/;"	p	namespace:cvflann	signature:(flann_distance_t distance_type, int order)
cvflann::test_index_checks	flann/index_testing.h	/^float test_index_checks(NNIndex<Distance>& index, const Matrix<typename Distance::ElementType>& inputData,$/;"	f	namespace:cvflann	signature:(NNIndex<Distance>& index, const Matrix<typename Distance::ElementType>& inputData, const Matrix<typename Distance::ElementType>& testData, const Matrix<int>& matches, int checks, float& precision, const Distance& distance, int nn = 1, int skipMatches = 0)
cvflann::test_index_precision	flann/index_testing.h	/^float test_index_precision(NNIndex<Distance>& index, const Matrix<typename Distance::ElementType>& inputData,$/;"	f	namespace:cvflann	signature:(NNIndex<Distance>& index, const Matrix<typename Distance::ElementType>& inputData, const Matrix<typename Distance::ElementType>& testData, const Matrix<int>& matches, float precision, int& checks, const Distance& distance, int nn = 1, int skipMatches = 0)
cvflann::test_index_precisions	flann/index_testing.h	/^void test_index_precisions(NNIndex<Distance>& index, const Matrix<typename Distance::ElementType>& inputData,$/;"	f	namespace:cvflann	signature:(NNIndex<Distance>& index, const Matrix<typename Distance::ElementType>& inputData, const Matrix<typename Distance::ElementType>& testData, const Matrix<int>& matches, float* precisions, int precisions_length, const Distance& distance, int nn = 1, int skipMatches = 0, float maxTime = 0)
cvmAdd	legacy/compat.hpp	197;"	d
cvmAlloc	legacy/compat.hpp	111;"	d
cvmAllocArray	legacy/compat.hpp	113;"	d
cvmCopy	legacy/compat.hpp	199;"	d
cvmCrossProduct	legacy/compat.hpp	205;"	d
cvmDet	legacy/compat.hpp	209;"	d
cvmDotProduct	legacy/compat.hpp	204;"	d
cvmEigenVV	legacy/compat.hpp	208;"	d
cvmFree	legacy/compat.hpp	112;"	d
cvmFreeArray	legacy/compat.hpp	114;"	d
cvmGet	core/types_c.h	/^CV_INLINE  double  cvmGet( const CvMat* mat, int row, int col )$/;"	f	signature:( const CvMat* mat, int row, int col )
cvmInvert	legacy/compat.hpp	202;"	d
cvmMahalanobis	legacy/compat.hpp	203;"	d
cvmMul	legacy/compat.hpp	200;"	d
cvmMulTransposed	legacy/compat.hpp	207;"	d
cvmPerspectiveProject	legacy/compat.hpp	/^CV_EXPORTS void cvmPerspectiveProject( const CvMat* mat, const CvArr* src, CvArr* dst );$/;"	p	signature:( const CvMat* mat, const CvArr* src, CvArr* dst )
cvmScale	legacy/compat.hpp	210;"	d
cvmSet	core/types_c.h	/^CV_INLINE  void  cvmSet( CvMat* mat, int row, int col, double value )$/;"	f	signature:( CvMat* mat, int row, int col, double value )
cvmSetIdentity	legacy/compat.hpp	196;"	d
cvmSetZero	legacy/compat.hpp	195;"	d
cvmSub	legacy/compat.hpp	198;"	d
cvmTrace	legacy/compat.hpp	206;"	d
cvmTranspose	legacy/compat.hpp	201;"	d
cvtColor	gpu/gpu.hpp	/^        CV_EXPORTS void cvtColor(const GpuMat& src, GpuMat& dst, int code, int dcn = 0, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int code, int dcn = 0, Stream& stream = Stream::Null())
cvtColor	imgproc/imgproc.hpp	/^CV_EXPORTS_W void cvtColor( InputArray src, OutputArray dst, int code, int dstCn=0 );$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int code, int dstCn=0 )
cvvAddSearchPath	highgui/highgui_c.h	485;"	d
cvvConvertImage	highgui/highgui_c.h	488;"	d
cvvCreateTrackbar	highgui/highgui_c.h	482;"	d
cvvDestroyWindow	highgui/highgui_c.h	481;"	d
cvvInitSystem	highgui/highgui_c.h	477;"	d
cvvLoadImage	highgui/highgui_c.h	483;"	d
cvvNamedWindow	highgui/highgui_c.h	478;"	d
cvvResizeWindow	highgui/highgui_c.h	480;"	d
cvvSaveImage	highgui/highgui_c.h	484;"	d
cvvShowImage	highgui/highgui_c.h	479;"	d
cvvWaitKey	highgui/highgui_c.h	486;"	d
cvvWaitKeyEx	highgui/highgui_c.h	487;"	d
cycle	contrib/contrib.hpp	/^        CV_PROP_RW int		cycle;$/;"	m	class:cv::StereoVar	access:public
cyrillic	core/core_c.h	/^    const int*  cyrillic;$/;"	m	struct:CvFont	access:public
d	gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
d	gpu/gpu.hpp	/^            GpuMat u[2], d[2], l[2], r[2];$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
d2	gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
data	contrib/contrib.hpp	/^        void* data;$/;"	m	class:cv::LevMarqSparse	access:public
data	core/core.hpp	/^    std::map<std::string, std::vector<std::string> > data;$/;"	m	class:cv::CommandLineParser	access:protected
data	core/core.hpp	/^    uchar* data;$/;"	m	class:cv::Mat	access:public
data	core/operations.hpp	/^        _Tp* data;$/;"	m	struct:cv::Vector::Hdr	access:public
data	core/types_c.h	/^    schar* data;              \/* Pointer to the first element of the block. *\/$/;"	m	struct:CvSeqBlock	access:public
data	core/types_c.h	/^    } data;$/;"	m	struct:CvFileNode	typeref:union:CvFileNode::__anon157	access:public
data	core/types_c.h	/^    } data;$/;"	m	struct:CvMat	typeref:union:CvMat::__anon151	access:public
data	core/types_c.h	/^    } data;$/;"	m	struct:CvMatND	typeref:union:CvMatND::__anon154	access:public
data	flann/matrix.h	/^    T* data;$/;"	m	class:cvflann::Matrix	access:public
data	flann/matrix.h	/^    void* data;$/;"	m	class:cvflann::UntypedMatrix	access:public
data	gpu/devmem2d.hpp	/^            T* data;$/;"	m	struct:cv::gpu::DevMem2D_	access:public
data	gpu/devmem2d.hpp	/^            T* data;$/;"	m	struct:cv::gpu::PtrStep_	access:public
data	gpu/gpu.hpp	/^            uchar* data;$/;"	m	class:cv::gpu::CudaMem	access:public
data	gpu/gpumat.hpp	/^        uchar* data;$/;"	m	class:cv::gpu::GpuMat	access:public
data	legacy/legacy.hpp	/^    const uchar* data() const { return image ? (const uchar*)image->imageData : 0; }$/;"	f	class:CvImage	access:public	signature:() const
data	legacy/legacy.hpp	/^    const uchar* data() const { return matrix ? matrix->data.ptr : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
data	legacy/legacy.hpp	/^    uchar* data() { return image ? (uchar*)image->imageData : 0; }$/;"	f	class:CvImage	access:public	signature:()
data	legacy/legacy.hpp	/^    uchar* data() { return matrix ? matrix->data.ptr : 0; }$/;"	f	class:CvMatrix	access:public	signature:()
data	legacy/legacy.hpp	/^    void* data;$/;"	m	union:__anon182	access:public
data	ml/ml.hpp	/^    CvDTreeTrainData* data;$/;"	m	class:CvBoost	access:protected
data	ml/ml.hpp	/^    CvDTreeTrainData* data;$/;"	m	class:CvDTree	access:protected
data	ml/ml.hpp	/^    CvDTreeTrainData* data;$/;"	m	class:CvGBTrees	access:protected
data	ml/ml.hpp	/^    CvDTreeTrainData* data;$/;"	m	class:CvRTrees	access:protected
data	ml/ml.hpp	/^    float* data;$/;"	m	struct:CvSVMKernelRow	access:public
data	ml/ml.hpp	/^    } data;$/;"	m	struct:CvVectors	typeref:union:CvVectors::__anon70	access:public
data	objdetect/objdetect.hpp	/^    Data data;$/;"	m	class:cv::CascadeClassifier	access:protected
dataOrder	core/types_c.h	/^    int  dataOrder;         \/* 0 - interleaved color channels, 1 - separate color channels.$/;"	m	struct:_IplImage	access:public
data_	flann/kdtree_single_index.h	/^    Matrix<ElementType> data_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
data_cost	gpu/gpu.hpp	/^            GpuMat data_cost;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
data_cost_selected	gpu/gpu.hpp	/^            GpuMat data_cost_selected;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
data_root	ml/ml.hpp	/^    CvDTreeNode* data_root;$/;"	m	struct:CvDTreeTrainData	access:public
data_type	flann/saving.h	/^    flann_datatype_t data_type;$/;"	m	struct:cvflann::IndexHeader	access:public
data_weight	gpu/gpu.hpp	/^            float data_weight;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
data_weight	gpu/gpu.hpp	/^            float data_weight;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
dataend	core/core.hpp	/^    uchar* dataend;$/;"	m	class:cv::Mat	access:public
dataend	gpu/gpu.hpp	/^            uchar* dataend;$/;"	m	class:cv::gpu::CudaMem	access:public
dataend	gpu/gpumat.hpp	/^        uchar* dataend;$/;"	m	class:cv::gpu::GpuMat	access:public
datalimit	core/core.hpp	/^    uchar* datalimit;$/;"	m	class:cv::Mat	access:public
datas	gpu/gpu.hpp	/^            std::vector<GpuMat> datas;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
dataset	flann/hierarchical_clustering_index.h	/^    const Matrix<ElementType> dataset;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
dataset_	flann/autotuned_index.h	/^    const Matrix<ElementType> dataset_;$/;"	m	class:cvflann::AutotunedIndex	access:private
dataset_	flann/kdtree_index.h	/^    const Matrix<ElementType> dataset_;$/;"	m	class:cvflann::KDTreeIndex	access:private
dataset_	flann/kdtree_single_index.h	/^    const Matrix<ElementType> dataset_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
dataset_	flann/kmeans_index.h	/^    const Matrix<ElementType> dataset_;$/;"	m	class:cvflann::KMeansIndex	access:private
dataset_	flann/linear_index.h	/^    const Matrix<ElementType> dataset_;$/;"	m	class:cvflann::LinearIndex	access:private
dataset_	flann/lsh_index.h	/^    Matrix<ElementType> dataset_;$/;"	m	class:cvflann::LshIndex	access:private
datastart	core/core.hpp	/^    uchar* datastart;$/;"	m	class:cv::Mat	access:public
datastart	core/operations.hpp	/^        _Tp* datastart;$/;"	m	struct:cv::Vector::Hdr	access:public
datastart	gpu/gpu.hpp	/^            uchar* datastart;$/;"	m	class:cv::gpu::CudaMem	access:public
datastart	gpu/gpumat.hpp	/^        uchar* datastart;$/;"	m	class:cv::gpu::GpuMat	access:public
db	core/types_c.h	/^        double* db;$/;"	m	union:CvMat::__anon151	access:public
db	core/types_c.h	/^        double* db;$/;"	m	union:CvMatND::__anon154	access:public
db	ml/ml.hpp	/^        double** db;$/;"	m	union:CvVectors::__anon70	access:public
dct	core/core.hpp	/^CV_EXPORTS_W void dct(InputArray src, OutputArray dst, int flags=0);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, int flags=0)
ddot	core/core.hpp	/^    double ddot(const Matx<_Tp, m, n>& v) const;$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& v) const
ddot	core/core.hpp	/^    double ddot(const Point3_& pt) const;$/;"	p	class:cv::Point3_	access:public	signature:(const Point3_& pt) const
ddot	core/core.hpp	/^    double ddot(const Point_& pt) const;$/;"	p	class:cv::Point_	access:public	signature:(const Point_& pt) const
ddot	core/operations.hpp	/^template<typename _Tp, int m, int n> inline double Matx<_Tp, m, n>::ddot(const Matx<_Tp, m, n>& M) const$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& M) const
ddot	core/operations.hpp	/^template<typename _Tp> inline double Point3_<_Tp>::ddot(const Point3_& pt) const$/;"	f	class:cv::Point3_	signature:(const Point3_& pt) const
ddot	core/operations.hpp	/^template<typename _Tp> inline double Point_<_Tp>::ddot(const Point_& pt) const$/;"	f	class:cv::Point_	signature:(const Point_& pt) const
dealloc	gpu/NCV.hpp	/^    virtual NCVStatus dealloc(NCVMemSegment &seg) = 0;$/;"	p	class:INCVMemAllocator	access:public	signature:(NCVMemSegment &seg)
dealloc	gpu/NCV.hpp	/^    virtual NCVStatus dealloc(NCVMemSegment &seg);$/;"	p	class:NCVMemNativeAllocator	access:public	signature:(NCVMemSegment &seg)
dealloc	gpu/NCV.hpp	/^    virtual NCVStatus dealloc(NCVMemSegment &seg);$/;"	p	class:NCVMemStackAllocator	access:public	signature:(NCVMemSegment &seg)
deallocate	core/core.hpp	/^    virtual void deallocate(int* refcount, uchar* datastart, uchar* data) = 0;$/;"	p	class:cv::MatAllocator	access:public	signature:(int* refcount, uchar* datastart, uchar* data)
deallocate	core/core.hpp	/^    void deallocate();$/;"	p	class:cv::AutoBuffer	access:public	signature:()
deallocate	core/core.hpp	/^    void deallocate();$/;"	p	class:cv::Mat	access:public	signature:()
deallocate	core/core.hpp	/^    void deallocate(pointer p, size_type) {fastFree(p); }$/;"	f	class:cv::Allocator	access:public	signature:(pointer p, size_type)
deallocate	core/core.hpp	/^template<typename _Tp> static inline void deallocate(_Tp* ptr, size_t)$/;"	f	namespace:cv	signature:(_Tp* ptr, size_t)
deallocate	core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline void AutoBuffer<_Tp, fixed_size>::deallocate()$/;"	f	class:cv::AutoBuffer	signature:()
decision_func	ml/ml.hpp	/^    CvSVMDecisionFunc* decision_func;$/;"	m	class:CvSVM	access:protected
decomposeProjectionMatrix	calib3d/calib3d.hpp	/^CV_EXPORTS_W void decomposeProjectionMatrix( InputArray projMatrix, OutputArray cameraMatrix,$/;"	p	namespace:cv	signature:( InputArray projMatrix, OutputArray cameraMatrix, OutputArray rotMatrix, OutputArray transVect, OutputArray rotMatrixX=noArray(), OutputArray rotMatrixY=noArray(), OutputArray rotMatrixZ=noArray(), OutputArray eulerAngles=noArray() )
defaultParams	contrib/contrib.hpp	/^        void defaultParams();$/;"	p	class:cv::SpinImageModel	access:protected	signature:()
default_func_addr	core/types_c.h	/^    void* default_func_addr;$/;"	m	struct:CvPluginFuncInfo	access:public
default_model_name	ml/ml.hpp	/^    const char* default_model_name;$/;"	m	class:CvStatModel	access:protected
degree	ml/ml.hpp	/^    CV_PROP_RW double      degree; \/\/ for poly$/;"	m	struct:CvSVMParams	access:public
deleteEdge	imgproc/imgproc.hpp	/^    void deleteEdge(int edge);$/;"	p	class:cv::Subdiv2D	access:protected	signature:(int edge)
deletePoint	imgproc/imgproc.hpp	/^    void deletePoint(int vtx);$/;"	p	class:cv::Subdiv2D	access:protected	signature:(int vtx)
delete_obj	calib3d/calib3d.hpp	/^template<> CV_EXPORTS void Ptr<CvStereoBMState>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	core/core.hpp	/^    void delete_obj();$/;"	p	class:cv::Ptr	access:public	signature:()
delete_obj	core/operations.hpp	/^template<> CV_EXPORTS void Ptr<CvFileStorage>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	core/operations.hpp	/^template<> CV_EXPORTS void Ptr<CvMat>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	core/operations.hpp	/^template<> CV_EXPORTS void Ptr<CvMatND>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	core/operations.hpp	/^template<> CV_EXPORTS void Ptr<CvMemStorage>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	core/operations.hpp	/^template<> CV_EXPORTS void Ptr<CvSparseMat>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	core/operations.hpp	/^template<> CV_EXPORTS void Ptr<IplImage>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	core/operations.hpp	/^template<typename _Tp> inline void Ptr<_Tp>::delete_obj()$/;"	f	class:cv::Ptr	signature:()
delete_obj	highgui/highgui.hpp	/^template<> void CV_EXPORTS Ptr<CvCapture>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	highgui/highgui.hpp	/^template<> void CV_EXPORTS Ptr<CvVideoWriter>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	imgproc/imgproc.hpp	/^template<> CV_EXPORTS void Ptr<CvHistogram>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	imgproc/imgproc.hpp	/^template<> CV_EXPORTS void Ptr<IplConvKernel>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	ml/ml.hpp	/^template<> CV_EXPORTS void Ptr<CvDTreeSplit>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delete_obj	objdetect/objdetect.hpp	/^template<> CV_EXPORTS void Ptr<CvHaarClassifierCascade>::delete_obj();$/;"	p	class:cv::Ptr	signature:()
delimiter	ml/ml.hpp	/^    char delimiter;$/;"	m	class:CvMLData	access:protected
delta	features2d/features2d.hpp	/^    int delta;$/;"	m	struct:CvMSERParams	access:public
delta	ml/ml.hpp	/^    float delta;$/;"	m	class:CvGBTrees	access:protected
delta	video/background_segm.hpp	/^    float  delta;		\/* Affects color and color co-occurrence quantization, typically set to 2.					*\/$/;"	m	struct:CvFGDStatModelParams	access:public
deltaP	contrib/contrib.hpp	/^        CvMat* deltaP; \/\/computed increase of parameters (result of normal system solution )$/;"	m	class:cv::LevMarqSparse	access:public
deltas	imgproc/types_c.h	/^    schar     deltas[8][2];$/;"	m	struct:CvChainPtReader	access:public
density	contrib/contrib.hpp	/^        double density;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
depth	core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, channels = cn, type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::Vec::__anon114
depth	core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, rows = m, cols = n, channels = rows*cols,$/;"	e	enum:cv::Matx::__anon113
depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon116
depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon117
depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon118
depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon119
depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon120
depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon121
depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon122
depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon123
depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon124
depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon126
depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon127
depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon128
depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon130
depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon133
depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 3,$/;"	e	enum:cv::DataType::__anon129
depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon131
depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon132
depth	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = cn,$/;"	e	enum:cv::DataType::__anon125
depth	core/core.hpp	/^    enum { generic_type = 1, depth = -1, channels = 1, fmt=0,$/;"	e	enum:cv::DataType::__anon115
depth	core/core.hpp	/^    int depth() const;$/;"	p	class:cv::Mat	access:public	signature:() const
depth	core/core.hpp	/^    int depth() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
depth	core/core.hpp	/^    int depth() const;$/;"	p	class:cv::Seq	access:public	signature:() const
depth	core/core.hpp	/^    int depth() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
depth	core/core.hpp	/^    int depth() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
depth	core/core.hpp	/^    virtual int depth(int i=-1) const;$/;"	p	class:cv::_InputArray	access:public	signature:(int i=-1) const
depth	core/mat.hpp	/^inline int Mat::depth() const { return CV_MAT_DEPTH(flags); }$/;"	f	class:cv::Mat	signature:() const
depth	core/mat.hpp	/^inline int SparseMat::depth() const$/;"	f	class:cv::SparseMat	signature:() const
depth	core/mat.hpp	/^template<typename _Tp> inline int Mat_<_Tp>::depth() const$/;"	f	class:cv::Mat_	signature:() const
depth	core/mat.hpp	/^template<typename _Tp> inline int SparseMat_<_Tp>::depth() const$/;"	f	class:cv::SparseMat_	signature:() const
depth	core/operations.hpp	/^template<typename _Tp> inline int Seq<_Tp>::depth() const$/;"	f	class:cv::Seq	signature:() const
depth	core/types_c.h	/^    int  depth;             \/* Pixel depth in bits: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16S,$/;"	m	struct:_IplImage	access:public
depth	features2d/features2d.hpp	/^  int depth() { return depth_; }$/;"	f	class:cv::RandomizedTree	access:public	signature:()
depth	gpu/gpu.hpp	/^            int depth() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
depth	gpu/gpumat.hpp	/^        int depth() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
depth	gpu/matrix_operations.hpp	/^inline int CudaMem::depth() const { return CV_MAT_DEPTH(flags); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
depth	imgproc/types_c.h	/^    float depth; \/* distance between the farthest point and the convex hull *\/$/;"	m	struct:CvConvexityDefect	access:public
depth	legacy/legacy.hpp	/^    int depth() const { return image ? image->depth : 0; }$/;"	f	class:CvImage	access:public	signature:() const
depth	legacy/legacy.hpp	/^    int depth() const { return matrix ? CV_MAT_DEPTH(matrix->type) : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
depth	ml/ml.hpp	/^    int depth;$/;"	m	struct:CvDTreeNode	access:public
depthHigh	contrib/contrib.hpp	/^        unsigned int depthLow, depthHigh;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
depthLow	contrib/contrib.hpp	/^        unsigned int depthLow, depthHigh;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
depth_	features2d/features2d.hpp	/^  int depth_;$/;"	m	class:cv::RandomizedTree	access:private
depth_point	imgproc/types_c.h	/^    CvPoint* depth_point; \/* the farthest from the convex hull point within the defect *\/$/;"	m	struct:CvConvexityDefect	access:public
derivAperture	objdetect/objdetect.hpp	/^    CV_PROP int derivAperture;$/;"	m	struct:cv::HOGDescriptor	access:public
desc	imgproc/imgproc_c.h	/^CVAPI(struct CvFeatureTree*) cvCreateKDTree(CvMat* desc);$/;"	v
descripotorsCount	features2d/features2d.hpp	/^    int descripotorsCount() const;$/;"	p	class:cv::BOWTrainer	access:public	signature:() const
descriptorExtractor	features2d/features2d.hpp	/^    Ptr<DescriptorExtractor> descriptorExtractor;$/;"	m	class:cv::OpponentColorDescriptorExtractor	access:protected
descriptorParams	features2d/features2d.hpp	/^    DescriptorParams descriptorParams;$/;"	m	class:cv::SIFT	access:protected
descriptorSize	features2d/features2d.hpp	/^    CV_WRAP int descriptorSize() const;$/;"	p	class:cv::SURF	access:public	signature:() const
descriptorSize	features2d/features2d.hpp	/^    int descriptorSize() const;$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:() const
descriptorSize	features2d/features2d.hpp	/^    int descriptorSize() const;$/;"	p	class:cv::SIFT	access:public	signature:() const
descriptorSize	features2d/features2d.hpp	/^    virtual int descriptorSize() const = 0;$/;"	p	class:cv::DescriptorExtractor	access:public	signature:() const
descriptorSize	features2d/features2d.hpp	/^    virtual int descriptorSize() const { return classifier_.classes(); }$/;"	f	class:cv::CalonderDescriptorExtractor	access:public	signature:() const
descriptorSize	features2d/features2d.hpp	/^    virtual int descriptorSize() const;$/;"	p	class:cv::BriefDescriptorExtractor	access:public	signature:() const
descriptorSize	features2d/features2d.hpp	/^    virtual int descriptorSize() const;$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:public	signature:() const
descriptorSize	features2d/features2d.hpp	/^    virtual int descriptorSize() const;$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:() const
descriptorSize	features2d/features2d.hpp	/^    virtual int descriptorSize() const;$/;"	p	class:cv::SurfDescriptorExtractor	access:public	signature:() const
descriptorSize	features2d/features2d.hpp	/^  int descriptorSize() const;$/;"	p	class:cv::ORB	access:public	signature:() const
descriptorSize	features2d/features2d.hpp	/^  virtual int descriptorSize() const;$/;"	p	class:cv::OrbDescriptorExtractor	access:public	signature:() const
descriptorSize	gpu/gpu.hpp	/^            int descriptorSize() const;$/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:() const
descriptorType	features2d/features2d.hpp	/^    int descriptorType() const;$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:() const
descriptorType	features2d/features2d.hpp	/^    virtual int descriptorType() const = 0;$/;"	p	class:cv::DescriptorExtractor	access:public	signature:() const
descriptorType	features2d/features2d.hpp	/^    virtual int descriptorType() const { return DataType<T>::type; }$/;"	f	class:cv::CalonderDescriptorExtractor	access:public	signature:() const
descriptorType	features2d/features2d.hpp	/^    virtual int descriptorType() const;$/;"	p	class:cv::BriefDescriptorExtractor	access:public	signature:() const
descriptorType	features2d/features2d.hpp	/^    virtual int descriptorType() const;$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:public	signature:() const
descriptorType	features2d/features2d.hpp	/^    virtual int descriptorType() const;$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:() const
descriptorType	features2d/features2d.hpp	/^    virtual int descriptorType() const;$/;"	p	class:cv::SurfDescriptorExtractor	access:public	signature:() const
descriptorType	features2d/features2d.hpp	/^  virtual int descriptorType() const;$/;"	p	class:cv::OrbDescriptorExtractor	access:public	signature:() const
descriptors	features2d/features2d.hpp	/^    vector<Mat> descriptors;$/;"	m	class:cv::BOWTrainer	access:protected
destroy	core/core.hpp	/^    void destroy(pointer p) { p->~_Tp(); }$/;"	f	class:cv::Allocator	access:public	signature:(pointer p)
destroyAllWindows	highgui/highgui.hpp	/^CV_EXPORTS_W void destroyAllWindows();$/;"	p	namespace:cv	signature:()
destroyWindow	highgui/highgui.hpp	/^CV_EXPORTS_W void destroyWindow( const string& winname );$/;"	p	namespace:cv	signature:( const string& winname )
det	gpu/gpu.hpp	/^            GpuMat det, trace;$/;"	m	class:cv::gpu::SURF_GPU	access:public
detach	legacy/legacy.hpp	/^    void detach()$/;"	f	class:CvImage	access:public	signature:()
detect	features2d/features2d.hpp	/^    void detect( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::FeatureDetector	access:public	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detect	features2d/features2d.hpp	/^    void detect( const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints, const vector<Mat>& masks=vector<Mat>() ) const;$/;"	p	class:cv::FeatureDetector	access:public	signature:( const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints, const vector<Mat>& masks=vector<Mat>() ) const
detect	gpu/gpu.hpp	/^            void detect(const GpuMat& img, vector<Point>& found_locations, $/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:(const GpuMat& img, vector<Point>& found_locations, double hit_threshold=0, Size win_stride=Size(), Size padding=Size())
detect	objdetect/objdetect.hpp	/^    CV_WRAP virtual void detect(const Mat& img, CV_OUT vector<Point>& foundLocations, $/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const Mat& img, CV_OUT vector<Point>& foundLocations, vector<double>& weights, double hitThreshold=0, Size winStride=Size(), Size padding=Size(), const vector<Point>& searchLocations=vector<Point>()) const
detect	objdetect/objdetect.hpp	/^    CV_WRAP virtual void detect(const Mat& img, CV_OUT vector<Point>& foundLocations,$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const Mat& img, CV_OUT vector<Point>& foundLocations, double hitThreshold=0, Size winStride=Size(), Size padding=Size(), const vector<Point>& searchLocations=vector<Point>()) const
detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const = 0;$/;"	p	class:cv::FeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::DenseFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::DynamicAdaptedFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::FastAdjuster	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::FastFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::GoodFeaturesToTrackDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::GridAdaptedFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::MserFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::PyramidAdaptedFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::SiftFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::StarAdjuster	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::StarFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::SurfAdjuster	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	features2d/features2d.hpp	/^    virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::SurfFeatureDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectImpl	features2d/features2d.hpp	/^  detectImpl(const cv::Mat& image, std::vector<cv::KeyPoint>& keypoints, const cv::Mat& mask = cv::Mat()) const;$/;"	p	class:cv::OrbFeatureDetector	access:protected	signature:(const cv::Mat& image, std::vector<cv::KeyPoint>& keypoints, const cv::Mat& mask = cv::Mat()) const
detectImpl	features2d/features2d.hpp	/^  virtual void detectImpl( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const;$/;"	p	class:cv::SimpleBlobDetector	access:protected	signature:( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() ) const
detectMultiScale	gpu/gpu.hpp	/^            int detectMultiScale( const GpuMat& image, GpuMat& objectsBuf, double scaleFactor=1.2, int minNeighbors=4, Size minSize=Size());$/;"	p	class:cv::gpu::CascadeClassifier_GPU	access:public	signature:( const GpuMat& image, GpuMat& objectsBuf, double scaleFactor=1.2, int minNeighbors=4, Size minSize=Size())
detectMultiScale	gpu/gpu.hpp	/^            void detectMultiScale(const GpuMat& img, vector<Rect>& found_locations,$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:(const GpuMat& img, vector<Rect>& found_locations, double hit_threshold=0, Size win_stride=Size(), Size padding=Size(), double scale0=1.05, int group_threshold=2)
detectMultiScale	objdetect/objdetect.hpp	/^	CV_WRAP virtual void detectMultiScale(const Mat& img, CV_OUT vector<Rect>& foundLocations, $/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const Mat& img, CV_OUT vector<Rect>& foundLocations, double hitThreshold=0, Size winStride=Size(), Size padding=Size(), double scale=1.05, double finalThreshold=2.0, bool useMeanshiftGrouping = false) const
detectMultiScale	objdetect/objdetect.hpp	/^    CV_WRAP virtual void detectMultiScale( const Mat& image,$/;"	p	class:cv::CascadeClassifier	access:public	signature:( const Mat& image, CV_OUT vector<Rect>& objects, double scaleFactor=1.1, int minNeighbors=3, int flags=0, Size minSize=Size(), Size maxSize=Size() )
detectMultiScale	objdetect/objdetect.hpp	/^    CV_WRAP virtual void detectMultiScale( const Mat& image,$/;"	p	class:cv::CascadeClassifier	access:public	signature:( const Mat& image, CV_OUT vector<Rect>& objects, vector<int>& rejectLevels, vector<double>& levelWeights, double scaleFactor=1.1, int minNeighbors=3, int flags=0, Size minSize=Size(), Size maxSize=Size(), bool outputRejectLevels=false )
detectMultiScale	objdetect/objdetect.hpp	/^    CV_WRAP virtual void detectMultiScale(const Mat& img, CV_OUT vector<Rect>& foundLocations, $/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const Mat& img, CV_OUT vector<Rect>& foundLocations, vector<double>& foundWeights, double hitThreshold=0, Size winStride=Size(), Size padding=Size(), double scale=1.05, double finalThreshold=2.0,bool useMeanshiftGrouping = false) const
detectSingleScale	objdetect/objdetect.hpp	/^    virtual bool detectSingleScale( const Mat& image, int stripCount, Size processingRectSize,$/;"	p	class:cv::CascadeClassifier	access:protected	signature:( const Mat& image, int stripCount, Size processingRectSize, int stripSize, int yStep, double factor, vector<Rect>& candidates, vector<int>& rejectLevels, vector<double>& levelWeights, bool outputRejectLevels=false)
detector	features2d/features2d.hpp	/^    Ptr<FeatureDetector> detector;$/;"	m	class:cv::GridAdaptedFeatureDetector	access:protected
detector	features2d/features2d.hpp	/^    Ptr<FeatureDetector> detector;$/;"	m	class:cv::PyramidAdaptedFeatureDetector	access:protected
detector	gpu/gpu.hpp	/^            GpuMat detector;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
detector	objdetect/objdetect.hpp	/^CVAPI(void) cvReleaseLatentSvmDetector(CvLatentSvmDetector** detector);$/;"	v
detectorParams	features2d/features2d.hpp	/^    DetectorParams detectorParams;$/;"	m	class:cv::SIFT	access:protected
determinant	core/core.hpp	/^CV_EXPORTS_W double determinant(InputArray mtx);$/;"	p	namespace:cv	signature:(InputArray mtx)
determinant	core/operations.hpp	/^double determinant(const Matx<_Tp, m, m>& a)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, m>& a)
deviceID	gpu/gpu.hpp	/^            int deviceID() const { return device_id_; }$/;"	f	class:cv::gpu::DeviceInfo	access:public	signature:() const
device_id_	gpu/gpu.hpp	/^            int device_id_;$/;"	m	class:cv::gpu::DeviceInfo	access:private
dextractor	features2d/features2d.hpp	/^    Ptr<DescriptorExtractor> dextractor;$/;"	m	class:cv::BOWImgDescriptorExtractor	access:protected
dft	core/core.hpp	/^CV_EXPORTS_W void dft(InputArray src, OutputArray dst, int flags=0, int nonzeroRows=0);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, int flags=0, int nonzeroRows=0)
dft	gpu/gpu.hpp	/^        CV_EXPORTS void dft(const GpuMat& src, GpuMat& dst, Size dft_size, int flags=0);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Size dft_size, int flags=0)
dft_size	gpu/gpu.hpp	/^            Size dft_size;$/;"	m	struct:cv::gpu::ConvolveBuf	access:private
diag	core/core.hpp	/^    Mat diag(int d=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int d=0) const
diag	core/core.hpp	/^    Mat_ diag(int d=0) const;$/;"	p	class:cv::Mat_	access:public	signature:(int d=0) const
diag	core/core.hpp	/^    Matx<_Tp, MIN(m,n), 1> diag() const;$/;"	p	class:cv::Matx	access:public	signature:() const
diag	core/core.hpp	/^    static Mat diag(const Mat& d);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& d)
diag	core/core.hpp	/^    static Matx diag(const diag_type& d);$/;"	p	class:cv::Matx	access:public	signature:(const diag_type& d)
diag	core/mat.hpp	/^    MatExpr diag(int d=0) const;$/;"	p	class:cv::MatExpr	access:public	signature:(int d=0) const
diag	core/mat.hpp	/^    virtual void diag(const MatExpr& expr, int d, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, int d, MatExpr& res) const
diag	core/mat.hpp	/^inline Mat Mat::diag(const Mat& d)$/;"	f	class:cv::Mat	signature:(const Mat& d)
diag	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::diag(int d) const$/;"	f	class:cv::Mat_	signature:(int d) const
diag	core/operations.hpp	/^Matx<_Tp, MIN(m,n), 1> Matx<_Tp, m, n>::diag() const$/;"	f	class:cv::Matx	signature:() const
diag	core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::diag(const Matx<_Tp,MIN(m,n),1>& d)$/;"	f	class:cv::Matx	signature:(const Matx<_Tp,MIN(m,n),1>& d)
diag_type	core/core.hpp	/^    typedef Matx<_Tp, MIN(m, n), 1> diag_type;$/;"	t	class:cv::Matx	access:public
difference_type	core/core.hpp	/^    typedef ptrdiff_t difference_type;$/;"	t	class:cv::Allocator	access:public
difference_type	core/core.hpp	/^    typedef ptrdiff_t difference_type;$/;"	t	class:cv::MatConstIterator	access:public
difference_type	core/core.hpp	/^    typedef ptrdiff_t difference_type;$/;"	t	class:cv::MatConstIterator_	access:public
dilate	gpu/gpu.hpp	/^        CV_EXPORTS void dilate( const GpuMat& src, GpuMat& dst, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:( const GpuMat& src, GpuMat& dst, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1, Stream& stream = Stream::Null())
dilate	imgproc/imgproc.hpp	/^CV_EXPORTS_W void dilate( InputArray src, OutputArray dst, InputArray kernel,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, InputArray kernel, Point anchor=Point(-1,-1), int iterations=1, int borderType=BORDER_CONSTANT, const Scalar& borderValue=morphologyDefaultBorderValue() )
dim	core/types_c.h	/^    dim[CV_MAX_DIM];$/;"	m	struct:CvMatND	typeref:struct:CvMatND::__anon155	access:public
dim_	flann/kdtree_single_index.h	/^    size_t dim_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
dims	core/core.hpp	/^        int dims;$/;"	m	struct:cv::SparseMat::Hdr	access:public
dims	core/core.hpp	/^    CV_WRAP int dims() const;$/;"	p	class:cv::KDTree	access:public	signature:() const
dims	core/core.hpp	/^    int dims() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
dims	core/core.hpp	/^    int dims;$/;"	m	class:cv::Mat	access:public
dims	core/core_c.h	/^    int dims; \/* number of dimensions to iterate *\/$/;"	m	struct:CvNArrayIterator	access:public
dims	core/mat.hpp	/^inline int SparseMat::dims() const$/;"	f	class:cv::SparseMat	signature:() const
dims	core/types_c.h	/^    int dims;$/;"	m	struct:CvMatND	access:public
dims	core/types_c.h	/^    int dims;$/;"	m	struct:CvSparseMat	access:public
dims	ml/ml.hpp	/^    int dims, count;$/;"	m	struct:CvVectors	access:public
dir	features2d/features2d.hpp	/^    float        dir;$/;"	m	struct:CvSURFPoint	access:public
direction	ml/ml.hpp	/^    CvMat* direction;$/;"	m	struct:CvDTreeTrainData	access:public
disc_single_jump	gpu/gpu.hpp	/^            float disc_single_jump;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
disc_single_jump	gpu/gpu.hpp	/^            float disc_single_jump;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
discardFloatPosteriors	features2d/features2d.hpp	/^  void discardFloatPosteriors() { freePosteriors(1); }$/;"	f	class:cv::RandomizedTree	access:public	signature:()
discardFloatPosteriors	features2d/features2d.hpp	/^  void discardFloatPosteriors();$/;"	p	class:cv::RTreeClassifier	access:public	signature:()
disp	calib3d/calib3d.hpp	/^    CvMat* disp;$/;"	m	struct:CvStereoBMState	access:public
disp12MaxDiff	calib3d/calib3d.hpp	/^    CV_PROP_RW int disp12MaxDiff;$/;"	m	class:cv::StereoSGBM	access:public
disp12MaxDiff	calib3d/calib3d.hpp	/^    int disp12MaxDiff;$/;"	m	struct:CvStereoBMState	access:public
dispLeft	calib3d/calib3d.hpp	/^    CvMat* dispLeft;$/;"	m	struct:CvStereoGCState	access:public
dispRight	calib3d/calib3d.hpp	/^    CvMat* dispRight;$/;"	m	struct:CvStereoGCState	access:public
disp_selected_pyr	gpu/gpu.hpp	/^            GpuMat disp_selected_pyr[2];$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
displayOverlay	highgui/highgui.hpp	/^CV_EXPORTS void displayOverlay(const string& winname, const string& text, int delayms);$/;"	p	namespace:cv	signature:(const string& winname, const string& text, int delayms)
displayStatusBar	highgui/highgui.hpp	/^CV_EXPORTS void displayStatusBar(const string& winname, const string& text, int delayms);$/;"	p	namespace:cv	signature:(const string& winname, const string& text, int delayms)
distType	flann/miniflann.hpp	/^    cvflann::flann_distance_t distType;$/;"	m	class:cv::flann::Index	access:protected
distType	gpu/gpu.hpp	/^            DistType distType;$/;"	m	class:cv::gpu::BruteForceMatcher_GPU_base	access:public
dist_	flann/result_set.h	/^        DistanceType dist_;$/;"	m	struct:cvflann::UniqueResultSet::DistIndex	access:public
dist_indices_	flann/result_set.h	/^    std::set<DistIndex> dist_indices_;$/;"	m	class:cvflann::UniqueResultSet	access:protected
distance	features2d/features2d.hpp	/^    Distance distance;$/;"	m	class:cv::BruteForceMatcher	access:protected
distance	features2d/features2d.hpp	/^    float distance;$/;"	m	struct:cv::DMatch	access:public
distance	flann/hierarchical_clustering_index.h	/^    Distance distance;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
distanceTransform	imgproc/imgproc.hpp	/^CV_EXPORTS void distanceTransform( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int distanceType, int maskSize )
distanceTransform	imgproc/imgproc.hpp	/^CV_EXPORTS_W void distanceTransform( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, OutputArray labels, int distanceType, int maskSize )
distance_	flann/autotuned_index.h	/^    Distance distance_;$/;"	m	class:cvflann::AutotunedIndex	access:private
distance_	flann/kdtree_index.h	/^    Distance distance_;$/;"	m	class:cvflann::KDTreeIndex	access:private
distance_	flann/kdtree_single_index.h	/^    Distance distance_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
distance_	flann/kmeans_index.h	/^    Distance distance_;$/;"	m	class:cvflann::KMeansIndex	access:private
distance_	flann/linear_index.h	/^    Distance distance_;$/;"	m	class:cvflann::LinearIndex	access:private
distance_	flann/lsh_index.h	/^    Distance distance_;$/;"	m	class:cvflann::LshIndex	access:private
distortion	legacy/legacy.hpp	/^    float   distortion[4]; \/* distortion coefficients - two coefficients for radial distortion$/;"	m	struct:CvCamera	access:public
distortion	legacy/legacy.hpp	/^    float distortion[4];$/;"	m	struct:__anon188	access:public
dists	flann/result_set.h	/^    DistanceType* dists;$/;"	m	class:cvflann::KNNResultSet	access:private
dists	flann/result_set.h	/^    DistanceType* dists;$/;"	m	class:cvflann::KNNSimpleResultSet	access:private
dists	flann/result_set.h	/^    DistanceType* dists;$/;"	m	class:cvflann::RadiusResultSet	access:private
disttype	legacy/compat.hpp	/^    int       disttype; \/* distribution type *\/$/;"	m	struct:CvRandState	access:public
divfeat	flann/kdtree_index.h	/^        int divfeat;$/;"	m	struct:cvflann::KDTreeIndex::Node	access:public
divfeat	flann/kdtree_single_index.h	/^    	int divfeat;$/;"	m	struct:cvflann::KDTreeSingleIndex::Node	access:public
divhigh	flann/kdtree_single_index.h	/^    	DistanceType divlow, divhigh;$/;"	m	struct:cvflann::KDTreeSingleIndex::Node	access:public
divide	core/core.hpp	/^CV_EXPORTS_W void divide(InputArray src1, InputArray src2, OutputArray dst,$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst, double scale=1, int dtype=-1)
divide	core/core.hpp	/^CV_EXPORTS_W void divide(double scale, InputArray src2,$/;"	p	namespace:cv	signature:(double scale, InputArray src2, OutputArray dst, int dtype=-1)
divide	core/mat.hpp	/^    virtual void divide(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const
divide	core/mat.hpp	/^    virtual void divide(double s, const MatExpr& expr, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(double s, const MatExpr& expr, MatExpr& res) const
divide	gpu/gpu.hpp	/^        CV_EXPORTS void divide(const GpuMat& a, const GpuMat& b, GpuMat& c, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c, Stream& stream = Stream::Null())
divide	gpu/gpu.hpp	/^        CV_EXPORTS void divide(const GpuMat& a, const Scalar& sc, GpuMat& c, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const Scalar& sc, GpuMat& c, Stream& stream = Stream::Null())
divideTree	flann/kdtree_index.h	/^    NodePtr divideTree(int* ind, int count)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(int* ind, int count)
divideTree	flann/kdtree_single_index.h	/^    NodePtr divideTree(int left, int right, BoundingBox& bbox)$/;"	f	class:cvflann::KDTreeSingleIndex	access:private	signature:(int left, int right, BoundingBox& bbox)
divlow	flann/kdtree_single_index.h	/^    	DistanceType divlow, divhigh;$/;"	m	struct:cvflann::KDTreeSingleIndex::Node	access:public
divval	flann/kdtree_index.h	/^        DistanceType divval;$/;"	m	struct:cvflann::KDTreeIndex::Node	access:public
dmatcher	features2d/features2d.hpp	/^    Ptr<DescriptorMatcher> dmatcher;$/;"	m	class:cv::BOWImgDescriptorExtractor	access:protected
do_responses_copy	ml/ml.hpp	/^    virtual void do_responses_copy();$/;"	p	struct:CvDTreeTrainData	access:public	signature:()
do_subsample	ml/ml.hpp	/^    virtual void do_subsample();$/;"	p	class:CvGBTrees	access:protected	signature:()
do_train	ml/ml.hpp	/^    virtual bool do_train( const CvMat* _subsample_idx );$/;"	p	class:CvDTree	access:protected	signature:( const CvMat* _subsample_idx )
do_train	ml/ml.hpp	/^    virtual bool do_train( int svm_type, int sample_count, int var_count, const float** samples,$/;"	p	class:CvSVM	access:protected	signature:( int svm_type, int sample_count, int var_count, const float** samples, const CvMat* responses, CvMemStorage* _storage, double* alpha )
dot	core/core.hpp	/^    _Tp dot(const Matx<_Tp, m, n>& v) const;$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& v) const
dot	core/core.hpp	/^    _Tp dot(const Point3_& pt) const;$/;"	p	class:cv::Point3_	access:public	signature:(const Point3_& pt) const
dot	core/core.hpp	/^    _Tp dot(const Point_& pt) const;$/;"	p	class:cv::Point_	access:public	signature:(const Point_& pt) const
dot	core/core.hpp	/^    double dot(InputArray m) const;$/;"	p	class:cv::Mat	access:public	signature:(InputArray m) const
dot	core/mat.hpp	/^    double dot(const Mat& m) const;$/;"	p	class:cv::MatExpr	access:public	signature:(const Mat& m) const
dot	core/operations.hpp	/^dot(const Vector<_Tp>& v1, const Vector<_Tp>& v2)$/;"	f	namespace:cv	signature:(const Vector<_Tp>& v1, const Vector<_Tp>& v2)
dot	core/operations.hpp	/^template<typename _Tp, int m, int n> inline _Tp Matx<_Tp, m, n>::dot(const Matx<_Tp, m, n>& M) const$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& M) const
dot	core/operations.hpp	/^template<typename _Tp> inline _Tp Point3_<_Tp>::dot(const Point3_& pt) const$/;"	f	class:cv::Point3_	signature:(const Point3_& pt) const
dot	core/operations.hpp	/^template<typename _Tp> inline _Tp Point_<_Tp>::dot(const Point_& pt) const$/;"	f	class:cv::Point_	signature:(const Point_& pt) const
download	gpu/gpumat.hpp	/^        void download(CudaMem& m, Stream& stream) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(CudaMem& m, Stream& stream) const
download	gpu/gpumat.hpp	/^        void download(cv::Mat& m) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(cv::Mat& m) const
downloadDescriptors	gpu/gpu.hpp	/^            void downloadDescriptors(const GpuMat& descriptorsGPU, vector<float>& descriptors);$/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:(const GpuMat& descriptorsGPU, vector<float>& descriptors)
downloadKeypoints	gpu/gpu.hpp	/^            void downloadKeypoints(const GpuMat& keypointsGPU, vector<KeyPoint>& keypoints);$/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:(const GpuMat& keypointsGPU, vector<KeyPoint>& keypoints)
downsample	gpu/gpu.hpp	/^        CV_EXPORTS void downsample(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null())
drawChessboardCorners	calib3d/calib3d.hpp	/^CV_EXPORTS_W void drawChessboardCorners( InputOutputArray image, Size patternSize,$/;"	p	namespace:cv	signature:( InputOutputArray image, Size patternSize, InputArray corners, bool patternWasFound )
drawColorDisp	gpu/gpu.hpp	/^        CV_EXPORTS void drawColorDisp(const GpuMat& src_disp, GpuMat& dst_disp, int ndisp, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src_disp, GpuMat& dst_disp, int ndisp, Stream& stream = Stream::Null())
drawContours	imgproc/imgproc.hpp	/^CV_EXPORTS_W void drawContours( InputOutputArray image, InputArrayOfArrays contours,$/;"	p	namespace:cv	signature:( InputOutputArray image, InputArrayOfArrays contours, int contourIdx, const Scalar& color, int thickness=1, int lineType=8, InputArray hierarchy=noArray(), int maxLevel=INT_MAX, Point offset=Point() )
drawDataMatrixCodes	objdetect/objdetect.hpp	/^CV_EXPORTS  void drawDataMatrixCodes(const std::vector<DataMatrixCode>& codes, Mat& drawImage);$/;"	p	namespace:cv	signature:(const std::vector<DataMatrixCode>& codes, Mat& drawImage)
drawKeypoints	features2d/features2d.hpp	/^CV_EXPORTS void drawKeypoints( const Mat& image, const vector<KeyPoint>& keypoints, Mat& outImage,$/;"	p	namespace:cv	signature:( const Mat& image, const vector<KeyPoint>& keypoints, Mat& outImage, const Scalar& color=Scalar::all(-1), int flags=DrawMatchesFlags::DEFAULT )
drawMatches	features2d/features2d.hpp	/^CV_EXPORTS void drawMatches( const Mat& img1, const vector<KeyPoint>& keypoints1,$/;"	p	namespace:cv	signature:( const Mat& img1, const vector<KeyPoint>& keypoints1, const Mat& img2, const vector<KeyPoint>& keypoints2, const vector<DMatch>& matches1to2, Mat& outImg, const Scalar& matchColor=Scalar::all(-1), const Scalar& singlePointColor=Scalar::all(-1), const vector<char>& matchesMask=vector<char>(), int flags=DrawMatchesFlags::DEFAULT )
drawMatches	features2d/features2d.hpp	/^CV_EXPORTS void drawMatches( const Mat& img1, const vector<KeyPoint>& keypoints1,$/;"	p	namespace:cv	signature:( const Mat& img1, const vector<KeyPoint>& keypoints1, const Mat& img2, const vector<KeyPoint>& keypoints2, const vector<vector<DMatch> >& matches1to2, Mat& outImg, const Scalar& matchColor=Scalar::all(-1), const Scalar& singlePointColor=Scalar::all(-1), const vector<vector<char> >& matchesMask=vector<vector<char> >(), int flags=DrawMatchesFlags::DEFAULT )
dst	core/core.hpp	/^    Matx<_Tp, m, n>* dst;$/;"	m	class:cv::MatxCommaInitializer	access:public
dst	core/core_c.h	/^    CvGraphVtx* dst;       \/* current graph edge destination vertex *\/$/;"	m	struct:CvGraphScanner	access:public
dstType	imgproc/imgproc.hpp	/^    int srcType, dstType, bufType;$/;"	m	class:cv::FilterEngine	access:public
dstY	imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
dummyfunc	flann/dummy.h	/^void dummyfunc();$/;"	p	namespace:cvflann	signature:()
dx	core/core_c.h	/^    float       dx; 			\/* horizontal interval between letters *\/$/;"	m	struct:CvFont	access:public
dx	gpu/gpu.hpp	/^            GpuMat dx, dy;$/;"	m	struct:cv::gpu::CannyBuf	access:public
dx1	imgproc/imgproc.hpp	/^    int dx1, dx2;$/;"	m	class:cv::FilterEngine	access:public
dx2	imgproc/imgproc.hpp	/^    int dx1, dx2;$/;"	m	class:cv::FilterEngine	access:public
dx_buf	gpu/gpu.hpp	/^            GpuMat dx_buf, dy_buf;$/;"	m	struct:cv::gpu::CannyBuf	access:public
dy	gpu/gpu.hpp	/^            GpuMat dx, dy;$/;"	m	struct:cv::gpu::CannyBuf	access:public
dy_buf	gpu/gpu.hpp	/^            GpuMat dx_buf, dy_buf;$/;"	m	struct:cv::gpu::CannyBuf	access:public
ea	contrib/contrib.hpp	/^        CvMat** ea; \/\/ sum_i  AijT * e_ij , used as right part of normal equation$/;"	m	class:cv::LevMarqSparse	access:public
eb	contrib/contrib.hpp	/^        CvMat** eb; \/\/ sum_j  BijT * e_ij , used as right part of normal equation$/;"	m	class:cv::LevMarqSparse	access:public
edge	core/core_c.h	/^    CvGraphEdge* edge;     \/* current edge *\/$/;"	m	struct:CvGraphScanner	access:public
edgeBlurSize	features2d/features2d.hpp	/^    int edgeBlurSize;$/;"	m	struct:CvMSERParams	access:public
edgeBuf	calib3d/calib3d.hpp	/^    CvMat* edgeBuf;$/;"	m	struct:CvStereoGCState	access:public
edgeBuf	gpu/gpu.hpp	/^            GpuMat edgeBuf;$/;"	m	struct:cv::gpu::CannyBuf	access:public
edgeDst	imgproc/imgproc.hpp	/^    CV_WRAP int edgeDst(int edge, CV_OUT Point2f* dstpt=0) const;$/;"	p	class:cv::Subdiv2D	access:public	signature:(int edge, CV_OUT Point2f* dstpt=0) const
edgeOrg	imgproc/imgproc.hpp	/^    CV_WRAP int edgeOrg(int edge, CV_OUT Point2f* orgpt=0) const;$/;"	p	class:cv::Subdiv2D	access:public	signature:(int edge, CV_OUT Point2f* orgpt=0) const
edgeThreshold	features2d/features2d.hpp	/^        double threshold, edgeThreshold;$/;"	m	struct:cv::SIFT::DetectorParams	access:public
edge_threshold	gpu/gpu.hpp	/^            float edge_threshold;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
edge_threshold_	features2d/features2d.hpp	/^    int edge_threshold_;$/;"	m	struct:cv::ORB::CommonParams	access:public
edge_weights	legacy/legacy.hpp	/^    float* edge_weights;$/;"	m	struct:CvCliqueFinder	access:public
egvals	legacy/legacy.hpp	/^    float egvals[2];$/;"	m	struct:CvContourOrientation	access:public
egvects	legacy/legacy.hpp	/^    float egvects[4];$/;"	m	struct:CvContourOrientation	access:public
ehmm	legacy/legacy.hpp	/^        struct CvEHMM* ehmm; \/* pointer to an embedded model or NULL, if it is a leaf *\/$/;"	m	union:CvEHMM::__anon183	typeref:struct:CvEHMM::__anon183::CvEHMM	access:public
eigen	core/core.hpp	/^CV_EXPORTS bool eigen(InputArray src, OutputArray eigenvalues, int lowindex=-1,$/;"	p	namespace:cv	signature:(InputArray src, OutputArray eigenvalues, int lowindex=-1, int highindex=-1)
eigen	core/core.hpp	/^CV_EXPORTS bool eigen(InputArray src, OutputArray eigenvalues,$/;"	p	namespace:cv	signature:(InputArray src, OutputArray eigenvalues, OutputArray eigenvectors, int lowindex=-1, int highindex=-1)
eigen	core/core.hpp	/^CV_EXPORTS_W bool eigen(InputArray src, bool computeEigenvectors,$/;"	p	namespace:cv	signature:(InputArray src, bool computeEigenvectors, OutputArray eigenvalues, OutputArray eigenvectors)
eigen2cv	core/eigen.hpp	/^void eigen2cv( const Eigen::Matrix<_Tp, _rows, _cols, _options, _maxRows, _maxCols>& src, Mat& dst )$/;"	f	namespace:cv	signature:( const Eigen::Matrix<_Tp, _rows, _cols, _options, _maxRows, _maxCols>& src, Mat& dst )
eigenvalues	core/core.hpp	/^    Mat eigenvalues; \/\/!< eigenvalues of the covariation matrix$/;"	m	class:cv::PCA	access:public
eigenvectors	core/core.hpp	/^    Mat eigenvectors; \/\/!< eigenvectors of the covariation matrix$/;"	m	class:cv::PCA	access:public
elemSize	core/core.hpp	/^    int step, elemSize;$/;"	m	class:cv::LineIterator	access:public
elemSize	core/core.hpp	/^    size_t elemSize() const;$/;"	p	class:cv::Mat	access:public	signature:() const
elemSize	core/core.hpp	/^    size_t elemSize() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
elemSize	core/core.hpp	/^    size_t elemSize() const;$/;"	p	class:cv::Seq	access:public	signature:() const
elemSize	core/core.hpp	/^    size_t elemSize() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
elemSize	core/core.hpp	/^    size_t elemSize;$/;"	m	class:cv::MatConstIterator	access:public
elemSize	core/mat.hpp	/^inline size_t Mat::elemSize() const { return dims > 0 ? step.p[dims-1] : 0; }$/;"	f	class:cv::Mat	signature:() const
elemSize	core/mat.hpp	/^inline size_t SparseMat::elemSize() const$/;"	f	class:cv::SparseMat	signature:() const
elemSize	core/mat.hpp	/^template<typename _Tp> inline size_t Mat_<_Tp>::elemSize() const$/;"	f	class:cv::Mat_	signature:() const
elemSize	core/operations.hpp	/^template<typename _Tp> inline size_t Seq<_Tp>::elemSize() const$/;"	f	class:cv::Seq	signature:() const
elemSize	gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ size_t elemSize() const { return elem_size; }$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:() const
elemSize	gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ size_t elemSize() const { return elem_size; }$/;"	f	struct:cv::gpu::PtrStep_	access:public	signature:() const
elemSize	gpu/gpu.hpp	/^            size_t elemSize() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
elemSize	gpu/gpumat.hpp	/^        size_t elemSize() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
elemSize	gpu/matrix_operations.hpp	/^inline size_t CudaMem::elemSize() const { return CV_ELEM_SIZE(flags); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
elemSize1	core/core.hpp	/^    size_t elemSize1() const;$/;"	p	class:cv::Mat	access:public	signature:() const
elemSize1	core/core.hpp	/^    size_t elemSize1() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
elemSize1	core/core.hpp	/^    size_t elemSize1() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
elemSize1	core/mat.hpp	/^inline size_t Mat::elemSize1() const { return CV_ELEM_SIZE1(flags); }$/;"	f	class:cv::Mat	signature:() const
elemSize1	core/mat.hpp	/^inline size_t SparseMat::elemSize1() const$/;"	f	class:cv::SparseMat	signature:() const
elemSize1	core/mat.hpp	/^template<typename _Tp> inline size_t Mat_<_Tp>::elemSize1() const$/;"	f	class:cv::Mat_	signature:() const
elemSize1	gpu/gpu.hpp	/^            size_t elemSize1() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
elemSize1	gpu/gpumat.hpp	/^        size_t elemSize1() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
elemSize1	gpu/matrix_operations.hpp	/^inline size_t CudaMem::elemSize1() const { return CV_ELEM_SIZE1(flags); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
elem_size	gpu/devmem2d.hpp	/^            enum { elem_size = sizeof(elem_type) };$/;"	e	enum:cv::gpu::DevMem2D_::__anon52
elem_size	gpu/devmem2d.hpp	/^            enum { elem_size = sizeof(elem_type) };$/;"	e	enum:cv::gpu::PtrStep_::__anon53
elem_type	gpu/devmem2d.hpp	/^            typedef T elem_type;$/;"	t	struct:cv::gpu::DevMem2D_	access:public
elem_type	gpu/devmem2d.hpp	/^            typedef T elem_type;$/;"	t	struct:cv::gpu::PtrStep_	access:public
element	imgproc/imgproc_c.h	/^CVAPI(void)  cvReleaseStructuringElement( IplConvKernel** element );$/;"	v
elementWise	core/mat.hpp	/^    virtual bool elementWise(const MatExpr& expr) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr) const
ellipse	core/core.hpp	/^CV_EXPORTS_W void ellipse(Mat& img, Point center, Size axes,$/;"	p	namespace:cv	signature:(Mat& img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar& color, int thickness=1, int lineType=8, int shift=0)
ellipse	core/core.hpp	/^CV_EXPORTS_W void ellipse(Mat& img, const RotatedRect& box, const Scalar& color,$/;"	p	namespace:cv	signature:(Mat& img, const RotatedRect& box, const Scalar& color, int thickness=1, int lineType=8)
ellipse2Poly	core/core.hpp	/^CV_EXPORTS_W void ellipse2Poly( Point center, Size axes, int angle,$/;"	p	namespace:cv	signature:( Point center, Size axes, int angle, int arcStart, int arcEnd, int delta, CV_OUT vector<Point>& pts )
ellipseAngle	contrib/contrib.hpp	/^        double ellipseAngle;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
ellipseHeight	contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
ellipseWidth	contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
elname	core/core.hpp	/^    string elname; \/\/!< the currently written element$/;"	m	class:cv::FileStorage	access:public
empty	core/core.hpp	/^    CV_WRAP bool empty() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
empty	core/core.hpp	/^    bool empty() const;$/;"	p	class:cv::Mat	access:public	signature:() const
empty	core/core.hpp	/^    bool empty() const;$/;"	p	class:cv::Ptr	access:public	signature:() const
empty	core/core.hpp	/^    bool empty() const;$/;"	p	class:cv::Range	access:public	signature:() const
empty	core/core.hpp	/^    bool empty() const;$/;"	p	class:cv::Seq	access:public	signature:() const
empty	core/core.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::_InputArray	access:public	signature:() const
empty	core/mat.hpp	/^inline bool Mat::empty() const { return data == 0 || total() == 0; }$/;"	f	class:cv::Mat	signature:() const
empty	core/operations.hpp	/^    bool empty() const { return hdr.size == 0; }$/;"	f	class:cv::Vector	access:public	signature:() const
empty	core/operations.hpp	/^inline bool FileNode::empty() const { return node == 0; }$/;"	f	class:cv::FileNode	signature:() const
empty	core/operations.hpp	/^inline bool Range::empty() const { return start == end; }$/;"	f	class:cv::Range	signature:() const
empty	core/operations.hpp	/^template<typename _Tp> inline bool Ptr<_Tp>::empty() const { return obj == 0; }$/;"	f	class:cv::Ptr	signature:() const
empty	core/operations.hpp	/^template<typename _Tp> inline bool Seq<_Tp>::empty() const$/;"	f	class:cv::Seq	signature:() const
empty	features2d/features2d.hpp	/^    virtual bool empty() const { return m_train_feature_count <= 0 ? true : false; }$/;"	f	class:cv::OneWayDescriptorBase	access:public	signature:() const
empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::CalonderDescriptorExtractor	access:public	signature:() const
empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::DescriptorExtractor	access:public	signature:() const
empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::DescriptorMatcher	access:public	signature:() const
empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::DynamicAdaptedFeatureDetector	access:public	signature:() const
empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::FeatureDetector	access:public	signature:() const
empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:() const
empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:() const
empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::GridAdaptedFeatureDetector	access:public	signature:() const
empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:() const
empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:public	signature:() const
empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::PyramidAdaptedFeatureDetector	access:public	signature:() const
empty	features2d/features2d.hpp	/^    virtual bool empty() const;$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:() const
empty	features2d/features2d.hpp	/^bool CalonderDescriptorExtractor<T>::empty() const$/;"	f	class:cv::CalonderDescriptorExtractor	signature:() const
empty	flann/any.h	/^    bool empty() const$/;"	f	struct:cdiggins::any	access:public	signature:() const
empty	flann/dynamic_bitset.h	/^    bool empty() const$/;"	f	class:DynamicBitset	access:public	signature:() const
empty	flann/heap.h	/^    bool empty()$/;"	f	class:cvflann::Heap	access:public	signature:()
empty	gpu/gpu.hpp	/^            bool empty() const;$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:() const
empty	gpu/gpu.hpp	/^            bool empty() const;$/;"	p	class:cv::gpu::CascadeClassifier_GPU	access:public	signature:() const
empty	gpu/gpu.hpp	/^            bool empty() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
empty	gpu/gpumat.hpp	/^        bool empty() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
empty	gpu/gpumat.hpp	/^    inline bool GpuMat::empty() const { return data == 0; }$/;"	f	class:cv::gpu::GpuMat	signature:() const
empty	gpu/matrix_operations.hpp	/^inline bool CudaMem::empty() const { return data == 0; }$/;"	f	class:cv::gpu::CudaMem	signature:() const
empty	objdetect/objdetect.hpp	/^    CV_WRAP virtual bool empty() const;$/;"	p	class:cv::CascadeClassifier	access:public	signature:() const
empty_any	flann/any.h	/^struct empty_any$/;"	s	namespace:cdiggins::anyimpl
end	contrib/contrib.hpp	/^            int begin, end;$/;"	m	struct:cv::Octree::Node	access:public
end	core/core.hpp	/^    FileNodeIterator end() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
end	core/core.hpp	/^    SeqIterator<_Tp> end() const;$/;"	p	class:cv::Seq	access:public	signature:() const
end	core/core.hpp	/^    SparseMatConstIterator end() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
end	core/core.hpp	/^    SparseMatConstIterator_<_Tp> end() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
end	core/core.hpp	/^    SparseMatIterator end();$/;"	p	class:cv::SparseMat	access:public	signature:()
end	core/core.hpp	/^    SparseMatIterator_<_Tp> end();$/;"	p	class:cv::SparseMat_	access:public	signature:()
end	core/core.hpp	/^    const_iterator end() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
end	core/core.hpp	/^    int start, end;$/;"	m	class:cv::Range	access:public
end	core/core.hpp	/^    iterator end();$/;"	p	class:cv::Mat_	access:public	signature:()
end	core/core.hpp	/^    template<typename _Tp> MatConstIterator_<_Tp> end() const;$/;"	p	class:cv::Mat	access:public	signature:() const
end	core/core.hpp	/^    template<typename _Tp> MatIterator_<_Tp> end();$/;"	p	class:cv::Mat	access:public	signature:()
end	core/core.hpp	/^    template<typename _Tp> SparseMatConstIterator_<_Tp> end() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
end	core/core.hpp	/^    template<typename _Tp> SparseMatIterator_<_Tp> end();$/;"	p	class:cv::SparseMat	access:public	signature:()
end	core/mat.hpp	/^inline SparseMatConstIterator SparseMat::end() const$/;"	f	class:cv::SparseMat	signature:() const
end	core/mat.hpp	/^inline SparseMatIterator SparseMat::end()$/;"	f	class:cv::SparseMat	signature:()
end	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> Mat::end() const$/;"	f	class:cv::Mat	signature:() const
end	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> Mat_<_Tp>::end() const$/;"	f	class:cv::Mat_	signature:() const
end	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> Mat::end()$/;"	f	class:cv::Mat	signature:()
end	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> Mat_<_Tp>::end()$/;"	f	class:cv::Mat_	signature:()
end	core/mat.hpp	/^template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat::end() const$/;"	f	class:cv::SparseMat	signature:() const
end	core/mat.hpp	/^template<typename _Tp> inline SparseMatConstIterator_<_Tp> SparseMat_<_Tp>::end() const$/;"	f	class:cv::SparseMat_	signature:() const
end	core/mat.hpp	/^template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat::end()$/;"	f	class:cv::SparseMat	signature:()
end	core/mat.hpp	/^template<typename _Tp> inline SparseMatIterator_<_Tp> SparseMat_<_Tp>::end()$/;"	f	class:cv::SparseMat_	signature:()
end	core/operations.hpp	/^    _Tp* end() { return hdr.data + hdr.size; }$/;"	f	class:cv::Vector	access:public	signature:()
end	core/operations.hpp	/^    const _Tp* end() const { return hdr.data + hdr.size; }$/;"	f	class:cv::Vector	access:public	signature:() const
end	core/operations.hpp	/^inline FileNodeIterator FileNode::end() const$/;"	f	class:cv::FileNode	signature:() const
end	core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp> Seq<_Tp>::end() const$/;"	f	class:cv::Seq	signature:() const
end	gpu/NCV.hpp	/^    Ncv8u *end;$/;"	m	class:NCVMemStackAllocator	access:private
end	gpu/devmem2d.hpp	/^            thrust::device_ptr<T> end() const { return thrust::device_ptr<T>(data) + cols * rows; }$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:() const
end	imgproc/types_c.h	/^    CvPoint* end; \/* point of the contour where the defect ends *\/$/;"	m	struct:CvConvexityDefect	access:public
end1	legacy/blobtrack.hpp	/^    int end1,end2;$/;"	m	struct:CvTracksTimePos	access:public
end2	legacy/blobtrack.hpp	/^    int end1,end2;$/;"	m	struct:CvTracksTimePos	access:public
endY	imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
end_index	core/types_c.h	/^    int  start_index, end_index;$/;"	m	struct:CvSlice	access:public
enqueueConvert	gpu/gpu.hpp	/^            void enqueueConvert(const GpuMat& src, GpuMat& dst, int type, double a = 1, double b = 0);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const GpuMat& src, GpuMat& dst, int type, double a = 1, double b = 0)
enqueueCopy	gpu/gpu.hpp	/^            void enqueueCopy(const GpuMat& src, GpuMat& dst);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const GpuMat& src, GpuMat& dst)
enqueueDownload	gpu/gpu.hpp	/^            void enqueueDownload(const GpuMat& src, CudaMem& dst);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const GpuMat& src, CudaMem& dst)
enqueueDownload	gpu/gpu.hpp	/^            void enqueueDownload(const GpuMat& src, Mat& dst);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const GpuMat& src, Mat& dst)
enqueueMemSet	gpu/gpu.hpp	/^            void enqueueMemSet(GpuMat& src, Scalar val);$/;"	p	class:cv::gpu::Stream	access:public	signature:(GpuMat& src, Scalar val)
enqueueMemSet	gpu/gpu.hpp	/^            void enqueueMemSet(GpuMat& src, Scalar val, const GpuMat& mask);$/;"	p	class:cv::gpu::Stream	access:public	signature:(GpuMat& src, Scalar val, const GpuMat& mask)
enqueueUpload	gpu/gpu.hpp	/^            void enqueueUpload(const CudaMem& src, GpuMat& dst);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const CudaMem& src, GpuMat& dst)
enqueueUpload	gpu/gpu.hpp	/^            void enqueueUpload(const Mat& src, GpuMat& dst);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const Mat& src, GpuMat& dst)
ensemble	ml/ml.hpp	/^    CvBoost* ensemble;$/;"	m	class:CvBoostTree	access:protected
ensureSizeIsEnough	gpu/gpumat.hpp	/^    CV_EXPORTS void ensureSizeIsEnough(Size size, int type, GpuMat& m);$/;"	p	namespace:cv::gpu	signature:(Size size, int type, GpuMat& m)
ensureSizeIsEnough	gpu/gpumat.hpp	/^    CV_EXPORTS void ensureSizeIsEnough(int rows, int cols, int type, GpuMat& m);$/;"	p	namespace:cv::gpu	signature:(int rows, int cols, int type, GpuMat& m)
epipole	legacy/legacy.hpp	/^    CvPoint3D32f epipole[2];$/;"	m	struct:CvStereoCamera	access:public
eps	ml/ml.hpp	/^    double eps;$/;"	m	class:CvSVMSolver	access:public
epsilon	core/core.hpp	/^    double epsilon; \/\/ the desired accuracy$/;"	m	class:cv::TermCriteria	access:public
epsilon	core/types_c.h	/^    double epsilon;$/;"	m	struct:CvTermCriteria	access:public
equalizeHist	gpu/gpu.hpp	/^        CV_EXPORTS void equalizeHist(const GpuMat& src, GpuMat& dst, GpuMat& hist, GpuMat& buf, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, GpuMat& hist, GpuMat& buf, Stream& stream = Stream::Null())
equalizeHist	gpu/gpu.hpp	/^        CV_EXPORTS void equalizeHist(const GpuMat& src, GpuMat& dst, GpuMat& hist, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, GpuMat& hist, Stream& stream = Stream::Null())
equalizeHist	gpu/gpu.hpp	/^        CV_EXPORTS void equalizeHist(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null())
equalizeHist	imgproc/imgproc.hpp	/^CV_EXPORTS_W void equalizeHist( InputArray src, OutputArray dst );$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst )
erase	core/core.hpp	/^    void erase(const int* idx, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, size_t* hashval=0)
erase	core/core.hpp	/^    void erase(int i0, int i1, int i2, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0)
erase	core/core.hpp	/^    void erase(int i0, int i1, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, size_t* hashval=0)
erode	gpu/gpu.hpp	/^        CV_EXPORTS void erode( const GpuMat& src, GpuMat& dst, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:( const GpuMat& src, GpuMat& dst, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1, Stream& stream = Stream::Null())
erode	imgproc/imgproc.hpp	/^CV_EXPORTS_W void erode( InputArray src, OutputArray dst, InputArray kernel,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, InputArray kernel, Point anchor=Point(-1,-1), int iterations=1, int borderType=BORDER_CONSTANT, const Scalar& borderValue=morphologyDefaultBorderValue() )
err	calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> err;$/;"	m	class:CvLevMarq	access:public
err	contrib/contrib.hpp	/^        CvMat* err; \/\/error X-hX$/;"	m	class:cv::LevMarqSparse	access:public
err	core/core.hpp	/^    int err, count;$/;"	m	class:cv::LineIterator	access:public
err	core/core.hpp	/^    string err; \/\/\/< error description$/;"	m	class:cv::Exception	access:public
err	core/types_c.h	/^    int  err;$/;"	m	struct:CvLineIterator	access:public
errNorm	calib3d/calib3d.hpp	/^    double prevErrNorm, errNorm;$/;"	m	class:CvLevMarq	access:public
errNorm	contrib/contrib.hpp	/^        double prevErrNorm, errNorm;$/;"	m	class:cv::LevMarqSparse	access:public
error	core/core.hpp	/^CV_EXPORTS void error( const Exception& exc );$/;"	p	namespace:cv	signature:( const Exception& exc )
error	gpu/gpu.hpp	/^        CV_EXPORTS void error(const char *error_string, const char *file, const int line, const char *func);$/;"	p	namespace:cv::gpu	signature:(const char *error_string, const char *file, const int line, const char *func)
errorCovPost	video/tracking.hpp	/^    Mat errorCovPost;       \/\/!< posteriori error estimate covariance matrix (P(k)): P(k)=(I-K(k)*H)*P'(k)$/;"	m	class:cv::KalmanFilter	access:public
errorCovPre	video/tracking.hpp	/^    Mat errorCovPre;        \/\/!< priori error estimate covariance matrix (P'(k)): P'(k)=A*P(k-1)*At + Q)*\/$/;"	m	class:cv::KalmanFilter	access:public
error_cov_post	video/tracking.hpp	/^    CvMat* error_cov_post;      \/* posteriori error estimate covariance matrix (P(k)):$/;"	m	struct:CvKalman	access:public
error_cov_pre	video/tracking.hpp	/^    CvMat* error_cov_pre;       \/* priori error estimate covariance matrix (P'(k)):$/;"	m	struct:CvKalman	access:public
escape_iters_	features2d/features2d.hpp	/^    int escape_iters_;$/;"	m	class:cv::DynamicAdaptedFeatureDetector	access:private
estimateAffine3D	calib3d/calib3d.hpp	/^CV_EXPORTS_W  int estimateAffine3D(InputArray _from, InputArray _to,$/;"	p	namespace:cv	signature:(InputArray _from, InputArray _to, OutputArray _out, OutputArray _inliers, double param1=3, double param2=0.99)
estimateBlockSize	gpu/gpu.hpp	/^            static Size estimateBlockSize(Size result_size, Size templ_size);$/;"	p	struct:cv::gpu::ConvolveBuf	access:private	signature:(Size result_size, Size templ_size)
estimateBuildParams	flann/autotuned_index.h	/^    IndexParams estimateBuildParams()$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:()
estimateQuantPercForPosteriors	features2d/features2d.hpp	/^  void estimateQuantPercForPosteriors(float perc[2]);$/;"	p	class:cv::RandomizedTree	access:private	signature:(float perc[2])
estimateRecommendedParams	gpu/gpu.hpp	/^            static void estimateRecommendedParams(int width, int height, int& ndisp, int& iters, int& levels);$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(int width, int height, int& ndisp, int& iters, int& levels)
estimateRecommendedParams	gpu/gpu.hpp	/^            static void estimateRecommendedParams(int width, int height, int& ndisp, int& iters, int& levels, int& nr_plane);$/;"	p	class:cv::gpu::StereoConstantSpaceBP	access:public	signature:(int width, int height, int& ndisp, int& iters, int& levels, int& nr_plane)
estimateResolution	contrib/contrib.hpp	/^        float estimateResolution(float tryRatio = 0.1f);$/;"	p	class:cv::Mesh3D	access:public	signature:(float tryRatio = 0.1f)
estimateRigidTransform	video/tracking.hpp	/^CV_EXPORTS_W Mat estimateRigidTransform( InputArray src, InputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, InputArray dst, bool fullAffine)
estimateSearchParams	flann/autotuned_index.h	/^    float estimateSearchParams(SearchParams& searchParams)$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:(SearchParams& searchParams)
etalonParamCount	legacy/legacy.hpp	/^    int     etalonParamCount;$/;"	m	class:CvCalibFilter	access:protected
etalonParams	legacy/legacy.hpp	/^    double* etalonParams;$/;"	m	class:CvCalibFilter	access:protected
etalonPointCount	legacy/legacy.hpp	/^    int     etalonPointCount;$/;"	m	class:CvCalibFilter	access:protected
etalonPoints	legacy/legacy.hpp	/^    CvPoint2D32f* etalonPoints;$/;"	m	class:CvCalibFilter	access:protected
etalonType	legacy/legacy.hpp	/^    CvCalibEtalonType  etalonType;$/;"	m	class:CvCalibFilter	access:protected
evaluateFeatureDetector	features2d/features2d.hpp	/^CV_EXPORTS void evaluateFeatureDetector( const Mat& img1, const Mat& img2, const Mat& H1to2,$/;"	p	namespace:cv	signature:( const Mat& img1, const Mat& img2, const Mat& H1to2, vector<KeyPoint>* keypoints1, vector<KeyPoint>* keypoints2, float& repeatability, int& correspCount, const Ptr<FeatureDetector>& fdetector=Ptr<FeatureDetector>() )
evaluateGenericDescriptorMatcher	features2d/features2d.hpp	/^CV_EXPORTS void evaluateGenericDescriptorMatcher( const Mat& img1, const Mat& img2, const Mat& H1to2,$/;"	p	namespace:cv	signature:( const Mat& img1, const Mat& img2, const Mat& H1to2, vector<KeyPoint>& keypoints1, vector<KeyPoint>& keypoints2, vector<vector<DMatch> >* matches1to2, vector<vector<uchar> >* correctMatches1to2Mask, vector<Point2f>& recallPrecisionCurve, const Ptr<GenericDescriptorMatcher>& dmatch=Ptr<GenericDescriptorMatcher>() )
evaluate_kdtree	flann/autotuned_index.h	/^    void evaluate_kdtree(CostData& cost)$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:(CostData& cost)
evaluate_kmeans	flann/autotuned_index.h	/^    void evaluate_kmeans(CostData& cost)$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:(CostData& cost)
evenLevels	gpu/gpu.hpp	/^        CV_EXPORTS void evenLevels(GpuMat& levels, int nLevels, int lowerLevel, int upperLevel);$/;"	p	namespace:cv::gpu	signature:(GpuMat& levels, int nLevels, int lowerLevel, int upperLevel)
exp	core/core.hpp	/^CV_EXPORTS_W void exp(InputArray src, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst)
exp	gpu/gpu.hpp	/^        CV_EXPORTS void exp(const GpuMat& a, GpuMat& b, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, GpuMat& b, Stream& stream = Stream::Null())
exploreNodeBranches	flann/kmeans_index.h	/^    int exploreNodeBranches(KMeansNodePtr node, const ElementType* q, DistanceType* domain_distances, Heap<BranchSt>* heap)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNodePtr node, const ElementType* q, DistanceType* domain_distances, Heap<BranchSt>* heap)
extended	features2d/features2d.hpp	/^    int    extended;$/;"	m	struct:CvSURFParams	access:public
extractChannel	core/core.hpp	/^CV_EXPORTS_W void extractChannel(InputArray src, OutputArray dst, int coi);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, int coi)
extractImageCOI	core/core.hpp	/^CV_EXPORTS void extractImageCOI(const CvArr* arr, OutputArray coiimg, int coi=-1);$/;"	p	namespace:cv	signature:(const CvArr* arr, OutputArray coiimg, int coi=-1)
extractInfo	contrib/contrib.hpp	/^        void extractInfo(IplImage *maskImage, IplImage *depthMap, bool initDepth);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(IplImage *maskImage, IplImage *depthMap, bool initDepth)
extractor	features2d/features2d.hpp	/^    Ptr<DescriptorExtractor> extractor;$/;"	m	class:cv::VectorDescriptorMatcher	access:protected
eye	core/core.hpp	/^    static MatExpr eye(Size size);$/;"	p	class:cv::Mat_	access:public	signature:(Size size)
eye	core/core.hpp	/^    static MatExpr eye(Size size, int type);$/;"	p	class:cv::Mat	access:public	signature:(Size size, int type)
eye	core/core.hpp	/^    static MatExpr eye(int rows, int cols);$/;"	p	class:cv::Mat_	access:public	signature:(int rows, int cols)
eye	core/core.hpp	/^    static MatExpr eye(int rows, int cols, int type);$/;"	p	class:cv::Mat	access:public	signature:(int rows, int cols, int type)
eye	core/core.hpp	/^    static Matx eye();$/;"	p	class:cv::Matx	access:public	signature:()
eye	core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::eye(Size sz)$/;"	f	class:cv::Mat_	signature:(Size sz)
eye	core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::eye(int rows, int cols)$/;"	f	class:cv::Mat_	signature:(int rows, int cols)
eye	core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::eye()$/;"	f	class:cv::Matx	signature:()
f	core/types_c.h	/^        double f; \/* scalar floating-point number *\/$/;"	m	union:CvFileNode::__anon157	access:public
f	core/types_c.h	/^    double f;$/;"	m	union:Cv64suf	access:public
f	core/types_c.h	/^    float f;$/;"	m	union:Cv32suf	access:public
fCT	video/background_segm.hpp	/^    float fCT;\/\/CT - complexity reduction prior$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
fHistogram	contrib/contrib.hpp	/^        CvHistogram *fHistogram;$/;"	m	class:CvAdaptiveSkinDetector::Histogram	access:public
fHistogramMergeFactor	contrib/contrib.hpp	/^    double fHistogramMergeFactor, fHuePercentCovered;$/;"	m	class:CvAdaptiveSkinDetector	access:private
fHuePercentCovered	contrib/contrib.hpp	/^    double fHistogramMergeFactor, fHuePercentCovered;$/;"	m	class:CvAdaptiveSkinDetector	access:private
fTau	video/background_segm.hpp	/^    float fTau;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
fVarInit	video/background_segm.hpp	/^    float fVarInit;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
fVarMax	video/background_segm.hpp	/^    float fVarMax;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
fVarMin	video/background_segm.hpp	/^    float fVarMin;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
f_param1	ml/ml.hpp	/^    double f_param1, f_param2;$/;"	m	class:CvANN_MLP	access:protected
f_param2	ml/ml.hpp	/^    double f_param1, f_param2;$/;"	m	class:CvANN_MLP	access:protected
fastAtan2	core/core.hpp	/^CV_EXPORTS_W float fastAtan2(float y, float x);$/;"	p	namespace:cv	signature:(float y, float x)
fastFree	core/core.hpp	/^CV_EXPORTS void fastFree(void* ptr);$/;"	p	namespace:cv	signature:(void* ptr)
fastMalloc	core/core.hpp	/^CV_EXPORTS void* fastMalloc(size_t bufSize);$/;"	p	namespace:cv	signature:(size_t bufSize)
featureEvaluator	objdetect/objdetect.hpp	/^    Ptr<FeatureEvaluator> featureEvaluator;$/;"	m	class:cv::CascadeClassifier	access:protected
featureIdx	objdetect/objdetect.hpp	/^            int featureIdx;$/;"	m	struct:cv::CascadeClassifier::Data::DTreeNode	access:public
featureScaleLevels	features2d/features2d.hpp	/^        int featureScaleLevels;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
featureScaleMul	features2d/features2d.hpp	/^        float featureScaleMul;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
featureType	flann/miniflann.hpp	/^    int featureType;$/;"	m	class:cv::flann::Index	access:protected
featureType	objdetect/objdetect.hpp	/^        int featureType;$/;"	m	class:cv::CascadeClassifier::Data	access:public
feature_size_	flann/lsh_index.h	/^    unsigned int feature_size_;$/;"	m	class:cvflann::LshIndex	access:private
features	features2d/features2d.hpp	/^    vector<Feature> features;$/;"	m	class:cv::FernClassifier	access:protected
fernClassifier	objdetect/objdetect.hpp	/^    FernClassifier fernClassifier;$/;"	m	class:cv::PlanarObjectDetector	access:protected
fi	contrib/contrib.hpp	/^        CV_PROP_RW float	fi;$/;"	m	class:cv::StereoVar	access:public
file	core/core.hpp	/^    string file; \/\/\/< source file name where the error has occured$/;"	m	class:cv::Exception	access:public
filename	features2d/features2d.hpp	/^        string filename;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
fill	core/core.hpp	/^    void fill( InputOutputArray mat, int distType, InputArray a, InputArray b );$/;"	p	class:cv::RNG	access:public	signature:( InputOutputArray mat, int distType, InputArray a, InputArray b )
fillConvexPoly	core/core.hpp	/^CV_EXPORTS void fillConvexPoly(Mat& img, const Point* pts, int npts,$/;"	p	namespace:cv	signature:(Mat& img, const Point* pts, int npts, const Scalar& color, int lineType=8, int shift=0)
fillConvexPoly	core/core.hpp	/^CV_EXPORTS_W void fillConvexPoly(InputOutputArray img, InputArray points,$/;"	p	namespace:cv	signature:(InputOutputArray img, InputArray points, const Scalar& color, int lineType=8, int shift=0)
fillPoly	core/core.hpp	/^CV_EXPORTS void fillPoly(Mat& img, const Point** pts,$/;"	p	namespace:cv	signature:(Mat& img, const Point** pts, const int* npts, int ncontours, const Scalar& color, int lineType=8, int shift=0, Point offset=Point() )
fillPoly	core/core.hpp	/^CV_EXPORTS_W void fillPoly(InputOutputArray img, InputArrayOfArrays pts,$/;"	p	namespace:cv	signature:(InputOutputArray img, InputArrayOfArrays pts, const Scalar& color, int lineType=8, int shift=0, Point offset=Point() )
fill_xor_mask	flann/lsh_index.h	/^    void fill_xor_mask(lsh::BucketKey key, int lowest_index, unsigned int level,$/;"	f	class:cvflann::LshIndex	access:private	signature:(lsh::BucketKey key, int lowest_index, unsigned int level, std::vector<lsh::BucketKey>& xor_masks)
filter	gpu/gpu.hpp	/^            Ptr<FilterEngine_GPU> filter;$/;"	m	struct:cv::gpu::PyrDownBuf	access:private
filter	gpu/gpu.hpp	/^            Ptr<FilterEngine_GPU> filter;$/;"	m	struct:cv::gpu::PyrUpBuf	access:private
filter2D	gpu/gpu.hpp	/^        CV_EXPORTS void filter2D(const GpuMat& src, GpuMat& dst, int ddepth, const Mat& kernel, Point anchor=Point(-1,-1), Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, const Mat& kernel, Point anchor=Point(-1,-1), Stream& stream = Stream::Null())
filter2D	imgproc/imgproc.hpp	/^    Ptr<BaseFilter> filter2D;$/;"	m	class:cv::FilterEngine	access:public
filter2D	imgproc/imgproc.hpp	/^CV_EXPORTS_W void filter2D( InputArray src, OutputArray dst, int ddepth,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor=Point(-1,-1), double delta=0, int borderType=BORDER_DEFAULT )
filterByArea	features2d/features2d.hpp	/^      bool filterByArea;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
filterByCircularity	features2d/features2d.hpp	/^      bool filterByCircularity;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
filterByColor	features2d/features2d.hpp	/^      bool filterByColor;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
filterByConvexity	features2d/features2d.hpp	/^      bool filterByConvexity;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
filterByInertia	features2d/features2d.hpp	/^      bool filterByInertia;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
filterDX	gpu/gpu.hpp	/^            Ptr<FilterEngine_GPU> filterDX, filterDY;$/;"	m	struct:cv::gpu::CannyBuf	access:public
filterDY	gpu/gpu.hpp	/^            Ptr<FilterEngine_GPU> filterDX, filterDY;$/;"	m	struct:cv::gpu::CannyBuf	access:public
filterSpeckles	calib3d/calib3d.hpp	/^CV_EXPORTS_W void filterSpeckles( InputOutputArray img, double newVal, int maxSpeckleSize, double maxDiff,$/;"	p	namespace:cv	signature:( InputOutputArray img, double newVal, int maxSpeckleSize, double maxDiff, InputOutputArray buf=noArray() )
filterSpeckles	gpu/gpu.hpp	/^    CV_EXPORTS void filterSpeckles( Mat& img, uchar newVal, int maxSpeckleSize, uchar diffThreshold, Mat& buf);$/;"	p	namespace:cv	signature:( Mat& img, uchar newVal, int maxSpeckleSize, uchar diffThreshold, Mat& buf)
filters	objdetect/objdetect.hpp	/^	CvLSVMFilterObject** filters;$/;"	m	struct:CvLatentSvmDetector	access:public
finalize	features2d/features2d.hpp	/^    virtual void finalize(RNG& rng);$/;"	p	class:cv::FernClassifier	access:protected	signature:(RNG& rng)
finalize	features2d/features2d.hpp	/^  void finalize(size_t reduced_num_dim, int num_quant_bits);$/;"	p	class:cv::RandomizedTree	access:private	signature:(size_t reduced_num_dim, int num_quant_bits)
find	core/core.hpp	/^    template<typename _Tp> const _Tp* find(const int* idx, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, size_t* hashval=0) const
find	core/core.hpp	/^    template<typename _Tp> const _Tp* find(int i0, int i1, int i2, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0) const
find	core/core.hpp	/^    template<typename _Tp> const _Tp* find(int i0, int i1, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, size_t* hashval=0) const
find	core/core.hpp	/^    template<typename _Tp> const _Tp* find(int i0, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, size_t* hashval=0) const
find	core/mat.hpp	/^template<typename _Tp> inline const _Tp* SparseMat::find(const int* idx, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(const int* idx, size_t* hashval) const
find	core/mat.hpp	/^template<typename _Tp> inline const _Tp* SparseMat::find(int i0, int i1, int i2, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, int i2, size_t* hashval) const
find	core/mat.hpp	/^template<typename _Tp> inline const _Tp* SparseMat::find(int i0, int i1, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, size_t* hashval) const
find	core/mat.hpp	/^template<typename _Tp> inline const _Tp* SparseMat::find(int i0, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, size_t* hashval) const
find4QuadCornerSubpix	calib3d/calib3d.hpp	/^CV_EXPORTS bool find4QuadCornerSubpix(InputArray img, InputOutputArray corners, Size region_size);$/;"	p	namespace:cv	signature:(InputArray img, InputOutputArray corners, Size region_size)
findBlobs	features2d/features2d.hpp	/^  virtual void findBlobs(const cv::Mat &image, const cv::Mat &binaryImage, std::vector<Center> &centers) const;$/;"	p	class:cv::SimpleBlobDetector	access:protected	signature:(const cv::Mat &image, const cv::Mat &binaryImage, std::vector<Center> &centers) const
findChessboardCorners	calib3d/calib3d.hpp	/^CV_EXPORTS_W bool findChessboardCorners( InputArray image, Size patternSize,$/;"	p	namespace:cv	signature:( InputArray image, Size patternSize, OutputArray corners, int flags=CALIB_CB_ADAPTIVE_THRESH+ CALIB_CB_NORMALIZE_IMAGE )
findCirclesGrid	calib3d/calib3d.hpp	/^CV_EXPORTS bool findCirclesGrid( InputArray image, Size patternSize,$/;"	p	namespace:cv	signature:( InputArray image, Size patternSize, OutputArray centers, int flags=CALIB_CB_SYMMETRIC_GRID, const Ptr<FeatureDetector> &blobDetector = new SimpleBlobDetector())
findCirclesGridDefault	calib3d/calib3d.hpp	/^CV_EXPORTS_W bool findCirclesGridDefault( InputArray image, Size patternSize,$/;"	p	namespace:cv	signature:( InputArray image, Size patternSize, OutputArray centers, int flags=CALIB_CB_SYMMETRIC_GRID )
findContours	imgproc/imgproc.hpp	/^CV_EXPORTS void findContours( InputOutputArray image, OutputArrayOfArrays contours,$/;"	p	namespace:cv	signature:( InputOutputArray image, OutputArrayOfArrays contours, int mode, int method, Point offset=Point())
findContours	imgproc/imgproc.hpp	/^CV_EXPORTS_W void findContours( InputOutputArray image, OutputArrayOfArrays contours,$/;"	p	namespace:cv	signature:( InputOutputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset=Point())
findCoverageIndex	contrib/contrib.hpp	/^        int findCoverageIndex(double surfaceToCover, int defaultValue = 0);$/;"	p	class:CvAdaptiveSkinDetector::Histogram	access:protected	signature:(double surfaceToCover, int defaultValue = 0)
findCurveThresholds	contrib/contrib.hpp	/^        void findCurveThresholds(int &x1, int &x2, double percent = 0.05);$/;"	p	class:CvAdaptiveSkinDetector::Histogram	access:public	signature:(int &x1, int &x2, double percent = 0.05)
findDataMatrix	objdetect/objdetect.hpp	/^CV_EXPORTS void findDataMatrix(const Mat& image, std::vector<DataMatrixCode>& codes);$/;"	p	namespace:cv	signature:(const Mat& image, std::vector<DataMatrixCode>& codes)
findExactNN	flann/kmeans_index.h	/^    void findExactNN(KMeansNodePtr node, ResultSet<DistanceType>& result, const ElementType* vec)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNodePtr node, ResultSet<DistanceType>& result, const ElementType* vec)
findFundamentalMat	calib3d/calib3d.hpp	/^CV_EXPORTS Mat findFundamentalMat( InputArray points1, InputArray points2,$/;"	p	namespace:cv	signature:( InputArray points1, InputArray points2, OutputArray mask, int method=FM_RANSAC, double param1=3., double param2=0.99)
findFundamentalMat	calib3d/calib3d.hpp	/^CV_EXPORTS_W Mat findFundamentalMat( InputArray points1, InputArray points2,$/;"	p	namespace:cv	signature:( InputArray points1, InputArray points2, int method=FM_RANSAC, double param1=3., double param2=0.99, OutputArray mask=noArray())
findHomography	calib3d/calib3d.hpp	/^CV_EXPORTS Mat findHomography( InputArray srcPoints, InputArray dstPoints,$/;"	p	namespace:cv	signature:( InputArray srcPoints, InputArray dstPoints, OutputArray mask, int method=0, double ransacReprojThreshold=3)
findHomography	calib3d/calib3d.hpp	/^CV_EXPORTS_W Mat findHomography( InputArray srcPoints, InputArray dstPoints,$/;"	p	namespace:cv	signature:( InputArray srcPoints, InputArray dstPoints, int method=0, double ransacReprojThreshold=3, OutputArray mask=noArray())
findLargestObject	gpu/gpu.hpp	/^            bool findLargestObject;$/;"	m	class:cv::gpu::CascadeClassifier_GPU	access:public
findNN	flann/hierarchical_clustering_index.h	/^    void findNN(NodePtr node, ResultSet<DistanceType>& result, const ElementType* vec, int& checks, int maxChecks,$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:private	signature:(NodePtr node, ResultSet<DistanceType>& result, const ElementType* vec, int& checks, int maxChecks, Heap<BranchSt>* heap, std::vector<bool>& checked)
findNN	flann/kmeans_index.h	/^    void findNN(KMeansNodePtr node, ResultSet<DistanceType>& result, const ElementType* vec, int& checks, int maxChecks,$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNodePtr node, ResultSet<DistanceType>& result, const ElementType* vec, int& checks, int maxChecks, Heap<BranchSt>* heap)
findNearest	core/core.hpp	/^    CV_WRAP int findNearest(InputArray vec, int K, int Emax,$/;"	p	class:cv::KDTree	access:public	signature:(InputArray vec, int K, int Emax, OutputArray neighborsIdx, OutputArray neighbors=noArray(), OutputArray dist=noArray(), OutputArray labels=noArray()) const
findNearest	imgproc/imgproc.hpp	/^    CV_WRAP int findNearest(Point2f pt, CV_OUT Point2f* nearestPt=0);$/;"	p	class:cv::Subdiv2D	access:public	signature:(Point2f pt, CV_OUT Point2f* nearestPt=0)
findNeighbors	flann/autotuned_index.h	/^    virtual void findNeighbors(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)
findNeighbors	flann/composite_index.h	/^    void findNeighbors(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)$/;"	f	class:cvflann::CompositeIndex	access:public	signature:(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)
findNeighbors	flann/flann_base.hpp	/^    void findNeighbors(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)$/;"	f	class:cvflann::Index	access:public	signature:(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)
findNeighbors	flann/hierarchical_clustering_index.h	/^    void findNeighbors(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:public	signature:(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)
findNeighbors	flann/kdtree_index.h	/^    void findNeighbors(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)
findNeighbors	flann/kdtree_single_index.h	/^    void findNeighbors(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)
findNeighbors	flann/kmeans_index.h	/^    void findNeighbors(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)
findNeighbors	flann/linear_index.h	/^    void findNeighbors(ResultSet<DistanceType>& resultSet, const ElementType* vec, const SearchParams& \/*searchParams*\/)$/;"	f	class:cvflann::LinearIndex	access:public	signature:(ResultSet<DistanceType>& resultSet, const ElementType* vec, const SearchParams& )
findNeighbors	flann/lsh_index.h	/^    void findNeighbors(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& \/*searchParams*\/)$/;"	f	class:cvflann::LshIndex	access:public	signature:(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& )
findNeighbors	flann/nn_index.h	/^    virtual void findNeighbors(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams) = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:(ResultSet<DistanceType>& result, const ElementType* vec, const SearchParams& searchParams)
findOptimumSearchWindow	contrib/contrib.hpp	/^    void findOptimumSearchWindow(SearchWindow &searchWindow, IplImage *maskImage, IplImage *depthMap, int maxIteration, int resizeMethod, bool initDepth);$/;"	p	class:CvFuzzyMeanShiftTracker	access:private	signature:(SearchWindow &searchWindow, IplImage *maskImage, IplImage *depthMap, int maxIteration, int resizeMethod, bool initDepth)
findOrthoRange	core/core.hpp	/^    CV_WRAP void findOrthoRange(InputArray minBounds,$/;"	p	class:cv::KDTree	access:public	signature:(InputArray minBounds, InputArray maxBounds, OutputArray neighborsIdx, OutputArray neighbors=noArray(), OutputArray labels=noArray()) const
find_best_split	ml/ml.hpp	/^    virtual CvDTreeSplit* find_best_split( CvDTreeNode* n );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n )
find_best_split	ml/ml.hpp	/^    virtual CvDTreeSplit* find_best_split( CvDTreeNode* n );$/;"	p	class:CvForestTree	access:protected	signature:( CvDTreeNode* n )
find_gradient	ml/ml.hpp	/^    virtual void find_gradient( const int k = 0);$/;"	p	class:CvGBTrees	access:protected	signature:( const int k = 0)
find_nearest	flann/ground_truth.h	/^void find_nearest(const Matrix<typename Distance::ElementType>& dataset, typename Distance::ElementType* query, int* matches, int nn,$/;"	f	namespace:cvflann	signature:(const Matrix<typename Distance::ElementType>& dataset, typename Distance::ElementType* query, int* matches, int nn, int skip = 0, Distance distance = Distance())
find_nearest	ml/ml.hpp	/^    CV_WRAP virtual float find_nearest( const cv::Mat& samples, int k, CV_OUT cv::Mat& results,$/;"	p	class:CvKNearest	access:public	signature:( const cv::Mat& samples, int k, CV_OUT cv::Mat& results, CV_OUT cv::Mat& neighborResponses, CV_OUT cv::Mat& dists) const
find_nearest	ml/ml.hpp	/^    virtual float find_nearest( const CvMat* samples, int k, CV_OUT CvMat* results=0,$/;"	p	class:CvKNearest	access:public	signature:( const CvMat* samples, int k, CV_OUT CvMat* results=0, const float** neighbors=0, CV_OUT CvMat* neighborResponses=0, CV_OUT CvMat* dist=0 ) const
find_nearest	ml/ml.hpp	/^    virtual float find_nearest( const cv::Mat& samples, int k, cv::Mat* results=0,$/;"	p	class:CvKNearest	access:public	signature:( const cv::Mat& samples, int k, cv::Mat* results=0, const float** neighbors=0, cv::Mat* neighborResponses=0, cv::Mat* dist=0 ) const
find_neighbors_direct	ml/ml.hpp	/^    virtual void find_neighbors_direct( const CvMat* _samples, int k, int start, int end,$/;"	p	class:CvKNearest	access:public	signature:( const CvMat* _samples, int k, int start, int end, float* neighbor_responses, const float** neighbors, float* dist ) const
find_optimal_value	ml/ml.hpp	/^    virtual float find_optimal_value( const CvMat* _Idx );$/;"	p	class:CvGBTrees	access:protected	signature:( const CvMat* _Idx )
find_split_cat_class	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_class( CvDTreeNode* n, int vi,$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_split_cat_class	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_class( CvDTreeNode* n, int vi,$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_split_cat_class	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_class( CvDTreeNode* n, int vi,$/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_split_cat_reg	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_split_cat_reg	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_split_cat_reg	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_cat_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_split_ord_class	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_class( CvDTreeNode* n, int vi, $/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_split_ord_class	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_class( CvDTreeNode* n, int vi, $/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_split_ord_class	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_class( CvDTreeNode* n, int vi, $/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_split_ord_reg	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_split_ord_reg	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_split_ord_reg	ml/ml.hpp	/^    virtual CvDTreeSplit* find_split_ord_reg( CvDTreeNode* n, int vi, $/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* n, int vi, float init_quality = 0, CvDTreeSplit* _split = 0, uchar* ext_buf = 0 )
find_surrogate_split_cat	ml/ml.hpp	/^    virtual CvDTreeSplit* find_surrogate_split_cat( CvDTreeNode* n, int vi, uchar* ext_buf = 0 );$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, uchar* ext_buf = 0 )
find_surrogate_split_cat	ml/ml.hpp	/^    virtual CvDTreeSplit* find_surrogate_split_cat( CvDTreeNode* n, int vi, uchar* ext_buf = 0 );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, uchar* ext_buf = 0 )
find_surrogate_split_ord	ml/ml.hpp	/^    virtual CvDTreeSplit* find_surrogate_split_ord( CvDTreeNode* n, int vi, uchar* ext_buf = 0 );$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n, int vi, uchar* ext_buf = 0 )
find_surrogate_split_ord	ml/ml.hpp	/^    virtual CvDTreeSplit* find_surrogate_split_ord( CvDTreeNode* n, int vi, uchar* ext_buf = 0 );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n, int vi, uchar* ext_buf = 0 )
fineFunction	objdetect/objdetect.hpp	/^    float fineFunction[4];$/;"	m	struct:__anon197	access:public
first	core/core_c.h	/^    static CvModuleInfo* first;$/;"	m	struct:CvModule	access:public
first	core/core_c.h	/^    static CvTypeInfo* first;$/;"	m	struct:CvType	access:public
first	objdetect/objdetect.hpp	/^            int first;$/;"	m	struct:cv::CascadeClassifier::Data::Stage	access:public
firstEdge	imgproc/imgproc.hpp	/^        int firstEdge;$/;"	m	struct:cv::Subdiv2D::Vertex	access:public
firstOctave	features2d/features2d.hpp	/^        int firstOctave; \/\/ it is not used now (firstOctave == 0 always)$/;"	m	struct:cv::SIFT::CommonParams	access:public
first_level_	features2d/features2d.hpp	/^    unsigned int first_level_;$/;"	m	struct:cv::ORB::CommonParams	access:public
fitEllipse	imgproc/imgproc.hpp	/^CV_EXPORTS_W RotatedRect fitEllipse( InputArray points );$/;"	p	namespace:cv	signature:( InputArray points )
fitLine	imgproc/imgproc.hpp	/^CV_EXPORTS_W void fitLine( InputArray points, OutputArray line, int distType,$/;"	p	namespace:cv	signature:( InputArray points, OutputArray line, int distType, double param, double reps, double aeps )
fixedSize	core/core.hpp	/^    virtual bool fixedSize() const;$/;"	p	class:cv::_OutputArray	access:public	signature:() const
fixedType	core/core.hpp	/^    virtual bool fixedType() const;$/;"	p	class:cv::_OutputArray	access:public	signature:() const
fixp	legacy/legacy.hpp	/^    int* fixp; \/\/node with minimal disconnections$/;"	m	struct:CvCliqueFinder	access:public
fjac	contrib/contrib.hpp	/^        void (*fjac)(int i, int j, Mat& point_params, Mat& cam_params, Mat& A, Mat& B, void* data);$/;"	m	class:cv::LevMarqSparse	access:public
fl	core/types_c.h	/^        float* fl;$/;"	m	union:CvMat::__anon151	access:public
fl	core/types_c.h	/^        float* fl;$/;"	m	union:CvMatND::__anon154	access:public
fl	ml/ml.hpp	/^        float** fl;$/;"	m	union:CvVectors::__anon70	access:public
flConfidence	legacy/legacy.hpp	/^    float* flConfidence;    \/* Confidence for each Sample            *\/$/;"	m	struct:CvConDensation	access:public
flCumulative	legacy/legacy.hpp	/^    float* flCumulative;    \/* Cumulative confidence                 *\/$/;"	m	struct:CvConDensation	access:public
flNewSamples	legacy/legacy.hpp	/^    float** flNewSamples;   \/* temporary array of the Sample Vectors *\/$/;"	m	struct:CvConDensation	access:public
flSamples	legacy/legacy.hpp	/^    float** flSamples;      \/* arr of the Sample Vectors             *\/$/;"	m	struct:CvConDensation	access:public
flags	contrib/contrib.hpp	/^        CV_PROP_RW int		flags;$/;"	m	class:cv::StereoVar	access:public
flags	core/core.hpp	/^    int flags;$/;"	m	class:cv::Mat	access:public
flags	core/core.hpp	/^    int flags;$/;"	m	class:cv::SparseMat	access:public
flags	core/core.hpp	/^    int flags;$/;"	m	class:cv::_InputArray	access:public
flags	core/mat.hpp	/^    int flags;$/;"	m	class:cv::MatExpr	access:public
flags	core/types_c.h	/^    int flags;$/;"	m	struct:CvTypeInfo	access:public
flags	features2d/features2d.hpp	/^    int flags;$/;"	m	class:cv::BOWKMeansTrainer	access:protected
flags	gpu/gpu.hpp	/^            int flags;$/;"	m	class:cv::gpu::CudaMem	access:public
flags	gpu/gpumat.hpp	/^        int flags;$/;"	m	class:cv::gpu::GpuMat	access:public
flags	objdetect/objdetect.hpp	/^    int  flags;$/;"	m	struct:CvHaarClassifierCascade	access:public
flann	flann/flann.hpp	/^namespace flann$/;"	n	namespace:cv
flann	flann/miniflann.hpp	/^namespace flann$/;"	n	namespace:cv
flannIndex	features2d/features2d.hpp	/^    Ptr<flann::Index> flannIndex;$/;"	m	class:cv::FlannBasedMatcher	access:protected
flann_algorithm_t	flann/defines.h	/^enum flann_algorithm_t$/;"	g	namespace:cvflann
flann_centers_init_t	flann/defines.h	/^enum flann_centers_init_t$/;"	g	namespace:cvflann
flann_datatype_t	flann/defines.h	/^enum flann_datatype_t$/;"	g	namespace:cvflann
flann_distance_t	flann/defines.h	/^enum flann_distance_t$/;"	g	namespace:cvflann
flann_distance_type	flann/flann.hpp	/^    CV_EXPORTS flann_distance_t flann_distance_type();$/;"	p	namespace:cvflann	signature:()
flann_log_level_t	flann/defines.h	/^enum flann_log_level_t$/;"	g	namespace:cvflann
flip	core/core.hpp	/^CV_EXPORTS_W void flip(InputArray src, OutputArray dst, int flipCode);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, int flipCode)
flip	gpu/gpu.hpp	/^        CV_EXPORTS void flip(const GpuMat& a, GpuMat& b, int flipCode, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, GpuMat& b, int flipCode, Stream& stream = Stream::Null())
floodFill	imgproc/imgproc.hpp	/^CV_EXPORTS int floodFill( InputOutputArray image,$/;"	p	namespace:cv	signature:( InputOutputArray image, Point seedPoint, Scalar newVal, CV_OUT Rect* rect=0, Scalar loDiff=Scalar(), Scalar upDiff=Scalar(), int flags=4 )
floodFill	imgproc/imgproc.hpp	/^CV_EXPORTS_W int floodFill( InputOutputArray image, InputOutputArray mask,$/;"	p	namespace:cv	signature:( InputOutputArray image, InputOutputArray mask, Point seedPoint, Scalar newVal, CV_OUT Rect* rect=0, Scalar loDiff=Scalar(), Scalar upDiff=Scalar(), int flags=4 )
fmt	core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon125
fmt	core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon126
fmt	core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon127
fmt	core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon128
fmt	core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon129
fmt	core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon130
fmt	core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon131
fmt	core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon132
fmt	core/core.hpp	/^           fmt = ((channels-1)<<8) + DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon133
fmt	core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon116
fmt	core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon117
fmt	core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon118
fmt	core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon119
fmt	core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon120
fmt	core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon121
fmt	core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon122
fmt	core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon123
fmt	core/core.hpp	/^           fmt=DataDepth<channel_type>::fmt,$/;"	e	enum:cv::DataType::__anon124
fmt	core/core.hpp	/^    enum { generic_type = 1, depth = -1, channels = 1, fmt=0,$/;"	e	enum:cv::DataType::__anon115
fmt	core/core.hpp	/^template<> class DataDepth<bool> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	e	enum:cv::DataDepth::__anon102
fmt	core/core.hpp	/^template<> class DataDepth<char> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	e	enum:cv::DataDepth::__anon105
fmt	core/core.hpp	/^template<> class DataDepth<double> { public: enum { value = CV_64F, fmt=(int)'d' }; };$/;"	e	enum:cv::DataDepth::__anon111
fmt	core/core.hpp	/^template<> class DataDepth<float> { public: enum { value = CV_32F, fmt=(int)'f' }; };$/;"	e	enum:cv::DataDepth::__anon110
fmt	core/core.hpp	/^template<> class DataDepth<int> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	e	enum:cv::DataDepth::__anon108
fmt	core/core.hpp	/^template<> class DataDepth<schar> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	e	enum:cv::DataDepth::__anon104
fmt	core/core.hpp	/^template<> class DataDepth<short> { public: enum { value = CV_16S, fmt=(int)'s' }; };$/;"	e	enum:cv::DataDepth::__anon107
fmt	core/core.hpp	/^template<> class DataDepth<uchar> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	e	enum:cv::DataDepth::__anon103
fmt	core/core.hpp	/^template<> class DataDepth<unsigned> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	e	enum:cv::DataDepth::__anon109
fmt	core/core.hpp	/^template<> class DataDepth<ushort> { public: enum { value = CV_16U, fmt=(int)'w' }; };$/;"	e	enum:cv::DataDepth::__anon106
fmt	core/core.hpp	/^template<typename _Tp> class DataDepth<_Tp*> { public: enum { value = CV_USRTYPE1, fmt=(int)'r' }; };$/;"	e	enum:cv::DataDepth::__anon112
fmt	core/operations.hpp	/^    const Formatter* fmt;$/;"	m	struct:cv::Formatted	access:public
fn_2d	core/internal.hpp	/^    void*   fn_2d[CV_DEPTH_MAX*4];$/;"	m	struct:CvBigFuncTable	access:public
fn_2d	core/internal.hpp	/^    void*   fn_2d[CV_DEPTH_MAX];$/;"	m	struct:CvFuncTable	access:public
focal_length	legacy/legacy.hpp	/^    float focal_length[2];$/;"	m	struct:__anon188	access:public
fontQt	highgui/highgui.hpp	/^CV_EXPORTS CvFont fontQt(const string& nameFont, int pointSize=-1,$/;"	p	namespace:cv	signature:(const string& nameFont, int pointSize=-1, Scalar color=Scalar::all(0), int weight=CV_FONT_NORMAL, int style=CV_STYLE_NORMAL, int spacing=0)
font_face	core/core_c.h	/^    int         font_face; 		\/\/Qt: bool italic         \/* =CV_FONT_* *\/$/;"	m	struct:CvFont	access:public
forest	ml/ml.hpp	/^    CvRTrees* forest;$/;"	m	class:CvForestTree	access:protected
format	core/core.hpp	/^CV_EXPORTS string format( const char* fmt, ... );$/;"	p	namespace:cv	signature:( const char* fmt, ... )
format	core/operations.hpp	/^static inline Formatted format(const Mat& mtx, const char* fmt,$/;"	f	namespace:cv	signature:(const Mat& mtx, const char* fmt, const vector<int>& params=vector<int>())
format	core/operations.hpp	/^template<typename _Tp> static inline Formatted format(const vector<Point3_<_Tp> >& vec,$/;"	f	namespace:cv	signature:(const vector<Point3_<_Tp> >& vec, const char* fmt, const vector<int>& params=vector<int>())
format	core/operations.hpp	/^template<typename _Tp> static inline Formatted format(const vector<Point_<_Tp> >& vec,$/;"	f	namespace:cv	signature:(const vector<Point_<_Tp> >& vec, const char* fmt, const vector<int>& params=vector<int>())
formatMessage	core/core.hpp	/^    void formatMessage();$/;"	p	class:cv::Exception	access:public	signature:()
frameSize	video/background_segm.hpp	/^    Size frameSize;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
frameSize	video/background_segm.hpp	/^    Size frameSize;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
frameType	video/background_segm.hpp	/^    int frameType;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
frameType	video/background_segm.hpp	/^    int frameType;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
framesAccepted	legacy/legacy.hpp	/^    int     framesAccepted;$/;"	m	class:CvCalibFilter	access:protected
framesTotal	legacy/legacy.hpp	/^    int     framesTotal;$/;"	m	class:CvCalibFilter	access:protected
free	flann/matrix.h	/^    FLANN_DEPRECATED void free()$/;"	f	class:cvflann::Matrix	access:public	signature:()
freeList	core/core.hpp	/^        size_t freeList;$/;"	m	struct:cv::SparseMat::Hdr	access:public
freeList	video/background_segm.hpp	/^    CvBGCodeBookElem* freeList;$/;"	m	struct:CvBGCodeBookModel	access:public
freeMemory	gpu/gpu.hpp	/^            size_t freeMemory() const;$/;"	p	class:cv::gpu::DeviceInfo	access:public	signature:() const
freePoint	imgproc/imgproc.hpp	/^    int freePoint;$/;"	m	class:cv::Subdiv2D	access:protected
freePosteriors	features2d/features2d.hpp	/^  void freePosteriors(int which);    \/\/ which: 1=posteriors_, 2=posteriors2_, 3=both$/;"	p	class:cv::RandomizedTree	access:private	signature:(int which)
freeQEdge	imgproc/imgproc.hpp	/^    int freeQEdge;$/;"	m	class:cv::Subdiv2D	access:protected
free_centers	flann/kmeans_index.h	/^    void free_centers(KMeansNodePtr node)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNodePtr node)
free_coef	gpu/gpu.hpp	/^            float free_coef;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
free_node	ml/ml.hpp	/^    virtual void free_node( CvDTreeNode* node );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* node )
free_node_data	ml/ml.hpp	/^    virtual void free_node_data( CvDTreeNode* node );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* node )
free_prune_data	ml/ml.hpp	/^    virtual void free_prune_data(bool cut_tree);$/;"	p	class:CvDTree	access:protected	signature:(bool cut_tree)
free_space	core/types_c.h	/^    int free_space;               \/* Remaining free space in current block.   *\/$/;"	m	struct:CvMemStorage	access:public
free_space	core/types_c.h	/^    int free_space;$/;"	m	struct:CvMemStoragePos	access:public
free_train_data	ml/ml.hpp	/^    virtual void free_train_data();$/;"	p	struct:CvDTreeTrainData	access:public	signature:()
free_train_test_idx	ml/ml.hpp	/^    void free_train_test_idx();$/;"	p	class:CvMLData	access:protected	signature:()
free_tree	ml/ml.hpp	/^    virtual void free_tree();$/;"	p	class:CvDTree	access:protected	signature:()
fromStringNumber	core/core.hpp	/^     _Tp fromStringNumber(const std::string& str);\/\/the default conversion function for numbers$/;"	p	class:cv::CommandLineParser	access:protected	signature:(const std::string& str)
fromUtf16	core/core.hpp	/^CV_EXPORTS string fromUtf16(const WString& str);$/;"	p	namespace:cv	signature:(const WString& str)
front	core/core.hpp	/^    _Tp& front();$/;"	p	class:cv::Seq	access:public	signature:()
front	core/core.hpp	/^    const _Tp& front() const;$/;"	p	class:cv::Seq	access:public	signature:() const
front	core/operations.hpp	/^    _Tp& front() { CV_DbgAssert(!empty()); return hdr.data[0]; }$/;"	f	class:cv::Vector	access:public	signature:()
front	core/operations.hpp	/^    const _Tp& front() const { CV_DbgAssert(!empty()); return hdr.data[0]; }$/;"	f	class:cv::Vector	access:public	signature:() const
front	core/operations.hpp	/^template<typename _Tp> inline _Tp& Seq<_Tp>::front()$/;"	f	class:cv::Seq	signature:()
front	core/operations.hpp	/^template<typename _Tp> inline const _Tp& Seq<_Tp>::front() const$/;"	f	class:cv::Seq	signature:() const
fs	core/core.hpp	/^    Ptr<CvFileStorage> fs; \/\/!< the underlying C FileStorage structure$/;"	m	class:cv::FileStorage	access:public
fs	core/core.hpp	/^    const CvFileStorage* fs;$/;"	m	class:cv::FileNode	access:public
fs	core/core.hpp	/^    const CvFileStorage* fs;$/;"	m	class:cv::FileNodeIterator	access:public
fs	core/core_c.h	/^CVAPI(void) cvEndWriteStruct( CvFileStorage* fs );$/;"	v
fs	core/core_c.h	/^CVAPI(void) cvReleaseFileStorage( CvFileStorage** fs );$/;"	v
fs	core/core_c.h	/^CVAPI(void) cvStartNextStream( CvFileStorage* fs );$/;"	v
fs	core/operations.hpp	/^    FileStorage* fs;$/;"	m	class:cv::VecWriterProxy	access:public
fs	core/operations.hpp	/^    FileStorage* fs;$/;"	m	class:cv::WriteStructContext	access:public
full	flann/result_set.h	/^    bool full() const$/;"	f	class:cvflann::KNNResultSet	access:public	signature:() const
full	flann/result_set.h	/^    bool full() const$/;"	f	class:cvflann::KNNSimpleResultSet	access:public	signature:() const
full	flann/result_set.h	/^    bool full() const$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:() const
full	flann/result_set.h	/^    inline bool full() const$/;"	f	class:cvflann::RadiusUniqueResultSet	access:public	signature:() const
full	flann/result_set.h	/^    inline bool full() const$/;"	f	class:cvflann::UniqueResultSet	access:public	signature:() const
full	flann/result_set.h	/^    virtual bool full() const = 0;$/;"	p	class:cvflann::ResultSet	access:public	signature:() const
fullDP	calib3d/calib3d.hpp	/^    CV_PROP_RW bool fullDP;$/;"	m	class:cv::StereoSGBM	access:public
func	contrib/contrib.hpp	/^        void (*func)(int i, int j, Mat& point_params, Mat& cam_params, Mat& estim, void* data);$/;"	m	class:cv::LevMarqSparse	access:public
func	core/core.hpp	/^    string func; \/\/\/< function name. Available only when the compiler supports __func__ macro$/;"	m	class:cv::Exception	access:public
func_addr	core/types_c.h	/^    void** func_addr;$/;"	m	struct:CvPluginFuncInfo	access:public
func_names	core/types_c.h	/^    const char* func_names;$/;"	m	struct:CvPluginFuncInfo	access:public
func_tab	core/types_c.h	/^    CvPluginFuncInfo* func_tab;$/;"	m	struct:CvModuleInfo	access:public
fundMatr	legacy/legacy.hpp	/^    float fundMatr[9]; \/* fundamental matrix *\/$/;"	m	struct:CvStereoCamera	access:public
fuzzyController	contrib/contrib.hpp	/^        CvFuzzyController fuzzyController;$/;"	m	class:CvFuzzyMeanShiftTracker::FuzzyResizer	access:private
fuzzyInput1	contrib/contrib.hpp	/^    CvFuzzyCurve *fuzzyInput1, *fuzzyInput2;$/;"	m	class:CvFuzzyRule	access:private
fuzzyInput2	contrib/contrib.hpp	/^    CvFuzzyCurve *fuzzyInput1, *fuzzyInput2;$/;"	m	class:CvFuzzyRule	access:private
fuzzyOutput	contrib/contrib.hpp	/^    CvFuzzyCurve *fuzzyOutput;$/;"	m	class:CvFuzzyRule	access:private
fuzzyResizer	contrib/contrib.hpp	/^        FuzzyResizer *fuzzyResizer;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
g_point	video/background_segm.hpp	/^    CvGaussBGPoint*            g_point;    $/;"	m	struct:CvGaussBGModel	access:public
g_values	video/background_segm.hpp	/^    CvGaussBGValues* g_values;$/;"	m	struct:CvGaussBGPoint	access:public
gain	video/tracking.hpp	/^    CvMat* gain;                \/* Kalman gain matrix (K(k)):$/;"	m	struct:CvKalman	access:public
gain	video/tracking.hpp	/^    Mat gain;               \/\/!< Kalman gain matrix (K(k)): K(k)=P'(k)*Ht*inv(H*P'(k)*Ht+R)$/;"	m	class:cv::KalmanFilter	access:public
gamma	contrib/contrib.hpp	/^        float gamma;$/;"	m	class:cv::SpinImageModel	access:public
gamma	ml/ml.hpp	/^    CV_PROP_RW double      gamma;  \/\/ for poly\/rbf\/sigmoid$/;"	m	struct:CvSVMParams	access:public
gammaCorrection	objdetect/objdetect.hpp	/^    CV_PROP bool gammaCorrection;$/;"	m	struct:cv::HOGDescriptor	access:public
gamma_correction	gpu/gpu.hpp	/^            bool gamma_correction;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
gaussian	core/core.hpp	/^    double gaussian(double sigma);$/;"	p	class:cv::RNG	access:public	signature:(double sigma)
gcd	core/operations.hpp	/^template<typename _Tp> static inline _Tp gcd(_Tp a, _Tp b)$/;"	f	namespace:cv	signature:(_Tp a, _Tp b)
gemm	core/core.hpp	/^CV_EXPORTS_W void gemm(InputArray src1, InputArray src2, double alpha,$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, double alpha, InputArray src3, double gamma, OutputArray dst, int flags=0)
generateRandomTransform	features2d/features2d.hpp	/^    void generateRandomTransform(Point2f srcCenter, Point2f dstCenter,$/;"	p	class:cv::PatchGenerator	access:public	signature:(Point2f srcCenter, Point2f dstCenter, CV_OUT Mat& transform, RNG& rng, bool inverse=false) const
generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon116
generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon117
generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon118
generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon119
generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon120
generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon121
generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon122
generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon123
generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 1,$/;"	e	enum:cv::DataType::__anon124
generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon126
generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon127
generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon128
generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon130
generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 2,$/;"	e	enum:cv::DataType::__anon133
generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 3,$/;"	e	enum:cv::DataType::__anon129
generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon131
generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = 4,$/;"	e	enum:cv::DataType::__anon132
generic_type	core/core.hpp	/^    enum { generic_type = 0, depth = DataDepth<channel_type>::value, channels = cn,$/;"	e	enum:cv::DataType::__anon125
generic_type	core/core.hpp	/^    enum { generic_type = 1, depth = -1, channels = 1, fmt=0,$/;"	e	enum:cv::DataType::__anon115
geometricConsistency	contrib/contrib.hpp	/^        static float geometricConsistency(const Point3f& pointScene1, const Point3f& normalScene1,$/;"	p	class:cv::SpinImageModel	access:public	signature:(const Point3f& pointScene1, const Point3f& normalScene1, const Point3f& pointModel1, const Point3f& normalModel1, const Point3f& pointScene2, const Point3f& normalScene2, const Point3f& pointModel2, const Point3f& normalModel2)
get	core/core.hpp	/^    _Tp get(const std::string& name, bool space_delete=true)$/;"	f	class:cv::CommandLineParser	access:public	signature:(const std::string& name, bool space_delete=true)
get	core/core.hpp	/^bool CommandLineParser::get<bool>(const std::string& name, bool space_delete);$/;"	p	class:cv::CommandLineParser	signature:(const std::string& name, bool space_delete)
get	core/operations.hpp	/^    static const Formatter* get(const char* fmt="");$/;"	p	class:cv::Formatter	access:public	signature:(const char* fmt=)
get	highgui/highgui.hpp	/^    CV_WRAP virtual double get(int propId);$/;"	p	class:cv::VideoCapture	access:public	signature:(int propId)
getAffineTransform	imgproc/imgproc.hpp	/^CV_EXPORTS Mat getAffineTransform( const Point2f src[], const Point2f dst[] );$/;"	p	namespace:cv	signature:( const Point2f src[], const Point2f dst[] )
getAffineTransform	imgproc/imgproc.hpp	/^CV_EXPORTS_W Mat getAffineTransform( InputArray src, InputArray dst );$/;"	p	namespace:cv	signature:( InputArray src, InputArray dst )
getAlgorithm	flann/miniflann.hpp	/^    CV_WRAP cvflann::flann_algorithm_t getAlgorithm() const;$/;"	p	class:cv::flann::Index	access:public	signature:() const
getAll	flann/miniflann.hpp	/^    void getAll(std::vector<std::string>& names,$/;"	p	struct:cv::flann::IndexParams	access:public	signature:(std::vector<std::string>& names, std::vector<int>& types, std::vector<std::string>& strValues, std::vector<double>& numValues) const
getAllocatorsAlignment	gpu/NCV.hpp	/^    Ncv32u getAllocatorsAlignment() const$/;"	f	class:NCVMatrixAlloc	access:public	signature:() const
getAllocatorsAlignment	gpu/NCV.hpp	/^    Ncv32u getAllocatorsAlignment() const$/;"	f	class:NCVVectorAlloc	access:public	signature:() const
getBackgroundImage	video/background_segm.hpp	/^    virtual void getBackgroundImage(OutputArray backgroundImage) const;$/;"	p	class:cv::BackgroundSubtractor	access:public	signature:(OutputArray backgroundImage) const
getBackgroundImage	video/background_segm.hpp	/^    virtual void getBackgroundImage(OutputArray backgroundImage) const;$/;"	p	class:cv::BackgroundSubtractorMOG2	access:public	signature:(OutputArray backgroundImage) const
getBlockHistogramSize	gpu/gpu.hpp	/^            size_t getBlockHistogramSize() const;$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:() const
getBoxFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseFilter_GPU> getBoxFilter_GPU(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1, -1));$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1, -1))
getBucketFromKey	flann/lsh_table.h	/^    inline const Bucket* getBucketFromKey(BucketKey key) const$/;"	f	class:cvflann::lsh::LshTable	access:public	signature:(BucketKey key) const
getBuffer	gpu/gpu.hpp	/^			static GpuMat getBuffer(const Size& sz, int type, GpuMat& buf);$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:(const Size& sz, int type, GpuMat& buf)
getBuffer	gpu/gpu.hpp	/^			static GpuMat getBuffer(int rows, int cols, int type, GpuMat& buf);$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:(int rows, int cols, int type, GpuMat& buf)
getCPUTickCount	core/core.hpp	/^CV_EXPORTS_W int64 getCPUTickCount();$/;"	p	namespace:cv	signature:()
getCenterOrdering	flann/kmeans_index.h	/^    void getCenterOrdering(KMeansNodePtr node, const ElementType* q, int* sort_indices)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNodePtr node, const ElementType* q, int* sort_indices)
getCentre	contrib/contrib.hpp	/^    double getCentre();$/;"	p	class:CvFuzzyCurve	access:public	signature:()
getClassCount	features2d/features2d.hpp	/^    int getClassCount() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
getClassifier	objdetect/objdetect.hpp	/^    const FernClassifier& getClassifier() const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:() const
getClassifierSize	gpu/gpu.hpp	/^            Size getClassifierSize() const;$/;"	p	class:cv::gpu::CascadeClassifier_GPU	access:public	signature:() const
getClusterCenters	flann/kmeans_index.h	/^    int getClusterCenters(Matrix<DistanceType>& centers)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(Matrix<DistanceType>& centers)
getColumnSumFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseColumnFilter> getColumnSumFilter( int sumType, int dstType,$/;"	p	namespace:cv	signature:( int sumType, int dstType, int ksize, int anchor=-1, double scale=1)
getColumnSumFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseColumnFilter_GPU> getColumnSumFilter_GPU(int sumType, int dstType, int ksize, int anchor = -1);$/;"	p	namespace:cv::gpu	signature:(int sumType, int dstType, int ksize, int anchor = -1)
getCommonParams	features2d/features2d.hpp	/^    CommonParams getCommonParams () const;$/;"	p	class:cv::SIFT	access:public	signature:() const
getCompressionMethod	features2d/features2d.hpp	/^    int getCompressionMethod() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
getConvertElem	core/core.hpp	/^CV_EXPORTS ConvertData getConvertElem(int fromType, int toType);$/;"	p	namespace:cv	signature:(int fromType, int toType)
getConvertScaleElem	core/core.hpp	/^CV_EXPORTS ConvertScaleData getConvertScaleElem(int fromType, int toType);$/;"	p	namespace:cv	signature:(int fromType, int toType)
getCounter	contrib/contrib.hpp	/^        int64 getCounter() const;$/;"	p	class:cv::TickMeter	access:public	signature:() const
getCovs	ml/ml.hpp	/^    CV_WRAP void getCovs(CV_OUT std::vector<cv::Mat>& covs)      const;$/;"	p	class:CvEM	access:public	signature:(CV_OUT std::vector<cv::Mat>& covs) const
getCudaEnabledDeviceCount	gpu/gpu.hpp	/^        CV_EXPORTS int getCudaEnabledDeviceCount();$/;"	p	namespace:cv::gpu	signature:()
getDaimlerPeopleDetector	objdetect/objdetect.hpp	/^	CV_WRAP static vector<float> getDaimlerPeopleDetector();$/;"	p	struct:cv::HOGDescriptor	access:public	signature:()
getData	core/core.hpp	/^    static _Tp getData(const std::string& str)$/;"	f	class:cv::CommandLineParser	access:protected	signature:(const std::string& str)
getData	features2d/features2d.hpp	/^inline uchar* getData(IplImage* image)$/;"	f	namespace:cv	signature:(IplImage* image)
getDefaultNewCameraMatrix	imgproc/imgproc.hpp	/^CV_EXPORTS_W Mat getDefaultNewCameraMatrix( InputArray cameraMatrix, Size imgsize=Size(),$/;"	p	namespace:cv	signature:( InputArray cameraMatrix, Size imgsize=Size(), bool centerPrincipalPoint=false )
getDefaultObjectName	core/core.hpp	/^    static string getDefaultObjectName(const string& filename);$/;"	p	class:cv::FileStorage	access:public	signature:(const string& filename)
getDefaultPeopleDetector	gpu/gpu.hpp	/^            static vector<float> getDefaultPeopleDetector();$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:()
getDefaultPeopleDetector	objdetect/objdetect.hpp	/^    CV_WRAP static vector<float> getDefaultPeopleDetector();$/;"	p	struct:cv::HOGDescriptor	access:public	signature:()
getDerivKernels	imgproc/imgproc.hpp	/^CV_EXPORTS_W void getDerivKernels( OutputArray kx, OutputArray ky,$/;"	p	namespace:cv	signature:( OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize=false, int ktype=CV_32F )
getDescriptor	features2d/features2d.hpp	/^        const Mat getDescriptor( int globalDescIdx ) const;$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:( int globalDescIdx ) const
getDescriptor	features2d/features2d.hpp	/^        const Mat getDescriptor( int imgIdx, int localDescIdx ) const;$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:( int imgIdx, int localDescIdx ) const
getDescriptorParams	features2d/features2d.hpp	/^    DescriptorParams getDescriptorParams () const;$/;"	p	class:cv::SIFT	access:public	signature:() const
getDescriptorSize	contrib/contrib.hpp	/^        size_t getDescriptorSize() const;$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:() const
getDescriptorSize	gpu/gpu.hpp	/^            size_t getDescriptorSize() const;$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:() const
getDescriptorSize	objdetect/objdetect.hpp	/^    CV_WRAP size_t getDescriptorSize() const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:() const
getDescriptors	features2d/features2d.hpp	/^        const Mat& getDescriptors() const;$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:() const
getDescriptors	features2d/features2d.hpp	/^    const vector<Mat>& getDescriptors() const;$/;"	p	class:cv::BOWTrainer	access:public	signature:() const
getDescriptors	gpu/gpu.hpp	/^            void getDescriptors(const GpuMat& img, Size win_stride, $/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:(const GpuMat& img, Size win_stride, GpuMat& descriptors, int descr_format=DESCR_FORMAT_COL_BY_COL)
getDetector	objdetect/objdetect.hpp	/^    const LDetector& getDetector() const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:() const
getDetectorParams	features2d/features2d.hpp	/^    DetectorParams getDetectorParams () const;$/;"	p	class:cv::SIFT	access:public	signature:() const
getDevice	gpu/gpu.hpp	/^        CV_EXPORTS int getDevice();$/;"	p	namespace:cv::gpu	signature:()
getDistance	flann/miniflann.hpp	/^    CV_WRAP cvflann::flann_distance_t getDistance() const;$/;"	p	class:cv::flann::Index	access:public	signature:() const
getDistanceToBorder	flann/kmeans_index.h	/^    DistanceType getDistanceToBorder(DistanceType* p, DistanceType* c, DistanceType* q)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(DistanceType* p, DistanceType* c, DistanceType* q)
getDouble	flann/miniflann.hpp	/^    double getDouble(const std::string& key, double defaultVal=-1) const;$/;"	p	struct:cv::flann::IndexParams	access:public	signature:(const std::string& key, double defaultVal=-1) const
getEdge	imgproc/imgproc.hpp	/^    CV_WRAP int getEdge( int edge, int nextEdgeType ) const;$/;"	p	class:cv::Subdiv2D	access:public	signature:( int edge, int nextEdgeType ) const
getEdgeList	imgproc/imgproc.hpp	/^    CV_WRAP void getEdgeList(CV_OUT vector<Vec4f>& edgeList) const;$/;"	p	class:cv::Subdiv2D	access:public	signature:(CV_OUT vector<Vec4f>& edgeList) const
getElemSize	core/core.hpp	/^static inline size_t getElemSize(int type) { return CV_ELEM_SIZE(type); }$/;"	f	namespace:cv	signature:(int type)
getExactNeighbors	flann/kdtree_index.h	/^    void getExactNeighbors(ResultSet<DistanceType>& result, const ElementType* vec, float epsError)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(ResultSet<DistanceType>& result, const ElementType* vec, float epsError)
getFeatureType	objdetect/objdetect.hpp	/^    int getFeatureType() const;$/;"	p	class:cv::CascadeClassifier	access:public	signature:() const
getFeatureType	objdetect/objdetect.hpp	/^    virtual int getFeatureType() const;$/;"	p	class:cv::FeatureEvaluator	access:public	signature:() const
getFirstTopLevelNode	core/core.hpp	/^    CV_WRAP FileNode getFirstTopLevelNode() const;$/;"	p	class:cv::FileStorage	access:public	signature:() const
getFirstTopLevelNode	core/operations.hpp	/^inline FileNode FileStorage::getFirstTopLevelNode() const$/;"	f	class:cv::FileStorage	signature:() const
getFloatSignature	features2d/features2d.hpp	/^  void getFloatSignature(IplImage *patch, float *sig) const { getSignature(patch, sig); }$/;"	f	class:cv::RTreeClassifier	access:public	signature:(IplImage *patch, float *sig) const
getGaussianKernel	imgproc/imgproc.hpp	/^CV_EXPORTS_W Mat getGaussianKernel( int ksize, double sigma, int ktype=CV_64F );$/;"	p	namespace:cv	signature:( int ksize, double sigma, int ktype=CV_64F )
getGridSize	contrib/contrib.hpp	/^        Size getGridSize( Size imgsize, Size winStride ) const;$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:( Size imgsize, Size winStride ) const
getImage	features2d/features2d.hpp	/^        const Mat& getImage( int imgIdx ) const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( int imgIdx ) const
getImages	features2d/features2d.hpp	/^        const vector<Mat>& getImages() const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:() const
getIndex	features2d/features2d.hpp	/^  int getIndex(uchar* patch_data) const;$/;"	p	class:cv::RandomizedTree	access:private	signature:(uchar* patch_data) const
getIndex	flann/flann_base.hpp	/^    FLANN_DEPRECATED NNIndex<Distance>* getIndex()$/;"	f	class:cvflann::Index	access:public	signature:()
getIndexParameters	flann/flann.hpp	/^        FLANN_DEPRECATED const ::cvflann::IndexParams* getIndexParameters() $/;"	f	class:cv::flann::Index_	access:public	signature:()
getIndexParameters	flann/flann.hpp	/^        FLANN_DEPRECATED const ::cvflann::IndexParams* getIndexParameters() { return nnIndex->getIndexParameters(); }$/;"	f	class:cv::flann::GenericIndex	access:public	signature:()
getIndexParameters	flann/flann_base.hpp	/^    FLANN_DEPRECATED  const IndexParams* getIndexParameters()$/;"	f	class:cvflann::Index	access:public	signature:()
getInt	flann/miniflann.hpp	/^    int getInt(const std::string& key, int defaultVal=-1) const;$/;"	p	struct:cv::flann::IndexParams	access:public	signature:(const std::string& key, int defaultVal=-1) const
getKernelType	imgproc/imgproc.hpp	/^CV_EXPORTS int getKernelType(InputArray kernel, Point anchor);$/;"	p	namespace:cv	signature:(InputArray kernel, Point anchor)
getKey	flann/lsh_table.h	/^    size_t getKey(const ElementType* \/*feature*\/) const$/;"	f	class:cvflann::lsh::LshTable	access:public	signature:(const ElementType* ) const
getKey	flann/lsh_table.h	/^inline size_t LshTable<unsigned char>::getKey(const unsigned char* feature) const$/;"	f	class:cvflann::lsh::LshTable	signature:(const unsigned char* feature) const
getKeyPoint	features2d/features2d.hpp	/^        const KeyPoint& getKeyPoint( int globalPointIdx ) const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( int globalPointIdx ) const
getKeyPoint	features2d/features2d.hpp	/^        const KeyPoint& getKeyPoint( int imgIdx, int localPointIdx ) const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( int imgIdx, int localPointIdx ) const
getKeypoints	features2d/features2d.hpp	/^        const vector<KeyPoint>& getKeypoints( int imgIdx ) const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( int imgIdx ) const
getKeypoints	features2d/features2d.hpp	/^        const vector<vector<KeyPoint> >& getKeypoints() const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:() const
getLeaf	features2d/features2d.hpp	/^    virtual int getLeaf(int fidx, const Mat& patch) const;$/;"	p	class:cv::FernClassifier	access:protected	signature:(int fidx, const Mat& patch) const
getLikelihood	ml/ml.hpp	/^    CV_WRAP inline double getLikelihood() const { return log_likelihood; }$/;"	f	class:CvEM	access:public	signature:() const
getLikelihoodDelta	ml/ml.hpp	/^    CV_WRAP inline double getLikelihoodDelta() const { return log_likelihood_delta; }$/;"	f	class:CvEM	access:public	signature:() const
getLinearColumnFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseColumnFilter> getLinearColumnFilter(int bufType, int dstType,$/;"	p	namespace:cv	signature:(int bufType, int dstType, InputArray kernel, int anchor, int symmetryType, double delta=0, int bits=0)
getLinearColumnFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseColumnFilter_GPU> getLinearColumnFilter_GPU(int bufType, int dstType, const Mat& columnKernel,$/;"	p	namespace:cv::gpu	signature:(int bufType, int dstType, const Mat& columnKernel, int anchor = -1, int borderType = BORDER_CONSTANT)
getLinearFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseFilter> getLinearFilter(int srcType, int dstType,$/;"	p	namespace:cv	signature:(int srcType, int dstType, InputArray kernel, Point anchor=Point(-1,-1), double delta=0, int bits=0)
getLinearFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseFilter_GPU> getLinearFilter_GPU(int srcType, int dstType, const Mat& kernel, const Size& ksize,$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Mat& kernel, const Size& ksize, Point anchor = Point(-1, -1))
getLinearRowFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseRowFilter> getLinearRowFilter(int srcType, int bufType,$/;"	p	namespace:cv	signature:(int srcType, int bufType, InputArray kernel, int anchor, int symmetryType)
getLinearRowFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseRowFilter_GPU> getLinearRowFilter_GPU(int srcType, int bufType, const Mat& rowKernel,$/;"	p	namespace:cv::gpu	signature:(int srcType, int bufType, const Mat& rowKernel, int anchor = -1, int borderType = BORDER_CONSTANT)
getLocalIdx	features2d/features2d.hpp	/^        void getLocalIdx( int globalDescIdx, int& imgIdx, int& localDescIdx ) const;$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:( int globalDescIdx, int& imgIdx, int& localDescIdx ) const
getLocalIdx	features2d/features2d.hpp	/^        void getLocalIdx( int globalPointIdx, int& imgIdx, int& localPointIdx ) const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:( int globalPointIdx, int& imgIdx, int& localPointIdx ) const
getMagno	contrib/retina.hpp	/^        void getMagno(Mat &retinaOutput_magno);$/;"	p	class:cv::Retina	access:public	signature:(Mat &retinaOutput_magno)
getMat	core/core.hpp	/^    virtual Mat getMat(int i=-1) const;$/;"	p	class:cv::_InputArray	access:public	signature:(int i=-1) const
getMatRef	core/core.hpp	/^    virtual Mat& getMatRef(int i=-1) const;$/;"	p	class:cv::_OutputArray	access:public	signature:(int i=-1) const
getMatVector	core/core.hpp	/^    virtual void getMatVector(vector<Mat>& mv) const;$/;"	p	class:cv::_InputArray	access:public	signature:(vector<Mat>& mv) const
getMaxFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseFilter_GPU> getMaxFilter_GPU(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1,-1));$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1,-1))
getMeans	ml/ml.hpp	/^    CV_WRAP cv::Mat  getMeans()     const;$/;"	p	class:CvEM	access:public	signature:() const
getMesh	contrib/contrib.hpp	/^        Mesh3D& getMesh() { return mesh; }$/;"	f	class:cv::SpinImageModel	access:public	signature:()
getMesh	contrib/contrib.hpp	/^        const Mesh3D& getMesh() const { return mesh; }$/;"	f	class:cv::SpinImageModel	access:public	signature:() const
getMinFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseFilter_GPU> getMinFilter_GPU(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1,-1));$/;"	p	namespace:cv::gpu	signature:(int srcType, int dstType, const Size& ksize, Point anchor = Point(-1,-1))
getMinVarianceClusters	flann/kmeans_index.h	/^    int getMinVarianceClusters(KMeansNodePtr root, KMeansNodePtr* clusters, int clusters_length, DistanceType& varianceValue)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(KMeansNodePtr root, KMeansNodePtr* clusters, int clusters_length, DistanceType& varianceValue)
getModelPoints	objdetect/objdetect.hpp	/^    vector<KeyPoint> getModelPoints() const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:() const
getModelROI	objdetect/objdetect.hpp	/^    Rect getModelROI() const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:() const
getMorphologyColumnFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseColumnFilter> getMorphologyColumnFilter(int op, int type, int ksize, int anchor=-1);$/;"	p	namespace:cv	signature:(int op, int type, int ksize, int anchor=-1)
getMorphologyFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseFilter> getMorphologyFilter(int op, int type, InputArray kernel,$/;"	p	namespace:cv	signature:(int op, int type, InputArray kernel, Point anchor=Point(-1,-1))
getMorphologyFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseFilter_GPU> getMorphologyFilter_GPU(int op, int type, const Mat& kernel, const Size& ksize,$/;"	p	namespace:cv::gpu	signature:(int op, int type, const Mat& kernel, const Size& ksize, Point anchor=Point(-1,-1))
getMorphologyRowFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseRowFilter> getMorphologyRowFilter(int op, int type, int ksize, int anchor=-1);$/;"	p	namespace:cv	signature:(int op, int type, int ksize, int anchor=-1)
getMostStable2D	features2d/features2d.hpp	/^    void getMostStable2D(const Mat& image, CV_OUT vector<KeyPoint>& keypoints,$/;"	p	class:cv::LDetector	access:public	signature:(const Mat& image, CV_OUT vector<KeyPoint>& keypoints, int maxCount, const PatchGenerator& patchGenerator) const
getNClusters	ml/ml.hpp	/^    CV_WRAP int  getNClusters() const;$/;"	p	class:CvEM	access:public	signature:() const
getNearestPoint	features2d/features2d.hpp	/^CV_EXPORTS int getNearestPoint( const vector<Point2f>& recallPrecisionCurve, float l_precision );$/;"	p	namespace:cv	signature:( const vector<Point2f>& recallPrecisionCurve, float l_precision )
getNeighbors	flann/kdtree_index.h	/^    void getNeighbors(ResultSet<DistanceType>& result, const ElementType* vec, int maxCheck, float epsError)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(ResultSet<DistanceType>& result, const ElementType* vec, int maxCheck, float epsError)
getNeighbors	flann/lsh_index.h	/^    void getNeighbors(const ElementType* vec, ResultSet<DistanceType>& result)$/;"	f	class:cvflann::LshIndex	access:private	signature:(const ElementType* vec, ResultSet<DistanceType>& result)
getNeighbors	flann/lsh_index.h	/^    void getNeighbors(const ElementType* vec, bool do_radius, float radius, bool do_k, unsigned int k_nn,$/;"	f	class:cvflann::LshIndex	access:private	signature:(const ElementType* vec, bool do_radius, float radius, bool do_k, unsigned int k_nn, float& checked_average)
getNodes	contrib/contrib.hpp	/^        const vector<Node>& getNodes() const { return nodes; }$/;"	f	class:cv::Octree	access:public	signature:() const
getNumThreads	core/core.hpp	/^CV_EXPORTS int getNumThreads();$/;"	p	namespace:cv	signature:()
getNumberOfCPUs	core/core.hpp	/^CV_EXPORTS_W int getNumberOfCPUs();$/;"	p	namespace:cv	signature:()
getOptimalDFTSize	core/core.hpp	/^CV_EXPORTS_W int getOptimalDFTSize(int vecsize);$/;"	p	namespace:cv	signature:(int vecsize)
getOptimalNewCameraMatrix	calib3d/calib3d.hpp	/^CV_EXPORTS_W Mat getOptimalNewCameraMatrix( InputArray cameraMatrix, InputArray distCoeffs,$/;"	p	namespace:cv	signature:( InputArray cameraMatrix, InputArray distCoeffs, Size imageSize, double alpha, Size newImgSize=Size(), CV_OUT Rect* validPixROI=0, bool centerPrincipalPoint=false)
getOriginalWindowSize	objdetect/objdetect.hpp	/^    virtual Size getOriginalWindowSize() const;$/;"	p	class:cv::CascadeClassifier	access:public	signature:() const
getOutputCurve	contrib/contrib.hpp	/^    CvFuzzyCurve *getOutputCurve();$/;"	p	class:CvFuzzyRule	access:public	signature:()
getParameters	flann/autotuned_index.h	/^    IndexParams getParameters() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
getParameters	flann/composite_index.h	/^    IndexParams getParameters() const$/;"	f	class:cvflann::CompositeIndex	access:public	signature:() const
getParameters	flann/flann.hpp	/^        ::cvflann::IndexParams getParameters() $/;"	f	class:cv::flann::Index_	access:public	signature:()
getParameters	flann/flann.hpp	/^        ::cvflann::IndexParams getParameters() { return nnIndex->getParameters(); }$/;"	f	class:cv::flann::GenericIndex	access:public	signature:()
getParameters	flann/flann_base.hpp	/^    IndexParams getParameters() const$/;"	f	class:cvflann::Index	access:public	signature:() const
getParameters	flann/hierarchical_clustering_index.h	/^    IndexParams getParameters() const$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:public	signature:() const
getParameters	flann/kdtree_index.h	/^    IndexParams getParameters() const$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:() const
getParameters	flann/kdtree_single_index.h	/^    IndexParams getParameters() const$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:() const
getParameters	flann/kmeans_index.h	/^    IndexParams getParameters() const$/;"	f	class:cvflann::KMeansIndex	access:public	signature:() const
getParameters	flann/linear_index.h	/^    IndexParams getParameters() const$/;"	f	class:cvflann::LinearIndex	access:public	signature:() const
getParameters	flann/lsh_index.h	/^    IndexParams getParameters() const$/;"	f	class:cvflann::LshIndex	access:public	signature:() const
getParameters	flann/nn_index.h	/^    virtual IndexParams getParameters() const = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:() const
getParvo	contrib/retina.hpp	/^        void getParvo(Mat &retinaOutput_parvo);$/;"	p	class:cv::Retina	access:public	signature:(Mat &retinaOutput_parvo)
getPatchSize	features2d/features2d.hpp	/^    Size getPatchSize() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
getPeopleDetector48x96	gpu/gpu.hpp	/^            static vector<float> getPeopleDetector48x96();$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:()
getPeopleDetector64x128	gpu/gpu.hpp	/^            static vector<float> getPeopleDetector64x128();$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:()
getPerspectiveTransform	imgproc/imgproc.hpp	/^CV_EXPORTS Mat getPerspectiveTransform( const Point2f src[], const Point2f dst[] );$/;"	p	namespace:cv	signature:( const Point2f src[], const Point2f dst[] )
getPerspectiveTransform	imgproc/imgproc.hpp	/^CV_EXPORTS_W Mat getPerspectiveTransform( InputArray src, InputArray dst );$/;"	p	namespace:cv	signature:( InputArray src, InputArray dst )
getPoint	core/core.hpp	/^    const float* getPoint(int ptidx, int* label=0) const;$/;"	p	class:cv::KDTree	access:public	signature:(int ptidx, int* label=0) const
getPoints	core/core.hpp	/^    CV_WRAP void getPoints(InputArray idx, OutputArray pts,$/;"	p	class:cv::KDTree	access:public	signature:(InputArray idx, OutputArray pts, OutputArray labels=noArray()) const
getPointsWithinSphere	contrib/contrib.hpp	/^        virtual void getPointsWithinSphere( const Point3f& center, float radius,$/;"	p	class:cv::Octree	access:public	signature:( const Point3f& center, float radius, vector<Point3f>& points ) const
getPosterior	features2d/features2d.hpp	/^  const float* getPosterior(uchar* patch_data) const;$/;"	p	class:cv::RandomizedTree	access:public	signature:(uchar* patch_data) const
getPosterior	features2d/features2d.hpp	/^  float* getPosterior(uchar* patch_data);$/;"	p	class:cv::RandomizedTree	access:public	signature:(uchar* patch_data)
getPosterior2	features2d/features2d.hpp	/^  const uchar* getPosterior2(uchar* patch_data) const;$/;"	p	class:cv::RandomizedTree	access:public	signature:(uchar* patch_data) const
getPosterior2	features2d/features2d.hpp	/^  uchar* getPosterior2(uchar* patch_data);$/;"	p	class:cv::RandomizedTree	access:public	signature:(uchar* patch_data)
getPosteriorByIndex	features2d/features2d.hpp	/^  inline const float* getPosteriorByIndex(int index) const;$/;"	p	class:cv::RandomizedTree	access:private	signature:(int index) const
getPosteriorByIndex	features2d/features2d.hpp	/^  inline float* getPosteriorByIndex(int index);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int index)
getPosteriorByIndex	features2d/features2d.hpp	/^inline const float* RandomizedTree::getPosteriorByIndex(int index) const$/;"	f	class:cv::RandomizedTree	signature:(int index) const
getPosteriorByIndex	features2d/features2d.hpp	/^inline float* RandomizedTree::getPosteriorByIndex(int index)$/;"	f	class:cv::RandomizedTree	signature:(int index)
getPosteriorByIndex2	features2d/features2d.hpp	/^  inline const uchar* getPosteriorByIndex2(int index) const;$/;"	p	class:cv::RandomizedTree	access:private	signature:(int index) const
getPosteriorByIndex2	features2d/features2d.hpp	/^  inline uchar* getPosteriorByIndex2(int index);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int index)
getPosteriorByIndex2	features2d/features2d.hpp	/^inline const uchar* RandomizedTree::getPosteriorByIndex2(int index) const$/;"	f	class:cv::RandomizedTree	signature:(int index) const
getPosteriorByIndex2	features2d/features2d.hpp	/^inline uchar* RandomizedTree::getPosteriorByIndex2(int index)$/;"	f	class:cv::RandomizedTree	signature:(int index)
getProbs	ml/ml.hpp	/^    CV_WRAP cv::Mat  getProbs()     const;$/;"	p	class:CvEM	access:public	signature:() const
getRecall	features2d/features2d.hpp	/^CV_EXPORTS float getRecall( const vector<Point2f>& recallPrecisionCurve, float l_precision );$/;"	p	namespace:cv	signature:( const vector<Point2f>& recallPrecisionCurve, float l_precision )
getRectSubPix	imgproc/imgproc.hpp	/^CV_EXPORTS_W void getRectSubPix( InputArray image, Size patchSize,$/;"	p	namespace:cv	signature:( InputArray image, Size patchSize, Point2f center, OutputArray patch, int patchType=-1 )
getResizeAttribsEdgeDensityFuzzy	contrib/contrib.hpp	/^        void getResizeAttribsEdgeDensityFuzzy(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh)
getResizeAttribsEdgeDensityLinear	contrib/contrib.hpp	/^        void getResizeAttribsEdgeDensityLinear(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh)
getResizeAttribsInnerDensity	contrib/contrib.hpp	/^        void getResizeAttribsInnerDensity(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(int &resizeDx, int &resizeDy, int &resizeDw, int &resizeDh)
getRotationMatrix2D	imgproc/imgproc.hpp	/^CV_EXPORTS_W Mat getRotationMatrix2D( Point2f center, double angle, double scale );$/;"	p	namespace:cv	signature:( Point2f center, double angle, double scale )
getRowSumFilter	imgproc/imgproc.hpp	/^CV_EXPORTS Ptr<BaseRowFilter> getRowSumFilter(int srcType, int sumType,$/;"	p	namespace:cv	signature:(int srcType, int sumType, int ksize, int anchor=-1)
getRowSumFilter_GPU	gpu/gpu.hpp	/^        CV_EXPORTS Ptr<BaseRowFilter_GPU> getRowSumFilter_GPU(int srcType, int sumType, int ksize, int anchor = -1);$/;"	p	namespace:cv::gpu	signature:(int srcType, int sumType, int ksize, int anchor = -1)
getSearchParameters	flann/autotuned_index.h	/^    SearchParams getSearchParameters() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
getSegment	gpu/NCV.hpp	/^    NCVMemSegment getSegment() const$/;"	f	class:NCVMatrixAlloc	access:public	signature:() const
getSegment	gpu/NCV.hpp	/^    NCVMemSegment getSegment() const$/;"	f	class:NCVVectorAlloc	access:public	signature:() const
getSeqElem	core/operations.hpp	/^CV_EXPORTS schar*  getSeqElem( const CvSeq* seq, int index );$/;"	p	namespace:cv	signature:( const CvSeq* seq, int index )
getSignature	features2d/features2d.hpp	/^  void getSignature(IplImage *patch, float *sig) const;$/;"	p	class:cv::RTreeClassifier	access:public	signature:(IplImage *patch, float *sig) const
getSignature	features2d/features2d.hpp	/^  void getSignature(IplImage *patch, uchar *sig) const;$/;"	p	class:cv::RTreeClassifier	access:public	signature:(IplImage *patch, uchar *sig) const
getSignatureSize	features2d/features2d.hpp	/^    int getSignatureSize() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
getSparseSignature	features2d/features2d.hpp	/^  void getSparseSignature(IplImage *patch, float *sig, float thresh) const;$/;"	p	class:cv::RTreeClassifier	access:public	signature:(IplImage *patch, float *sig, float thresh) const
getSpeedup	flann/autotuned_index.h	/^    float getSpeedup() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
getSpinCount	contrib/contrib.hpp	/^        size_t getSpinCount() const { return spinImages.rows; }$/;"	f	class:cv::SpinImageModel	access:public	signature:() const
getSpinImage	contrib/contrib.hpp	/^        Mat getSpinImage(size_t index) const { return spinImages.row((int)index); }$/;"	f	class:cv::SpinImageModel	access:public	signature:(size_t index) const
getSpinNormal	contrib/contrib.hpp	/^        const Point3f& getSpinNormal(size_t index) const { return mesh.normals[subset[index]]; }$/;"	f	class:cv::SpinImageModel	access:public	signature:(size_t index) const
getSpinVertex	contrib/contrib.hpp	/^        const Point3f& getSpinVertex(size_t index) const { return mesh.vtx[subset[index]]; }$/;"	f	class:cv::SpinImageModel	access:public	signature:(size_t index) const
getStats	flann/lsh_table.h	/^    LshStats getStats() const;$/;"	p	class:cvflann::lsh::LshTable	access:public	signature:() const
getStats	flann/lsh_table.h	/^inline LshStats LshTable<unsigned char>::getStats() const$/;"	f	class:cvflann::lsh::LshTable	signature:() const
getStream	gpu/stream_accessor.hpp	/^            CV_EXPORTS static cudaStream_t getStream(const Stream& stream);$/;"	p	struct:cv::gpu::StreamAccessor	access:public	signature:(const Stream& stream)
getString	core/core.hpp	/^    std::string getString(const std::string& name);$/;"	p	class:cv::CommandLineParser	access:protected	signature:(const std::string& name)
getString	flann/miniflann.hpp	/^    std::string getString(const std::string& key, const std::string& defaultVal=std::string()) const;$/;"	p	struct:cv::flann::IndexParams	access:public	signature:(const std::string& key, const std::string& defaultVal=std::string()) const
getStructCount	features2d/features2d.hpp	/^    int getStructCount() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
getStructSize	features2d/features2d.hpp	/^    int getStructSize() const;$/;"	p	class:cv::FernClassifier	access:public	signature:() const
getStructuringElement	imgproc/imgproc.hpp	/^CV_EXPORTS_W Mat getStructuringElement(int shape, Size ksize, Point anchor=Point(-1,-1));$/;"	p	namespace:cv	signature:(int shape, Size ksize, Point anchor=Point(-1,-1))
getTextSize	core/core.hpp	/^CV_EXPORTS_W Size getTextSize(const string& text, int fontFace,$/;"	p	namespace:cv	signature:(const string& text, int fontFace, double fontScale, int thickness, CV_OUT int* baseLine)
getThreadNum	core/core.hpp	/^CV_EXPORTS int getThreadNum();$/;"	p	namespace:cv	signature:()
getTickCount	core/core.hpp	/^CV_EXPORTS_W int64 getTickCount();$/;"	p	namespace:cv	signature:()
getTickFrequency	core/core.hpp	/^CV_EXPORTS_W double getTickFrequency();$/;"	p	namespace:cv	signature:()
getTimeMicro	contrib/contrib.hpp	/^        double getTimeMicro() const;$/;"	p	class:cv::TickMeter	access:public	signature:() const
getTimeMilli	contrib/contrib.hpp	/^        double getTimeMilli() const;$/;"	p	class:cv::TickMeter	access:public	signature:() const
getTimeSec	contrib/contrib.hpp	/^        double getTimeSec()   const;$/;"	p	class:cv::TickMeter	access:public	signature:() const
getTimeTicks	contrib/contrib.hpp	/^        int64 getTimeTicks() const;$/;"	p	class:cv::TickMeter	access:public	signature:() const
getTrackbarPos	highgui/highgui.hpp	/^CV_EXPORTS_W int getTrackbarPos( const string& trackbarname, const string& winname );$/;"	p	namespace:cv	signature:( const string& trackbarname, const string& winname )
getTrainDescriptors	features2d/features2d.hpp	/^    const vector<Mat>& getTrainDescriptors() const;$/;"	p	class:cv::DescriptorMatcher	access:public	signature:() const
getTrainDescriptors	gpu/gpu.hpp	/^            const std::vector<GpuMat>& getTrainDescriptors() const;$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:() const
getTrainImages	features2d/features2d.hpp	/^    const vector<Mat>& getTrainImages() const;$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:() const
getTrainKeypoints	features2d/features2d.hpp	/^    const vector<vector<KeyPoint> >& getTrainKeypoints() const;$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:() const
getTriangleList	imgproc/imgproc.hpp	/^    CV_WRAP void getTriangleList(CV_OUT vector<Vec6f>& triangleList) const;$/;"	p	class:cv::Subdiv2D	access:public	signature:(CV_OUT vector<Vec6f>& triangleList) const
getType	flann/autotuned_index.h	/^    virtual flann_algorithm_t getType() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
getType	flann/composite_index.h	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::CompositeIndex	access:public	signature:() const
getType	flann/flann_base.hpp	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::Index	access:public	signature:() const
getType	flann/hierarchical_clustering_index.h	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:public	signature:() const
getType	flann/kdtree_index.h	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:() const
getType	flann/kdtree_single_index.h	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:() const
getType	flann/kmeans_index.h	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::KMeansIndex	access:public	signature:() const
getType	flann/linear_index.h	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::LinearIndex	access:public	signature:() const
getType	flann/lsh_index.h	/^    flann_algorithm_t getType() const$/;"	f	class:cvflann::LshIndex	access:public	signature:() const
getType	flann/nn_index.h	/^    virtual flann_algorithm_t getType() const = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:() const
getValidDisparityROI	calib3d/calib3d.hpp	/^CV_EXPORTS_W Rect getValidDisparityROI( Rect roi1, Rect roi2,$/;"	p	namespace:cv	signature:( Rect roi1, Rect roi2, int minDisparity, int numberOfDisparities, int SADWindowSize )
getValue	contrib/contrib.hpp	/^    double getValue();$/;"	p	class:CvFuzzyCurve	access:public	signature:()
getVarImportance	ml/ml.hpp	/^    CV_WRAP virtual cv::Mat getVarImportance();$/;"	p	class:CvDTree	access:public	signature:()
getVarImportance	ml/ml.hpp	/^    CV_WRAP virtual cv::Mat getVarImportance();$/;"	p	class:CvRTrees	access:public	signature:()
getVertex	imgproc/imgproc.hpp	/^    CV_WRAP Point2f getVertex(int vertex, CV_OUT int* firstEdge=0) const;$/;"	p	class:cv::Subdiv2D	access:public	signature:(int vertex, CV_OUT int* firstEdge=0) const
getVocabulary	features2d/features2d.hpp	/^    const Mat& getVocabulary() const;$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:() const
getVoronoiFacetList	imgproc/imgproc.hpp	/^    CV_WRAP void getVoronoiFacetList(const vector<int>& idx, CV_OUT vector<vector<Point2f> >& facetList,$/;"	p	class:cv::Subdiv2D	access:public	signature:(const vector<int>& idx, CV_OUT vector<vector<Point2f> >& facetList, CV_OUT vector<Point2f>& facetCenters)
getWeights	ml/ml.hpp	/^    CV_WRAP cv::Mat  getWeights()   const;$/;"	p	class:CvEM	access:public	signature:() const
getWinSigma	gpu/gpu.hpp	/^            double getWinSigma() const;$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:() const
getWinSigma	objdetect/objdetect.hpp	/^    CV_WRAP double getWinSigma() const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:() const
getWindowProperty	highgui/highgui.hpp	/^CV_EXPORTS_W double getWindowProperty(const string& winname, int prop_id);\/\/YV$/;"	p	namespace:cv	signature:(const string& winname, int prop_id)
get_active_var_mask	ml/ml.hpp	/^    CvMat* get_active_var_mask();$/;"	p	class:CvRTrees	access:public	signature:()
get_active_vars	ml/ml.hpp	/^    virtual const CvMat* get_active_vars(bool absolute_idx=true);$/;"	p	class:CvBoost	access:public	signature:(bool absolute_idx=true)
get_back_project	legacy/legacy.hpp	/^    virtual IplImage* get_back_project()$/;"	f	class:CvCamShiftTracker	access:public	signature:()
get_cat_var_data	ml/ml.hpp	/^    virtual const int* get_cat_var_data( CvDTreeNode* n, int vi, int* cat_values_buf );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, int vi, int* cat_values_buf )
get_cat_var_data	ml/ml.hpp	/^    virtual const int* get_cat_var_data( CvDTreeNode* n, int vi, int* cat_values_buf );$/;"	p	struct:CvERTreeTrainData	access:public	signature:( CvDTreeNode* n, int vi, int* cat_values_buf )
get_center	legacy/legacy.hpp	/^    CvPoint2D32f get_center() const \/\/ center of the object$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
get_child_buf_idx	ml/ml.hpp	/^    virtual int get_child_buf_idx( CvDTreeNode* n );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n )
get_class_labels	ml/ml.hpp	/^    virtual const int* get_class_labels( CvDTreeNode* n, int* labels_buf );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, int* labels_buf )
get_class_labels_map	ml/ml.hpp	/^    const std::map<std::string, int>& get_class_labels_map() const;$/;"	p	class:CvMLData	access:public	signature:() const
get_covs	ml/ml.hpp	/^    const CvMat** get_covs()      const;$/;"	p	class:CvEM	access:public	signature:() const
get_cv_labels	ml/ml.hpp	/^    virtual const int* get_cv_labels( CvDTreeNode* n, int* labels_buf );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, int* labels_buf )
get_cv_labels	ml/ml.hpp	/^    virtual const int* get_cv_labels( CvDTreeNode* n, int* labels_buf );$/;"	p	struct:CvERTreeTrainData	access:public	signature:( CvDTreeNode* n, int* labels_buf )
get_data	ml/ml.hpp	/^    CvDTreeTrainData* get_data();$/;"	p	class:CvDTree	access:public	signature:()
get_data	ml/ml.hpp	/^    const CvDTreeTrainData* get_data() const;$/;"	p	class:CvBoost	access:public	signature:() const
get_default_grid	ml/ml.hpp	/^    static CvParamGrid get_default_grid( int param_id );$/;"	p	class:CvSVM	access:public	signature:( int param_id )
get_delimiter	ml/ml.hpp	/^    char get_delimiter() const;$/;"	p	class:CvMLData	access:public	signature:() const
get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type()$/;"	f	namespace:cvflann::__anon204	signature:()
get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type<char>() { return H5T_NATIVE_CHAR; }$/;"	f	namespace:cvflann::__anon204	signature:()
get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type<double>() { return H5T_NATIVE_DOUBLE; }$/;"	f	namespace:cvflann::__anon204	signature:()
get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type<float>() { return H5T_NATIVE_FLOAT; }$/;"	f	namespace:cvflann::__anon204	signature:()
get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type<int>() { return H5T_NATIVE_INT; }$/;"	f	namespace:cvflann::__anon204	signature:()
get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type<long double>() { return H5T_NATIVE_LDOUBLE; }$/;"	f	namespace:cvflann::__anon204	signature:()
get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type<long>() { return H5T_NATIVE_LONG; }$/;"	f	namespace:cvflann::__anon204	signature:()
get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type<short int>() { return H5T_NATIVE_SHORT; }$/;"	f	namespace:cvflann::__anon204	signature:()
get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type<unsigned char>() { return H5T_NATIVE_UCHAR; }$/;"	f	namespace:cvflann::__anon204	signature:()
get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type<unsigned int>() { return H5T_NATIVE_UINT; }$/;"	f	namespace:cvflann::__anon204	signature:()
get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type<unsigned long>() { return H5T_NATIVE_ULONG; }$/;"	f	namespace:cvflann::__anon204	signature:()
get_hdf5_type	flann/hdf5.h	/^hid_t get_hdf5_type<unsigned short int>() { return H5T_NATIVE_USHORT; }$/;"	f	namespace:cvflann::__anon204	signature:()
get_hist_dims	legacy/legacy.hpp	/^    int     get_hist_dims( int* dims = 0 ) const \/\/ returns number of histogram dimensions and sets$/;"	f	class:CvCamShiftTracker	access:public	signature:( int* dims = 0 ) const
get_layer_count	ml/ml.hpp	/^    int get_layer_count() { return layer_sizes ? layer_sizes->cols : 0; }$/;"	f	class:CvANN_MLP	access:public	signature:()
get_layer_sizes	ml/ml.hpp	/^    const CvMat* get_layer_sizes() { return layer_sizes; }$/;"	f	class:CvANN_MLP	access:public	signature:()
get_len	ml/ml.hpp	/^	int get_len(const CvMat* mat) const;$/;"	p	class:CvGBTrees	access:protected	signature:(const CvMat* mat) const
get_length	legacy/legacy.hpp	/^    float   get_length() const \/\/ the larger linear size of the object$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
get_log_likelihood	ml/ml.hpp	/^    inline double get_log_likelihood() const { return log_likelihood; }$/;"	f	class:CvEM	access:public	signature:() const
get_log_likelihood_delta	ml/ml.hpp	/^    inline double get_log_likelihood_delta() const { return log_likelihood_delta; }$/;"	f	class:CvEM	access:public	signature:() const
get_max_ch_val	legacy/legacy.hpp	/^    int     get_max_ch_val( int channel ) const \/\/ get the maximum allowed value of the specified channel$/;"	f	class:CvCamShiftTracker	access:public	signature:( int channel ) const
get_max_k	ml/ml.hpp	/^    int get_max_k() const;$/;"	p	class:CvKNearest	access:public	signature:() const
get_means	ml/ml.hpp	/^    const CvMat*  get_means()     const;$/;"	p	class:CvEM	access:public	signature:() const
get_min_ch_val	legacy/legacy.hpp	/^    int     get_min_ch_val( int channel ) const \/\/ get the minimum allowed value of the specified channel$/;"	f	class:CvCamShiftTracker	access:public	signature:( int channel ) const
get_minor	core/core.hpp	/^    template<int m1, int n1> Matx<_Tp, m1, n1> get_minor(int i, int j) const;$/;"	p	class:cv::Matx	access:public	signature:(int i, int j) const
get_minor	core/operations.hpp	/^Matx<_Tp, m1, n1> Matx<_Tp, m, n>::get_minor(int i, int j) const$/;"	f	class:cv::Matx	signature:(int i, int j) const
get_miss_ch	ml/ml.hpp	/^    char get_miss_ch() const;$/;"	p	class:CvMLData	access:public	signature:() const
get_missing	ml/ml.hpp	/^    const CvMat* get_missing() const;$/;"	p	class:CvMLData	access:public	signature:() const
get_nclusters	ml/ml.hpp	/^    int           get_nclusters() const;$/;"	p	class:CvEM	access:public	signature:() const
get_num_classes	ml/ml.hpp	/^    int get_num_classes() const;$/;"	p	struct:CvDTreeTrainData	access:public	signature:() const
get_num_valid	ml/ml.hpp	/^    int get_num_valid(int vi) { return num_valid ? num_valid[vi] : sample_count; }$/;"	f	struct:CvDTreeNode	access:public	signature:(int vi)
get_ord_responses	ml/ml.hpp	/^    virtual const float* get_ord_responses( CvDTreeNode* n, float* values_buf, int* sample_indices_buf );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, float* values_buf, int* sample_indices_buf )
get_ord_var_data	ml/ml.hpp	/^    virtual void get_ord_var_data( CvDTreeNode* n, int vi, float* ord_values_buf, int* missing_buf,$/;"	p	struct:CvERTreeTrainData	access:public	signature:( CvDTreeNode* n, int vi, float* ord_values_buf, int* missing_buf, const float** ord_values, const int** missing, int* sample_buf = 0 )
get_ord_var_data	ml/ml.hpp	/^    virtual void get_ord_var_data( CvDTreeNode* n, int vi, float* ord_values_buf, int* sorted_indices_buf,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, int vi, float* ord_values_buf, int* sorted_indices_buf, const float** ord_values, const int** sorted_indices, int* sample_indices_buf )
get_orientation	legacy/legacy.hpp	/^    float   get_orientation() const \/\/ orientation of the object in degrees$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
get_param	flann/params.h	/^T get_param(const IndexParams& params, std::string name)$/;"	f	namespace:cvflann	signature:(const IndexParams& params, std::string name)
get_param	flann/params.h	/^T get_param(const IndexParams& params, std::string name, const T& default_value)$/;"	f	namespace:cvflann	signature:(const IndexParams& params, std::string name, const T& default_value)
get_params	ml/ml.hpp	/^    const CvBoostParams& get_params() const;$/;"	p	class:CvBoost	access:public	signature:() const
get_params	ml/ml.hpp	/^    virtual CvSVMParams get_params() const { return params; };$/;"	f	class:CvSVM	access:public	signature:() const
get_policy	flann/any.h	/^base_any_policy* get_policy()$/;"	f	namespace:cdiggins::anyimpl	signature:()
get_probs	ml/ml.hpp	/^    const CvMat*  get_probs()     const;$/;"	p	class:CvEM	access:public	signature:() const
get_proximity	ml/ml.hpp	/^    virtual float get_proximity( const CvMat* sample1, const CvMat* sample2,$/;"	p	class:CvRTrees	access:public	signature:( const CvMat* sample1, const CvMat* sample2, const CvMat* missing1 = 0, const CvMat* missing2 = 0 ) const
get_pruned_tree_idx	ml/ml.hpp	/^    int get_pruned_tree_idx() const;$/;"	p	class:CvDTree	access:public	signature:() const
get_response_idx	ml/ml.hpp	/^    int get_response_idx() const;$/;"	p	class:CvMLData	access:public	signature:() const
get_responses	ml/ml.hpp	/^    const CvMat* get_responses();$/;"	p	class:CvMLData	access:public	signature:()
get_rng	ml/ml.hpp	/^    CvRNG* get_rng();$/;"	p	class:CvRTrees	access:public	signature:()
get_root	ml/ml.hpp	/^    const CvDTreeNode* get_root() const;$/;"	p	class:CvDTree	access:public	signature:() const
get_row	ml/ml.hpp	/^    virtual float* get_row( int i, float* dst );$/;"	p	class:CvSVMSolver	access:public	signature:( int i, float* dst )
get_row_base	ml/ml.hpp	/^    virtual float* get_row_base( int i, bool* _existed );$/;"	p	class:CvSVMSolver	access:public	signature:( int i, bool* _existed )
get_row_func	ml/ml.hpp	/^    GetRow get_row_func;$/;"	m	class:CvSVMSolver	access:public
get_row_one_class	ml/ml.hpp	/^    virtual float* get_row_one_class( int i, float* row, float* dst, bool existed );$/;"	p	class:CvSVMSolver	access:public	signature:( int i, float* row, float* dst, bool existed )
get_row_svc	ml/ml.hpp	/^    virtual float* get_row_svc( int i, float* row, float* dst, bool existed );$/;"	p	class:CvSVMSolver	access:public	signature:( int i, float* row, float* dst, bool existed )
get_row_svr	ml/ml.hpp	/^    virtual float* get_row_svr( int i, float* row, float* dst, bool existed );$/;"	p	class:CvSVMSolver	access:public	signature:( int i, float* row, float* dst, bool existed )
get_sample_count	ml/ml.hpp	/^    int get_sample_count() const;$/;"	p	class:CvKNearest	access:public	signature:() const
get_sample_indices	ml/ml.hpp	/^    virtual const int* get_sample_indices( CvDTreeNode* n, int* indices_buf );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* n, int* indices_buf )
get_sample_indices	ml/ml.hpp	/^    virtual const int* get_sample_indices( CvDTreeNode* n, int* indices_buf );$/;"	p	struct:CvERTreeTrainData	access:public	signature:( CvDTreeNode* n, int* indices_buf )
get_size	flann/any.h	/^    virtual size_t get_size() = 0;$/;"	p	struct:cdiggins::anyimpl::base_any_policy	access:public	signature:()
get_size	flann/any.h	/^    virtual size_t get_size() { return sizeof(T); }$/;"	f	struct:cdiggins::anyimpl::typed_base_any_policy	access:public	signature:()
get_subtree_weights	ml/ml.hpp	/^    CvMat* get_subtree_weights();$/;"	p	class:CvBoost	access:public	signature:()
get_support_vector	ml/ml.hpp	/^    virtual const float* get_support_vector(int i) const;$/;"	p	class:CvSVM	access:public	signature:(int i) const
get_support_vector_count	ml/ml.hpp	/^    CV_WRAP virtual int get_support_vector_count() const;$/;"	p	class:CvSVM	access:public	signature:() const
get_test_sample_idx	ml/ml.hpp	/^    const CvMat* get_test_sample_idx() const;$/;"	p	class:CvMLData	access:public	signature:() const
get_threshold	legacy/legacy.hpp	/^    int     get_threshold() const \/\/ thresholding value that applied to back project$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
get_train_error	ml/ml.hpp	/^    virtual float get_train_error();    $/;"	p	class:CvRTrees	access:public	signature:()
get_train_sample_idx	ml/ml.hpp	/^    const CvMat* get_train_sample_idx() const;$/;"	p	class:CvMLData	access:public	signature:() const
get_tree	ml/ml.hpp	/^    CvForestTree* get_tree(int i) const;$/;"	p	class:CvRTrees	access:public	signature:(int i) const
get_tree_count	ml/ml.hpp	/^    int get_tree_count() const;$/;"	p	class:CvRTrees	access:public	signature:() const
get_value	flann/any.h	/^    virtual void* get_value(void** src) = 0;$/;"	p	struct:cdiggins::anyimpl::base_any_policy	access:public	signature:(void** src)
get_value	flann/any.h	/^    virtual void* get_value(void** src) { return *src; }$/;"	f	struct:cdiggins::anyimpl::big_any_policy	access:public	signature:(void** src)
get_value	flann/any.h	/^    virtual void* get_value(void** src) { return reinterpret_cast<void*>(src); }$/;"	f	struct:cdiggins::anyimpl::small_any_policy	access:public	signature:(void** src)
get_values	ml/ml.hpp	/^    const CvMat* get_values() const;$/;"	p	class:CvMLData	access:public	signature:() const
get_var_count	ml/ml.hpp	/^    CV_WRAP int get_var_count() const { return var_idx ? var_idx->cols : var_all; }$/;"	f	class:CvSVM	access:public	signature:() const
get_var_count	ml/ml.hpp	/^    int get_var_count() const;$/;"	p	class:CvKNearest	access:public	signature:() const
get_var_count	ml/ml.hpp	/^    virtual int get_var_count() const {return data ? data->var_count : 0;}$/;"	f	class:CvForestTree	access:public	signature:() const
get_var_idx	ml/ml.hpp	/^    const CvMat* get_var_idx();$/;"	p	class:CvMLData	access:public	signature:()
get_var_importance	ml/ml.hpp	/^    virtual const CvMat* get_var_importance();$/;"	p	class:CvDTree	access:public	signature:()
get_var_importance	ml/ml.hpp	/^    virtual const CvMat* get_var_importance();$/;"	p	class:CvRTrees	access:public	signature:()
get_var_type	ml/ml.hpp	/^    int get_var_type( int var_idx ) const;$/;"	p	class:CvMLData	access:public	signature:( int var_idx ) const
get_var_type	ml/ml.hpp	/^    int get_var_type(int vi) const;$/;"	p	struct:CvDTreeTrainData	access:public	signature:(int vi) const
get_var_types	ml/ml.hpp	/^    const CvMat* get_var_types();$/;"	p	class:CvMLData	access:public	signature:()
get_vectors	ml/ml.hpp	/^    virtual void get_vectors( const CvMat* _subsample_idx, float* values, uchar* missing,$/;"	p	struct:CvERTreeTrainData	access:public	signature:( const CvMat* _subsample_idx, float* values, uchar* missing, float* responses, bool get_class_idx=false )
get_vectors	ml/ml.hpp	/^    virtual void get_vectors( const CvMat* _subsample_idx,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( const CvMat* _subsample_idx, float* values, uchar* missing, float* responses, bool get_class_idx=false )
get_weak_predictors	ml/ml.hpp	/^    CvSeq* get_weak_predictors();$/;"	p	class:CvBoost	access:public	signature:()
get_weak_response	ml/ml.hpp	/^    CvMat* get_weak_response();$/;"	p	class:CvBoost	access:public	signature:()
get_weights	ml/ml.hpp	/^    CvMat* get_weights();$/;"	p	class:CvBoost	access:public	signature:()
get_weights	ml/ml.hpp	/^    const CvMat*  get_weights()   const;$/;"	p	class:CvEM	access:public	signature:() const
get_weights	ml/ml.hpp	/^    double* get_weights(int layer)$/;"	f	class:CvANN_MLP	access:public	signature:(int layer)
get_width	legacy/legacy.hpp	/^    float   get_width() const \/\/ the smaller linear size of the object$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
get_window	legacy/legacy.hpp	/^    CvRect get_window() const \/\/ bounding rectangle for the object$/;"	f	class:CvCamShiftTracker	access:public	signature:() const
get_work_var_count	ml/ml.hpp	/^    int get_work_var_count() const {return work_var_count;}$/;"	f	struct:CvDTreeTrainData	access:public	signature:() const
good	features2d/features2d.hpp	/^    virtual bool good() const = 0;$/;"	p	class:cv::AdjusterAdapter	access:public	signature:() const
good	features2d/features2d.hpp	/^    virtual bool good() const;$/;"	p	class:cv::FastAdjuster	access:public	signature:() const
good	features2d/features2d.hpp	/^    virtual bool good() const;$/;"	p	class:cv::StarAdjuster	access:public	signature:() const
good	features2d/features2d.hpp	/^    virtual bool good() const;$/;"	p	class:cv::SurfAdjuster	access:public	signature:() const
goodFeaturesToTrack	imgproc/imgproc.hpp	/^CV_EXPORTS_W void goodFeaturesToTrack( InputArray image, OutputArray corners,$/;"	p	namespace:cv	signature:( InputArray image, OutputArray corners, int maxCorners, double qualityLevel, double minDistance, InputArray mask=noArray(), int blockSize=3, bool useHarrisDetector=false, double k=0.04 )
gpu	gpu/devmem2d.hpp	/^    namespace gpu$/;"	n	namespace:cv
gpu	gpu/gpu.hpp	/^    namespace gpu$/;"	n	namespace:cv
gpu	gpu/gpumat.hpp	/^namespace cv { namespace gpu$/;"	n	namespace:cv
gpu	gpu/matrix_operations.hpp	/^namespace gpu$/;"	n	namespace:cv
gpu	gpu/stream_accessor.hpp	/^    namespace gpu$/;"	n	namespace:cv
grab	highgui/highgui.hpp	/^    CV_WRAP virtual bool grab();$/;"	p	class:cv::VideoCapture	access:public	signature:()
grabCut	imgproc/imgproc.hpp	/^CV_EXPORTS_W void grabCut( InputArray img, InputOutputArray mask, Rect rect, $/;"	p	namespace:cv	signature:( InputArray img, InputOutputArray mask, Rect rect, InputOutputArray bgdModel, InputOutputArray fgdModel, int iterCount, int mode = GC_EVAL )
grad	gpu/gpu.hpp	/^            GpuMat grad, qangle, grad_buf, qangle_buf;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
grad_buf	gpu/gpu.hpp	/^            GpuMat grad, qangle, grad_buf, qangle_buf;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
graph	core/core_c.h	/^    CvGraph* graph;        \/* the graph *\/$/;"	m	struct:CvGraphScanner	access:public
graph	core/core_c.h	/^CVAPI(void)  cvClearGraph( CvGraph* graph );$/;"	v
graph	legacy/legacy.hpp	/^    CvGraph* graph;$/;"	m	struct:CvCliqueFinder	access:public
graphcut	gpu/gpu.hpp	/^        CV_EXPORTS void graphcut(GpuMat& terminals, GpuMat& leftTransp, GpuMat& rightTransp, GpuMat& top, GpuMat& bottom, GpuMat& labels, GpuMat& buf, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(GpuMat& terminals, GpuMat& leftTransp, GpuMat& rightTransp, GpuMat& top, GpuMat& bottom, GpuMat& labels, GpuMat& buf, Stream& stream = Stream::Null())
grayImg	legacy/legacy.hpp	/^    CvMat*  grayImg;$/;"	m	class:CvCalibFilter	access:protected
greek	core/core_c.h	/^    const int*  greek;$/;"	m	struct:CvFont	access:public
gridCols	features2d/features2d.hpp	/^    int gridCols;$/;"	m	class:cv::GridAdaptedFeatureDetector	access:protected
gridRows	features2d/features2d.hpp	/^    int gridRows;$/;"	m	class:cv::GridAdaptedFeatureDetector	access:protected
groupRectangles	objdetect/objdetect.hpp	/^CV_EXPORTS void groupRectangles( vector<Rect>& rectList, int groupThreshold, double eps, vector<int>* weights, vector<double>* levelWeights );$/;"	p	namespace:cv	signature:( vector<Rect>& rectList, int groupThreshold, double eps, vector<int>* weights, vector<double>* levelWeights )
groupRectangles	objdetect/objdetect.hpp	/^CV_EXPORTS void groupRectangles(CV_OUT CV_IN_OUT vector<Rect>& rectList, int groupThreshold, double eps=0.2);$/;"	p	namespace:cv	signature:(CV_OUT CV_IN_OUT vector<Rect>& rectList, int groupThreshold, double eps=0.2)
groupRectangles	objdetect/objdetect.hpp	/^CV_EXPORTS void groupRectangles(vector<Rect>& rectList, vector<int>& rejectLevels, $/;"	p	namespace:cv	signature:(vector<Rect>& rectList, vector<int>& rejectLevels, vector<double>& levelWeights, int groupThreshold, double eps=0.2)
groupRectangles	objdetect/objdetect.hpp	/^CV_EXPORTS_W void groupRectangles(CV_OUT CV_IN_OUT vector<Rect>& rectList, CV_OUT vector<int>& weights, int groupThreshold, double eps=0.2);$/;"	p	namespace:cv	signature:(CV_OUT CV_IN_OUT vector<Rect>& rectList, CV_OUT vector<int>& weights, int groupThreshold, double eps=0.2)
groupRectangles_meanshift	objdetect/objdetect.hpp	/^CV_EXPORTS void groupRectangles_meanshift(vector<Rect>& rectList, vector<double>& foundWeights, vector<double>& foundScales, $/;"	p	namespace:cv	signature:(vector<Rect>& rectList, vector<double>& foundWeights, vector<double>& foundScales, double detectThreshold = 0.0, Size winDetSize = Size(64, 128))
groupingCreteria	contrib/contrib.hpp	/^        static float groupingCreteria(const Point3f& pointScene1, const Point3f& normalScene1,$/;"	p	class:cv::SpinImageModel	access:public	signature:(const Point3f& pointScene1, const Point3f& normalScene1, const Point3f& pointModel1, const Point3f& normalModel1, const Point3f& pointScene2, const Point3f& normalScene2, const Point3f& pointModel2, const Point3f& normalModel2, float gamma)
grow_forest	ml/ml.hpp	/^    virtual bool grow_forest( const CvTermCriteria term_crit );$/;"	p	class:CvERTrees	access:protected	signature:( const CvTermCriteria term_crit )
grow_forest	ml/ml.hpp	/^    virtual bool grow_forest( const CvTermCriteria term_crit );$/;"	p	class:CvRTrees	access:protected	signature:( const CvTermCriteria term_crit )
gt_matches_	flann/autotuned_index.h	/^    Matrix<int> gt_matches_;$/;"	m	class:cvflann::AutotunedIndex	access:private
h	legacy/blobtrack.hpp	/^    float   w,h; \/* blob sizes      *\/$/;"	m	struct:CvBlob	access:public
h1	imgproc/imgproc.hpp	/^  int h1, h2;$/;"	m	struct:lsh_hash	access:public
h2	imgproc/imgproc.hpp	/^  int h1, h2;$/;"	m	struct:lsh_hash	access:public
hX	contrib/contrib.hpp	/^        CvMat* hX; \/\/current measurement extimation given new parameter vector $/;"	m	class:cv::LevMarqSparse	access:public
haar_feature	objdetect/objdetect.hpp	/^    CvHaarFeature* haar_feature;$/;"	m	struct:CvHaarClassifier	access:public
half_patch_size_	features2d/features2d.hpp	/^  int half_patch_size_;$/;"	m	class:cv::ORB	access:private
has	core/core.hpp	/^    bool has(const std::string& keys);$/;"	p	class:cv::CommandLineParser	access:protected	signature:(const std::string& keys)
has	gpu/gpu.hpp	/^            static bool has(int major, int minor);$/;"	p	class:cv::gpu::TargetArchs	access:public	signature:(int major, int minor)
hasBin	gpu/gpu.hpp	/^            static bool hasBin(int major, int minor);$/;"	p	class:cv::gpu::TargetArchs	access:public	signature:(int major, int minor)
hasEqualOrGreater	gpu/gpu.hpp	/^            static bool hasEqualOrGreater(int major, int minor);$/;"	p	class:cv::gpu::TargetArchs	access:public	signature:(int major, int minor)
hasEqualOrGreaterBin	gpu/gpu.hpp	/^            static bool hasEqualOrGreaterBin(int major, int minor);$/;"	p	class:cv::gpu::TargetArchs	access:public	signature:(int major, int minor)
hasEqualOrGreaterPtx	gpu/gpu.hpp	/^            static bool hasEqualOrGreaterPtx(int major, int minor);$/;"	p	class:cv::gpu::TargetArchs	access:public	signature:(int major, int minor)
hasEqualOrLessPtx	gpu/gpu.hpp	/^            static bool hasEqualOrLessPtx(int major, int minor);$/;"	p	class:cv::gpu::TargetArchs	access:public	signature:(int major, int minor)
hasPtx	gpu/gpu.hpp	/^            static bool hasPtx(int major, int minor);$/;"	p	class:cv::gpu::TargetArchs	access:public	signature:(int major, int minor)
has_type	flann/any.h	/^    bool has_type()$/;"	f	struct:cdiggins::any	access:public	signature:()
hash	core/core.hpp	/^    size_t hash(const int* idx) const;$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx) const
hash	core/core.hpp	/^    size_t hash(int i0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0) const
hash	core/core.hpp	/^    size_t hash(int i0, int i1) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1) const
hash	core/core.hpp	/^    size_t hash(int i0, int i1, int i2) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2) const
hash	core/mat.hpp	/^inline size_t SparseMat::hash(const int* idx) const$/;"	f	class:cv::SparseMat	signature:(const int* idx) const
hash	core/mat.hpp	/^inline size_t SparseMat::hash(int i0) const$/;"	f	class:cv::SparseMat	signature:(int i0) const
hash	core/mat.hpp	/^inline size_t SparseMat::hash(int i0, int i1) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1) const
hash	core/mat.hpp	/^inline size_t SparseMat::hash(int i0, int i1, int i2) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, int i2) const
hash	features2d/features2d.hpp	/^    size_t hash() const;$/;"	p	class:cv::KeyPoint	access:public	signature:() const
hash_insert	imgproc/imgproc.hpp	/^  virtual void hash_insert(lsh_hash h, int l, int i) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(lsh_hash h, int l, int i)
hash_lookup	imgproc/imgproc.hpp	/^  virtual int hash_lookup(lsh_hash h, int l, int* ret_i, int ret_i_max) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(lsh_hash h, int l, int* ret_i, int ret_i_max)
hash_remove	imgproc/imgproc.hpp	/^  virtual void hash_remove(lsh_hash h, int l, int i) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(lsh_hash h, int l, int i)
hashidx	core/core.hpp	/^    size_t hashidx;$/;"	m	class:cv::SparseMatConstIterator	access:public
hashsize	core/types_c.h	/^    int hashsize;$/;"	m	struct:CvSparseMat	access:public
hashtab	core/core.hpp	/^        vector<size_t> hashtab;$/;"	m	struct:cv::SparseMat::Hdr	access:public
hashtable	core/types_c.h	/^    void** hashtable;$/;"	m	struct:CvSparseMat	access:public
hashval	core/core.hpp	/^        size_t hashval;$/;"	m	struct:cv::SparseMat::Node	access:public
hashval	core/types_c.h	/^    unsigned hashval;$/;"	m	struct:CvSparseNode	access:public
hashval	core/types_c.h	/^    unsigned hashval;$/;"	m	struct:CvStringHashNode	access:public
have_active_cat_vars	ml/ml.hpp	/^    bool have_active_cat_vars;$/;"	m	class:CvBoost	access:protected
have_labels	ml/ml.hpp	/^    bool have_labels, have_priors;$/;"	m	struct:CvDTreeTrainData	access:public
have_priors	ml/ml.hpp	/^    bool have_labels, have_priors;$/;"	m	struct:CvDTreeTrainData	access:public
have_subsample	ml/ml.hpp	/^    bool have_subsample;$/;"	m	class:CvBoost	access:protected
hconcat	core/core.hpp	/^CV_EXPORTS void hconcat(InputArray src1, InputArray src2, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst)
hconcat	core/core.hpp	/^CV_EXPORTS void hconcat(const Mat* src, size_t nsrc, OutputArray dst);$/;"	p	namespace:cv	signature:(const Mat* src, size_t nsrc, OutputArray dst)
hconcat	core/core.hpp	/^CV_EXPORTS_W void hconcat(InputArray src, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst)
hdr	core/core.hpp	/^    Hdr* hdr;$/;"	m	class:cv::SparseMat	access:public
hdr	core/core_c.h	/^    CvMatND* hdr[CV_MAX_ARR]; \/* pointers to the headers of the$/;"	m	struct:CvNArrayIterator	access:public
hdr	core/operations.hpp	/^    Hdr hdr;$/;"	m	class:cv::Vector	access:protected
hdr_refcount	core/types_c.h	/^    int hdr_refcount;$/;"	m	struct:CvMat	access:public
hdr_refcount	core/types_c.h	/^    int hdr_refcount;$/;"	m	struct:CvMatND	access:public
hdr_refcount	core/types_c.h	/^    int hdr_refcount;$/;"	m	struct:CvSparseMat	access:public
header_	core/wimage.hpp	/^    IplImage header_;$/;"	m	class:cv::WImageView	access:protected
header_	core/wimage.hpp	/^    IplImage header_;$/;"	m	class:cv::WImageViewC	access:protected
header_size	core/types_c.h	/^    int header_size;$/;"	m	struct:CvTypeInfo	access:public
heap	core/types_c.h	/^    struct CvSet* heap;$/;"	m	struct:CvSparseMat	typeref:struct:CvSparseMat::CvSet	access:public
heap	flann/heap.h	/^    std::vector<T> heap;$/;"	m	class:cvflann::Heap	access:private
height	contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
height	core/core.hpp	/^    _Tp width, height; \/\/ the width and the height$/;"	m	class:cv::Size_	access:public
height	core/core.hpp	/^    _Tp x, y, width, height; \/\/< the top-left corner, as well as width and height of the rectangle$/;"	m	class:cv::Rect_	access:public
height	core/types_c.h	/^        int height;$/;"	m	union:CvMat::__anon152	access:public
height	core/types_c.h	/^    float height;$/;"	m	struct:CvSize2D32f	access:public
height	core/types_c.h	/^    int  height;            \/* Image height in pixels.                          *\/$/;"	m	struct:_IplImage	access:public
height	core/types_c.h	/^    int  height;$/;"	m	struct:_IplROI	access:public
height	core/types_c.h	/^    int height;$/;"	m	struct:CvRect	access:public
height	core/types_c.h	/^    int height;$/;"	m	struct:__anon156	access:public
height	gpu/NCV.hpp	/^    Ncv32s height;     \/\/\/< Rectangle height.$/;"	m	struct:NcvRect32s	access:public
height	gpu/NCV.hpp	/^    Ncv32s height; \/\/\/< Rectangle height.$/;"	m	struct:NcvSize32s	access:public
height	gpu/NCV.hpp	/^    Ncv32u height() const {return this->_height;}$/;"	f	class:NCVMatrix	access:public	signature:() const
height	gpu/NCV.hpp	/^    Ncv32u height;     \/\/\/< Rectangle height.$/;"	m	struct:NcvRect32u	access:public
height	gpu/NCV.hpp	/^    Ncv32u height; \/\/\/< Rectangle height.$/;"	m	struct:NcvSize32u	access:public
height	gpu/NCV.hpp	/^    Ncv8u height;$/;"	m	struct:NcvRect8u	access:public
height	legacy/compat.hpp	/^    int     height;                 \/* height of the image  ( in pixels )               *\/$/;"	m	struct:_CvPixelPosition8u	access:public
height	legacy/compat.hpp	/^    int     height;$/;"	m	struct:_CvPixelPosition32f	access:public
height	legacy/compat.hpp	/^    int     height;$/;"	m	struct:_CvPixelPosition8s	access:public
height	legacy/legacy.hpp	/^    int height() const { return image ? image->height : 0; }$/;"	f	class:CvImage	access:public	signature:() const
hessian	features2d/features2d.hpp	/^    float        hessian;$/;"	m	struct:CvSURFPoint	access:public
hessianThreshold	features2d/features2d.hpp	/^    double hessianThreshold;$/;"	m	struct:CvSURFParams	access:public
hid_cascade	objdetect/objdetect.hpp	/^    CvHidHaarClassifierCascade* hid_cascade;$/;"	m	struct:CvHaarClassifierCascade	access:public
hierarchicalClustering	flann/flann.hpp	/^FLANN_DEPRECATED int hierarchicalClustering(const Mat& features, Mat& centers, const ::cvflann::IndexParams& params)$/;"	f	namespace:cv::flann	signature:(const Mat& features, Mat& centers, const ::cvflann::IndexParams& params)
hierarchicalClustering	flann/flann.hpp	/^int hierarchicalClustering(const Mat& features, Mat& centers, const ::cvflann::IndexParams& params,$/;"	f	namespace:cv::flann	signature:(const Mat& features, Mat& centers, const ::cvflann::IndexParams& params, Distance d = Distance())
hierarchicalClustering	flann/flann_base.hpp	/^int hierarchicalClustering(const Matrix<typename Distance::ElementType>& points, Matrix<typename Distance::ResultType>& centers,$/;"	f	namespace:cvflann	signature:(const Matrix<typename Distance::ElementType>& points, Matrix<typename Distance::ResultType>& centers, const KMeansIndexParams& params, Distance d = Distance())
high	flann/kdtree_single_index.h	/^        DistanceType low, high;$/;"	m	struct:cvflann::KDTreeSingleIndex::Interval	access:public
hist	imgproc/imgproc_c.h	/^CVAPI(void)  cvClearHist( CvHistogram* hist );$/;"	v
hist	imgproc/imgproc_c.h	/^CVAPI(void)  cvReleaseHist( CvHistogram** hist );$/;"	v
histEven	gpu/gpu.hpp	/^        CV_EXPORTS void histEven(const GpuMat& src, GpuMat hist[4], GpuMat& buf, int histSize[4], int lowerLevel[4], int upperLevel[4], Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat hist[4], GpuMat& buf, int histSize[4], int lowerLevel[4], int upperLevel[4], Stream& stream = Stream::Null())
histEven	gpu/gpu.hpp	/^        CV_EXPORTS void histEven(const GpuMat& src, GpuMat hist[4], int histSize[4], int lowerLevel[4], int upperLevel[4], Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat hist[4], int histSize[4], int lowerLevel[4], int upperLevel[4], Stream& stream = Stream::Null())
histEven	gpu/gpu.hpp	/^        CV_EXPORTS void histEven(const GpuMat& src, GpuMat& hist, GpuMat& buf, int histSize, int lowerLevel, int upperLevel, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& hist, GpuMat& buf, int histSize, int lowerLevel, int upperLevel, Stream& stream = Stream::Null())
histEven	gpu/gpu.hpp	/^        CV_EXPORTS void histEven(const GpuMat& src, GpuMat& hist, int histSize, int lowerLevel, int upperLevel, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& hist, int histSize, int lowerLevel, int upperLevel, Stream& stream = Stream::Null())
histRange	gpu/gpu.hpp	/^        CV_EXPORTS void histRange(const GpuMat& src, GpuMat hist[4], const GpuMat levels[4], GpuMat& buf, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat hist[4], const GpuMat levels[4], GpuMat& buf, Stream& stream = Stream::Null())
histRange	gpu/gpu.hpp	/^        CV_EXPORTS void histRange(const GpuMat& src, GpuMat hist[4], const GpuMat levels[4], Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat hist[4], const GpuMat levels[4], Stream& stream = Stream::Null())
histRange	gpu/gpu.hpp	/^        CV_EXPORTS void histRange(const GpuMat& src, GpuMat& hist, const GpuMat& levels, GpuMat& buf, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& hist, const GpuMat& levels, GpuMat& buf, Stream& stream = Stream::Null())
histRange	gpu/gpu.hpp	/^        CV_EXPORTS void histRange(const GpuMat& src, GpuMat& hist, const GpuMat& levels, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& hist, const GpuMat& levels, Stream& stream = Stream::Null())
histogramHueMotion	contrib/contrib.hpp	/^    Histogram histogramHueMotion, skinHueHistogram;$/;"	m	class:CvAdaptiveSkinDetector	access:private
histogramNormType	objdetect/objdetect.hpp	/^    CV_PROP int histogramNormType;$/;"	m	struct:cv::HOGDescriptor	access:public
history	video/background_segm.hpp	/^    int history;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
history	video/background_segm.hpp	/^    int history;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
hmm	legacy/legacy.hpp	/^CVAPI(void)  cvRelease2DHMM( CvEHMM** hmm );$/;"	v
horizontalEdgeBottom	contrib/contrib.hpp	/^        int verticalEdgeLeft, verticalEdgeRight, horizontalEdgeTop, horizontalEdgeBottom;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
horizontalEdgeTop	contrib/contrib.hpp	/^        int verticalEdgeLeft, verticalEdgeRight, horizontalEdgeTop, horizontalEdgeBottom;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
hscale	core/core_c.h	/^    float       hscale, vscale;$/;"	m	struct:CvFont	access:public
hu1	imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
hu2	imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
hu3	imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
hu4	imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
hu5	imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
hu6	imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
hu7	imgproc/types_c.h	/^    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; \/* Hu invariants *\/$/;"	m	struct:CvHuMoments	access:public
i	core/types_c.h	/^        int i;    \/* scalar integer number *\/$/;"	m	union:CvFileNode::__anon157	access:public
i	core/types_c.h	/^        int* i;$/;"	m	union:CvMat::__anon151	access:public
i	core/types_c.h	/^        int* i;$/;"	m	union:CvMatND::__anon154	access:public
i	core/types_c.h	/^    int i;$/;"	m	union:Cv32suf	access:public
i	core/types_c.h	/^    int64 i;$/;"	m	union:Cv64suf	access:public
i	ml/ml.hpp	/^    int* i;$/;"	m	struct:CvPair16u32s	access:public
iInput	contrib/contrib.hpp	/^        CvFuzzyFunction iInput, iOutput;$/;"	m	class:CvFuzzyMeanShiftTracker::FuzzyResizer	access:private
iOutput	contrib/contrib.hpp	/^        CvFuzzyFunction iInput, iOutput;$/;"	m	class:CvFuzzyMeanShiftTracker::FuzzyResizer	access:private
icvSqDist2D32f	legacy/legacy.hpp	/^CV_INLINE double icvSqDist2D32f( CvPoint2D32f pt1, CvPoint2D32f pt2 )$/;"	f	signature:( CvPoint2D32f pt1, CvPoint2D32f pt2 )
id	legacy/legacy.hpp	/^    int id;$/;"	m	struct:__anon185	access:public
id	legacy/legacy.hpp	/^    int id;$/;"	m	struct:__anon186	access:public
idct	core/core.hpp	/^CV_EXPORTS_W void idct(InputArray src, OutputArray dst, int flags=0);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, int flags=0)
idft	core/core.hpp	/^CV_EXPORTS_W void idft(InputArray src, OutputArray dst, int flags=0, int nonzeroRows=0);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, int flags=0, int nonzeroRows=0)
idx	core/core.hpp	/^        int idx;$/;"	m	struct:cv::KDTree::Node	access:public
idx	core/core.hpp	/^        int idx[CV_MAX_DIM];$/;"	m	struct:cv::SparseMat::Node	access:public
idx	core/core.hpp	/^    int idx;$/;"	m	class:cv::MatxCommaInitializer	access:public
idx	core/core.hpp	/^    size_t idx;$/;"	m	class:cv::NAryMatIterator	access:protected
idxoffset	core/types_c.h	/^    int idxoffset;$/;"	m	struct:CvSparseMat	access:public
im	core/core.hpp	/^    _Tp re, im; \/\/< the real and the imaginary parts$/;"	m	class:cv::Complex	access:public
image	core/core_c.h	/^CVAPI(CvRect) cvGetImageROI( const IplImage* image );$/;"	v
image	core/core_c.h	/^CVAPI(IplImage*) cvCloneImage( const IplImage* image );$/;"	v
image	core/core_c.h	/^CVAPI(int)  cvGetImageCOI( const IplImage* image );$/;"	v
image	core/core_c.h	/^CVAPI(void)  cvReleaseImage( IplImage** image );$/;"	v
image	core/core_c.h	/^CVAPI(void)  cvReleaseImageHeader( IplImage** image );$/;"	v
image	core/core_c.h	/^CVAPI(void)  cvResetImageROI( IplImage* image );$/;"	v
image	features2d/features2d.hpp	/^  IplImage* image;$/;"	m	struct:cv::BaseKeypoint	access:public
image	legacy/legacy.hpp	/^    IplImage* image;$/;"	m	class:CvImage	access:protected
imageCount	features2d/features2d.hpp	/^        size_t imageCount() const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:() const
imageData	core/types_c.h	/^    char *imageData;        \/* Pointer to aligned image data.         *\/$/;"	m	struct:_IplImage	access:public
imageDataOrigin	core/types_c.h	/^    char *imageDataOrigin;  \/* Pointer to very origin of image data$/;"	m	struct:_IplImage	access:public
imageId	core/types_c.h	/^    void  *imageId;                 \/* "           " *\/$/;"	m	struct:_IplImage	access:public
imageSize	core/types_c.h	/^    int  imageSize;         \/* Image data size in bytes$/;"	m	struct:_IplImage	access:public
imageWidth	contrib/contrib.hpp	/^        int imageWidth;$/;"	m	class:cv::SpinImageModel	access:public
image_	core/wimage.hpp	/^    IplImage* image_;$/;"	m	class:cv::WImage	access:protected
image_block	gpu/gpu.hpp	/^            GpuMat image_block, templ_block, result_data;$/;"	m	struct:cv::gpu::ConvolveBuf	access:private
image_scales	gpu/gpu.hpp	/^			std::vector<GpuMat> image_scales;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
image_spect	gpu/gpu.hpp	/^            GpuMat image_spect, templ_spect, result_spect;$/;"	m	struct:cv::gpu::ConvolveBuf	access:private
image_type	gpu/gpu.hpp	/^            int image_type;$/;"	m	struct:cv::gpu::PyrDownBuf	access:private
image_type	gpu/gpu.hpp	/^            int image_type;$/;"	m	struct:cv::gpu::PyrUpBuf	access:private
images	features2d/features2d.hpp	/^        vector<Mat> images;$/;"	m	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:protected
imax	legacy/legacy.hpp	/^    int imax, imin;$/;"	m	struct:CvContourOrientation	access:public
imdecode	highgui/highgui.hpp	/^CV_EXPORTS_W Mat imdecode( InputArray buf, int flags );$/;"	p	namespace:cv	signature:( InputArray buf, int flags )
imencode	highgui/highgui.hpp	/^CV_EXPORTS_W bool imencode( const string& ext, InputArray img,$/;"	p	namespace:cv	signature:( const string& ext, InputArray img, vector<uchar>& buf, const vector<int>& params=vector<int>())
img	legacy/legacy.hpp	/^CVAPI(void)  cvDeleteMoire( IplImage*  img );$/;"	v
imgFilteredFrame	contrib/contrib.hpp	/^    IplImage *imgHueFrame, *imgSaturationFrame, *imgLastGrayFrame, *imgMotionFrame, *imgFilteredFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
imgGrayFrame	contrib/contrib.hpp	/^    IplImage *imgShrinked, *imgTemp, *imgGrayFrame, *imgHSVFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
imgHSVFrame	contrib/contrib.hpp	/^    IplImage *imgShrinked, *imgTemp, *imgGrayFrame, *imgHSVFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
imgHueFrame	contrib/contrib.hpp	/^    IplImage *imgHueFrame, *imgSaturationFrame, *imgLastGrayFrame, *imgMotionFrame, *imgFilteredFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
imgIdx	features2d/features2d.hpp	/^    int imgIdx;   \/\/ train image index$/;"	m	struct:cv::DMatch	access:public
imgLastGrayFrame	contrib/contrib.hpp	/^    IplImage *imgHueFrame, *imgSaturationFrame, *imgLastGrayFrame, *imgMotionFrame, *imgFilteredFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
imgMotionFrame	contrib/contrib.hpp	/^    IplImage *imgHueFrame, *imgSaturationFrame, *imgLastGrayFrame, *imgMotionFrame, *imgFilteredFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
imgSaturationFrame	contrib/contrib.hpp	/^    IplImage *imgHueFrame, *imgSaturationFrame, *imgLastGrayFrame, *imgMotionFrame, *imgFilteredFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
imgShrinked	contrib/contrib.hpp	/^    IplImage *imgShrinked, *imgTemp, *imgGrayFrame, *imgHSVFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
imgSize	legacy/legacy.hpp	/^    CvSize  imgSize;$/;"	m	class:CvCalibFilter	access:protected
imgSize	legacy/legacy.hpp	/^    float   imgSize[2]; \/* size of the camera view, used during calibration *\/$/;"	m	struct:CvCamera	access:public
imgTemp	contrib/contrib.hpp	/^    IplImage *imgShrinked, *imgTemp, *imgGrayFrame, *imgHSVFrame;$/;"	m	class:CvAdaptiveSkinDetector	access:private
imin	legacy/legacy.hpp	/^    int imax, imin;$/;"	m	struct:CvContourOrientation	access:public
impl	gpu/gpu.hpp	/^            CascadeClassifierImpl* impl;$/;"	m	class:cv::gpu::CascadeClassifier_GPU	access:private
impl	gpu/gpu.hpp	/^            Impl *impl;$/;"	m	class:cv::gpu::Stream	access:private
impl	legacy/blobtrack.hpp	/^    class CvObjectDetectorImpl* impl;$/;"	m	class:CvObjectDetector	typeref:class:CvObjectDetector::CvObjectDetectorImpl	access:protected
imread	highgui/highgui.hpp	/^CV_EXPORTS_W Mat imread( const string& filename, int flags=1 );$/;"	p	namespace:cv	signature:( const string& filename, int flags=1 )
imshow	highgui/highgui.hpp	/^CV_EXPORTS_W void imshow( const string& winname, InputArray mat );$/;"	p	namespace:cv	signature:( const string& winname, InputArray mat )
imwrite	highgui/highgui.hpp	/^CV_EXPORTS_W bool imwrite( const string& filename, InputArray img,$/;"	p	namespace:cv	signature:( const string& filename, InputArray img, const vector<int>& params=vector<int>())
inRange	core/core.hpp	/^CV_EXPORTS_W void inRange(InputArray src, InputArray lowerb,$/;"	p	namespace:cv	signature:(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst)
index	core/core.hpp	/^    int index;$/;"	m	class:cv::SeqIterator	access:public
index	core/core.hpp	/^    size_t index(const _Tp& elem) const;$/;"	p	class:cv::Seq	access:public	signature:(const _Tp& elem) const
index	core/core_c.h	/^    int      index;        \/* the lower bound of certainly visited vertices *\/$/;"	m	struct:CvGraphScanner	access:public
index	core/operations.hpp	/^template<typename _Tp> inline size_t Seq<_Tp>::index(const _Tp& elem) const$/;"	f	class:cv::Seq	signature:(const _Tp& elem) const
index	flann/miniflann.hpp	/^    void* index;$/;"	m	class:cv::flann::Index	access:protected
index1	legacy/legacy.hpp	/^    int index1;$/;"	m	struct:CvLCMEdge	access:public
index2	legacy/legacy.hpp	/^    int index2;$/;"	m	struct:CvLCMEdge	access:public
indexParams	features2d/features2d.hpp	/^    Ptr<flann::IndexParams> indexParams;$/;"	m	class:cv::FlannBasedMatcher	access:protected
index_	flann/result_set.h	/^        unsigned int index_;$/;"	m	struct:cvflann::UniqueResultSet::DistIndex	access:public
index_creator	flann/all_indices.h	/^struct index_creator$/;"	s	namespace:cvflann
index_creator	flann/all_indices.h	/^struct index_creator<False,False,Distance>$/;"	s	namespace:cvflann
index_creator	flann/all_indices.h	/^struct index_creator<False,VectorSpace,Distance>$/;"	s	namespace:cvflann
index_params_	flann/composite_index.h	/^    const IndexParams index_params_;$/;"	m	class:cvflann::CompositeIndex	access:private
index_params_	flann/flann_base.hpp	/^    IndexParams index_params_;$/;"	m	class:cvflann::Index	access:private
index_params_	flann/kdtree_index.h	/^    IndexParams index_params_;$/;"	m	class:cvflann::KDTreeIndex	access:private
index_params_	flann/kdtree_single_index.h	/^    IndexParams index_params_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
index_params_	flann/kmeans_index.h	/^    IndexParams index_params_;$/;"	m	class:cvflann::KMeansIndex	access:private
index_params_	flann/linear_index.h	/^    IndexParams index_params_;$/;"	m	class:cvflann::LinearIndex	access:private
index_params_	flann/lsh_index.h	/^    IndexParams index_params_;$/;"	m	class:cvflann::LshIndex	access:private
index_type	flann/saving.h	/^    flann_algorithm_t index_type;$/;"	m	struct:cvflann::IndexHeader	access:public
indices	flann/hierarchical_clustering_index.h	/^        int* indices;$/;"	m	struct:cvflann::HierarchicalClusteringIndex::Node	access:public
indices	flann/hierarchical_clustering_index.h	/^    int** indices;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
indices	flann/kmeans_index.h	/^        int* indices;$/;"	m	struct:cvflann::KMeansIndex::KMeansNode	access:public
indices	flann/result_set.h	/^    int* indices;$/;"	m	class:cvflann::KNNResultSet	access:private
indices	flann/result_set.h	/^    int* indices;$/;"	m	class:cvflann::KNNSimpleResultSet	access:private
indices	flann/result_set.h	/^    int* indices;$/;"	m	class:cvflann::RadiusResultSet	access:private
indices_	flann/kmeans_index.h	/^    int* indices_;$/;"	m	class:cvflann::KMeansIndex	access:private
info	core/core_c.h	/^    CvModuleInfo* info;$/;"	m	struct:CvModule	access:public
info	core/core_c.h	/^    CvTypeInfo* info;$/;"	m	struct:CvType	access:public
info	core/core_c.h	/^CVAPI(void) cvRegisterType( const CvTypeInfo* info );$/;"	v
info	core/types_c.h	/^    struct CvTypeInfo* info; \/* type information$/;"	m	struct:CvFileNode	typeref:struct:CvFileNode::CvTypeInfo	access:public
init	calib3d/calib3d.hpp	/^    void init( int nparams, int nerrs, CvTermCriteria criteria=$/;"	p	class:CvLevMarq	access:public	signature:( int nparams, int nerrs, CvTermCriteria criteria= cvTermCriteria(CV_TERMCRIT_EPS+CV_TERMCRIT_ITER,30,DBL_EPSILON), bool completeSymmFlag=false )
init	calib3d/calib3d.hpp	/^    void init(int preset, int ndisparities=0, int SADWindowSize=21);$/;"	p	class:cv::StereoBM	access:public	signature:(int preset, int ndisparities=0, int SADWindowSize=21)
init	core/core.hpp	/^    void init(const Mat** arrays, Mat* planes, uchar** ptrs, int narrays=-1);$/;"	p	class:cv::NAryMatIterator	access:public	signature:(const Mat** arrays, Mat* planes, uchar** ptrs, int narrays=-1)
init	features2d/features2d.hpp	/^  void init(int classes, int depth, RNG &rng);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int classes, int depth, RNG &rng)
init	flann/random.h	/^    void init(int n)$/;"	f	class:cvflann::UniqueRandom	access:public	signature:(int n)
init	flann/result_set.h	/^    void init()$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:()
init	flann/result_set.h	/^    void init(int* indices_, DistanceType* dists_)$/;"	f	class:cvflann::KNNResultSet	access:public	signature:(int* indices_, DistanceType* dists_)
init	flann/result_set.h	/^    void init(int* indices_, DistanceType* dists_)$/;"	f	class:cvflann::KNNSimpleResultSet	access:public	signature:(int* indices_, DistanceType* dists_)
init	imgproc/imgproc.hpp	/^    void init(const Ptr<BaseFilter>& _filter2D,$/;"	p	class:cv::FilterEngine	access:public	signature:(const Ptr<BaseFilter>& _filter2D, const Ptr<BaseRowFilter>& _rowFilter, const Ptr<BaseColumnFilter>& _columnFilter, int srcType, int dstType, int bufType, int _rowBorderType=BORDER_REPLICATE, int _columnBorderType=-1, const Scalar& _borderValue=Scalar())
init	video/tracking.hpp	/^    void init(int dynamParams, int measureParams, int controlParams=0, int type=CV_32F);$/;"	p	class:cv::KalmanFilter	access:public	signature:(int dynamParams, int measureParams, int controlParams=0, int type=CV_32F)
initCameraMatrix2D	calib3d/calib3d.hpp	/^CV_EXPORTS_W Mat initCameraMatrix2D( InputArrayOfArrays objectPoints,$/;"	p	namespace:cv	signature:( InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, double aspectRatio=1. )
initData	contrib/contrib.hpp	/^    void initData(IplImage *src, int widthDivider, int heightDivider);$/;"	p	class:CvAdaptiveSkinDetector	access:protected	signature:(IplImage *src, int widthDivider, int heightDivider)
initDelaunay	imgproc/imgproc.hpp	/^    CV_WRAP void initDelaunay(Rect rect);$/;"	p	class:cv::Subdiv2D	access:public	signature:(Rect rect)
initDepthValues	contrib/contrib.hpp	/^        void initDepthValues(IplImage *maskImage, IplImage *depthMap);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(IplImage *maskImage, IplImage *depthMap)
initFeatureScale	features2d/features2d.hpp	/^        float initFeatureScale;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
initImgBound	features2d/features2d.hpp	/^        int initImgBound;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
initUndistortRectifyMap	imgproc/imgproc.hpp	/^CV_EXPORTS_W void initUndistortRectifyMap( InputArray cameraMatrix, InputArray distCoeffs,$/;"	p	namespace:cv	signature:( InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2 )
initWideAngleProjMap	imgproc/imgproc.hpp	/^CV_EXPORTS_W float initWideAngleProjMap( InputArray cameraMatrix, InputArray distCoeffs,$/;"	p	namespace:cv	signature:( InputArray cameraMatrix, InputArray distCoeffs, Size imageSize, int destImageWidth, int m1type, OutputArray map1, OutputArray map2, int projType=PROJ_SPHERICAL_EQRECT, double alpha=0)
initXyStep	features2d/features2d.hpp	/^        int initXyStep;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
init_auto	ml/ml.hpp	/^    virtual void init_auto( const CvVectors& samples );$/;"	p	class:CvEM	access:protected	signature:( const CvVectors& samples )
init_em	ml/ml.hpp	/^    virtual void init_em( const CvVectors& train_data );$/;"	p	class:CvEM	access:protected	signature:( const CvVectors& train_data )
init_thresh_	features2d/features2d.hpp	/^    double thresh_, init_thresh_, min_thresh_, max_thresh_;$/;"	m	class:cv::StarAdjuster	access:protected
init_thresh_	features2d/features2d.hpp	/^    double thresh_, init_thresh_, min_thresh_, max_thresh_;$/;"	m	class:cv::SurfAdjuster	access:protected
init_thresh_	features2d/features2d.hpp	/^    int init_thresh_, min_thresh_, max_thresh_;$/;"	m	class:cv::FastAdjuster	access:protected
init_weights	ml/ml.hpp	/^    virtual void init_weights();$/;"	p	class:CvANN_MLP	access:protected	signature:()
initialize	features2d/features2d.hpp	/^    void initialize( const Params& params, const Ptr<OneWayDescriptorBase>& base=Ptr<OneWayDescriptorBase>() );$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:( const Params& params, const Ptr<OneWayDescriptorBase>& base=Ptr<OneWayDescriptorBase>() )
initialize	flann/lsh_table.h	/^    void initialize(size_t key_size)$/;"	f	class:cvflann::lsh::LshTable	access:private	signature:(size_t key_size)
initialize	video/background_segm.hpp	/^    virtual void initialize(Size frameSize, int frameType);$/;"	p	class:cv::BackgroundSubtractorMOG	access:public	signature:(Size frameSize, int frameType)
initialize	video/background_segm.hpp	/^    virtual void initialize(Size frameSize, int frameType);$/;"	p	class:cv::BackgroundSubtractorMOG2	access:public	signature:(Size frameSize, int frameType)
inpaint	imgproc/imgproc.hpp	/^CV_EXPORTS_W void inpaint( InputArray src, InputArray inpaintMask,$/;"	p	namespace:cv	signature:( InputArray src, InputArray inpaintMask, OutputArray dst, double inpaintRange, int flags )
insert	core/core.hpp	/^    void insert(int idx, const _Tp& elem);$/;"	p	class:cv::Seq	access:public	signature:(int idx, const _Tp& elem)
insert	core/core.hpp	/^    void insert(int idx, const _Tp* elems, size_t count);$/;"	p	class:cv::Seq	access:public	signature:(int idx, const _Tp* elems, size_t count)
insert	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::insert(int idx, const _Tp& elem)$/;"	f	class:cv::Seq	signature:(int idx, const _Tp& elem)
insert	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::insert(int idx, const _Tp* elems, size_t count)$/;"	f	class:cv::Seq	signature:(int idx, const _Tp* elems, size_t count)
insert	flann/heap.h	/^    void insert(T value)$/;"	f	class:cvflann::Heap	access:public	signature:(T value)
insert	imgproc/imgproc.hpp	/^    CV_WRAP int insert(Point2f pt);$/;"	p	class:cv::Subdiv2D	access:public	signature:(Point2f pt)
insert	imgproc/imgproc.hpp	/^    CV_WRAP void insert(const vector<Point2f>& ptvec);$/;"	p	class:cv::Subdiv2D	access:public	signature:(const vector<Point2f>& ptvec)
insertChannel	core/core.hpp	/^CV_EXPORTS_W void insertChannel(InputArray src, InputOutputArray dst, int coi);$/;"	p	namespace:cv	signature:(InputArray src, InputOutputArray dst, int coi)
insertImageCOI	core/core.hpp	/^CV_EXPORTS void insertImageCOI(InputArray coiimg, CvArr* arr, int coi=-1);  $/;"	p	namespace:cv	signature:(InputArray coiimg, CvArr* arr, int coi=-1)
inside	core/core.hpp	/^    bool inside(const Rect_<_Tp>& r) const;$/;"	p	class:cv::Point_	access:public	signature:(const Rect_<_Tp>& r) const
inside	core/operations.hpp	/^template<typename _Tp> inline bool Point_<_Tp>::inside( const Rect_<_Tp>& r ) const$/;"	f	class:cv::Point_	signature:( const Rect_<_Tp>& r ) const
instance	flann/logger.h	/^    static Logger& instance()$/;"	f	class:cvflann::Logger	access:private	signature:()
instance	flann/object_factory.h	/^    static ThisClass& instance()$/;"	f	class:cvflann::ObjectFactory	access:public	signature:()
int64	core/types_c.h	/^typedef __int64 int64;$/;"	t
int64	core/types_c.h	/^typedef int64_t int64;$/;"	t
intBuffer	gpu/gpu.hpp	/^            GpuMat sum, mask1, maskSum, intBuffer;$/;"	m	class:cv::gpu::SURF_GPU	access:public
integral	gpu/gpu.hpp	/^        CV_EXPORTS void integral(const GpuMat& src, GpuMat& sum, GpuMat& sqsum, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& sum, GpuMat& sqsum, Stream& stream = Stream::Null())
integral	gpu/gpu.hpp	/^        CV_EXPORTS void integral(const GpuMat& src, GpuMat& sum, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& sum, Stream& stream = Stream::Null())
integral	imgproc/imgproc.hpp	/^CV_EXPORTS_AS(integral2) void integral( InputArray src, OutputArray sum,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray sum, OutputArray sqsum, int sdepth=-1 )
integral	imgproc/imgproc.hpp	/^CV_EXPORTS_AS(integral3) void integral( InputArray src, OutputArray sum,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray sum, OutputArray sqsum, OutputArray tilted, int sdepth=-1 )
integral	imgproc/imgproc.hpp	/^CV_EXPORTS_W void integral( InputArray src, OutputArray sum, int sdepth=-1 );$/;"	p	namespace:cv	signature:( InputArray src, OutputArray sum, int sdepth=-1 )
integralBuffered	gpu/gpu.hpp	/^        CV_EXPORTS void integralBuffered(const GpuMat& src, GpuMat& sum, GpuMat& buffer, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& sum, GpuMat& buffer, Stream& stream = Stream::Null())
integral_image_steps_	features2d/features2d.hpp	/^  std::vector<size_t> integral_image_steps_;$/;"	m	class:cv::ORB	access:private
interactionRadius	calib3d/calib3d.hpp	/^    int interactionRadius;$/;"	m	struct:CvStereoGCState	access:public
inv	core/core.hpp	/^    MatExpr inv(int method=DECOMP_LU) const;$/;"	p	class:cv::Mat	access:public	signature:(int method=DECOMP_LU) const
inv	core/core.hpp	/^    Matx<_Tp, n, m> inv(int method=DECOMP_LU) const;$/;"	p	class:cv::Matx	access:public	signature:(int method=DECOMP_LU) const
inv	core/mat.hpp	/^    MatExpr inv(int method = DECOMP_LU) const;$/;"	p	class:cv::MatExpr	access:public	signature:(int method = DECOMP_LU) const
inv	core/operations.hpp	/^Matx<_Tp, n, m> Matx<_Tp, m, n>::inv(int method) const$/;"	f	class:cv::Matx	signature:(int method) const
inv_V_star	contrib/contrib.hpp	/^        CvMat** inv_V_star; \/\/inverse of V*$/;"	m	class:cv::LevMarqSparse	access:public
inv_eigen_values	ml/ml.hpp	/^    CvMat* inv_eigen_values;$/;"	m	class:CvEM	access:protected
inv_eigen_values	ml/ml.hpp	/^    CvMat** inv_eigen_values;$/;"	m	class:CvNormalBayesClassifier	access:protected
inv_sqrt_m00	imgproc/types_c.h	/^    double  inv_sqrt_m00; \/* m00 != 0 ? 1\/sqrt(m00) : 0 *\/$/;"	m	struct:CvMoments	access:public
inv_var	legacy/legacy.hpp	/^    float* inv_var;     \/* square root of inversed variances corresp. to each mixture*\/$/;"	m	struct:CvEHMMState	access:public
inversed	ml/ml.hpp	/^    int inversed;$/;"	m	struct:CvDTreeSplit	access:public
invert	core/core.hpp	/^CV_EXPORTS_W double invert(InputArray src, OutputArray dst, int flags=DECOMP_LU);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, int flags=DECOMP_LU)
invert	core/mat.hpp	/^    virtual void invert(const MatExpr& expr, int method, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, int method, MatExpr& res) const
invertAffineTransform	imgproc/imgproc.hpp	/^CV_EXPORTS_W void invertAffineTransform( InputArray M, OutputArray iM );$/;"	p	namespace:cv	signature:( InputArray M, OutputArray iM )
iplHeight	legacy/legacy.hpp	/^CV_INLINE int iplHeight( const IplImage* img )$/;"	f	signature:( const IplImage* img )
iplWidth	legacy/legacy.hpp	/^CV_INLINE int iplWidth( const IplImage* img )$/;"	f	signature:( const IplImage* img )
ippiSize	core/internal.hpp	/^CV_INLINE IppiSize ippiSize(int width, int height)$/;"	f	signature:(int width, int height)
isCalibrated	legacy/legacy.hpp	/^    bool    isCalibrated;$/;"	m	class:CvCalibFilter	access:protected
isCompatible	gpu/gpu.hpp	/^            bool isCompatible() const;$/;"	p	class:cv::gpu::DeviceInfo	access:public	signature:() const
isContinuous	core/core.hpp	/^    bool isContinuous() const;$/;"	p	class:cv::Mat	access:public	signature:() const
isContinuous	core/mat.hpp	/^inline bool Mat::isContinuous() const { return (flags & CONTINUOUS_FLAG) != 0; }$/;"	f	class:cv::Mat	signature:() const
isContinuous	gpu/gpu.hpp	/^            bool isContinuous() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
isContinuous	gpu/gpumat.hpp	/^        bool isContinuous() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
isContinuous	gpu/matrix_operations.hpp	/^inline bool CudaMem::isContinuous() const { return (flags & Mat::CONTINUOUS_FLAG) != 0; }$/;"	f	class:cv::gpu::CudaMem	signature:() const
isContourConvex	imgproc/imgproc.hpp	/^CV_EXPORTS_W bool isContourConvex( InputArray contour );$/;"	p	namespace:cv	signature:( InputArray contour )
isCounting	gpu/NCV.hpp	/^    virtual NcvBool isCounting(void) const = 0;$/;"	p	class:INCVMemAllocator	access:public	signature:(void) const
isCounting	gpu/NCV.hpp	/^    virtual NcvBool isCounting(void) const;$/;"	p	class:NCVMemNativeAllocator	access:public	signature:(void) const
isCounting	gpu/NCV.hpp	/^    virtual NcvBool isCounting(void) const;$/;"	p	class:NCVMemStackAllocator	access:public	signature:(void) const
isInitialized	gpu/NCV.hpp	/^    virtual NcvBool isInitialized(void) const = 0;$/;"	p	class:INCVMemAllocator	access:public	signature:(void) const
isInitialized	gpu/NCV.hpp	/^    virtual NcvBool isInitialized(void) const;$/;"	p	class:NCVMemNativeAllocator	access:public	signature:(void) const
isInitialized	gpu/NCV.hpp	/^    virtual NcvBool isInitialized(void) const;$/;"	p	class:NCVMemStackAllocator	access:public	signature:(void) const
isInstance	core/operations.hpp	/^    static int isInstance(const void* ptr)$/;"	f	struct:cv::RTTIImpl	access:public	signature:(const void* ptr)
isInt	core/core.hpp	/^    CV_WRAP bool isInt() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
isInt	core/operations.hpp	/^inline bool FileNode::isInt() const { return type() == INT; }$/;"	f	class:cv::FileNode	signature:() const
isLeaf	contrib/contrib.hpp	/^            bool isLeaf;$/;"	m	struct:cv::Octree::Node	access:public
isMap	core/core.hpp	/^    CV_WRAP bool isMap() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
isMap	core/operations.hpp	/^inline bool FileNode::isMap() const { return type() == MAP; }$/;"	f	class:cv::FileNode	signature:() const
isMaskSupported	features2d/features2d.hpp	/^    virtual bool isMaskSupported() = 0;$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:()
isMaskSupported	features2d/features2d.hpp	/^    virtual bool isMaskSupported() const = 0;$/;"	p	class:cv::DescriptorMatcher	access:public	signature:() const
isMaskSupported	features2d/features2d.hpp	/^    virtual bool isMaskSupported() const { return true; }$/;"	f	class:cv::BruteForceMatcher	access:public	signature:() const
isMaskSupported	features2d/features2d.hpp	/^    virtual bool isMaskSupported() const;$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:() const
isMaskSupported	features2d/features2d.hpp	/^    virtual bool isMaskSupported();$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:()
isMaskSupported	features2d/features2d.hpp	/^    virtual bool isMaskSupported();$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:()
isMaskSupported	features2d/features2d.hpp	/^    virtual bool isMaskSupported();$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:()
isMaskSupported	gpu/gpu.hpp	/^            bool isMaskSupported() const;$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:() const
isMaskedOut	features2d/features2d.hpp	/^    static bool isMaskedOut( const vector<Mat>& masks, int queryIdx );$/;"	p	class:cv::DescriptorMatcher	access:protected	signature:( const vector<Mat>& masks, int queryIdx )
isMemAllocated	gpu/NCV.hpp	/^    NcvBool isMemAllocated() const$/;"	f	class:NCVMatrixAlloc	access:public	signature:() const
isMemAllocated	gpu/NCV.hpp	/^    NcvBool isMemAllocated() const$/;"	f	class:NCVVectorAlloc	access:public	signature:() const
isMemReused	gpu/NCV.hpp	/^    NcvBool isMemReused() const$/;"	f	class:NCVMatrixReuse	access:public	signature:() const
isMemReused	gpu/NCV.hpp	/^    NcvBool isMemReused() const$/;"	f	class:NCVVectorReuse	access:public	signature:() const
isNamed	core/core.hpp	/^    CV_WRAP bool isNamed() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
isNamed	core/operations.hpp	/^inline bool FileNode::isNamed() const { return !node ? false : (node->tag & NAMED) != 0; }$/;"	f	class:cv::FileNode	signature:() const
isNone	core/core.hpp	/^    CV_WRAP bool isNone() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
isNone	core/operations.hpp	/^inline bool FileNode::isNone() const { return type() == NONE; }$/;"	f	class:cv::FileNode	signature:() const
isNormalize	features2d/features2d.hpp	/^        bool isNormalize; \/\/ it is not used now (true always)$/;"	m	struct:cv::SIFT::DescriptorParams	access:public
isOldFormatCascade	objdetect/objdetect.hpp	/^    bool isOldFormatCascade() const;$/;"	p	class:cv::CascadeClassifier	access:public	signature:() const
isOpened	core/core.hpp	/^    CV_WRAP virtual bool isOpened() const;$/;"	p	class:cv::FileStorage	access:public	signature:() const
isOpened	highgui/highgui.hpp	/^    CV_WRAP virtual bool isOpened() const;$/;"	p	class:cv::VideoCapture	access:public	signature:() const
isOpened	highgui/highgui.hpp	/^    CV_WRAP virtual bool isOpened() const;$/;"	p	class:cv::VideoWriter	access:public	signature:() const
isPossibleMatch	features2d/features2d.hpp	/^    static bool isPossibleMatch( const Mat& mask, int queryIdx, int trainIdx );$/;"	p	class:cv::DescriptorMatcher	access:protected	signature:( const Mat& mask, int queryIdx, int trainIdx )
isReal	core/core.hpp	/^    CV_WRAP bool isReal() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
isReal	core/core.hpp	/^    bool isReal() const;$/;"	p	class:cv::Scalar_	access:public	signature:() const
isReal	core/operations.hpp	/^inline bool FileNode::isReal() const { return type() == REAL; }$/;"	f	class:cv::FileNode	signature:() const
isReal	core/operations.hpp	/^template<typename _Tp> inline bool Scalar_<_Tp>::isReal() const$/;"	f	class:cv::Scalar_	signature:() const
isRightOf	imgproc/imgproc.hpp	/^    int isRightOf(Point2f pt, int edge) const;$/;"	p	class:cv::Subdiv2D	access:protected	signature:(Point2f pt, int edge) const
isSeparable	imgproc/imgproc.hpp	/^    bool isSeparable() const { return (const BaseFilter*)filter2D == 0; }$/;"	f	class:cv::FilterEngine	access:public	signature:() const
isSeq	core/core.hpp	/^    CV_WRAP bool isSeq() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
isSeq	core/operations.hpp	/^inline bool FileNode::isSeq() const { return type() == SEQ; }$/;"	f	class:cv::FileNode	signature:() const
isString	core/core.hpp	/^    CV_WRAP bool isString() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
isString	core/operations.hpp	/^inline bool FileNode::isString() const { return type() == STR; }$/;"	f	class:cv::FileNode	signature:() const
isStumpBased	objdetect/objdetect.hpp	/^        bool isStumpBased;$/;"	m	class:cv::CascadeClassifier::Data	access:public
isSubmatrix	core/core.hpp	/^    bool isSubmatrix() const;$/;"	p	class:cv::Mat	access:public	signature:() const
isSubmatrix	core/mat.hpp	/^inline bool Mat::isSubmatrix() const { return (flags & SUBMATRIX_FLAG) != 0; }$/;"	f	class:cv::Mat	signature:() const
is_buf_16u	ml/ml.hpp	/^    int is_buf_16u;$/;"	m	struct:CvDTreeTrainData	access:public
is_classifier	ml/ml.hpp	/^    bool is_classifier;$/;"	m	struct:CvDTreeTrainData	access:public
is_full_	flann/result_set.h	/^    bool is_full_;$/;"	m	class:cvflann::UniqueResultSet	access:protected
is_instance	core/types_c.h	/^    CvIsInstanceFunc is_instance;$/;"	m	struct:CvTypeInfo	access:public
is_kdtree_distance	flann/dist.h	/^    typedef False is_kdtree_distance;$/;"	t	struct:cvflann::Hamming	access:public
is_kdtree_distance	flann/dist.h	/^    typedef False is_kdtree_distance;$/;"	t	struct:cvflann::Hamming2	access:public
is_kdtree_distance	flann/dist.h	/^    typedef False is_kdtree_distance;$/;"	t	struct:cvflann::HammingLUT	access:public
is_kdtree_distance	flann/dist.h	/^    typedef False is_kdtree_distance;$/;"	t	struct:cvflann::MaxDistance	access:public
is_kdtree_distance	flann/dist.h	/^    typedef True is_kdtree_distance;$/;"	t	struct:cvflann::ChiSquareDistance	access:public
is_kdtree_distance	flann/dist.h	/^    typedef True is_kdtree_distance;$/;"	t	struct:cvflann::HellingerDistance	access:public
is_kdtree_distance	flann/dist.h	/^    typedef True is_kdtree_distance;$/;"	t	struct:cvflann::HistIntersectionDistance	access:public
is_kdtree_distance	flann/dist.h	/^    typedef True is_kdtree_distance;$/;"	t	struct:cvflann::KL_Divergence	access:public
is_kdtree_distance	flann/dist.h	/^    typedef True is_kdtree_distance;$/;"	t	struct:cvflann::L1	access:public
is_kdtree_distance	flann/dist.h	/^    typedef True is_kdtree_distance;$/;"	t	struct:cvflann::L2	access:public
is_kdtree_distance	flann/dist.h	/^    typedef True is_kdtree_distance;$/;"	t	struct:cvflann::L2_Simple	access:public
is_kdtree_distance	flann/dist.h	/^    typedef True is_kdtree_distance;$/;"	t	struct:cvflann::MinkowskiDistance	access:public
is_obj_without_holes	video/background_segm.hpp	/^    int    is_obj_without_holes;\/* If TRUE we ignore holes within foreground blobs. Defaults to TRUE.						*\/$/;"	m	struct:CvFGDStatModelParams	access:public
is_regression	ml/ml.hpp	/^    bool is_regression() const;$/;"	p	class:CvKNearest	access:public	signature:() const
is_trained_dyn_model	video/background_segm.hpp	/^    uchar                 is_trained_dyn_model;$/;"	m	struct:CvBGPixelStat	access:public
is_trained_st_model	video/background_segm.hpp	/^    uchar                 is_trained_st_model;$/;"	m	struct:CvBGPixelStat	access:public
is_valid	legacy/legacy.hpp	/^    bool is_valid() { return image != 0; }$/;"	f	class:CvImage	access:public	signature:()
is_valid	legacy/legacy.hpp	/^    bool is_valid() { return matrix != 0; }$/;"	f	class:CvMatrix	access:public	signature:()
is_vector_space_distance	flann/dist.h	/^    typedef False is_vector_space_distance;$/;"	t	struct:cvflann::Hamming	access:public
is_vector_space_distance	flann/dist.h	/^    typedef False is_vector_space_distance;$/;"	t	struct:cvflann::Hamming2	access:public
is_vector_space_distance	flann/dist.h	/^    typedef False is_vector_space_distance;$/;"	t	struct:cvflann::HammingLUT	access:public
is_vector_space_distance	flann/dist.h	/^    typedef True is_vector_space_distance;$/;"	t	struct:cvflann::ChiSquareDistance	access:public
is_vector_space_distance	flann/dist.h	/^    typedef True is_vector_space_distance;$/;"	t	struct:cvflann::HellingerDistance	access:public
is_vector_space_distance	flann/dist.h	/^    typedef True is_vector_space_distance;$/;"	t	struct:cvflann::HistIntersectionDistance	access:public
is_vector_space_distance	flann/dist.h	/^    typedef True is_vector_space_distance;$/;"	t	struct:cvflann::KL_Divergence	access:public
is_vector_space_distance	flann/dist.h	/^    typedef True is_vector_space_distance;$/;"	t	struct:cvflann::L1	access:public
is_vector_space_distance	flann/dist.h	/^    typedef True is_vector_space_distance;$/;"	t	struct:cvflann::L2	access:public
is_vector_space_distance	flann/dist.h	/^    typedef True is_vector_space_distance;$/;"	t	struct:cvflann::L2_Simple	access:public
is_vector_space_distance	flann/dist.h	/^    typedef True is_vector_space_distance;$/;"	t	struct:cvflann::MaxDistance	access:public
is_vector_space_distance	flann/dist.h	/^    typedef True is_vector_space_distance;$/;"	t	struct:cvflann::MinkowskiDistance	access:public
isfree	imgproc/imgproc.hpp	/^        bool isfree() const;$/;"	p	struct:cv::Subdiv2D::QuadEdge	access:public	signature:() const
isfree	imgproc/imgproc.hpp	/^        bool isfree() const;$/;"	p	struct:cv::Subdiv2D::Vertex	access:public	signature:() const
isvirtual	imgproc/imgproc.hpp	/^        bool isvirtual() const;$/;"	p	struct:cv::Subdiv2D::Vertex	access:public	signature:() const
it	core/core.hpp	/^    MatIterator_<_Tp> it;$/;"	m	class:cv::MatCommaInitializer_	access:protected
it	core/operations.hpp	/^    FileNodeIterator* it;$/;"	m	class:cv::VecReaderProxy	access:public
iterations_	flann/kmeans_index.h	/^    int iterations_;$/;"	m	class:cvflann::KMeansIndex	access:private
iterator	core/core.hpp	/^    typedef MatIterator_<_Tp> iterator;$/;"	t	class:cv::Mat_	access:public
iterator	core/core.hpp	/^    typedef SeqIterator<_Tp> iterator;$/;"	t	class:cv::Seq	access:public
iterator	core/core.hpp	/^    typedef SparseMatIterator iterator;$/;"	t	class:cv::SparseMat	access:public
iterator	core/core.hpp	/^    typedef SparseMatIterator_<_Tp> iterator;$/;"	t	class:cv::SparseMat_	access:public
iterator	core/operations.hpp	/^    typedef _Tp* iterator;$/;"	t	class:cv::Vector	access:public
iterator_category	core/core.hpp	/^    typedef std::forward_iterator_tag iterator_category;$/;"	t	class:cv::SparseMatConstIterator_	access:public
iterator_category	core/core.hpp	/^    typedef std::forward_iterator_tag iterator_category;$/;"	t	class:cv::SparseMatIterator_	access:public
iterator_category	core/core.hpp	/^    typedef std::random_access_iterator_tag iterator_category;$/;"	t	class:cv::MatConstIterator	access:public
iterator_category	core/core.hpp	/^    typedef std::random_access_iterator_tag iterator_category;$/;"	t	class:cv::MatConstIterator_	access:public
iterator_category	core/core.hpp	/^    typedef std::random_access_iterator_tag iterator_category;$/;"	t	class:cv::MatIterator_	access:public
iterdepth	core/core.hpp	/^    int iterdepth;$/;"	m	class:cv::NAryMatIterator	access:protected
iters	calib3d/calib3d.hpp	/^    int iters;$/;"	m	class:CvLevMarq	access:public
iters	contrib/contrib.hpp	/^        int iters;$/;"	m	class:cv::LevMarqSparse	access:public
iters	gpu/gpu.hpp	/^            int iters;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
iters	gpu/gpu.hpp	/^            int iters;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
iters	gpu/gpu.hpp	/^            int iters;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
k	features2d/features2d.hpp	/^        double k;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
k	legacy/legacy.hpp	/^    int k; \/\/stack size$/;"	m	struct:CvCliqueFinder	access:public
kArray	flann/lsh_table.h	/^        kArray, kBitsetHash, kHash$/;"	e	enum:cvflann::lsh::LshTable::SpeedLevel
kBitsetHash	flann/lsh_table.h	/^        kArray, kBitsetHash, kHash$/;"	e	enum:cvflann::lsh::LshTable::SpeedLevel
kBytes	features2d/features2d.hpp	/^  enum { kBytes = 32 };$/;"	e	enum:cv::ORB::__anon191
kChannels	core/wimage.hpp	/^    enum { kChannels = C };$/;"	e	enum:cv::WImageBufferC::__anon95
kChannels	core/wimage.hpp	/^    enum { kChannels = C };$/;"	e	enum:cv::WImageC::__anon94
kChannels	core/wimage.hpp	/^    enum { kChannels = C };$/;"	e	enum:cv::WImageViewC::__anon96
kHash	flann/lsh_table.h	/^        kArray, kBitsetHash, kHash$/;"	e	enum:cvflann::lsh::LshTable::SpeedLevel
kKernelWidth	features2d/features2d.hpp	/^  static const int kKernelWidth = 5;$/;"	m	class:cv::ORB	access:private
kalman	video/tracking.hpp	/^CVAPI(void)  cvReleaseKalman( CvKalman** kalman);$/;"	v
kdtree_index_	flann/composite_index.h	/^    KDTreeIndex<Distance>* kdtree_index_;$/;"	m	class:cvflann::CompositeIndex	access:private
keep_floats_	features2d/features2d.hpp	/^  bool keep_floats_;$/;"	m	class:cv::RTreeClassifier	access:private
ker	gpu/gpu.hpp	/^            static Mat ker;$/;"	m	struct:cv::gpu::PyrDownBuf	access:private
ker	gpu/gpu.hpp	/^            static Mat ker;$/;"	m	struct:cv::gpu::PyrUpBuf	access:private
kernel	contrib/contrib.hpp	/^    SearchWindow kernel;$/;"	m	class:CvFuzzyMeanShiftTracker	access:public
kernel	ml/ml.hpp	/^    CvSVMKernel* kernel;$/;"	m	class:CvSVM	access:protected
kernel	ml/ml.hpp	/^    CvSVMKernel* kernel;$/;"	m	class:CvSVMSolver	access:public
kernel_type	ml/ml.hpp	/^    CV_PROP_RW int         kernel_type;$/;"	m	struct:CvSVMParams	access:public
key_bitset_	flann/lsh_table.h	/^    DynamicBitset key_bitset_;$/;"	m	class:cvflann::lsh::LshTable	access:private
key_size_	flann/lsh_index.h	/^    unsigned int key_size_;$/;"	m	class:cvflann::LshIndex	access:private
key_size_	flann/lsh_table.h	/^    unsigned int key_size_;$/;"	m	class:cvflann::lsh::LshTable	access:private
keypointCount	features2d/features2d.hpp	/^        size_t keypointCount() const;$/;"	p	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:public	signature:() const
keypoints	features2d/features2d.hpp	/^        vector<vector<KeyPoint> > keypoints;$/;"	m	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:protected
keypointsRatio	gpu/gpu.hpp	/^            float keypointsRatio;$/;"	m	class:cv::gpu::SURF_GPU	access:public
kind	core/core.hpp	/^    virtual int kind() const;$/;"	p	class:cv::_InputArray	access:public	signature:() const
kmeans	core/core.hpp	/^CV_EXPORTS_W double kmeans( InputArray data, int K, CV_OUT InputOutputArray bestLabels,$/;"	p	namespace:cv	signature:( InputArray data, int K, CV_OUT InputOutputArray bestLabels, TermCriteria criteria, int attempts, int flags, OutputArray centers=noArray() )
kmeans	ml/ml.hpp	/^    virtual void kmeans( const CvVectors& train_data, int nclusters,$/;"	p	class:CvEM	access:protected	signature:( const CvVectors& train_data, int nclusters, CvMat* labels, CvTermCriteria criteria, const CvMat* means )
kmeans_index_	flann/composite_index.h	/^    KMeansIndex<Distance>* kmeans_index_;$/;"	m	class:cvflann::CompositeIndex	access:private
knnMatch	features2d/features2d.hpp	/^    void knnMatch( const Mat& queryDescriptors, const Mat& trainDescriptors,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, const Mat& trainDescriptors, vector<vector<DMatch> >& matches, int k, const Mat& mask=Mat(), bool compactResult=false ) const
knnMatch	features2d/features2d.hpp	/^    void knnMatch( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
knnMatch	features2d/features2d.hpp	/^    void knnMatch( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, const Mat& trainImage, vector<KeyPoint>& trainKeypoints, vector<vector<DMatch> >& matches, int k, const Mat& mask=Mat(), bool compactResult=false ) const
knnMatch	features2d/features2d.hpp	/^    void knnMatch( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
knnMatch	gpu/gpu.hpp	/^            void knnMatch(const GpuMat& queryDescs, const GpuMat& trainDescs,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& queryDescs, const GpuMat& trainDescs, GpuMat& trainIdx, GpuMat& distance, GpuMat& allDist, int k, const GpuMat& mask = GpuMat(), Stream& stream = Stream::Null())
knnMatch	gpu/gpu.hpp	/^            void knnMatch(const GpuMat& queryDescs, const GpuMat& trainDescs,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& queryDescs, const GpuMat& trainDescs, std::vector< std::vector<DMatch> >& matches, int k, const GpuMat& mask = GpuMat(), bool compactResult = false)
knnMatch	gpu/gpu.hpp	/^            void knnMatch(const GpuMat& queryDescs, std::vector< std::vector<DMatch> >& matches, int knn,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& queryDescs, std::vector< std::vector<DMatch> >& matches, int knn, const std::vector<GpuMat>& masks = std::vector<GpuMat>(), bool compactResult = false )
knnMatchConvert	gpu/gpu.hpp	/^            static void knnMatchConvert(const Mat& trainIdx, const Mat& distance,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const Mat& trainIdx, const Mat& distance, std::vector< std::vector<DMatch> >& matches, bool compactResult = false)
knnMatchDownload	gpu/gpu.hpp	/^            static void knnMatchDownload(const GpuMat& trainIdx, const GpuMat& distance,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& trainIdx, const GpuMat& distance, std::vector< std::vector<DMatch> >& matches, bool compactResult = false)
knnMatchImpl	features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	p	class:cv::BruteForceMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
knnMatchImpl	features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	p	class:cv::DescriptorMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
knnMatchImpl	features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	p	class:cv::FlannBasedMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
knnMatchImpl	features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::FernDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
knnMatchImpl	features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
knnMatchImpl	features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::OneWayDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
knnMatchImpl	features2d/features2d.hpp	/^    virtual void knnMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::VectorDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
knnMatchImpl	features2d/features2d.hpp	/^void BruteForceMatcher<Distance>::knnMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	f	class:cv::BruteForceMatcher	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
knnMatchImpl	features2d/features2d.hpp	/^void BruteForceMatcher<L2<float> >::knnMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k,$/;"	p	class:cv::BruteForceMatcher	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, int k, const vector<Mat>& masks, bool compactResult )
knnSearch	flann/flann.hpp	/^	void knnSearch(const Mat& queries, Mat& indices, Mat& dists, int knn, const ::cvflann::SearchParams& params);$/;"	p	class:cv::flann::Index_	access:public	signature:(const Mat& queries, Mat& indices, Mat& dists, int knn, const ::cvflann::SearchParams& params)
knnSearch	flann/flann.hpp	/^	void knnSearch(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, int knn, const ::cvflann::SearchParams& params);$/;"	p	class:cv::flann::Index_	access:public	signature:(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, int knn, const ::cvflann::SearchParams& params)
knnSearch	flann/flann.hpp	/^        void knnSearch(const Mat& queries, Mat& indices, Mat& dists, int knn, const ::cvflann::SearchParams& params);$/;"	p	class:cv::flann::GenericIndex	access:public	signature:(const Mat& queries, Mat& indices, Mat& dists, int knn, const ::cvflann::SearchParams& params)
knnSearch	flann/flann.hpp	/^        void knnSearch(const vector<ElementType>& query, vector<int>& indices, $/;"	p	class:cv::flann::GenericIndex	access:public	signature:(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, int knn, const ::cvflann::SearchParams& params)
knnSearch	flann/flann.hpp	/^void GenericIndex<Distance>::knnSearch(const Mat& queries, Mat& indices, Mat& dists, int knn, const ::cvflann::SearchParams& searchParams)$/;"	f	class:cv::flann::GenericIndex	signature:(const Mat& queries, Mat& indices, Mat& dists, int knn, const ::cvflann::SearchParams& searchParams)
knnSearch	flann/flann.hpp	/^void GenericIndex<Distance>::knnSearch(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, int knn, const ::cvflann::SearchParams& searchParams)$/;"	f	class:cv::flann::GenericIndex	signature:(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, int knn, const ::cvflann::SearchParams& searchParams)
knnSearch	flann/flann.hpp	/^void Index_<T>::knnSearch(const Mat& queries, Mat& indices, Mat& dists, int knn, const ::cvflann::SearchParams& searchParams)$/;"	f	class:cv::flann::Index_	signature:(const Mat& queries, Mat& indices, Mat& dists, int knn, const ::cvflann::SearchParams& searchParams)
knnSearch	flann/flann.hpp	/^void Index_<T>::knnSearch(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, int knn, const ::cvflann::SearchParams& searchParams)$/;"	f	class:cv::flann::Index_	signature:(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, int knn, const ::cvflann::SearchParams& searchParams)
knnSearch	flann/flann_base.hpp	/^    void knnSearch(const Matrix<ElementType>& queries, Matrix<int>& indices, Matrix<DistanceType>& dists, int knn, const SearchParams& params)$/;"	f	class:cvflann::Index	access:public	signature:(const Matrix<ElementType>& queries, Matrix<int>& indices, Matrix<DistanceType>& dists, int knn, const SearchParams& params)
knnSearch	flann/kdtree_single_index.h	/^    void knnSearch(const Matrix<ElementType>& queries, Matrix<int>& indices, Matrix<DistanceType>& dists, int knn, const SearchParams& params)$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:(const Matrix<ElementType>& queries, Matrix<int>& indices, Matrix<DistanceType>& dists, int knn, const SearchParams& params)
knnSearch	flann/lsh_index.h	/^    virtual void knnSearch(const Matrix<ElementType>& queries, Matrix<int>& indices, Matrix<DistanceType>& dists, int knn, const SearchParams& params)$/;"	f	class:cvflann::LshIndex	access:public	signature:(const Matrix<ElementType>& queries, Matrix<int>& indices, Matrix<DistanceType>& dists, int knn, const SearchParams& params)
knnSearch	flann/miniflann.hpp	/^    CV_WRAP virtual void knnSearch(InputArray query, OutputArray indices, $/;"	p	class:cv::flann::Index	access:public	signature:(InputArray query, OutputArray indices, OutputArray dists, int knn, const SearchParams& params=SearchParams())
knnSearch	flann/nn_index.h	/^    virtual void knnSearch(const Matrix<ElementType>& queries, Matrix<int>& indices, Matrix<DistanceType>& dists, int knn, const SearchParams& params)$/;"	f	class:cvflann::NNIndex	access:public	signature:(const Matrix<ElementType>& queries, Matrix<int>& indices, Matrix<DistanceType>& dists, int knn, const SearchParams& params)
ksize	gpu/gpu.hpp	/^            Size ksize;$/;"	m	class:cv::gpu::BaseFilter_GPU	access:public
ksize	gpu/gpu.hpp	/^            int ksize, anchor;$/;"	m	class:cv::gpu::BaseColumnFilter_GPU	access:public
ksize	gpu/gpu.hpp	/^            int ksize, anchor;$/;"	m	class:cv::gpu::BaseRowFilter_GPU	access:public
ksize	imgproc/imgproc.hpp	/^    Size ksize;$/;"	m	class:cv::BaseFilter	access:public
ksize	imgproc/imgproc.hpp	/^    Size ksize;$/;"	m	class:cv::FilterEngine	access:public
ksize	imgproc/imgproc.hpp	/^    int ksize, anchor;$/;"	m	class:cv::BaseColumnFilter	access:public
ksize	imgproc/imgproc.hpp	/^    int ksize, anchor;$/;"	m	class:cv::BaseRowFilter	access:public
l	gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
l	gpu/gpu.hpp	/^            GpuMat u[2], d[2], l[2], r[2];$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
l	objdetect/objdetect.hpp	/^    int l;$/;"	m	struct:__anon196	access:public
l2	gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
labels	core/core.hpp	/^    CV_PROP vector<int> labels; \/\/!< the parallel array of labels.$/;"	m	class:cv::KDTree	access:public
labels	gpu/gpu.hpp	/^            GpuMat labels, labels_buf;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
labels_buf	gpu/gpu.hpp	/^            GpuMat labels, labels_buf;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
labels_host	gpu/gpu.hpp	/^            Mat labels_host;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
lambda	calib3d/calib3d.hpp	/^    float K, lambda, lambda1, lambda2;$/;"	m	struct:CvStereoGCState	access:public
lambda	contrib/contrib.hpp	/^        CV_PROP_RW float	lambda;$/;"	m	class:cv::StereoVar	access:public
lambda	contrib/contrib.hpp	/^        double lambda;$/;"	m	class:cv::LevMarqSparse	access:public
lambda	contrib/contrib.hpp	/^        float lambda;$/;"	m	class:cv::SpinImageModel	access:public
lambda1	calib3d/calib3d.hpp	/^    float K, lambda, lambda1, lambda2;$/;"	m	struct:CvStereoGCState	access:public
lambda1	features2d/features2d.hpp	/^    float lambda1;$/;"	m	class:cv::CvAffinePose	access:public
lambda2	calib3d/calib3d.hpp	/^    float K, lambda, lambda1, lambda2;$/;"	m	struct:CvStereoGCState	access:public
lambda2	features2d/features2d.hpp	/^    float lambda2;$/;"	m	class:cv::CvAffinePose	access:public
lambdaLg10	calib3d/calib3d.hpp	/^    int lambdaLg10;$/;"	m	class:CvLevMarq	access:public
lambdaMax	features2d/features2d.hpp	/^    double lambdaMin, lambdaMax;$/;"	m	class:cv::PatchGenerator	access:public
lambdaMin	features2d/features2d.hpp	/^    double lambdaMin, lambdaMax;$/;"	m	class:cv::PatchGenerator	access:public
laplacian	features2d/features2d.hpp	/^    int          laplacian;$/;"	m	struct:CvSURFPoint	access:public
largeSize	contrib/contrib.hpp	/^        int largeSize;$/;"	m	class:cv::SelfSimDescriptor	access:public
last	core/core_c.h	/^    static CvModuleInfo* last;$/;"	m	struct:CvModule	access:public
last	core/core_c.h	/^    static CvTypeInfo* last;$/;"	m	struct:CvType	access:public
latestCounts	legacy/legacy.hpp	/^    int     latestCounts[MAX_CAMERAS];$/;"	m	class:CvCalibFilter	access:protected
latestPoints	legacy/legacy.hpp	/^    CvPoint2D32f* latestPoints[MAX_CAMERAS];$/;"	m	class:CvCalibFilter	access:protected
layer_sizes	ml/ml.hpp	/^    CvMat* layer_sizes;$/;"	m	class:CvANN_MLP	access:protected
ldetector	objdetect/objdetect.hpp	/^    LDetector ldetector;$/;"	m	class:cv::PlanarObjectDetector	access:protected
ldh	contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
ldw	contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
ldx	contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
ldy	contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
leBuf	gpu/gpu.hpp	/^            GpuMat minSSD, leBuf, riBuf;$/;"	m	class:cv::gpu::StereoBM_GPU	access:private
leaf_counts_	features2d/features2d.hpp	/^  std::vector<int> leaf_counts_;$/;"	m	class:cv::RandomizedTree	access:private
leaf_max_size_	flann/kdtree_single_index.h	/^    int leaf_max_size_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
leaf_size_	flann/hierarchical_clustering_index.h	/^    int leaf_size_;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
learnMax	video/background_segm.hpp	/^    uchar learnMax[3];$/;"	m	struct:CvBGCodeBookElem	access:public
learnMin	video/background_segm.hpp	/^    uchar learnMin[3];$/;"	m	struct:CvBGCodeBookElem	access:public
leaves	objdetect/objdetect.hpp	/^        vector<float> leaves;$/;"	m	class:cv::CascadeClassifier::Data	access:public
leavesPerStruct	features2d/features2d.hpp	/^    int leavesPerStruct;$/;"	m	class:cv::FernClassifier	access:protected
leaves_get	ml/ml.hpp	/^    void leaves_get( CvDTreeNode** leaves, int& count, CvDTreeNode* node );$/;"	p	class:CvGBTrees	access:protected	signature:( CvDTreeNode** leaves, int& count, CvDTreeNode* node )
left	calib3d/calib3d.hpp	/^    CvMat* left;$/;"	m	struct:CvStereoGCState	access:public
left	core/core.hpp	/^        int left, right;$/;"	m	struct:cv::KDTree::Node	access:public
left	flann/kdtree_single_index.h	/^    	int left, right;$/;"	m	struct:cvflann::KDTreeSingleIndex::Node	access:public
left	ml/ml.hpp	/^    CvDTreeNode* left;$/;"	m	struct:CvDTreeNode	access:public
left	objdetect/objdetect.hpp	/^            int left;$/;"	m	struct:cv::CascadeClassifier::Data::DTreeNode	access:public
left	objdetect/objdetect.hpp	/^    int* left;$/;"	m	struct:CvHaarClassifier	access:public
len	core/types_c.h	/^    int len;$/;"	m	struct:CvString	access:public
len1	legacy/blobtrack.hpp	/^    int len1,len2;$/;"	m	struct:CvTracksTimePos	access:public
len2	legacy/blobtrack.hpp	/^    int len1,len2;$/;"	m	struct:CvTracksTimePos	access:public
length	flann/heap.h	/^    int length;$/;"	m	class:cvflann::Heap	access:private
length	gpu/NCV.hpp	/^    size_t length() const {return this->_length;}$/;"	f	class:NCVVector	access:public	signature:() const
level	core/core_c.h	/^    int level;$/;"	m	struct:CvTreeNodeIterator	access:public
level	flann/hierarchical_clustering_index.h	/^        int level;$/;"	m	struct:cvflann::HierarchicalClusteringIndex::Node	access:public
level	flann/kmeans_index.h	/^        int level;$/;"	m	struct:cvflann::KMeansIndex::KMeansNode	access:public
level	legacy/legacy.hpp	/^    int level; \/* 0 - lowest(i.e its states are real states), ..... *\/$/;"	m	struct:CvEHMM	access:public
levels	contrib/contrib.hpp	/^        CV_PROP_RW int		levels;$/;"	m	class:cv::StereoVar	access:public
levels	gpu/gpu.hpp	/^            int levels;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
levels	gpu/gpu.hpp	/^            int levels;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
line	core/core.hpp	/^    int line; \/\/\/< line number in the source file where the error has occured $/;"	m	class:cv::Exception	access:public
line	core/core.hpp	/^CV_EXPORTS_W void line(Mat& img, Point pt1, Point pt2, const Scalar& color,$/;"	p	namespace:cv	signature:(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness=1, int lineType=8, int shift=0)
lineCoeffs	legacy/legacy.hpp	/^    CvStereoLineCoeff* lineCoeffs;$/;"	m	struct:CvStereoCamera	access:public
lineThresholdBinarized	features2d/features2d.hpp	/^    int lineThresholdBinarized;$/;"	m	struct:CvStarDetectorParams	access:public
lineThresholdProjected	features2d/features2d.hpp	/^    int lineThresholdProjected;$/;"	m	struct:CvStarDetectorParams	access:public
line_type	core/core_c.h	/^    int         line_type;		\/\/Qt: PointSize$/;"	m	struct:CvFont	access:public
load	flann/miniflann.hpp	/^    CV_WRAP virtual bool load(InputArray features, const std::string& filename);$/;"	p	class:cv::flann::Index	access:public	signature:(InputArray features, const std::string& filename)
load	gpu/gpu.hpp	/^            bool load(const string& filename);$/;"	p	class:cv::gpu::CascadeClassifier_GPU	access:public	signature:(const string& filename)
load	legacy/legacy.hpp	/^    bool load( const char* filename, const char* imgname=0, int color=-1 );$/;"	p	class:CvImage	access:public	signature:( const char* filename, const char* imgname=0, int color=-1 )
load	legacy/legacy.hpp	/^    bool load( const char* filename, const char* matname=0, int color=-1 );$/;"	p	class:CvMatrix	access:public	signature:( const char* filename, const char* matname=0, int color=-1 )
load	ml/ml.hpp	/^    CV_WRAP virtual void load( const char* filename, const char* name=0 );$/;"	p	class:CvStatModel	access:public	signature:( const char* filename, const char* name=0 )
load	objdetect/objdetect.hpp	/^    CV_WRAP bool load( const string& filename );$/;"	p	class:cv::CascadeClassifier	access:public	signature:( const string& filename )
load	objdetect/objdetect.hpp	/^    CV_WRAP virtual bool load(const String& filename, const String& objname=String());$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const String& filename, const String& objname=String())
loadIndex	flann/autotuned_index.h	/^    virtual void loadIndex(FILE* stream)$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:(FILE* stream)
loadIndex	flann/composite_index.h	/^    void loadIndex(FILE* stream)$/;"	f	class:cvflann::CompositeIndex	access:public	signature:(FILE* stream)
loadIndex	flann/flann_base.hpp	/^    virtual void loadIndex(FILE* stream)$/;"	f	class:cvflann::Index	access:public	signature:(FILE* stream)
loadIndex	flann/hierarchical_clustering_index.h	/^    void loadIndex(FILE* stream)$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:public	signature:(FILE* stream)
loadIndex	flann/kdtree_index.h	/^    void loadIndex(FILE* stream)$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:(FILE* stream)
loadIndex	flann/kdtree_single_index.h	/^    void loadIndex(FILE* stream)$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:(FILE* stream)
loadIndex	flann/kmeans_index.h	/^    void loadIndex(FILE* stream)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(FILE* stream)
loadIndex	flann/linear_index.h	/^    void loadIndex(FILE*)$/;"	f	class:cvflann::LinearIndex	access:public	signature:(FILE*)
loadIndex	flann/lsh_index.h	/^    void loadIndex(FILE* stream)$/;"	f	class:cvflann::LshIndex	access:public	signature:(FILE* stream)
loadIndex	flann/nn_index.h	/^    virtual void loadIndex(FILE* stream) = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:(FILE* stream)
loadWindowParameters	highgui/highgui.hpp	/^CV_EXPORTS void loadWindowParameters(const string& windowName);$/;"	p	namespace:cv	signature:(const string& windowName)
load_from_file	flann/hdf5.h	/^void load_from_file(cvflann::Matrix<T>& dataset, const std::string& filename, const std::string& name)$/;"	f	namespace:cvflann	signature:(cvflann::Matrix<T>& dataset, const std::string& filename, const std::string& name)
load_from_file	flann/hdf5.h	/^void load_from_file(cvflann::Matrix<T>& dataset, const std::string& filename, const std::string& name)$/;"	f	namespace:cvflann::mpi	signature:(cvflann::Matrix<T>& dataset, const std::string& filename, const std::string& name)
load_header	flann/saving.h	/^inline IndexHeader load_header(FILE* stream)$/;"	f	namespace:cvflann	signature:(FILE* stream)
load_saved_index	flann/flann_base.hpp	/^NNIndex<Distance>* load_saved_index(const Matrix<typename Distance::ElementType>& dataset, const std::string& filename, Distance distance)$/;"	f	namespace:cvflann	signature:(const Matrix<typename Distance::ElementType>& dataset, const std::string& filename, Distance distance)
load_tree	flann/hierarchical_clustering_index.h	/^    void load_tree(FILE* stream, NodePtr& node, int num)$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:private	signature:(FILE* stream, NodePtr& node, int num)
load_tree	flann/kdtree_index.h	/^    void load_tree(FILE* stream, NodePtr& tree)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(FILE* stream, NodePtr& tree)
load_tree	flann/kdtree_single_index.h	/^    void load_tree(FILE* stream, NodePtr& tree)$/;"	f	class:cvflann::KDTreeSingleIndex	access:private	signature:(FILE* stream, NodePtr& tree)
load_tree	flann/kmeans_index.h	/^    void load_tree(FILE* stream, KMeansNodePtr& node)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(FILE* stream, KMeansNodePtr& node)
load_value	flann/saving.h	/^void load_value(FILE* stream, T& value, size_t count = 1)$/;"	f	namespace:cvflann	signature:(FILE* stream, T& value, size_t count = 1)
load_value	flann/saving.h	/^void load_value(FILE* stream, cvflann::Matrix<T>& value)$/;"	f	namespace:cvflann	signature:(FILE* stream, cvflann::Matrix<T>& value)
load_value	flann/saving.h	/^void load_value(FILE* stream, std::vector<T>& value)$/;"	f	namespace:cvflann	signature:(FILE* stream, std::vector<T>& value)
loaded_	flann/flann_base.hpp	/^    bool loaded_;$/;"	m	class:cvflann::Index	access:private
loaded_from	core/types_c.h	/^    int loaded_from;$/;"	m	struct:CvPluginFuncInfo	access:public
loc	flann/allocator.h	/^    void*   loc;      \/* Current location in block to next allocate memory. *\/$/;"	m	class:cvflann::PooledAllocator	access:private
locate	imgproc/imgproc.hpp	/^    CV_WRAP int locate(Point2f pt, CV_OUT int& edge, CV_OUT int& vertex);$/;"	p	class:cv::Subdiv2D	access:public	signature:(Point2f pt, CV_OUT int& edge, CV_OUT int& vertex)
locateROI	core/core.hpp	/^    void locateROI( Size& wholeSize, Point& ofs ) const;$/;"	p	class:cv::Mat	access:public	signature:( Size& wholeSize, Point& ofs ) const
locateROI	gpu/gpumat.hpp	/^        void locateROI( Size& wholeSize, Point& ofs ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( Size& wholeSize, Point& ofs ) const
location	features2d/features2d.hpp	/^      Point2d location;$/;"	m	struct:cv::SimpleBlobDetector::Center	access:public
log	core/core.hpp	/^CV_EXPORTS_W void log(InputArray src, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst)
log	flann/logger.h	/^    static int log(int level, const char* fmt, ...)$/;"	f	class:cvflann::Logger	access:public	signature:(int level, const char* fmt, ...)
log	gpu/gpu.hpp	/^        CV_EXPORTS void log(const GpuMat& a, GpuMat& b, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, GpuMat& b, Stream& stream = Stream::Null())
logLevel	flann/logger.h	/^    int logLevel;$/;"	m	class:cvflann::Logger	access:private
log_likelihood	ml/ml.hpp	/^    double log_likelihood;$/;"	m	class:CvEM	access:protected
log_likelihood_delta	ml/ml.hpp	/^    double log_likelihood_delta;$/;"	m	class:CvEM	access:protected
log_var_val	legacy/legacy.hpp	/^    float* log_var_val; \/* sum of 0.5 (LN2PI + ln(variance[i]) ) for i=1,n *\/$/;"	m	struct:CvEHMMState	access:public
log_verbosity	flann/flann_base.hpp	/^inline void log_verbosity(int level)$/;"	f	namespace:cvflann	signature:(int level)
log_weight_div_det	ml/ml.hpp	/^    CvMat* log_weight_div_det;$/;"	m	class:CvEM	access:protected
loss_function_type	ml/ml.hpp	/^    CV_PROP_RW int loss_function_type;$/;"	m	struct:CvGBTreesParams	access:public
low	flann/kdtree_single_index.h	/^        DistanceType low, high;$/;"	m	struct:cvflann::KDTreeSingleIndex::Interval	access:public
lpos	core/core.hpp	/^    ptrdiff_t lpos() const;$/;"	p	class:cv::MatConstIterator	access:public	signature:() const
lru_list	ml/ml.hpp	/^    CvSVMKernelRow lru_list;$/;"	m	class:CvSVMSolver	access:public
lsh	flann/lsh_table.h	/^namespace lsh$/;"	n	namespace:cvflann
lsh_hash	imgproc/imgproc.hpp	/^struct lsh_hash {$/;"	s
lsh_hash::h1	imgproc/imgproc.hpp	/^  int h1, h2;$/;"	m	struct:lsh_hash	access:public
lsh_hash::h2	imgproc/imgproc.hpp	/^  int h1, h2;$/;"	m	struct:lsh_hash	access:public
m	core/core.hpp	/^    const Mat* m;$/;"	m	class:cv::MatConstIterator	access:public
m	core/core.hpp	/^    const SparseMat* m;$/;"	m	class:cv::SparseMatConstIterator	access:public
m	legacy/legacy.hpp	/^    float m[3][3];$/;"	m	struct:CvMatrix3	access:public
m00	contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
m00	imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
m00	imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
m01	contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
m01	imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
m01	imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
m02	contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
m02	imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
m02	imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
m03	imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
m03	imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
m10	contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
m10	imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
m10	imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
m11	contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
m11	imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
m11	imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
m12	imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
m12	imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
m20	contrib/contrib.hpp	/^        long m00, m01, m10, m11, m02, m20;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
m20	imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
m20	imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
m21	imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
m21	imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
m30	imgproc/imgproc.hpp	/^    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;$/;"	m	class:cv::Moments	access:public
m30	imgproc/types_c.h	/^    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; \/* spatial moments *\/$/;"	m	struct:CvMoments	access:public
m_Wnd	legacy/blobtrack.hpp	/^    int         m_Wnd;$/;"	m	class:CvVSModule	access:protected
m_affine_poses	features2d/features2d.hpp	/^    CvAffinePose* m_affine_poses; \/\/ an array of poses$/;"	m	class:cv::OneWayDescriptor	access:protected
m_back_project	legacy/legacy.hpp	/^    IplImage*  m_back_project;$/;"	m	class:CvCamShiftTracker	access:protected
m_box	legacy/legacy.hpp	/^    CvBox2D    m_box;$/;"	m	class:CvCamShiftTracker	access:protected
m_center	features2d/features2d.hpp	/^    CvPoint m_center; \/\/ the coordinates of the feature (the center of the input image ROI)$/;"	m	class:cv::OneWayDescriptor	access:protected
m_color_planes	legacy/legacy.hpp	/^    IplImage*  m_color_planes[CV_MAX_DIM];$/;"	m	class:CvCamShiftTracker	access:protected
m_comp	legacy/legacy.hpp	/^    CvConnectedComp m_comp;$/;"	m	class:CvCamShiftTracker	access:protected
m_descriptors	features2d/features2d.hpp	/^    OneWayDescriptor* m_descriptors; \/\/ array of train feature descriptors$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_feature_name	features2d/features2d.hpp	/^    string m_feature_name; \/\/ the name of the feature associated with the descriptor$/;"	m	class:cv::OneWayDescriptor	access:protected
m_hist	legacy/legacy.hpp	/^    CvHistogram* m_hist;$/;"	m	class:CvCamShiftTracker	access:protected
m_hist_ranges	legacy/legacy.hpp	/^    float*     m_hist_ranges[CV_MAX_DIM];$/;"	m	class:CvCamShiftTracker	access:protected
m_hist_ranges_data	legacy/legacy.hpp	/^    float      m_hist_ranges_data[CV_MAX_DIM][2];$/;"	m	class:CvCamShiftTracker	access:protected
m_image	legacy/blobtrack.hpp	/^    IplImage* m_image;$/;"	m	class:CvImageDrawer	access:protected
m_input_patch	features2d/features2d.hpp	/^    IplImage* m_input_patch;$/;"	m	class:cv::OneWayDescriptor	access:protected
m_mask	legacy/legacy.hpp	/^    IplImage*  m_mask;$/;"	m	class:CvCamShiftTracker	access:protected
m_max_ch_val	legacy/legacy.hpp	/^    int        m_max_ch_val[CV_MAX_DIM];$/;"	m	class:CvCamShiftTracker	access:protected
m_min_ch_val	legacy/legacy.hpp	/^    int        m_min_ch_val[CV_MAX_DIM];$/;"	m	class:CvCamShiftTracker	access:protected
m_object_feature_count	features2d/features2d.hpp	/^    int m_object_feature_count; \/\/ the number of the positive features$/;"	m	class:cv::OneWayDescriptorObject	access:protected
m_pElemFormat	legacy/blobtrack.hpp	/^    char            m_pElemFormat[1024];$/;"	m	class:CvBlobSeq	access:protected
m_pMem	legacy/blobtrack.hpp	/^    CvMemStorage*   m_pMem;$/;"	m	class:CvBlobSeq	access:protected
m_pMem	legacy/blobtrack.hpp	/^    CvMemStorage*   m_pMem;$/;"	m	class:CvBlobTrackSeq	access:protected
m_pModuleName	legacy/blobtrack.hpp	/^    char*       m_pModuleName;$/;"	m	class:CvVSModule	access:private
m_pModuleTypeName	legacy/blobtrack.hpp	/^    char*       m_pModuleTypeName;$/;"	m	class:CvVSModule	access:private
m_pNickName	legacy/blobtrack.hpp	/^    char*       m_pNickName;$/;"	m	class:CvVSModule	access:private
m_pParamList	legacy/blobtrack.hpp	/^    CvDefParam*   m_pParamList;$/;"	m	class:CvVSModule	access:private
m_pSeq	legacy/blobtrack.hpp	/^    CvSeq*          m_pSeq;$/;"	m	class:CvBlobSeq	access:protected
m_pSeq	legacy/blobtrack.hpp	/^    CvSeq*          m_pSeq;$/;"	m	class:CvBlobTrackSeq	access:protected
m_part_id	features2d/features2d.hpp	/^    int* m_part_id; \/\/ contains part id for each of object descriptors$/;"	m	class:cv::OneWayDescriptorObject	access:protected
m_patch_size	features2d/features2d.hpp	/^    CvSize m_patch_size; \/\/ patch size$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_patch_size	features2d/features2d.hpp	/^    CvSize m_patch_size; \/\/ size of each image$/;"	m	class:cv::OneWayDescriptor	access:protected
m_pca_avg	features2d/features2d.hpp	/^    CvMat* m_pca_avg; \/\/ PCA average Vector for small patches$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_pca_coeffs	features2d/features2d.hpp	/^    CvMat** m_pca_coeffs; \/\/ an array of length m_pose_count containing pca decomposition of the patch in different poses$/;"	m	class:cv::OneWayDescriptor	access:protected
m_pca_descriptors	features2d/features2d.hpp	/^    OneWayDescriptor* m_pca_descriptors; \/\/ an array of PCA descriptors$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_pca_descriptors_matrix	features2d/features2d.hpp	/^    CvMat* m_pca_descriptors_matrix;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_pca_descriptors_tree	features2d/features2d.hpp	/^    cv::flann::Index* m_pca_descriptors_tree;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_pca_dim_high	features2d/features2d.hpp	/^    int m_pca_dim_high; \/\/ the number of descriptor pca components to use for generating affine poses$/;"	m	class:cv::OneWayDescriptor	access:protected
m_pca_dim_high	features2d/features2d.hpp	/^    int m_pca_dim_high;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_pca_dim_low	features2d/features2d.hpp	/^    int m_pca_dim_low; \/\/ the number of pca components to use for comparison$/;"	m	class:cv::OneWayDescriptor	access:protected
m_pca_dim_low	features2d/features2d.hpp	/^    int m_pca_dim_low;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_pca_eigenvectors	features2d/features2d.hpp	/^    CvMat* m_pca_eigenvectors; \/\/ PCA eigenvectors for small patches$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_pca_hr_avg	features2d/features2d.hpp	/^    CvMat* m_pca_hr_avg; \/\/ PCA average Vector for large patches$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_pca_hr_eigenvectors	features2d/features2d.hpp	/^    CvMat* m_pca_hr_eigenvectors; \/\/ PCA eigenvectors for large patches$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_pose_count	features2d/features2d.hpp	/^    int m_pose_count; \/\/ the number of poses for each descriptor$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_pose_count	features2d/features2d.hpp	/^    int m_pose_count; \/\/ the number of poses$/;"	m	class:cv::OneWayDescriptor	access:protected
m_poses	features2d/features2d.hpp	/^    CvAffinePose* m_poses; \/\/ array of poses$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_pyr_levels	features2d/features2d.hpp	/^    int m_pyr_levels;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_samples	features2d/features2d.hpp	/^    IplImage** m_samples; \/\/ an array of length m_pose_count containing the patch in different poses$/;"	m	class:cv::OneWayDescriptor	access:protected
m_shape	legacy/blobtrack.hpp	/^    CvDrawShape m_shape[16];$/;"	m	class:CvImageDrawer	access:protected
m_temp	legacy/legacy.hpp	/^    IplImage*  m_temp;$/;"	m	class:CvCamShiftTracker	access:protected
m_threshold	legacy/legacy.hpp	/^    int        m_threshold;$/;"	m	class:CvCamShiftTracker	access:protected
m_train_feature_count	features2d/features2d.hpp	/^    int m_train_feature_count; \/\/ the number of the training features$/;"	m	class:cv::OneWayDescriptorBase	access:protected
m_train_features	features2d/features2d.hpp	/^    vector<cv::KeyPoint> m_train_features; \/\/ train features$/;"	m	class:cv::OneWayDescriptorObject	access:protected
m_train_patch	features2d/features2d.hpp	/^    IplImage* m_train_patch;$/;"	m	class:cv::OneWayDescriptor	access:protected
m_transforms	features2d/features2d.hpp	/^    CvMat** m_transforms; \/\/ an array of affine transforms corresponding to poses$/;"	m	class:cv::OneWayDescriptor	access:protected
m_transforms	features2d/features2d.hpp	/^    CvMat** m_transforms; \/\/ array of affine transformations corresponding to poses$/;"	m	class:cv::OneWayDescriptorBase	access:protected
magnification	features2d/features2d.hpp	/^        double magnification;$/;"	m	struct:cv::SIFT::DescriptorParams	access:public
magnitude	core/core.hpp	/^CV_EXPORTS_W void magnitude(InputArray x, InputArray y, OutputArray magnitude);$/;"	p	namespace:cv	signature:(InputArray x, InputArray y, OutputArray magnitude)
magnitude	gpu/gpu.hpp	/^        CV_EXPORTS void magnitude(const GpuMat& x, GpuMat& magnitude, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, GpuMat& magnitude, Stream& stream = Stream::Null())
magnitude	gpu/gpu.hpp	/^        CV_EXPORTS void magnitude(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, Stream& stream = Stream::Null())
magnitudeSqr	gpu/gpu.hpp	/^        CV_EXPORTS void magnitudeSqr(const GpuMat& x, GpuMat& magnitude, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, GpuMat& magnitude, Stream& stream = Stream::Null())
magnitudeSqr	gpu/gpu.hpp	/^        CV_EXPORTS void magnitudeSqr(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& magnitude, Stream& stream = Stream::Null())
majorVersion	gpu/gpu.hpp	/^            int majorVersion() const { return majorVersion_; }$/;"	f	class:cv::gpu::DeviceInfo	access:public	signature:() const
majorVersion_	gpu/gpu.hpp	/^            int majorVersion_;$/;"	m	class:cv::gpu::DeviceInfo	access:private
makeGpuCollection	gpu/gpu.hpp	/^            void makeGpuCollection(GpuMat& trainCollection, GpuMat& maskCollection,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(GpuMat& trainCollection, GpuMat& maskCollection, const vector<GpuMat>& masks = std::vector<GpuMat>())
makePosteriors2	features2d/features2d.hpp	/^  void makePosteriors2(int num_quant_bits);$/;"	p	class:cv::RandomizedTree	access:private	signature:(int num_quant_bits)
map	core/types_c.h	/^        CvFileNodeHash* map; \/* map (collection of named file nodes) *\/$/;"	m	union:CvFileNode::__anon157	access:public
mask	calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> mask;$/;"	m	class:CvLevMarq	access:public
mask	core/core_c.h	/^    int      mask;         \/* event mask *\/$/;"	m	struct:CvGraphScanner	access:public
mask1	gpu/gpu.hpp	/^            GpuMat sum, mask1, maskSum, intBuffer;$/;"	m	class:cv::gpu::SURF_GPU	access:public
maskROI	core/types_c.h	/^    struct _IplImage *maskROI;      \/* Must be NULL. *\/$/;"	m	struct:_IplImage	typeref:struct:_IplImage::_IplImage	access:public
maskSum	gpu/gpu.hpp	/^            GpuMat sum, mask1, maskSum, intBuffer;$/;"	m	class:cv::gpu::SURF_GPU	access:public
mask_	flann/lsh_table.h	/^    std::vector<size_t> mask_;$/;"	m	class:cvflann::lsh::LshTable	access:private
mat	core/core_c.h	/^CVAPI(CvMat*) cvCloneMat( const CvMat* mat );$/;"	v
mat	core/core_c.h	/^CVAPI(CvMatND*) cvCloneMatND( const CvMatND* mat );$/;"	v
mat	core/core_c.h	/^CVAPI(CvScalar) cvTrace( const CvArr* mat );$/;"	v
mat	core/core_c.h	/^CVAPI(CvSparseMat*) cvCloneSparseMat( const CvSparseMat* mat );$/;"	v
mat	core/core_c.h	/^CVAPI(double) cvDet( const CvArr* mat );$/;"	v
mat	core/core_c.h	/^CVAPI(void)  cvReleaseMat( CvMat** mat );$/;"	v
mat	core/core_c.h	/^CVAPI(void)  cvReleaseSparseMat( CvSparseMat** mat );$/;"	v
mat	core/types_c.h	/^    CvMatND mat;                    \/* Embedded matrix header for array histograms. *\/$/;"	m	struct:CvHistogram	access:public
mat	core/types_c.h	/^    CvSparseMat* mat;$/;"	m	struct:CvSparseMatIterator	access:public
mat	legacy/legacy.hpp	/^    float mat[4][4];              \/* maps camera coordinates to world coordinates *\/$/;"	m	struct:__anon187	access:public
matMulDeriv	calib3d/calib3d.hpp	/^CV_EXPORTS_W void matMulDeriv( InputArray A, InputArray B,$/;"	p	namespace:cv	signature:( InputArray A, InputArray B, OutputArray dABdA, OutputArray dABdB )
mat_type	core/core.hpp	/^    typedef Matx<_Tp, m, n> mat_type;$/;"	t	class:cv::Matx	access:public
match	contrib/contrib.hpp	/^        void match(const SpinImageModel& scene, vector< vector<Vec2i> >& result);$/;"	p	class:cv::SpinImageModel	access:public	signature:(const SpinImageModel& scene, vector< vector<Vec2i> >& result)
match	features2d/features2d.hpp	/^    void match( const Mat& queryDescriptors, const Mat& trainDescriptors,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, const Mat& trainDescriptors, vector<DMatch>& matches, const Mat& mask=Mat() ) const
match	features2d/features2d.hpp	/^    void match( const Mat& queryDescriptors, vector<DMatch>& matches,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, vector<DMatch>& matches, const vector<Mat>& masks=vector<Mat>() )
match	features2d/features2d.hpp	/^    void match( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, const Mat& trainImage, vector<KeyPoint>& trainKeypoints, vector<DMatch>& matches, const Mat& mask=Mat() ) const
match	features2d/features2d.hpp	/^    void match( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<DMatch>& matches, const vector<Mat>& masks=vector<Mat>() )
match	gpu/gpu.hpp	/^            void match(const GpuMat& queryDescs, const GpuMat& trainDescs, std::vector<DMatch>& matches,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& queryDescs, const GpuMat& trainDescs, std::vector<DMatch>& matches, const GpuMat& mask = GpuMat())
match	gpu/gpu.hpp	/^            void match(const GpuMat& queryDescs, std::vector<DMatch>& matches, const std::vector<GpuMat>& masks = std::vector<GpuMat>());$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& queryDescs, std::vector<DMatch>& matches, const std::vector<GpuMat>& masks = std::vector<GpuMat>())
matchCollection	gpu/gpu.hpp	/^            void matchCollection(const GpuMat& queryDescs, const GpuMat& trainCollection,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& queryDescs, const GpuMat& trainCollection, GpuMat& trainIdx, GpuMat& imgIdx, GpuMat& distance, const GpuMat& maskCollection, Stream& stream = Stream::Null())
matchConvert	gpu/gpu.hpp	/^            static void matchConvert(const Mat& trainIdx, const Mat& distance, std::vector<DMatch>& matches);$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const Mat& trainIdx, const Mat& distance, std::vector<DMatch>& matches)
matchConvert	gpu/gpu.hpp	/^            static void matchConvert(const Mat& trainIdx, const Mat& imgIdx, const Mat& distance, std::vector<DMatch>& matches);$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const Mat& trainIdx, const Mat& imgIdx, const Mat& distance, std::vector<DMatch>& matches)
matchDownload	gpu/gpu.hpp	/^            static void matchDownload(const GpuMat& trainIdx, const GpuMat& distance, std::vector<DMatch>& matches);$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& trainIdx, const GpuMat& distance, std::vector<DMatch>& matches)
matchDownload	gpu/gpu.hpp	/^            static void matchDownload(const GpuMat& trainIdx, const GpuMat& imgIdx, const GpuMat& distance, std::vector<DMatch>& matches);$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& trainIdx, const GpuMat& imgIdx, const GpuMat& distance, std::vector<DMatch>& matches)
matchShapes	imgproc/imgproc.hpp	/^CV_EXPORTS_W double matchShapes( InputArray contour1, InputArray contour2,$/;"	p	namespace:cv	signature:( InputArray contour1, InputArray contour2, int method, double parameter )
matchSingle	gpu/gpu.hpp	/^            void matchSingle(const GpuMat& queryDescs, const GpuMat& trainDescs,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& queryDescs, const GpuMat& trainDescs, GpuMat& trainIdx, GpuMat& distance, const GpuMat& mask = GpuMat(), Stream& stream = Stream::Null())
matchSpinToModel	contrib/contrib.hpp	/^        void matchSpinToModel(const Mat& spin, vector<int>& indeces,$/;"	p	class:cv::SpinImageModel	access:protected	signature:(const Mat& spin, vector<int>& indeces, vector<float>& corrCoeffs, bool useExtremeOutliers = true) const
matchTemplate	gpu/gpu.hpp	/^        CV_EXPORTS void matchTemplate(const GpuMat& image, const GpuMat& templ, GpuMat& result, int method);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& image, const GpuMat& templ, GpuMat& result, int method)
matchTemplate	imgproc/imgproc.hpp	/^CV_EXPORTS_W void matchTemplate( InputArray image, InputArray templ,$/;"	p	namespace:cv	signature:( InputArray image, InputArray templ, OutputArray result, int method )
match_sum	video/background_segm.hpp	/^    int         match_sum;$/;"	m	struct:CvGaussBGValues	access:public
matcher	features2d/features2d.hpp	/^    Ptr<DescriptorMatcher> matcher;$/;"	m	class:cv::VectorDescriptorMatcher	access:protected
matmul	core/mat.hpp	/^    virtual void matmul(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const
matrix	legacy/legacy.hpp	/^    CvMat* matrix;$/;"	m	class:CvMatrix	access:protected
matrix	legacy/legacy.hpp	/^    float   matrix[9]; \/* intinsic camera parameters:  [ fx 0 cx; 0 fy cy; 0 0 1 ] *\/$/;"	m	struct:CvCamera	access:public
max	core/core.hpp	/^CV_EXPORTS void max(const Mat& src1, const Mat& src2, Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, Mat& dst)
max	core/core.hpp	/^CV_EXPORTS void max(const Mat& src1, double src2, Mat& dst);    $/;"	p	namespace:cv	signature:(const Mat& src1, double src2, Mat& dst)
max	core/core.hpp	/^CV_EXPORTS_W void max(InputArray src1, InputArray src2, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst)
max	core/core.hpp	73;"	d
max	core/internal.hpp	144;"	d
max	core/internal.hpp	69;"	d
max	core/mat.hpp	/^CV_EXPORTS MatExpr max(const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
max	core/mat.hpp	/^CV_EXPORTS MatExpr max(const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
max	core/mat.hpp	/^CV_EXPORTS MatExpr max(double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
max	core/mat.hpp	/^template<typename _Tp> static inline MatExpr max(const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
max	core/mat.hpp	/^template<typename _Tp> static inline MatExpr max(const Mat_<_Tp>& a, double s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, double s)
max	core/mat.hpp	/^template<typename _Tp> static inline MatExpr max(double s, const Mat_<_Tp>& a)$/;"	f	namespace:cv	signature:(double s, const Mat_<_Tp>& a)
max	core/mat.hpp	/^template<typename _Tp> static inline void max(const Mat_<_Tp>& a, const Mat_<_Tp>& b, Mat_<_Tp>& c)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b, Mat_<_Tp>& c)
max	core/mat.hpp	/^template<typename _Tp> static inline void max(const Mat_<_Tp>& a, double s, Mat_<_Tp>& c)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, double s, Mat_<_Tp>& c)
max	core/mat.hpp	/^template<typename _Tp> static inline void max(double s, const Mat_<_Tp>& a, Mat_<_Tp>& c)$/;"	f	namespace:cv	signature:(double s, const Mat_<_Tp>& a, Mat_<_Tp>& c)
max	gpu/gpu.hpp	/^        CV_EXPORTS void max(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, Stream& stream = Stream::Null())
max	gpu/gpu.hpp	/^        CV_EXPORTS void max(const GpuMat& src1, double src2, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, double src2, GpuMat& dst, Stream& stream = Stream::Null())
max	legacy/legacy.hpp	/^    float max, min; \/\/ minimum and maximum projections$/;"	m	struct:CvContourOrientation	access:public
maxArea	features2d/features2d.hpp	/^      float minArea, maxArea;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
maxArea	features2d/features2d.hpp	/^    int maxArea;$/;"	m	struct:CvMSERParams	access:public
maxCircularity	features2d/features2d.hpp	/^      float minCircularity, maxCircularity;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
maxConvexity	features2d/features2d.hpp	/^      float minConvexity, maxConvexity;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
maxCorners	features2d/features2d.hpp	/^        int maxCorners;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
maxCount	core/core.hpp	/^    int maxCount; \/\/ the maximum number of iterations\/elements$/;"	m	class:cv::TermCriteria	access:public
maxDepth	core/core.hpp	/^    CV_PROP int maxDepth; \/\/!< maximum depth of the search tree. Do not modify it$/;"	m	class:cv::KDTree	access:public
maxDisp	contrib/contrib.hpp	/^        CV_PROP_RW int		maxDisp;$/;"	m	class:cv::StereoVar	access:public
maxEvolution	features2d/features2d.hpp	/^    int maxEvolution;$/;"	m	struct:CvMSERParams	access:public
maxHeight	contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
maxInertiaRatio	features2d/features2d.hpp	/^      float minInertiaRatio, maxInertiaRatio;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
maxIters	calib3d/calib3d.hpp	/^    int maxIters;$/;"	m	struct:CvStereoGCState	access:public
maxLevel	features2d/features2d.hpp	/^    int maxLevel;$/;"	m	class:cv::PyramidAdaptedFeatureDetector	access:protected
maxLevels	contrib/contrib.hpp	/^            int maxLevels;$/;"	m	struct:cv::Octree::Node	access:public
maxPoints	legacy/legacy.hpp	/^    int     maxPoints;$/;"	m	class:CvCalibFilter	access:protected
maxPosBuffer	gpu/gpu.hpp	/^            GpuMat maxPosBuffer;$/;"	m	class:cv::gpu::SURF_GPU	access:public
maxScale	features2d/features2d.hpp	/^        float minScale, maxScale, stepScale;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
maxSize	features2d/features2d.hpp	/^    int maxSize;$/;"	m	struct:CvStarDetectorParams	access:public
maxSize	gpu/NCV.hpp	/^    virtual size_t maxSize(void) const = 0;$/;"	p	class:INCVMemAllocator	access:public	signature:(void) const
maxSize	gpu/NCV.hpp	/^    virtual size_t maxSize(void) const;$/;"	p	class:NCVMemNativeAllocator	access:public	signature:(void) const
maxSize	gpu/NCV.hpp	/^    virtual size_t maxSize(void) const;$/;"	p	class:NCVMemStackAllocator	access:public	signature:(void) const
maxThreshold	features2d/features2d.hpp	/^      float maxThreshold;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
maxTotalKeypoints	features2d/features2d.hpp	/^    int maxTotalKeypoints;$/;"	m	class:cv::GridAdaptedFeatureDetector	access:protected
maxVariation	features2d/features2d.hpp	/^    float maxVariation;$/;"	m	struct:CvMSERParams	access:public
maxWidth	contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
maxWidth	imgproc/imgproc.hpp	/^    int maxWidth;$/;"	m	class:cv::FilterEngine	access:public
max_buf_sz	ml/ml.hpp	/^    int max_count, max_buf_sz;$/;"	m	class:CvANN_MLP	access:protected
max_c_count	ml/ml.hpp	/^    int sample_count, var_all, var_count, max_c_count;$/;"	m	struct:CvDTreeTrainData	access:public
max_categories	ml/ml.hpp	/^    CV_PROP_RW int   max_categories;$/;"	m	struct:CvDTreeParams	access:public
max_count	ml/ml.hpp	/^    int max_count, max_buf_sz;$/;"	m	class:CvANN_MLP	access:protected
max_data_term	gpu/gpu.hpp	/^            float max_data_term;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
max_data_term	gpu/gpu.hpp	/^            float max_data_term;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
max_depth	ml/ml.hpp	/^    CV_PROP_RW int   max_depth;$/;"	m	struct:CvDTreeParams	access:public
max_disc_term	gpu/gpu.hpp	/^            float max_disc_term;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
max_disc_term	gpu/gpu.hpp	/^            float max_disc_term;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
max_disc_threshold	gpu/gpu.hpp	/^            float max_disc_threshold;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
max_features_	features2d/features2d.hpp	/^    int min_features_, max_features_;$/;"	m	class:cv::DynamicAdaptedFeatureDetector	access:private
max_iter	core/types_c.h	/^    int    max_iter;$/;"	m	struct:CvTermCriteria	access:public
max_iter	ml/ml.hpp	/^    int max_iter;$/;"	m	class:CvSVMSolver	access:public
max_k	ml/ml.hpp	/^    int max_k, var_count;$/;"	m	class:CvKNearest	access:protected
max_level	core/core_c.h	/^    int max_level;$/;"	m	struct:CvTreeNodeIterator	access:public
max_size	core/core.hpp	/^    size_type max_size() const$/;"	f	class:cv::Allocator	access:public	signature:() const
max_thresh_	features2d/features2d.hpp	/^    double thresh_, init_thresh_, min_thresh_, max_thresh_;$/;"	m	class:cv::StarAdjuster	access:protected
max_thresh_	features2d/features2d.hpp	/^    double thresh_, init_thresh_, min_thresh_, max_thresh_;$/;"	m	class:cv::SurfAdjuster	access:protected
max_thresh_	features2d/features2d.hpp	/^    int init_thresh_, min_thresh_, max_thresh_;$/;"	m	class:cv::FastAdjuster	access:protected
max_val	ml/ml.hpp	/^    CV_PROP_RW double max_val;$/;"	m	struct:CvParamGrid	access:public
max_val	ml/ml.hpp	/^    double min_val, max_val, min_val1, max_val1;$/;"	m	class:CvANN_MLP	access:protected
max_val1	ml/ml.hpp	/^    double min_val, max_val, min_val1, max_val1;$/;"	m	class:CvANN_MLP	access:protected
maxlr	ml/ml.hpp	/^    double maxlr;$/;"	m	struct:CvDTreeNode	access:public
mean	core/core.hpp	/^    Mat mean; \/\/!< mean value subtracted before the projection and added after the back projection$/;"	m	class:cv::PCA	access:public
mean	core/core.hpp	/^CV_EXPORTS_W Scalar mean(InputArray src, InputArray mask=noArray());$/;"	p	namespace:cv	signature:(InputArray src, InputArray mask=noArray())
mean	video/background_segm.hpp	/^    double      mean[CV_BGFG_MOG_NCOLORS];$/;"	m	struct:CvGaussBGValues	access:public
meanShift	contrib/contrib.hpp	/^        bool meanShift(IplImage *maskImage, IplImage *depthMap, int maxIteration, bool initDepth);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(IplImage *maskImage, IplImage *depthMap, int maxIteration, bool initDepth)
meanShift	video/tracking.hpp	/^CV_EXPORTS_W int meanShift( InputArray probImage, CV_OUT CV_IN_OUT Rect& window,$/;"	p	namespace:cv	signature:( InputArray probImage, CV_OUT CV_IN_OUT Rect& window, TermCriteria criteria )
meanShiftFiltering	gpu/gpu.hpp	/^        CV_EXPORTS void meanShiftFiltering(const GpuMat& src, GpuMat& dst, int sp, int sr,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int sp, int sr, TermCriteria criteria = TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 5, 1))
meanShiftProc	gpu/gpu.hpp	/^        CV_EXPORTS void meanShiftProc(const GpuMat& src, GpuMat& dstr, GpuMat& dstsp, int sp, int sr,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dstr, GpuMat& dstsp, int sp, int sr, TermCriteria criteria = TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 5, 1))
meanShiftSegmentation	gpu/gpu.hpp	/^        CV_EXPORTS void meanShiftSegmentation(const GpuMat& src, Mat& dst, int sp, int sr, int minsize,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, Mat& dst, int sp, int sr, int minsize, TermCriteria criteria = TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 5, 1))
meanSplit	flann/kdtree_index.h	/^    void meanSplit(int* ind, int count, int& index, int& cutfeat, DistanceType& cutval)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(int* ind, int count, int& index, int& cutfeat, DistanceType& cutval)
meanStdDev	core/core.hpp	/^CV_EXPORTS_W void meanStdDev(InputArray src, OutputArray mean, OutputArray stddev,$/;"	p	namespace:cv	signature:(InputArray src, OutputArray mean, OutputArray stddev, InputArray mask=noArray())
meanStdDev	gpu/gpu.hpp	/^        CV_EXPORTS void meanStdDev(const GpuMat& mtx, Scalar& mean, Scalar& stddev);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& mtx, Scalar& mean, Scalar& stddev)
mean_	flann/kdtree_index.h	/^    DistanceType* mean_;$/;"	m	class:cvflann::KDTreeIndex	access:private
mean_radius	flann/kmeans_index.h	/^        DistanceType mean_radius;$/;"	m	struct:cvflann::KMeansIndex::KMeansNode	access:public
means	ml/ml.hpp	/^    CvMat* means;$/;"	m	class:CvEM	access:protected
means	ml/ml.hpp	/^    const CvMat* means;$/;"	m	struct:CvEMParams	access:public
meanshift_profile	legacy/blobtrack.hpp	/^    int     meanshift_profile;$/;"	m	struct:CvBlobTrackerParamMS	access:public
measurementMatrix	video/tracking.hpp	/^    Mat measurementMatrix;  \/\/!< measurement matrix (H)$/;"	m	class:cv::KalmanFilter	access:public
measurementNoiseCov	video/tracking.hpp	/^    Mat measurementNoiseCov;\/\/!< measurement noise covariance matrix (R)$/;"	m	class:cv::KalmanFilter	access:public
measurement_matrix	video/tracking.hpp	/^    CvMat* measurement_matrix;  \/* measurement matrix (H) *\/$/;"	m	struct:CvKalman	access:public
measurement_noise_cov	video/tracking.hpp	/^    CvMat* measurement_noise_cov; \/* measurement noise covariance matrix (R) *\/$/;"	m	struct:CvKalman	access:public
medianBlur	imgproc/imgproc.hpp	/^CV_EXPORTS_W void medianBlur( InputArray src, OutputArray dst, int ksize );$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int ksize )
memSegCopyHelper	gpu/NCV.hpp	/^NCV_EXPORTS NCVStatus memSegCopyHelper(void *dst, NCVMemoryType dstType,$/;"	p	signature:(void *dst, NCVMemoryType dstType, const void *src, NCVMemoryType srcType, size_t sz, cudaStream_t cuStream)
memSegCopyHelper2D	gpu/NCV.hpp	/^NCV_EXPORTS NCVStatus memSegCopyHelper2D(void *dst, Ncv32u dstPitch, NCVMemoryType dstType,$/;"	p	signature:(void *dst, Ncv32u dstPitch, NCVMemoryType dstType, const void *src, Ncv32u srcPitch, NCVMemoryType srcType, Ncv32u widthbytes, Ncv32u height, cudaStream_t cuStream)
memType	gpu/NCV.hpp	/^    NCVMemoryType memType() const {return this->_memtype;}$/;"	f	class:NCVMatrix	access:public	signature:() const
memType	gpu/NCV.hpp	/^    NCVMemoryType memType() const {return this->_memtype;}$/;"	f	class:NCVVector	access:public	signature:() const
memType	gpu/NCV.hpp	/^    virtual NCVMemoryType memType(void) const = 0;$/;"	p	class:INCVMemAllocator	access:public	signature:(void) const
memType	gpu/NCV.hpp	/^    virtual NCVMemoryType memType(void) const;$/;"	p	class:NCVMemNativeAllocator	access:public	signature:(void) const
memType	gpu/NCV.hpp	/^    virtual NCVMemoryType memType(void) const;$/;"	p	class:NCVMemStackAllocator	access:public	signature:(void) const
memoryCost	flann/autotuned_index.h	/^        float memoryCost;$/;"	m	struct:cvflann::AutotunedIndex::CostData	access:public
memoryCounter	flann/hierarchical_clustering_index.h	/^    int memoryCounter;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
memoryCounter_	flann/kmeans_index.h	/^    int memoryCounter_;$/;"	m	class:cvflann::KMeansIndex	access:private
memory_weight_	flann/autotuned_index.h	/^    float memory_weight_;$/;"	m	class:cvflann::AutotunedIndex	access:private
memtype	gpu/NCV.hpp	/^    NCVMemoryType memtype;$/;"	m	struct:NCVMemPtr	access:public
merge	core/core.hpp	/^CV_EXPORTS void merge(const Mat* mv, size_t count, OutputArray dst);$/;"	p	namespace:cv	signature:(const Mat* mv, size_t count, OutputArray dst)
merge	core/core.hpp	/^CV_EXPORTS_W void merge(const vector<Mat>& mv, OutputArray dst);$/;"	p	namespace:cv	signature:(const vector<Mat>& mv, OutputArray dst)
merge	gpu/gpu.hpp	/^        CV_EXPORTS void merge(const GpuMat* src, size_t n, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat* src, size_t n, GpuMat& dst, Stream& stream = Stream::Null())
merge	gpu/gpu.hpp	/^        CV_EXPORTS void merge(const vector<GpuMat>& src, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const vector<GpuMat>& src, GpuMat& dst, Stream& stream = Stream::Null())
mergeWith	contrib/contrib.hpp	/^        void mergeWith(Histogram *source, double weight);$/;"	p	class:CvAdaptiveSkinDetector::Histogram	access:public	signature:(Histogram *source, double weight)
mergedDescriptors	features2d/features2d.hpp	/^        Mat mergedDescriptors;$/;"	m	class:cv::DescriptorMatcher::DescriptorCollection	access:protected
mergedDescriptors	features2d/features2d.hpp	/^    DescriptorCollection mergedDescriptors;$/;"	m	class:cv::FlannBasedMatcher	access:protected
mesh	contrib/contrib.hpp	/^        Mesh3D mesh;$/;"	m	class:cv::SpinImageModel	access:protected
middleSplit	flann/kdtree_single_index.h	/^    void middleSplit(int* ind, int count, int& index, int& cutfeat, DistanceType& cutval, const BoundingBox& bbox)$/;"	f	class:cvflann::KDTreeSingleIndex	access:private	signature:(int* ind, int count, int& index, int& cutfeat, DistanceType& cutval, const BoundingBox& bbox)
middleSplit_	flann/kdtree_single_index.h	/^    void middleSplit_(int* ind, int count, int& index, int& cutfeat, DistanceType& cutval, const BoundingBox& bbox)$/;"	f	class:cvflann::KDTreeSingleIndex	access:private	signature:(int* ind, int count, int& index, int& cutfeat, DistanceType& cutval, const BoundingBox& bbox)
min	core/core.hpp	/^CV_EXPORTS void min(const Mat& src1, const Mat& src2, Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, const Mat& src2, Mat& dst)
min	core/core.hpp	/^CV_EXPORTS void min(const Mat& src1, double src2, Mat& dst);$/;"	p	namespace:cv	signature:(const Mat& src1, double src2, Mat& dst)
min	core/core.hpp	/^CV_EXPORTS_W void min(InputArray src1, InputArray src2, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst)
min	core/core.hpp	72;"	d
min	core/internal.hpp	143;"	d
min	core/internal.hpp	68;"	d
min	core/mat.hpp	/^CV_EXPORTS MatExpr min(const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
min	core/mat.hpp	/^CV_EXPORTS MatExpr min(const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
min	core/mat.hpp	/^CV_EXPORTS MatExpr min(double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
min	core/mat.hpp	/^template<typename _Tp> static inline MatExpr min(const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
min	core/mat.hpp	/^template<typename _Tp> static inline MatExpr min(const Mat_<_Tp>& a, double s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, double s)
min	core/mat.hpp	/^template<typename _Tp> static inline MatExpr min(double s, const Mat_<_Tp>& a)$/;"	f	namespace:cv	signature:(double s, const Mat_<_Tp>& a)
min	core/mat.hpp	/^template<typename _Tp> static inline void min(const Mat_<_Tp>& a, const Mat_<_Tp>& b, Mat_<_Tp>& c)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b, Mat_<_Tp>& c)
min	core/mat.hpp	/^template<typename _Tp> static inline void min(const Mat_<_Tp>& a, double s, Mat_<_Tp>& c)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, double s, Mat_<_Tp>& c)
min	core/mat.hpp	/^template<typename _Tp> static inline void min(double s, const Mat_<_Tp>& a, Mat_<_Tp>& c)$/;"	f	namespace:cv	signature:(double s, const Mat_<_Tp>& a, Mat_<_Tp>& c)
min	gpu/gpu.hpp	/^        CV_EXPORTS void min(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, GpuMat& dst, Stream& stream = Stream::Null())
min	gpu/gpu.hpp	/^        CV_EXPORTS void min(const GpuMat& src1, double src2, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, double src2, GpuMat& dst, Stream& stream = Stream::Null())
min	legacy/legacy.hpp	/^    float max, min; \/\/ minimum and maximum projections$/;"	m	struct:CvContourOrientation	access:public
minArea	features2d/features2d.hpp	/^      float minArea, maxArea;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
minArea	features2d/features2d.hpp	/^    int minArea;$/;"	m	struct:CvMSERParams	access:public
minArea	video/background_segm.hpp	/^    double  bg_threshold, std_threshold, minArea;$/;"	m	struct:CvGaussBGStatModelParams	access:public
minArea	video/background_segm.hpp	/^    float  minArea;		\/* Discard foreground blobs whose bounding box is smaller than this threshold.					*\/$/;"	m	struct:CvFGDStatModelParams	access:public
minAreaRect	imgproc/imgproc.hpp	/^CV_EXPORTS_W RotatedRect minAreaRect( InputArray points );$/;"	p	namespace:cv	signature:( InputArray points )
minCircularity	features2d/features2d.hpp	/^      float minCircularity, maxCircularity;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
minConvexity	features2d/features2d.hpp	/^      float minConvexity, maxConvexity;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
minDisp	contrib/contrib.hpp	/^        CV_PROP_RW int		minDisp;$/;"	m	class:cv::StereoVar	access:public
minDisparity	calib3d/calib3d.hpp	/^    CV_PROP_RW int minDisparity;$/;"	m	class:cv::StereoSGBM	access:public
minDisparity	calib3d/calib3d.hpp	/^    int minDisparity;  \/\/ minimum disparity (can be negative)$/;"	m	struct:CvStereoBMState	access:public
minDisparity	calib3d/calib3d.hpp	/^    int minDisparity;$/;"	m	struct:CvStereoGCState	access:public
minDistBetweenBlobs	features2d/features2d.hpp	/^      float minDistBetweenBlobs;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
minDistance	features2d/features2d.hpp	/^        double minDistance;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
minDiversity	features2d/features2d.hpp	/^    float minDiversity;$/;"	m	struct:CvMSERParams	access:public
minEnclosingCircle	imgproc/imgproc.hpp	/^CV_EXPORTS_W void minEnclosingCircle( InputArray points,$/;"	p	namespace:cv	signature:( InputArray points, CV_OUT Point2f& center, CV_OUT float& radius )
minInertiaRatio	features2d/features2d.hpp	/^      float minInertiaRatio, maxInertiaRatio;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
minMargin	features2d/features2d.hpp	/^    double minMargin;$/;"	m	struct:CvMSERParams	access:public
minMax	gpu/gpu.hpp	/^        CV_EXPORTS void minMax(const GpuMat& src, double* minVal, double* maxVal, const GpuMat& mask, GpuMat& buf);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, double* minVal, double* maxVal, const GpuMat& mask, GpuMat& buf)
minMax	gpu/gpu.hpp	/^        CV_EXPORTS void minMax(const GpuMat& src, double* minVal, double* maxVal=0, const GpuMat& mask=GpuMat());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, double* minVal, double* maxVal=0, const GpuMat& mask=GpuMat())
minMaxIdx	core/core.hpp	/^CV_EXPORTS void minMaxIdx(InputArray src, double* minVal, double* maxVal,$/;"	p	namespace:cv	signature:(InputArray src, double* minVal, double* maxVal, int* minIdx=0, int* maxIdx=0, InputArray mask=noArray())
minMaxLoc	core/core.hpp	/^CV_EXPORTS void minMaxLoc(const SparseMat& a, double* minVal,$/;"	p	namespace:cv	signature:(const SparseMat& a, double* minVal, double* maxVal, int* minIdx=0, int* maxIdx=0)
minMaxLoc	core/core.hpp	/^CV_EXPORTS_W void minMaxLoc(InputArray src, CV_OUT double* minVal,$/;"	p	namespace:cv	signature:(InputArray src, CV_OUT double* minVal, CV_OUT double* maxVal=0, CV_OUT Point* minLoc=0, CV_OUT Point* maxLoc=0, InputArray mask=noArray())
minMaxLoc	gpu/gpu.hpp	/^        CV_EXPORTS void minMaxLoc(const GpuMat& src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, const GpuMat& mask, GpuMat& valbuf, GpuMat& locbuf)
minMaxLoc	gpu/gpu.hpp	/^        CV_EXPORTS void minMaxLoc(const GpuMat& src, double* minVal, double* maxVal=0, Point* minLoc=0, Point* maxLoc=0,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, double* minVal, double* maxVal=0, Point* minLoc=0, Point* maxLoc=0, const GpuMat& mask=GpuMat())
minNeighbors	contrib/contrib.hpp	/^        int minNeighbors;$/;"	m	class:cv::SpinImageModel	access:public
minPoints	contrib/contrib.hpp	/^        int minPoints;$/;"	m	class:cv::Octree	access:private
minRepeatability	features2d/features2d.hpp	/^      size_t minRepeatability;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
minSSD	gpu/gpu.hpp	/^            GpuMat minSSD, leBuf, riBuf;$/;"	m	class:cv::gpu::StereoBM_GPU	access:private
minScale	features2d/features2d.hpp	/^        float minScale, maxScale, stepScale;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
minThreshold	features2d/features2d.hpp	/^      float minThreshold;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
min_disp_th	gpu/gpu.hpp	/^            int min_disp_th;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
min_features_	features2d/features2d.hpp	/^    int min_features_, max_features_;$/;"	m	class:cv::DynamicAdaptedFeatureDetector	access:private
min_sample_count	ml/ml.hpp	/^    CV_PROP_RW int   min_sample_count;$/;"	m	struct:CvDTreeParams	access:public
min_thresh_	features2d/features2d.hpp	/^    double thresh_, init_thresh_, min_thresh_, max_thresh_;$/;"	m	class:cv::StarAdjuster	access:protected
min_thresh_	features2d/features2d.hpp	/^    double thresh_, init_thresh_, min_thresh_, max_thresh_;$/;"	m	class:cv::SurfAdjuster	access:protected
min_thresh_	features2d/features2d.hpp	/^    int init_thresh_, min_thresh_, max_thresh_;$/;"	m	class:cv::FastAdjuster	access:protected
min_val	ml/ml.hpp	/^    CV_PROP_RW double min_val;$/;"	m	struct:CvParamGrid	access:public
min_val	ml/ml.hpp	/^    double min_val, max_val, min_val1, max_val1;$/;"	m	class:CvANN_MLP	access:protected
min_val1	ml/ml.hpp	/^    double min_val, max_val, min_val1, max_val1;$/;"	m	class:CvANN_MLP	access:protected
mindist	flann/result_set.h	/^    DistanceType mindist;     \/* Minimum distance to query for all nodes below. *\/$/;"	m	struct:cvflann::BranchStruct	access:public
minorVersion	gpu/gpu.hpp	/^            int minorVersion() const { return minorVersion_; }$/;"	f	class:cv::gpu::DeviceInfo	access:public	signature:() const
minorVersion_	gpu/gpu.hpp	/^            int minorVersion_;$/;"	m	class:cv::gpu::DeviceInfo	access:private
minusDelta	core/core.hpp	/^    int minusDelta, plusDelta;$/;"	m	class:cv::LineIterator	access:public
minusStep	core/core.hpp	/^    int minusStep, plusStep;$/;"	m	class:cv::LineIterator	access:public
minus_delta	core/types_c.h	/^    int  minus_delta;$/;"	m	struct:CvLineIterator	access:public
minus_step	core/types_c.h	/^    int  minus_step;$/;"	m	struct:CvLineIterator	access:public
miss_ch	ml/ml.hpp	/^    char miss_ch;$/;"	m	class:CvMLData	access:protected
missing	ml/ml.hpp	/^    CvMat* missing;$/;"	m	class:CvGBTrees	access:protected
missing	ml/ml.hpp	/^    CvMat* missing;$/;"	m	class:CvMLData	access:protected
missing_mask	ml/ml.hpp	/^    const CvMat* missing_mask;$/;"	m	struct:CvERTreeTrainData	access:public
mix	legacy/legacy.hpp	/^    int* mix;  \/* number of mixture to which observation belong *\/$/;"	m	struct:CvImgObsInfo	access:public
mix	ml/ml.hpp	/^    bool mix;$/;"	m	class:CvMLData	access:protected
mix	ml/ml.hpp	/^    bool mix;$/;"	m	struct:CvTrainTestSplit	access:public
mixChannels	core/core.hpp	/^CV_EXPORTS void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts,$/;"	p	namespace:cv	signature:(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)
mixChannels	core/core.hpp	/^CV_EXPORTS void mixChannels(const vector<Mat>& src, vector<Mat>& dst,$/;"	p	namespace:cv	signature:(const vector<Mat>& src, vector<Mat>& dst, const int* fromTo, size_t npairs)
mixChannels	core/core.hpp	/^CV_EXPORTS_W void mixChannels(InputArrayOfArrays src, InputArrayOfArrays dst,$/;"	p	namespace:cv	signature:(InputArrayOfArrays src, InputArrayOfArrays dst, const vector<int>& fromTo)
mix_train_and_test_idx	ml/ml.hpp	/^    void mix_train_and_test_idx();$/;"	p	class:CvMLData	access:public	signature:()
modMax	video/background_segm.hpp	/^    uchar modMax[3];$/;"	m	struct:CvBGCodeBookModel	access:public
modMin	video/background_segm.hpp	/^    uchar modMin[3];$/;"	m	struct:CvBGCodeBookModel	access:public
model	video/background_segm.hpp	/^CVAPI(void) cvReleaseBGCodeBookModel( CvBGCodeBookModel** model );$/;"	v
modelPoints	objdetect/objdetect.hpp	/^    vector<KeyPoint> modelPoints;$/;"	m	class:cv::PlanarObjectDetector	access:protected
modelROI	objdetect/objdetect.hpp	/^    Rect modelROI;$/;"	m	class:cv::PlanarObjectDetector	access:protected
module_info	core/core_c.h	/^CVAPI(int)  cvRegisterModule( const CvModuleInfo* module_info );$/;"	v
moments	imgproc/imgproc.hpp	/^CV_EXPORTS_W Moments moments( InputArray array, bool binaryImage=false );$/;"	p	namespace:cv	signature:( InputArray array, bool binaryImage=false )
morphologyDefaultBorderValue	imgproc/imgproc.hpp	/^static inline Scalar morphologyDefaultBorderValue() { return Scalar::all(DBL_MAX); }$/;"	f	namespace:cv	signature:()
morphologyEx	gpu/gpu.hpp	/^        CV_EXPORTS void morphologyEx( const GpuMat& src, GpuMat& dst, int op, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:( const GpuMat& src, GpuMat& dst, int op, const Mat& kernel, Point anchor = Point(-1, -1), int iterations = 1, Stream& stream = Stream::Null())
morphologyEx	imgproc/imgproc.hpp	/^CV_EXPORTS_W void morphologyEx( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor=Point(-1,-1), int iterations=1, int borderType=BORDER_CONSTANT, const Scalar& borderValue=morphologyDefaultBorderValue() )
move	flann/any.h	/^    virtual void move(void* const* src, void** dest) = 0;$/;"	p	struct:cdiggins::anyimpl::base_any_policy	access:public	signature:(void* const* src, void** dest)
move	flann/any.h	/^    virtual void move(void* const* src, void** dest) { *dest = *src; }$/;"	f	struct:cdiggins::anyimpl::small_any_policy	access:public	signature:(void* const* src, void** dest)
move	flann/any.h	/^    virtual void move(void* const* src, void** dest)$/;"	f	struct:cdiggins::anyimpl::big_any_policy	access:public	signature:(void* const* src, void** dest)
mpi	flann/hdf5.h	/^namespace mpi$/;"	n	namespace:cvflann
mser	features2d/features2d.hpp	/^    MSER mser;$/;"	m	class:cv::MserFeatureDetector	access:protected
msg	core/core.hpp	/^    string msg; \/\/\/< the formatted error message$/;"	m	class:cv::Exception	access:public
msg	objdetect/objdetect.hpp	/^  char msg[4]; \/\/TODO std::string$/;"	m	struct:cv::DataMatrixCode	access:public
msg	objdetect/objdetect.hpp	/^  char msg[4];$/;"	m	struct:CvDataMatrixCode	access:public
msg_type	gpu/gpu.hpp	/^            int msg_type;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
msg_type	gpu/gpu.hpp	/^            int msg_type;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
mtx	core/operations.hpp	/^    Mat mtx;$/;"	m	struct:cv::Formatted	access:public
mu	legacy/legacy.hpp	/^    float* mu;          \/*mean vectors corresponding to each mixture*\/$/;"	m	struct:CvEHMMState	access:public
mu02	imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
mu02	imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
mu03	imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
mu03	imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
mu11	imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
mu11	imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
mu12	imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
mu12	imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
mu20	imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
mu20	imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
mu21	imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
mu21	imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
mu30	imgproc/imgproc.hpp	/^    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;$/;"	m	class:cv::Moments	access:public
mu30	imgproc/types_c.h	/^    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; \/* central moments *\/$/;"	m	struct:CvMoments	access:public
mul	core/core.hpp	/^    MatExpr mul(InputArray m, double scale=1) const;$/;"	p	class:cv::Mat	access:public	signature:(InputArray m, double scale=1) const
mul	core/core.hpp	/^    Matx<_Tp, m, n> mul(const Matx<_Tp, m, n>& a) const;$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, n>& a) const
mul	core/core.hpp	/^    Scalar_<_Tp> mul(const Scalar_<_Tp>& t, double scale=1 ) const;$/;"	p	class:cv::Scalar_	access:public	signature:(const Scalar_<_Tp>& t, double scale=1 ) const
mul	core/core.hpp	/^    Vec mul(const Vec<_Tp, cn>& v) const;$/;"	p	class:cv::Vec	access:public	signature:(const Vec<_Tp, cn>& v) const
mul	core/mat.hpp	/^    MatExpr mul(const Mat& m, double scale=1) const;$/;"	p	class:cv::MatExpr	access:public	signature:(const Mat& m, double scale=1) const
mul	core/mat.hpp	/^    MatExpr mul(const MatExpr& e, double scale=1) const;$/;"	p	class:cv::MatExpr	access:public	signature:(const MatExpr& e, double scale=1) const
mul	core/operations.hpp	/^Matx<_Tp, m, n> Matx<_Tp, m, n>::mul(const Matx<_Tp, m, n>& a) const$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, n>& a) const
mul	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn> Vec<_Tp, cn>::mul(const Vec<_Tp, cn>& v) const$/;"	f	class:cv::Vec	signature:(const Vec<_Tp, cn>& v) const
mul	core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp> Scalar_<_Tp>::mul(const Scalar_<_Tp>& t, double scale ) const$/;"	f	class:cv::Scalar_	signature:(const Scalar_<_Tp>& t, double scale ) const
mulAndScaleSpectrums	gpu/gpu.hpp	/^        CV_EXPORTS void mulAndScaleSpectrums(const GpuMat& a, const GpuMat& b, GpuMat& c, int flags, $/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c, int flags, float scale, bool conjB=false)
mulSpectrums	core/core.hpp	/^CV_EXPORTS_W void mulSpectrums(InputArray a, InputArray b, OutputArray c,$/;"	p	namespace:cv	signature:(InputArray a, InputArray b, OutputArray c, int flags, bool conjB=false)
mulSpectrums	gpu/gpu.hpp	/^        CV_EXPORTS void mulSpectrums(const GpuMat& a, const GpuMat& b, GpuMat& c, int flags, bool conjB=false);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c, int flags, bool conjB=false)
mulTransposed	core/core.hpp	/^CV_EXPORTS_W void mulTransposed( InputArray src, OutputArray dst, bool aTa,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, bool aTa, InputArray delta=noArray(), double scale=1, int dtype=-1 )
multiProcessorCount	gpu/gpu.hpp	/^            int multiProcessorCount() const { return multi_processor_count_; }$/;"	f	class:cv::gpu::DeviceInfo	access:public	signature:() const
multi_probe_level_	flann/lsh_index.h	/^    unsigned int multi_probe_level_;$/;"	m	class:cvflann::LshIndex	access:private
multi_processor_count_	gpu/gpu.hpp	/^            int multi_processor_count_;$/;"	m	class:cv::gpu::DeviceInfo	access:private
multiply	core/core.hpp	/^CV_EXPORTS_W void multiply(InputArray src1, InputArray src2,$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst, double scale=1, int dtype=-1)
multiply	core/mat.hpp	/^    virtual void multiply(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const
multiply	core/mat.hpp	/^    virtual void multiply(const MatExpr& expr1, double s, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, double s, MatExpr& res) const
multiply	gpu/gpu.hpp	/^        CV_EXPORTS void multiply(const GpuMat& a, const GpuMat& b, GpuMat& c, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c, Stream& stream = Stream::Null())
multiply	gpu/gpu.hpp	/^        CV_EXPORTS void multiply(const GpuMat& a, const Scalar& sc, GpuMat& c, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const Scalar& sc, GpuMat& c, Stream& stream = Stream::Null())
nChannels	core/types_c.h	/^    int  nChannels;         \/* Most of OpenCV functions support 1,2,3 or 4 channels *\/$/;"	m	struct:_IplImage	access:public
nCols	core/types_c.h	/^    int  nCols;$/;"	m	struct:_IplConvKernel	access:public
nCols	core/types_c.h	/^    int  nCols;$/;"	m	struct:_IplConvKernelFP	access:public
nFrameCount	contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
nIt	contrib/contrib.hpp	/^        CV_PROP_RW int		nIt;$/;"	m	class:cv::StereoVar	access:public
nMorphingMethod	contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
nOctaveLayers	features2d/features2d.hpp	/^        int nOctaves, nOctaveLayers;$/;"	m	struct:cv::SIFT::CommonParams	access:public
nOctaveLayers	features2d/features2d.hpp	/^    int    nOctaveLayers;$/;"	m	struct:CvSURFParams	access:public
nOctaves	features2d/features2d.hpp	/^        int nOctaves, nOctaveLayers;$/;"	m	struct:cv::SIFT::CommonParams	access:public
nOctaves	features2d/features2d.hpp	/^    int    nOctaves;$/;"	m	struct:CvSURFParams	access:public
nOctaves	features2d/features2d.hpp	/^    int nOctaves;$/;"	m	class:cv::LDetector	access:public
nRows	core/types_c.h	/^    int  nRows;$/;"	m	struct:_IplConvKernel	access:public
nRows	core/types_c.h	/^    int  nRows;$/;"	m	struct:_IplConvKernelFP	access:public
nSamplingDivider	contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
nShadowDetection	video/background_segm.hpp	/^    unsigned char nShadowDetection;\/\/do shadow detection - insert this value as the detection result - 127 default value$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
nShiftR	core/types_c.h	/^    int  nShiftR;$/;"	m	struct:_IplConvKernel	access:public
nSize	core/types_c.h	/^    int  nSize;             \/* sizeof(IplImage) *\/$/;"	m	struct:_IplImage	access:public
nSkinHueLowerBound	contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
nSkinHueUpperBound	contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
nStartCounter	contrib/contrib.hpp	/^    int nStartCounter, nFrameCount, nSkinHueLowerBound, nSkinHueUpperBound, nMorphingMethod, nSamplingDivider;$/;"	m	class:CvAdaptiveSkinDetector	access:private
nViews	features2d/features2d.hpp	/^    int nViews;$/;"	m	class:cv::LDetector	access:public
n_buckets_	flann/lsh_table.h	/^    size_t n_buckets_;$/;"	m	struct:cvflann::lsh::LshStats	access:public
n_features_	features2d/features2d.hpp	/^  size_t n_features_;$/;"	m	class:cv::ORB	access:private
n_features_	features2d/features2d.hpp	/^  unsigned int n_features_;$/;"	m	class:cv::OrbFeatureDetector	access:private
n_features_per_level_	features2d/features2d.hpp	/^  std::vector<size_t> n_features_per_level_;$/;"	m	class:cv::ORB	access:private
n_gauss	video/background_segm.hpp	/^    int     n_gauss;$/;"	m	struct:CvGaussBGStatModelParams	access:public
n_levels_	features2d/features2d.hpp	/^    unsigned int n_levels_;$/;"	m	struct:cv::ORB::CommonParams	access:public
nactive_vars	ml/ml.hpp	/^    CV_PROP_RW int nactive_vars;$/;"	m	struct:CvRTParams	access:public
name	core/core.hpp	/^    CV_WRAP string name() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
name	core/types_c.h	/^    const char* name;$/;"	m	struct:CvModuleInfo	access:public
name	gpu/gpu.hpp	/^            string name() const { return name_; }$/;"	f	class:cv::gpu::DeviceInfo	access:public	signature:() const
nameFont	core/core_c.h	/^	const char* nameFont;		\/\/Qt:nameFont$/;"	m	struct:CvFont	access:public
name_	gpu/gpu.hpp	/^            string name_;$/;"	m	class:cv::gpu::DeviceInfo	access:private
namedWindow	highgui/highgui.hpp	/^CV_EXPORTS_W void namedWindow( const string& winname, int flags=WINDOW_AUTOSIZE );$/;"	p	namespace:cv	signature:( const string& winname, int flags=WINDOW_AUTOSIZE )
narrays	core/core.hpp	/^    int narrays;$/;"	m	class:cv::NAryMatIterator	access:public
nbins	gpu/gpu.hpp	/^            int nbins;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
nbins	objdetect/objdetect.hpp	/^    CV_PROP int nbins;$/;"	m	struct:cv::HOGDescriptor	access:public
ncategories	objdetect/objdetect.hpp	/^        int ncategories;$/;"	m	class:cv::CascadeClassifier::Data	access:public
nclasses	features2d/features2d.hpp	/^        int nclasses;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
nclasses	features2d/features2d.hpp	/^    int nclasses;$/;"	m	class:cv::FernClassifier	access:protected
nclasses	ml/ml.hpp	/^    int nclasses;$/;"	m	class:CvRTrees	access:protected
nclusters	ml/ml.hpp	/^    CV_PROP_RW int nclusters;$/;"	m	struct:CvEMParams	access:public
ncvAssertCUDAReturn	gpu/NCV.hpp	268;"	d
ncvAssertPrintCheck	gpu/NCV.hpp	235;"	d
ncvAssertPrintReturn	gpu/NCV.hpp	241;"	d
ncvAssertReturn	gpu/NCV.hpp	245;"	d
ncvAssertReturnNcvStat	gpu/NCV.hpp	256;"	d
ncvDebugOutput	gpu/NCV.hpp	/^NCV_EXPORTS void ncvDebugOutput(const char *msg, ...);$/;"	p	signature:(const char *msg, ...)
ncvDrawRects_32u_device	gpu/NCV.hpp	/^NCV_EXPORTS NCVStatus ncvDrawRects_32u_device(Ncv32u *d_dst, Ncv32u dstStride, Ncv32u dstWidth, Ncv32u dstHeight,$/;"	p	signature:(Ncv32u *d_dst, Ncv32u dstStride, Ncv32u dstWidth, Ncv32u dstHeight, NcvRect32u *d_rects, Ncv32u numRects, Ncv32u color, cudaStream_t cuStream)
ncvDrawRects_32u_host	gpu/NCV.hpp	/^NCV_EXPORTS NCVStatus ncvDrawRects_32u_host(Ncv32u *h_dst, Ncv32u dstStride, Ncv32u dstWidth, Ncv32u dstHeight,$/;"	p	signature:(Ncv32u *h_dst, Ncv32u dstStride, Ncv32u dstWidth, Ncv32u dstHeight, NcvRect32u *h_rects, Ncv32u numRects, Ncv32u color)
ncvDrawRects_8u_device	gpu/NCV.hpp	/^NCV_EXPORTS NCVStatus ncvDrawRects_8u_device(Ncv8u *d_dst, Ncv32u dstStride, Ncv32u dstWidth, Ncv32u dstHeight,$/;"	p	signature:(Ncv8u *d_dst, Ncv32u dstStride, Ncv32u dstWidth, Ncv32u dstHeight, NcvRect32u *d_rects, Ncv32u numRects, Ncv8u color, cudaStream_t cuStream)
ncvDrawRects_8u_host	gpu/NCV.hpp	/^NCV_EXPORTS NCVStatus ncvDrawRects_8u_host(Ncv8u *h_dst, Ncv32u dstStride, Ncv32u dstWidth, Ncv32u dstHeight,$/;"	p	signature:(Ncv8u *h_dst, Ncv32u dstStride, Ncv32u dstWidth, Ncv32u dstHeight, NcvRect32u *h_rects, Ncv32u numRects, Ncv8u color)
ncvEndQueryTimerMs	gpu/NCV.hpp	/^NCV_EXPORTS double ncvEndQueryTimerMs(NcvTimer t);$/;"	p	signature:(NcvTimer t)
ncvEndQueryTimerUs	gpu/NCV.hpp	/^NCV_EXPORTS double ncvEndQueryTimerUs(NcvTimer t);$/;"	p	signature:(NcvTimer t)
ncvGroupRectangles_host	gpu/NCV.hpp	/^NCV_EXPORTS NCVStatus ncvGroupRectangles_host(NCVVector<NcvRect32u> &hypotheses, Ncv32u &numHypotheses,$/;"	p	signature:(NCVVector<NcvRect32u> &hypotheses, Ncv32u &numHypotheses, Ncv32u minNeighbors, Ncv32f intersectEps, NCVVector<Ncv32u> *hypothesesWeights)
ncvSetDebugOutputHandler	gpu/NCV.hpp	/^NCV_EXPORTS void ncvSetDebugOutputHandler(NCVDebugOutputHandler* func);$/;"	p	signature:(NCVDebugOutputHandler* func)
ncvStartTimer	gpu/NCV.hpp	/^NCV_EXPORTS NcvTimer ncvStartTimer(void);$/;"	p	signature:(void)
ndisp	gpu/gpu.hpp	/^            int ndisp;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
ndisp	gpu/gpu.hpp	/^            int ndisp;$/;"	m	class:cv::gpu::StereoBM_GPU	access:public
ndisp	gpu/gpu.hpp	/^            int ndisp;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:public
ndisp	gpu/gpu.hpp	/^            int ndisp;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
ne	legacy/legacy.hpp	/^    int* ne;$/;"	m	struct:CvCliqueFinder	access:public
needSwapCameras	legacy/legacy.hpp	/^    int needSwapCameras;\/* flag set to 1 if need to swap cameras for good reconstruction *\/$/;"	m	struct:CvStereoCamera	access:public
needed	core/core.hpp	/^    virtual bool needed() const;$/;"	p	class:cv::_OutputArray	access:public	signature:() const
neighbors	objdetect/objdetect.hpp	/^    int neighbors;$/;"	m	struct:CvAvgComp	access:public
newCurve	contrib/contrib.hpp	/^    CvFuzzyCurve *newCurve();$/;"	p	class:CvFuzzyFunction	access:public	signature:()
newEdge	imgproc/imgproc.hpp	/^    int newEdge();$/;"	p	class:cv::Subdiv2D	access:protected	signature:()
newNode	core/core.hpp	/^    uchar* newNode(const int* idx, size_t hashval);$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, size_t hashval)
newPoint	imgproc/imgproc.hpp	/^    int newPoint(Point2f pt, bool isvirtual, int firstEdge=0);$/;"	p	class:cv::Subdiv2D	access:protected	signature:(Point2f pt, bool isvirtual, int firstEdge=0)
new_node	ml/ml.hpp	/^    virtual CvDTreeNode* new_node( CvDTreeNode* parent, int count,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvDTreeNode* parent, int count, int storage_idx, int offset )
new_split_cat	ml/ml.hpp	/^    virtual CvDTreeSplit* new_split_cat( int vi, float quality );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( int vi, float quality )
new_split_ord	ml/ml.hpp	/^    virtual CvDTreeSplit* new_split_ord( int vi, float cmp_val,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( int vi, float cmp_val, int split_point, int inversed, float quality )
next	core/core.hpp	/^        size_t next;$/;"	m	struct:cv::SparseMat::Node	access:public
next	core/core.hpp	/^    unsigned next();$/;"	p	class:cv::RNG	access:public	signature:()
next	core/operations.hpp	/^inline unsigned RNG::next()$/;"	f	class:cv::RNG	signature:()
next	core/types_c.h	/^    struct CvAttrList* next;   \/* Pointer to next chunk of the attributes list.                    *\/$/;"	m	struct:CvAttrList	typeref:struct:CvAttrList::CvAttrList	access:public
next	core/types_c.h	/^    struct CvMemBlock*  next;$/;"	m	struct:CvMemBlock	typeref:struct:CvMemBlock::CvMemBlock	access:public
next	core/types_c.h	/^    struct CvModuleInfo* next;$/;"	m	struct:CvModuleInfo	typeref:struct:CvModuleInfo::CvModuleInfo	access:public
next	core/types_c.h	/^    struct CvSeqBlock*  next; \/* Next sequence block.                       *\/$/;"	m	struct:CvSeqBlock	typeref:struct:CvSeqBlock::CvSeqBlock	access:public
next	core/types_c.h	/^    struct CvSparseNode* next;$/;"	m	struct:CvSparseNode	typeref:struct:CvSparseNode::CvSparseNode	access:public
next	core/types_c.h	/^    struct CvStringHashNode* next;$/;"	m	struct:CvStringHashNode	typeref:struct:CvStringHashNode::CvStringHashNode	access:public
next	core/types_c.h	/^    struct CvTypeInfo* next;$/;"	m	struct:CvTypeInfo	typeref:struct:CvTypeInfo::CvTypeInfo	access:public
next	flann/random.h	/^    int next()$/;"	f	class:cvflann::UniqueRandom	access:public	signature:()
next	imgproc/imgproc.hpp	/^        int next[4];$/;"	m	struct:cv::Subdiv2D::QuadEdge	access:public
next	legacy/blobtrack.hpp	/^    struct CvDefParam*    next;$/;"	m	struct:CvDefParam	typeref:struct:CvDefParam::CvDefParam	access:public
next	legacy/legacy.hpp	/^    struct CvVoronoiSite2D *next[2];$/;"	m	struct:CvVoronoiSite2D	typeref:struct:CvVoronoiSite2D::CvVoronoiSite2D	access:public
next	ml/ml.hpp	/^    CvDTreeSplit* next;$/;"	m	struct:CvDTreeSplit	access:public
next	ml/ml.hpp	/^    CvSVMKernelRow* next;$/;"	m	struct:CvSVMKernelRow	access:public
next	ml/ml.hpp	/^    CvVectors* next;$/;"	m	struct:CvVectors	access:public
next	objdetect/objdetect.hpp	/^    int next;$/;"	m	struct:CvHaarStageClassifier	access:public
next	video/background_segm.hpp	/^    struct CvBGCodeBookElem* next;$/;"	m	struct:CvBGCodeBookElem	typeref:struct:CvBGCodeBookElem::CvBGCodeBookElem	access:public
nextEdge	imgproc/imgproc.hpp	/^    CV_WRAP int nextEdge(int edge) const;$/;"	p	class:cv::Subdiv2D	access:public	signature:(int edge) const
nframes	video/background_segm.hpp	/^    int nframes;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
nframes	video/background_segm.hpp	/^    int nframes;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
nlevels	gpu/gpu.hpp	/^            int nlevels;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
nlevels	objdetect/objdetect.hpp	/^    CV_PROP int nlevels;$/;"	m	struct:cv::HOGDescriptor	access:public
nmixtures	video/background_segm.hpp	/^    int nmixtures;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
nmixtures	video/background_segm.hpp	/^    int nmixtures;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
nnIndex	flann/flann.hpp	/^        ::cvflann::Index<Distance>* nnIndex;$/;"	m	class:cv::flann::GenericIndex	access:private
nnIndex_	flann/flann_base.hpp	/^    NNIndex<Distance>* nnIndex_;$/;"	m	class:cvflann::Index	access:private
nnIndex_L1	flann/flann.hpp	/^        ::cvflann::Index< L1<ElementType> >* nnIndex_L1;$/;"	m	class:cv::flann::Index_	access:private
nnIndex_L2	flann/flann.hpp	/^        ::cvflann::Index< L2<ElementType> >* nnIndex_L2;$/;"	m	class:cv::flann::Index_	access:private
noArray	core/core.hpp	/^CV_EXPORTS OutputArray noArray();$/;"	p	namespace:cv	signature:()
noOfSigBits	legacy/blobtrack.hpp	/^    int     noOfSigBits;$/;"	m	struct:CvBlobTrackerParamMS	access:public
nod	legacy/legacy.hpp	/^    int* nod;$/;"	m	struct:CvCliqueFinder	access:public
node	core/core.hpp	/^    Node* node(size_t nidx);$/;"	p	class:cv::SparseMat	access:public	signature:(size_t nidx)
node	core/core.hpp	/^    SparseMat::Node* node() const;$/;"	p	class:cv::SparseMatIterator	access:public	signature:() const
node	core/core.hpp	/^    const CvFileNode* node;$/;"	m	class:cv::FileNode	access:public
node	core/core.hpp	/^    const Node* node(size_t nidx) const;$/;"	p	class:cv::SparseMat	access:public	signature:(size_t nidx) const
node	core/core.hpp	/^    const SparseMat::Node* node() const;$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:() const
node	core/core_c.h	/^    const void* node;$/;"	m	struct:CvTreeNodeIterator	access:public
node	core/core_c.h	/^CVAPI(const char*) cvGetFileNodeName( const CvFileNode* node );$/;"	v
node	core/mat.hpp	/^inline SparseMat::Node* SparseMat::node(size_t nidx)$/;"	f	class:cv::SparseMat	signature:(size_t nidx)
node	core/mat.hpp	/^inline SparseMat::Node* SparseMatIterator::node() const$/;"	f	class:cv::SparseMatIterator	signature:() const
node	core/mat.hpp	/^inline const SparseMat::Node* SparseMat::node(size_t nidx) const$/;"	f	class:cv::SparseMat	signature:(size_t nidx) const
node	core/mat.hpp	/^inline const SparseMat::Node* SparseMatConstIterator::node() const$/;"	f	class:cv::SparseMatConstIterator	signature:() const
node	core/types_c.h	/^    CvSparseNode* node;$/;"	m	struct:CvSparseMatIterator	access:public
node	flann/result_set.h	/^    T node;           \/* Tree node at which search resumes *\/$/;"	m	struct:cvflann::BranchStruct	access:public
nodeCount	core/core.hpp	/^        size_t nodeCount;$/;"	m	struct:cv::SparseMat::Hdr	access:public
nodeCount	objdetect/objdetect.hpp	/^            int nodeCount;$/;"	m	struct:cv::CascadeClassifier::Data::DTree	access:public
nodeSize	core/core.hpp	/^        size_t nodeSize;$/;"	m	struct:cv::SparseMat::Hdr	access:public
node_heap	ml/ml.hpp	/^    CvSet* node_heap;$/;"	m	struct:CvDTreeTrainData	access:public
node_risk	ml/ml.hpp	/^    double node_risk, tree_risk, tree_error;$/;"	m	struct:CvDTreeNode	access:public
nodes	contrib/contrib.hpp	/^        vector<Node> nodes;$/;"	m	class:cv::Octree	access:private
nodes	core/core.hpp	/^    vector<Node> nodes; \/\/!< all the tree nodes$/;"	m	class:cv::KDTree	access:public
nodes	objdetect/objdetect.hpp	/^        vector<DTreeNode> nodes;$/;"	m	class:cv::CascadeClassifier::Data	access:public
nodes_	features2d/features2d.hpp	/^  std::vector<RTreeNode> nodes_;$/;"	m	class:cv::RandomizedTree	access:private
noiseRange	features2d/features2d.hpp	/^    double noiseRange;$/;"	m	class:cv::PatchGenerator	access:public
noiseSigma	video/background_segm.hpp	/^    double noiseSigma;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
nonmaxSuppression	features2d/features2d.hpp	/^    bool nonmaxSuppression;$/;"	m	class:cv::FastFeatureDetector	access:protected
nonmax_	features2d/features2d.hpp	/^    bool nonmax_;$/;"	m	class:cv::FastAdjuster	access:protected
norm	core/core.hpp	/^CV_EXPORTS double norm( const SparseMat& src, int normType );$/;"	p	namespace:cv	signature:( const SparseMat& src, int normType )
norm	core/core.hpp	/^CV_EXPORTS_W double norm(InputArray src1, InputArray src2,$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, int normType=NORM_L2, InputArray mask=noArray())
norm	core/core.hpp	/^CV_EXPORTS_W double norm(InputArray src1, int normType=NORM_L2, InputArray mask=noArray());$/;"	p	namespace:cv	signature:(InputArray src1, int normType=NORM_L2, InputArray mask=noArray())
norm	core/operations.hpp	/^double norm(const Matx<_Tp, m, n>& M)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& M)
norm	core/operations.hpp	/^double norm(const Matx<_Tp, m, n>& M, int normType)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& M, int normType)
norm	core/operations.hpp	/^template<typename _Tp> static inline double norm(const Point3_<_Tp>& pt)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& pt)
norm	core/operations.hpp	/^template<typename _Tp> static inline double norm(const Point_<_Tp>& pt)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& pt)
norm	gpu/gpu.hpp	/^        CV_EXPORTS double norm(const GpuMat& src1, const GpuMat& src2, int normType=NORM_L2);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, const GpuMat& src2, int normType=NORM_L2)
norm	gpu/gpu.hpp	/^        CV_EXPORTS double norm(const GpuMat& src1, int normType, GpuMat& buf);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, int normType, GpuMat& buf)
norm	gpu/gpu.hpp	/^        CV_EXPORTS double norm(const GpuMat& src1, int normType=NORM_L2);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, int normType=NORM_L2)
normType	core/core.hpp	/^    CV_PROP_RW int normType; \/\/!< type of the distance (cv::NORM_L1 or cv::NORM_L2) used for search. Initially set to cv::NORM_L2, but you can modify it$/;"	m	class:cv::KDTree	access:public
normalRadius	contrib/contrib.hpp	/^        float normalRadius;$/;"	m	class:cv::SpinImageModel	access:public
normalize	core/core.hpp	/^CV_EXPORTS void normalize( const SparseMat& src, SparseMat& dst, double alpha, int normType );$/;"	p	namespace:cv	signature:( const SparseMat& src, SparseMat& dst, double alpha, int normType )
normalize	core/core.hpp	/^CV_EXPORTS_W void normalize( InputArray src, OutputArray dst, double alpha=1, double beta=0,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, double alpha=1, double beta=0, int norm_type=NORM_L2, int dtype=-1, InputArray mask=noArray())
normals	contrib/contrib.hpp	/^        vector<Point3f> normals;$/;"	m	class:cv::Mesh3D	access:public
nplanes	core/core.hpp	/^    size_t nplanes;$/;"	m	class:cv::NAryMatIterator	access:public
nppError	gpu/gpu.hpp	/^        CV_EXPORTS void nppError( int err, const char *file, const int line, const char *func);$/;"	p	namespace:cv::gpu	signature:( int err, const char *file, const int line, const char *func)
nppStGetActiveCUDAstream	gpu/NPP_staging.hpp	/^cudaStream_t nppStGetActiveCUDAstream();$/;"	p	signature:()
nppStSetActiveCUDAstream	gpu/NPP_staging.hpp	/^cudaStream_t nppStSetActiveCUDAstream(cudaStream_t cudaStream);$/;"	p	signature:(cudaStream_t cudaStream)
nppiStDecimate_32f_C1R	gpu/NPP_staging.hpp	/^NCVStatus nppiStDecimate_32f_C1R(Ncv32f *d_src, Ncv32u srcStep,$/;"	p	signature:(Ncv32f *d_src, Ncv32u srcStep, Ncv32f *d_dst, Ncv32u dstStep, NcvSize32u srcRoi, Ncv32u scale, NcvBool readThruTexture)
nppiStDecimate_32f_C1R_host	gpu/NPP_staging.hpp	/^NCVStatus nppiStDecimate_32f_C1R_host(Ncv32f *h_src, Ncv32u srcStep,$/;"	p	signature:(Ncv32f *h_src, Ncv32u srcStep, Ncv32f *h_dst, Ncv32u dstStep, NcvSize32u srcRoi, Ncv32u scale)
nppiStDecimate_32s_C1R	gpu/NPP_staging.hpp	/^NCVStatus nppiStDecimate_32s_C1R(Ncv32s *d_src, Ncv32u srcStep,$/;"	p	signature:(Ncv32s *d_src, Ncv32u srcStep, Ncv32s *d_dst, Ncv32u dstStep, NcvSize32u srcRoi, Ncv32u scale, NcvBool readThruTexture)
nppiStDecimate_32s_C1R_host	gpu/NPP_staging.hpp	/^NCVStatus nppiStDecimate_32s_C1R_host(Ncv32s *h_src, Ncv32u srcStep,$/;"	p	signature:(Ncv32s *h_src, Ncv32u srcStep, Ncv32s *h_dst, Ncv32u dstStep, NcvSize32u srcRoi, Ncv32u scale)
nppiStDecimate_32u_C1R	gpu/NPP_staging.hpp	/^NCVStatus nppiStDecimate_32u_C1R(Ncv32u *d_src, Ncv32u srcStep,$/;"	p	signature:(Ncv32u *d_src, Ncv32u srcStep, Ncv32u *d_dst, Ncv32u dstStep, NcvSize32u srcRoi, Ncv32u scale, NcvBool readThruTexture)
nppiStDecimate_32u_C1R_host	gpu/NPP_staging.hpp	/^NCVStatus nppiStDecimate_32u_C1R_host(Ncv32u *h_src, Ncv32u srcStep,$/;"	p	signature:(Ncv32u *h_src, Ncv32u srcStep, Ncv32u *h_dst, Ncv32u dstStep, NcvSize32u srcRoi, Ncv32u scale)
nppiStDecimate_64f_C1R	gpu/NPP_staging.hpp	/^NCVStatus nppiStDecimate_64f_C1R(Ncv64f *d_src, Ncv32u srcStep,$/;"	p	signature:(Ncv64f *d_src, Ncv32u srcStep, Ncv64f *d_dst, Ncv32u dstStep, NcvSize32u srcRoi, Ncv32u scale, NcvBool readThruTexture)
nppiStDecimate_64f_C1R_host	gpu/NPP_staging.hpp	/^NCVStatus nppiStDecimate_64f_C1R_host(Ncv64f *h_src, Ncv32u srcStep,$/;"	p	signature:(Ncv64f *h_src, Ncv32u srcStep, Ncv64f *h_dst, Ncv32u dstStep, NcvSize32u srcRoi, Ncv32u scale)
nppiStDecimate_64s_C1R	gpu/NPP_staging.hpp	/^NCVStatus nppiStDecimate_64s_C1R(Ncv64s *d_src, Ncv32u srcStep,$/;"	p	signature:(Ncv64s *d_src, Ncv32u srcStep, Ncv64s *d_dst, Ncv32u dstStep, NcvSize32u srcRoi, Ncv32u scale, NcvBool readThruTexture)
nppiStDecimate_64s_C1R_host	gpu/NPP_staging.hpp	/^NCVStatus nppiStDecimate_64s_C1R_host(Ncv64s *h_src, Ncv32u srcStep,$/;"	p	signature:(Ncv64s *h_src, Ncv32u srcStep, Ncv64s *h_dst, Ncv32u dstStep, NcvSize32u srcRoi, Ncv32u scale)
nppiStDecimate_64u_C1R	gpu/NPP_staging.hpp	/^NCVStatus nppiStDecimate_64u_C1R(Ncv64u *d_src, Ncv32u srcStep,$/;"	p	signature:(Ncv64u *d_src, Ncv32u srcStep, Ncv64u *d_dst, Ncv32u dstStep, NcvSize32u srcRoi, Ncv32u scale, NcvBool readThruTexture)
nppiStDecimate_64u_C1R_host	gpu/NPP_staging.hpp	/^NCVStatus nppiStDecimate_64u_C1R_host(Ncv64u *h_src, Ncv32u srcStep,$/;"	p	signature:(Ncv64u *h_src, Ncv32u srcStep, Ncv64u *h_dst, Ncv32u dstStep, NcvSize32u srcRoi, Ncv32u scale)
nppiStIntegralGetSize_32f32f	gpu/NPP_staging.hpp	/^NCVStatus nppiStIntegralGetSize_32f32f(NcvSize32u roiSize, Ncv32u *pBufsize, cudaDeviceProp &devProp);$/;"	p	signature:(NcvSize32u roiSize, Ncv32u *pBufsize, cudaDeviceProp &devProp)
nppiStIntegralGetSize_8u32u	gpu/NPP_staging.hpp	/^NCVStatus nppiStIntegralGetSize_8u32u(NcvSize32u roiSize, Ncv32u *pBufsize, cudaDeviceProp &devProp);$/;"	p	signature:(NcvSize32u roiSize, Ncv32u *pBufsize, cudaDeviceProp &devProp)
nppiStIntegral_32f32f_C1R	gpu/NPP_staging.hpp	/^NCVStatus nppiStIntegral_32f32f_C1R(Ncv32f *d_src, Ncv32u srcStep,$/;"	p	signature:(Ncv32f *d_src, Ncv32u srcStep, Ncv32f *d_dst, Ncv32u dstStep, NcvSize32u roiSize, Ncv8u *pBuffer, Ncv32u bufSize, cudaDeviceProp &devProp)
nppiStIntegral_32f32f_C1R_host	gpu/NPP_staging.hpp	/^NCVStatus nppiStIntegral_32f32f_C1R_host(Ncv32f *h_src, Ncv32u srcStep,$/;"	p	signature:(Ncv32f *h_src, Ncv32u srcStep, Ncv32f *h_dst, Ncv32u dstStep, NcvSize32u roiSize)
nppiStIntegral_8u32u_C1R	gpu/NPP_staging.hpp	/^NCVStatus nppiStIntegral_8u32u_C1R(Ncv8u *d_src, Ncv32u srcStep,$/;"	p	signature:(Ncv8u *d_src, Ncv32u srcStep, Ncv32u *d_dst, Ncv32u dstStep, NcvSize32u roiSize, Ncv8u *pBuffer, Ncv32u bufSize, cudaDeviceProp &devProp)
nppiStIntegral_8u32u_C1R_host	gpu/NPP_staging.hpp	/^NCVStatus nppiStIntegral_8u32u_C1R_host(Ncv8u *h_src, Ncv32u srcStep,$/;"	p	signature:(Ncv8u *h_src, Ncv32u srcStep, Ncv32u *h_dst, Ncv32u dstStep, NcvSize32u roiSize)
nppiStRectStdDev_32f_C1R	gpu/NPP_staging.hpp	/^NCVStatus nppiStRectStdDev_32f_C1R(Ncv32u *d_sum, Ncv32u sumStep,$/;"	p	signature:(Ncv32u *d_sum, Ncv32u sumStep, Ncv64u *d_sqsum, Ncv32u sqsumStep, Ncv32f *d_norm, Ncv32u normStep, NcvSize32u roi, NcvRect32u rect, Ncv32f scaleArea, NcvBool readThruTexture)
nppiStRectStdDev_32f_C1R_host	gpu/NPP_staging.hpp	/^NCVStatus nppiStRectStdDev_32f_C1R_host(Ncv32u *h_sum, Ncv32u sumStep,$/;"	p	signature:(Ncv32u *h_sum, Ncv32u sumStep, Ncv64u *h_sqsum, Ncv32u sqsumStep, Ncv32f *h_norm, Ncv32u normStep, NcvSize32u roi, NcvRect32u rect, Ncv32f scaleArea)
nppiStSqrIntegralGetSize_8u64u	gpu/NPP_staging.hpp	/^NCVStatus nppiStSqrIntegralGetSize_8u64u(NcvSize32u roiSize, Ncv32u *pBufsize, cudaDeviceProp &devProp);$/;"	p	signature:(NcvSize32u roiSize, Ncv32u *pBufsize, cudaDeviceProp &devProp)
nppiStSqrIntegral_8u64u_C1R	gpu/NPP_staging.hpp	/^NCVStatus nppiStSqrIntegral_8u64u_C1R(Ncv8u *d_src, Ncv32u srcStep,$/;"	p	signature:(Ncv8u *d_src, Ncv32u srcStep, Ncv64u *d_dst, Ncv32u dstStep, NcvSize32u roiSize, Ncv8u *pBuffer, Ncv32u bufSize, cudaDeviceProp &devProp)
nppiStSqrIntegral_8u64u_C1R_host	gpu/NPP_staging.hpp	/^NCVStatus nppiStSqrIntegral_8u64u_C1R_host(Ncv8u *h_src, Ncv32u srcStep,$/;"	p	signature:(Ncv8u *h_src, Ncv32u srcStep, Ncv64u *h_dst, Ncv32u dstStep, NcvSize32u roiSize)
nppiStTranspose_128_C1R	gpu/NPP_staging.hpp	/^NCVStatus nppiStTranspose_128_C1R(void *d_src, Ncv32u srcStep,$/;"	p	signature:(void *d_src, Ncv32u srcStep, void *d_dst, Ncv32u dstStep, NcvSize32u srcRoi)
nppiStTranspose_128_C1R_host	gpu/NPP_staging.hpp	/^NCVStatus nppiStTranspose_128_C1R_host(void *d_src, Ncv32u srcStep,$/;"	p	signature:(void *d_src, Ncv32u srcStep, void *d_dst, Ncv32u dstStep, NcvSize32u srcRoi)
nppiStTranspose_32f_C1R	gpu/NPP_staging.hpp	/^NCVStatus nppiStTranspose_32f_C1R(Ncv32f *d_src, Ncv32u srcStride,$/;"	p	signature:(Ncv32f *d_src, Ncv32u srcStride, Ncv32f *d_dst, Ncv32u dstStride, NcvSize32u srcRoi)
nppiStTranspose_32f_C1R_host	gpu/NPP_staging.hpp	/^NCVStatus nppiStTranspose_32f_C1R_host(Ncv32f *h_src, Ncv32u srcStride,$/;"	p	signature:(Ncv32f *h_src, Ncv32u srcStride, Ncv32f *h_dst, Ncv32u dstStride, NcvSize32u srcRoi)
nppiStTranspose_32s_C1R	gpu/NPP_staging.hpp	/^NCVStatus nppiStTranspose_32s_C1R(Ncv32s *d_src, Ncv32u srcStride,$/;"	p	signature:(Ncv32s *d_src, Ncv32u srcStride, Ncv32s *d_dst, Ncv32u dstStride, NcvSize32u srcRoi)
nppiStTranspose_32s_C1R_host	gpu/NPP_staging.hpp	/^NCVStatus nppiStTranspose_32s_C1R_host(Ncv32s *h_src, Ncv32u srcStride,$/;"	p	signature:(Ncv32s *h_src, Ncv32u srcStride, Ncv32s *h_dst, Ncv32u dstStride, NcvSize32u srcRoi)
nppiStTranspose_32u_C1R	gpu/NPP_staging.hpp	/^NCVStatus nppiStTranspose_32u_C1R(Ncv32u *d_src, Ncv32u srcStride,$/;"	p	signature:(Ncv32u *d_src, Ncv32u srcStride, Ncv32u *d_dst, Ncv32u dstStride, NcvSize32u srcRoi)
nppiStTranspose_32u_C1R_host	gpu/NPP_staging.hpp	/^NCVStatus nppiStTranspose_32u_C1R_host(Ncv32u *h_src, Ncv32u srcStride,$/;"	p	signature:(Ncv32u *h_src, Ncv32u srcStride, Ncv32u *h_dst, Ncv32u dstStride, NcvSize32u srcRoi)
nppiStTranspose_64f_C1R	gpu/NPP_staging.hpp	/^NCVStatus nppiStTranspose_64f_C1R(Ncv64f *d_src, Ncv32u srcStride,$/;"	p	signature:(Ncv64f *d_src, Ncv32u srcStride, Ncv64f *d_dst, Ncv32u dstStride, NcvSize32u srcRoi)
nppiStTranspose_64f_C1R_host	gpu/NPP_staging.hpp	/^NCVStatus nppiStTranspose_64f_C1R_host(Ncv64f *h_src, Ncv32u srcStride,$/;"	p	signature:(Ncv64f *h_src, Ncv32u srcStride, Ncv64f *h_dst, Ncv32u dstStride, NcvSize32u srcRoi)
nppiStTranspose_64s_C1R	gpu/NPP_staging.hpp	/^NCVStatus nppiStTranspose_64s_C1R(Ncv64s *d_src, Ncv32u srcStride,$/;"	p	signature:(Ncv64s *d_src, Ncv32u srcStride, Ncv64s *d_dst, Ncv32u dstStride, NcvSize32u srcRoi)
nppiStTranspose_64s_C1R_host	gpu/NPP_staging.hpp	/^NCVStatus nppiStTranspose_64s_C1R_host(Ncv64s *h_src, Ncv32u srcStride,$/;"	p	signature:(Ncv64s *h_src, Ncv32u srcStride, Ncv64s *h_dst, Ncv32u dstStride, NcvSize32u srcRoi)
nppiStTranspose_64u_C1R	gpu/NPP_staging.hpp	/^NCVStatus nppiStTranspose_64u_C1R(Ncv64u *d_src, Ncv32u srcStride,$/;"	p	signature:(Ncv64u *d_src, Ncv32u srcStride, Ncv64u *d_dst, Ncv32u dstStride, NcvSize32u srcRoi)
nppiStTranspose_64u_C1R_host	gpu/NPP_staging.hpp	/^NCVStatus nppiStTranspose_64u_C1R_host(Ncv64u *h_src, Ncv32u srcStride,$/;"	p	signature:(Ncv64u *h_src, Ncv32u srcStride, Ncv64u *h_dst, Ncv32u dstStride, NcvSize32u srcRoi)
nppsStCompactGetSize_32f	gpu/NPP_staging.hpp	/^NCVStatus nppsStCompactGetSize_32f(Ncv32u srcLen, Ncv32u *pBufsize, cudaDeviceProp &devProp);$/;"	p	signature:(Ncv32u srcLen, Ncv32u *pBufsize, cudaDeviceProp &devProp)
nppsStCompactGetSize_32s	gpu/NPP_staging.hpp	/^NCVStatus nppsStCompactGetSize_32s(Ncv32u srcLen, Ncv32u *pBufsize, cudaDeviceProp &devProp);$/;"	p	signature:(Ncv32u srcLen, Ncv32u *pBufsize, cudaDeviceProp &devProp)
nppsStCompactGetSize_32u	gpu/NPP_staging.hpp	/^NCVStatus nppsStCompactGetSize_32u(Ncv32u srcLen, Ncv32u *pBufsize, cudaDeviceProp &devProp);$/;"	p	signature:(Ncv32u srcLen, Ncv32u *pBufsize, cudaDeviceProp &devProp)
nppsStCompact_32f	gpu/NPP_staging.hpp	/^NCVStatus nppsStCompact_32f(Ncv32f *d_src, Ncv32u srcLen,$/;"	p	signature:(Ncv32f *d_src, Ncv32u srcLen, Ncv32f *d_dst, Ncv32u *p_dstLen, Ncv32f elemRemove, Ncv8u *pBuffer, Ncv32u bufSize, cudaDeviceProp &devProp)
nppsStCompact_32f_host	gpu/NPP_staging.hpp	/^NCVStatus nppsStCompact_32f_host(Ncv32f *h_src, Ncv32u srcLen,$/;"	p	signature:(Ncv32f *h_src, Ncv32u srcLen, Ncv32f *h_dst, Ncv32u *dstLen, Ncv32f elemRemove)
nppsStCompact_32s	gpu/NPP_staging.hpp	/^NCVStatus nppsStCompact_32s(Ncv32s *d_src, Ncv32u srcLen,$/;"	p	signature:(Ncv32s *d_src, Ncv32u srcLen, Ncv32s *d_dst, Ncv32u *p_dstLen, Ncv32s elemRemove, Ncv8u *pBuffer, Ncv32u bufSize, cudaDeviceProp &devProp)
nppsStCompact_32s_host	gpu/NPP_staging.hpp	/^NCVStatus nppsStCompact_32s_host(Ncv32s *h_src, Ncv32u srcLen,$/;"	p	signature:(Ncv32s *h_src, Ncv32u srcLen, Ncv32s *h_dst, Ncv32u *dstLen, Ncv32s elemRemove)
nppsStCompact_32u	gpu/NPP_staging.hpp	/^NCVStatus nppsStCompact_32u(Ncv32u *d_src, Ncv32u srcLen,$/;"	p	signature:(Ncv32u *d_src, Ncv32u srcLen, Ncv32u *d_dst, Ncv32u *p_dstLen, Ncv32u elemRemove, Ncv8u *pBuffer, Ncv32u bufSize, cudaDeviceProp &devProp)
nppsStCompact_32u_host	gpu/NPP_staging.hpp	/^NCVStatus nppsStCompact_32u_host(Ncv32u *h_src, Ncv32u srcLen,$/;"	p	signature:(Ncv32u *h_src, Ncv32u srcLen, Ncv32u *h_dst, Ncv32u *dstLen, Ncv32u elemRemove)
nr_plane	gpu/gpu.hpp	/^            int nr_plane;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
nsamples	ml/ml.hpp	/^    int nsamples;$/;"	m	class:CvRTrees	access:protected
nstructs	features2d/features2d.hpp	/^        int nstructs;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
nstructs	features2d/features2d.hpp	/^    int nstructs;$/;"	m	class:cv::FernClassifier	access:protected
ntrees	ml/ml.hpp	/^    int ntrees;$/;"	m	class:CvRTrees	access:protected
ntrees	objdetect/objdetect.hpp	/^            int ntrees;$/;"	m	struct:cv::CascadeClassifier::Data::Stage	access:public
nu	ml/ml.hpp	/^    CV_PROP_RW double      nu; \/\/ for CV_SVM_NU_SVC, CV_SVM_ONE_CLASS, and CV_SVM_NU_SVR$/;"	m	struct:CvSVMParams	access:public
nu02	imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
nu03	imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
nu11	imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
nu12	imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
nu20	imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
nu21	imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
nu30	imgproc/imgproc.hpp	/^    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;$/;"	m	class:cv::Moments	access:public
numFeatures	objdetect/objdetect.hpp	/^    int numFeatures;$/;"	m	struct:__anon197	access:public
numIters	contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
numPartsWithin	gpu/gpu.hpp	/^            static Size numPartsWithin(Size size, Size part_size, Size stride);$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:(Size size, Size part_size, Size stride)
numPartsWithin	gpu/gpu.hpp	/^            static int numPartsWithin(int size, int part_size, int stride);$/;"	p	struct:cv::gpu::HOGDescriptor	access:protected	signature:(int size, int part_size, int stride)
numShifts	contrib/contrib.hpp	/^        int ldx, ldy, ldw, ldh, numShifts, numIters;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
num_cam_param	contrib/contrib.hpp	/^        int num_cam_param;$/;"	m	class:cv::LevMarqSparse	access:public
num_cams	contrib/contrib.hpp	/^        int num_cams;$/;"	m	class:cv::LevMarqSparse	access:public
num_components	objdetect/objdetect.hpp	/^	int num_components;$/;"	m	struct:CvLatentSvmDetector	access:public
num_err_param	contrib/contrib.hpp	/^        int num_err_param;$/;"	m	class:cv::LevMarqSparse	access:public
num_filters	objdetect/objdetect.hpp	/^	int num_filters;$/;"	m	struct:CvLatentSvmDetector	access:public
num_leaves_	features2d/features2d.hpp	/^  int num_leaves_;$/;"	m	class:cv::RandomizedTree	access:private
num_mix	legacy/legacy.hpp	/^    int num_mix;        \/*number of mixtures in this state*\/$/;"	m	struct:CvEHMMState	access:public
num_part_filters	objdetect/objdetect.hpp	/^	int* num_part_filters;$/;"	m	struct:CvLatentSvmDetector	access:public
num_point_param	contrib/contrib.hpp	/^        int num_point_param;$/;"	m	class:cv::LevMarqSparse	access:public
num_points	contrib/contrib.hpp	/^        int num_points;$/;"	m	class:cv::LevMarqSparse	access:public
num_quant_bits_	features2d/features2d.hpp	/^  int num_quant_bits_;$/;"	m	class:cv::RTreeClassifier	access:private
num_states	legacy/legacy.hpp	/^    int num_states; \/* number of HMM states *\/$/;"	m	struct:CvEHMM	access:public
num_valid	ml/ml.hpp	/^    int* num_valid;$/;"	m	struct:CvDTreeNode	access:public
numberOfAngles	contrib/contrib.hpp	/^        int numberOfAngles;$/;"	m	class:cv::SelfSimDescriptor	access:public
numberOfDisparities	calib3d/calib3d.hpp	/^    CV_PROP_RW int numberOfDisparities;$/;"	m	class:cv::StereoSGBM	access:public
numberOfDisparities	calib3d/calib3d.hpp	/^    int numberOfDisparities; \/\/ maximum disparity - minimum disparity (> 0)$/;"	m	struct:CvStereoBMState	access:public
numberOfDisparities	calib3d/calib3d.hpp	/^    int numberOfDisparities;$/;"	m	struct:CvStereoGCState	access:public
numberOfDistanceBuckets	contrib/contrib.hpp	/^        int numberOfDistanceBuckets;$/;"	m	class:cv::SelfSimDescriptor	access:public
nv_heap	ml/ml.hpp	/^    CvSet* nv_heap;$/;"	m	struct:CvDTreeTrainData	access:public
nviews	features2d/features2d.hpp	/^        int nviews;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
nzcount	core/core.hpp	/^    size_t nzcount() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
nzcount	core/mat.hpp	/^inline size_t SparseMat::nzcount() const$/;"	f	class:cv::SparseMat	signature:() const
obj	core/core.hpp	/^    _Tp* obj; \/\/< the object pointer.$/;"	m	class:cv::Ptr	access:protected
obj	core/core.hpp	/^    void* obj;$/;"	m	class:cv::_InputArray	access:public
obj	ml/ml.hpp	/^    double obj;$/;"	m	struct:CvSVMSolutionInfo	access:public
object	flann/any.h	/^    void* object;$/;"	m	struct:cdiggins::any	access:private
object_registry	flann/object_factory.h	/^    ObjectRegistry object_registry;$/;"	m	class:cvflann::ObjectFactory	access:private
obs	legacy/legacy.hpp	/^    float* obs;\/\/consequtive observations$/;"	m	struct:CvImgObsInfo	access:public
obsProb	legacy/legacy.hpp	/^    float** obsProb; \/* if level == 0 - array of brob matrices corresponding to hmm$/;"	m	struct:CvEHMM	access:public
obs_info	legacy/legacy.hpp	/^CVAPI(void)  cvReleaseObsInfo( CvImgObsInfo** obs_info );$/;"	v
obs_size	legacy/legacy.hpp	/^    int obs_size;$/;"	m	struct:CvImgObsInfo	access:public
obs_x	legacy/legacy.hpp	/^    int obs_x;$/;"	m	struct:CvImgObsInfo	access:public
obs_y	legacy/legacy.hpp	/^    int obs_y;$/;"	m	struct:CvImgObsInfo	access:public
occlusionCost	calib3d/calib3d.hpp	/^    int occlusionCost;$/;"	m	struct:CvStereoGCState	access:public
octave	features2d/features2d.hpp	/^    CV_PROP_RW int octave; \/\/!< octave (pyramid layer) from which the keypoint has been extracted$/;"	m	class:cv::KeyPoint	access:public
octree	contrib/contrib.hpp	/^        Octree octree;$/;"	m	class:cv::Mesh3D	access:public
offset	ml/ml.hpp	/^    int offset;$/;"	m	struct:CvDTreeNode	access:public
offset1	features2d/features2d.hpp	/^  short offset1, offset2;$/;"	m	struct:cv::RTreeNode	access:public
offset2	features2d/features2d.hpp	/^  short offset1, offset2;$/;"	m	struct:cv::RTreeNode	access:public
oldCascade	objdetect/objdetect.hpp	/^    Ptr<CvHaarClassifierCascade> oldCascade;$/;"	m	class:cv::CascadeClassifier	access:protected
old_state	features2d/features2d.hpp	/^        const uint64 old_state;$/;"	m	struct:cv::DefaultRngAuto	access:public
ones	core/core.hpp	/^    static MatExpr ones(Size size);$/;"	p	class:cv::Mat_	access:public	signature:(Size size)
ones	core/core.hpp	/^    static MatExpr ones(Size size, int type);$/;"	p	class:cv::Mat	access:public	signature:(Size size, int type)
ones	core/core.hpp	/^    static MatExpr ones(int _ndims, const int* _sizes);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes)
ones	core/core.hpp	/^    static MatExpr ones(int ndims, const int* sz, int type);$/;"	p	class:cv::Mat	access:public	signature:(int ndims, const int* sz, int type)
ones	core/core.hpp	/^    static MatExpr ones(int rows, int cols);$/;"	p	class:cv::Mat_	access:public	signature:(int rows, int cols)
ones	core/core.hpp	/^    static MatExpr ones(int rows, int cols, int type);$/;"	p	class:cv::Mat	access:public	signature:(int rows, int cols, int type)
ones	core/core.hpp	/^    static Matx ones();$/;"	p	class:cv::Matx	access:public	signature:()
ones	core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::ones(Size sz)$/;"	f	class:cv::Mat_	signature:(Size sz)
ones	core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::ones(int rows, int cols)$/;"	f	class:cv::Mat_	signature:(int rows, int cols)
ones	core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::ones()$/;"	f	class:cv::Matx	signature:()
oob_error	ml/ml.hpp	/^    double oob_error;$/;"	m	class:CvRTrees	access:protected
op	core/mat.hpp	/^    const MatOp* op;$/;"	m	class:cv::MatExpr	access:public
open	core/core.hpp	/^    CV_WRAP virtual bool open(const string& filename, int flags, const string& encoding=string());$/;"	p	class:cv::FileStorage	access:public	signature:(const string& filename, int flags, const string& encoding=string())
open	highgui/highgui.hpp	/^    CV_WRAP virtual bool open(const string& filename);$/;"	p	class:cv::VideoCapture	access:public	signature:(const string& filename)
open	highgui/highgui.hpp	/^    CV_WRAP virtual bool open(const string& filename, int fourcc, double fps,$/;"	p	class:cv::VideoWriter	access:public	signature:(const string& filename, int fourcc, double fps, Size frameSize, bool isColor=true)
open	highgui/highgui.hpp	/^    CV_WRAP virtual bool open(int device);$/;"	p	class:cv::VideoCapture	access:public	signature:(int device)
operator !	core/operations.hpp	/^static inline bool operator !(const Range& r)$/;"	f	namespace:cv	signature:(const Range& r)
operator !=	core/core.hpp	/^        bool operator != (const MSize& sz) const;$/;"	p	struct:cv::Mat::MSize	access:public	signature:(const MSize& sz) const
operator !=	core/mat.hpp	/^CV_EXPORTS MatExpr operator != (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator !=	core/mat.hpp	/^CV_EXPORTS MatExpr operator != (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
operator !=	core/mat.hpp	/^CV_EXPORTS MatExpr operator != (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
operator !=	core/mat.hpp	/^inline bool Mat::MSize::operator != (const MSize& sz) const$/;"	f	class:cv::Mat::MSize	signature:(const MSize& sz) const
operator !=	core/mat.hpp	/^operator != (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
operator !=	core/mat.hpp	/^operator != (const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)$/;"	f	namespace:cv	signature:(const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)
operator !=	core/mat.hpp	/^operator != (const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)$/;"	f	namespace:cv	signature:(const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)
operator !=	core/mat.hpp	/^static inline bool operator != (const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)$/;"	f	namespace:cv	signature:(const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)
operator !=	core/operations.hpp	/^bool operator != (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
operator !=	core/operations.hpp	/^bool operator != (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
operator !=	core/operations.hpp	/^static inline bool operator != (const FileNodeIterator& it1, const FileNodeIterator& it2)$/;"	f	namespace:cv	signature:(const FileNodeIterator& it1, const FileNodeIterator& it2)
operator !=	core/operations.hpp	/^static inline bool operator != (const Range& r1, const Range& r2)$/;"	f	namespace:cv	signature:(const Range& r1, const Range& r2)
operator !=	core/operations.hpp	/^template<typename _Tp> inline bool operator != (const SeqIterator<_Tp>& a,$/;"	f	namespace:cv	signature:(const SeqIterator<_Tp>& a, const SeqIterator<_Tp>& b)
operator !=	core/operations.hpp	/^template<typename _Tp> static inline bool operator != ( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )$/;"	f	namespace:cv	signature:( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )
operator !=	core/operations.hpp	/^template<typename _Tp> static inline bool operator != (const Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, const Point3_<_Tp>& b)
operator !=	core/operations.hpp	/^template<typename _Tp> static inline bool operator != (const Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, const Point_<_Tp>& b)
operator !=	core/operations.hpp	/^template<typename _Tp> static inline bool operator != (const Rect_<_Tp>& a, const Rect_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Rect_<_Tp>& b)
operator !=	core/operations.hpp	/^template<typename _Tp> static inline bool operator != (const Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Size_<_Tp>& a, const Size_<_Tp>& b)
operator &	core/mat.hpp	/^CV_EXPORTS MatExpr operator & (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator &	core/mat.hpp	/^CV_EXPORTS MatExpr operator & (const Mat& a, const Scalar& s);$/;"	p	namespace:cv	signature:(const Mat& a, const Scalar& s)
operator &	core/mat.hpp	/^CV_EXPORTS MatExpr operator & (const Scalar& s, const Mat& a);$/;"	p	namespace:cv	signature:(const Scalar& s, const Mat& a)
operator &	core/operations.hpp	/^static inline Range operator & (const Range& r1, const Range& r2)$/;"	f	namespace:cv	signature:(const Range& r1, const Range& r2)
operator &	core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp> operator & (const Rect_<_Tp>& a, const Rect_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Rect_<_Tp>& b)
operator &=	core/mat.hpp	/^operator &= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
operator &=	core/mat.hpp	/^operator &= (const Mat_<_Tp>& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Scalar& s)
operator &=	core/mat.hpp	/^static inline Mat& operator &= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
operator &=	core/mat.hpp	/^static inline Mat& operator &= (const Mat& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat& a, const Scalar& s)
operator &=	core/operations.hpp	/^static inline Range& operator &= (Range& r1, const Range& r2)$/;"	f	namespace:cv	signature:(Range& r1, const Range& r2)
operator &=	core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator &= ( Rect_<_Tp>& a, const Rect_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Rect_<_Tp>& b )
operator ()	calib3d/calib3d.hpp	/^    CV_WRAP_AS(compute) virtual void operator()(InputArray left, InputArray right,$/;"	p	class:cv::StereoSGBM	access:public	signature:(InputArray left, InputArray right, OutputArray disp)
operator ()	calib3d/calib3d.hpp	/^    CV_WRAP_AS(compute) void operator()( InputArray left, InputArray right,$/;"	p	class:cv::StereoBM	access:public	signature:( InputArray left, InputArray right, OutputArray disparity, int disptype=CV_16S )
operator ()	contrib/contrib.hpp	/^        CV_WRAP_AS(compute) virtual void operator()(const Mat& left, const Mat& right, Mat& disp);$/;"	p	class:cv::StereoVar	access:public	signature:(const Mat& left, const Mat& right, Mat& disp)
operator ()	core/core.hpp	/^        Size operator()() const;$/;"	p	struct:cv::Mat::MSize	access:public	signature:() const
operator ()	core/core.hpp	/^    Mat operator()( Range rowRange, Range colRange ) const;$/;"	p	class:cv::Mat	access:public	signature:( Range rowRange, Range colRange ) const
operator ()	core/core.hpp	/^    Mat operator()( const Range* ranges ) const;$/;"	p	class:cv::Mat	access:public	signature:( const Range* ranges ) const
operator ()	core/core.hpp	/^    Mat operator()( const Rect& roi ) const;$/;"	p	class:cv::Mat	access:public	signature:( const Rect& roi ) const
operator ()	core/core.hpp	/^    Mat_ operator()( const Range& rowRange, const Range& colRange ) const;$/;"	p	class:cv::Mat_	access:public	signature:( const Range& rowRange, const Range& colRange ) const
operator ()	core/core.hpp	/^    Mat_ operator()( const Range* ranges ) const;$/;"	p	class:cv::Mat_	access:public	signature:( const Range* ranges ) const
operator ()	core/core.hpp	/^    Mat_ operator()( const Rect& roi ) const;$/;"	p	class:cv::Mat_	access:public	signature:( const Rect& roi ) const
operator ()	core/core.hpp	/^    PCA& operator()(InputArray data, InputArray mean, int flags, int maxComponents=0);$/;"	p	class:cv::PCA	access:public	signature:(InputArray data, InputArray mean, int flags, int maxComponents=0)
operator ()	core/core.hpp	/^    SVD& operator ()( InputArray src, int flags=0 );$/;"	p	class:cv::SVD	access:public	signature:( InputArray src, int flags=0 )
operator ()	core/core.hpp	/^    _Tp operator()(const int* idx, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat_	access:public	signature:(const int* idx, size_t* hashval=0) const
operator ()	core/core.hpp	/^    _Tp operator()(int i0, int i1, int i2, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0) const
operator ()	core/core.hpp	/^    _Tp operator()(int i0, int i1, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, int i1, size_t* hashval=0) const
operator ()	core/core.hpp	/^    _Tp operator()(int i0, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, size_t* hashval=0) const
operator ()	core/core.hpp	/^    _Tp& operator ()(Point pt);$/;"	p	class:cv::Mat_	access:public	signature:(Point pt)
operator ()	core/core.hpp	/^    _Tp& operator ()(const int* idx);$/;"	p	class:cv::Mat_	access:public	signature:(const int* idx)
operator ()	core/core.hpp	/^    _Tp& operator ()(int i);$/;"	p	class:cv::Matx	access:public	signature:(int i)
operator ()	core/core.hpp	/^    _Tp& operator ()(int i);$/;"	p	class:cv::Vec	access:public	signature:(int i)
operator ()	core/core.hpp	/^    _Tp& operator ()(int i, int j);$/;"	p	class:cv::Matx	access:public	signature:(int i, int j)
operator ()	core/core.hpp	/^    _Tp& operator ()(int idx0);$/;"	p	class:cv::Mat_	access:public	signature:(int idx0)
operator ()	core/core.hpp	/^    _Tp& operator ()(int idx0, int idx1);$/;"	p	class:cv::Mat_	access:public	signature:(int idx0, int idx1)
operator ()	core/core.hpp	/^    _Tp& operator ()(int idx0, int idx1, int idx2);$/;"	p	class:cv::Mat_	access:public	signature:(int idx0, int idx1, int idx2)
operator ()	core/core.hpp	/^    const _Tp& operator ()(Point pt) const;$/;"	p	class:cv::Mat_	access:public	signature:(Point pt) const
operator ()	core/core.hpp	/^    const _Tp& operator ()(const int* idx) const;$/;"	p	class:cv::Mat_	access:public	signature:(const int* idx) const
operator ()	core/core.hpp	/^    const _Tp& operator ()(int i) const;$/;"	p	class:cv::Matx	access:public	signature:(int i) const
operator ()	core/core.hpp	/^    const _Tp& operator ()(int i) const;$/;"	p	class:cv::Vec	access:public	signature:(int i) const
operator ()	core/core.hpp	/^    const _Tp& operator ()(int i, int j) const;$/;"	p	class:cv::Matx	access:public	signature:(int i, int j) const
operator ()	core/core.hpp	/^    const _Tp& operator ()(int idx0) const;$/;"	p	class:cv::Mat_	access:public	signature:(int idx0) const
operator ()	core/core.hpp	/^    const _Tp& operator ()(int idx0, int idx1) const;$/;"	p	class:cv::Mat_	access:public	signature:(int idx0, int idx1) const
operator ()	core/core.hpp	/^    const _Tp& operator ()(int idx0, int idx1, int idx2) const;$/;"	p	class:cv::Mat_	access:public	signature:(int idx0, int idx1, int idx2) const
operator ()	core/core.hpp	/^    template<int n> _Tp& operator ()(const Vec<int, n>& idx);$/;"	p	class:cv::Mat_	access:public	signature:(const Vec<int, n>& idx)
operator ()	core/core.hpp	/^    template<int n> const _Tp& operator ()(const Vec<int, n>& idx) const;$/;"	p	class:cv::Mat_	access:public	signature:(const Vec<int, n>& idx) const
operator ()	core/core.hpp	/^    unsigned operator ()();$/;"	p	class:cv::RNG	access:public	signature:()
operator ()	core/core.hpp	/^    unsigned operator()(unsigned N);$/;"	p	class:cv::RNG	access:public	signature:(unsigned N)
operator ()	core/mat.hpp	/^    MatExpr operator()( const Range& rowRange, const Range& colRange ) const;$/;"	p	class:cv::MatExpr	access:public	signature:( const Range& rowRange, const Range& colRange ) const
operator ()	core/mat.hpp	/^    MatExpr operator()( const Rect& roi ) const;$/;"	p	class:cv::MatExpr	access:public	signature:( const Rect& roi ) const
operator ()	core/mat.hpp	/^SparseMat_<_Tp>::operator()(const int* idx, size_t* hashval) const$/;"	f	class:cv::SparseMat_	signature:(const int* idx, size_t* hashval) const
operator ()	core/mat.hpp	/^SparseMat_<_Tp>::operator()(int i0, int i1, int i2, size_t* hashval) const$/;"	f	class:cv::SparseMat_	signature:(int i0, int i1, int i2, size_t* hashval) const
operator ()	core/mat.hpp	/^SparseMat_<_Tp>::operator()(int i0, int i1, size_t* hashval) const$/;"	f	class:cv::SparseMat_	signature:(int i0, int i1, size_t* hashval) const
operator ()	core/mat.hpp	/^SparseMat_<_Tp>::operator()(int i0, size_t* hashval) const$/;"	f	class:cv::SparseMat_	signature:(int i0, size_t* hashval) const
operator ()	core/mat.hpp	/^inline Mat Mat::operator()( Range rowRange, Range colRange ) const$/;"	f	class:cv::Mat	signature:( Range rowRange, Range colRange ) const
operator ()	core/mat.hpp	/^inline Mat Mat::operator()( const Rect& roi ) const$/;"	f	class:cv::Mat	signature:( const Rect& roi ) const
operator ()	core/mat.hpp	/^inline Mat Mat::operator()(const Range* ranges) const$/;"	f	class:cv::Mat	signature:(const Range* ranges) const
operator ()	core/mat.hpp	/^inline Size Mat::MSize::operator()() const$/;"	f	class:cv::Mat::MSize	signature:() const
operator ()	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::operator()( const Range& rowRange, const Range& colRange ) const$/;"	f	class:cv::Mat_	signature:( const Range& rowRange, const Range& colRange ) const
operator ()	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::operator()( const Range* ranges ) const$/;"	f	class:cv::Mat_	signature:( const Range* ranges ) const
operator ()	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::operator()( const Rect& roi ) const$/;"	f	class:cv::Mat_	signature:( const Rect& roi ) const
operator ()	core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(Point pt)$/;"	f	class:cv::Mat_	signature:(Point pt)
operator ()	core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(const int* idx)$/;"	f	class:cv::Mat_	signature:(const int* idx)
operator ()	core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(int i0)$/;"	f	class:cv::Mat_	signature:(int i0)
operator ()	core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(int i0, int i1)$/;"	f	class:cv::Mat_	signature:(int i0, int i1)
operator ()	core/mat.hpp	/^template<typename _Tp> inline _Tp& Mat_<_Tp>::operator ()(int i0, int i1, int i2)$/;"	f	class:cv::Mat_	signature:(int i0, int i1, int i2)
operator ()	core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(Point pt) const$/;"	f	class:cv::Mat_	signature:(Point pt) const
operator ()	core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(const int* idx) const$/;"	f	class:cv::Mat_	signature:(const int* idx) const
operator ()	core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(int i0) const$/;"	f	class:cv::Mat_	signature:(int i0) const
operator ()	core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(int i0, int i1) const$/;"	f	class:cv::Mat_	signature:(int i0, int i1) const
operator ()	core/mat.hpp	/^template<typename _Tp> inline const _Tp& Mat_<_Tp>::operator ()(int i0, int i1, int i2) const$/;"	f	class:cv::Mat_	signature:(int i0, int i1, int i2) const
operator ()	core/operations.hpp	/^    Vector operator() (const Range& r) const { return Vector(*this, r); }$/;"	f	class:cv::Vector	access:public	signature:(const Range& r) const
operator ()	core/operations.hpp	/^    bool operator()(const Matx<_Tp, 2, 2>& a, Matx<_Tp, 2, 2>& b, int) const$/;"	f	struct:cv::Matx_FastInvOp	access:public	signature:(const Matx<_Tp, 2, 2>& a, Matx<_Tp, 2, 2>& b, int) const
operator ()	core/operations.hpp	/^    bool operator()(const Matx<_Tp, 2, 2>& a, const Matx<_Tp, 2, 1>& b,$/;"	f	struct:cv::Matx_FastSolveOp	access:public	signature:(const Matx<_Tp, 2, 2>& a, const Matx<_Tp, 2, 1>& b, Matx<_Tp, 2, 1>& x, int method) const
operator ()	core/operations.hpp	/^    bool operator()(const Matx<_Tp, 3, 3>& a, Matx<_Tp, 3, 3>& b, int) const$/;"	f	struct:cv::Matx_FastInvOp	access:public	signature:(const Matx<_Tp, 3, 3>& a, Matx<_Tp, 3, 3>& b, int) const
operator ()	core/operations.hpp	/^    bool operator()(const Matx<_Tp, 3, 3>& a, const Matx<_Tp, 3, 1>& b,$/;"	f	struct:cv::Matx_FastSolveOp	access:public	signature:(const Matx<_Tp, 3, 3>& a, const Matx<_Tp, 3, 1>& b, Matx<_Tp, 3, 1>& x, int method) const
operator ()	core/operations.hpp	/^    bool operator()(const Matx<_Tp, m, m>& a, Matx<_Tp, m, m>& b, int method) const$/;"	f	struct:cv::Matx_FastInvOp	access:public	signature:(const Matx<_Tp, m, m>& a, Matx<_Tp, m, m>& b, int method) const
operator ()	core/operations.hpp	/^    bool operator()(const Matx<_Tp, m, m>& a, const Matx<_Tp, m, n>& b,$/;"	f	struct:cv::Matx_FastSolveOp	access:public	signature:(const Matx<_Tp, m, m>& a, const Matx<_Tp, m, n>& b, Matx<_Tp, m, n>& x, int method) const
operator ()	core/operations.hpp	/^    bool operator()(const _Tp& a, const _Tp& b) const { return a < b; }$/;"	f	class:cv::LessThan	access:public	signature:(const _Tp& a, const _Tp& b) const
operator ()	core/operations.hpp	/^    bool operator()(const _Tp& a, const _Tp& b) const { return a >= b; }$/;"	f	class:cv::GreaterEq	access:public	signature:(const _Tp& a, const _Tp& b) const
operator ()	core/operations.hpp	/^    bool operator()(int a, int b) const { return arr[a] < arr[b]; }$/;"	f	class:cv::LessThanIdx	access:public	signature:(int a, int b) const
operator ()	core/operations.hpp	/^    bool operator()(int a, int b) const { return arr[a] >= arr[b]; }$/;"	f	class:cv::GreaterEqIdx	access:public	signature:(int a, int b) const
operator ()	core/operations.hpp	/^    double operator ()(const Matx<_Tp, 1, 1>& a) const$/;"	f	struct:cv::Matx_DetOp	access:public	signature:(const Matx<_Tp, 1, 1>& a) const
operator ()	core/operations.hpp	/^    double operator ()(const Matx<_Tp, 2, 2>& a) const$/;"	f	struct:cv::Matx_DetOp	access:public	signature:(const Matx<_Tp, 2, 2>& a) const
operator ()	core/operations.hpp	/^    double operator ()(const Matx<_Tp, 3, 3>& a) const$/;"	f	struct:cv::Matx_DetOp	access:public	signature:(const Matx<_Tp, 3, 3>& a) const
operator ()	core/operations.hpp	/^    double operator ()(const Matx<_Tp, m, m>& a) const$/;"	f	struct:cv::Matx_DetOp	access:public	signature:(const Matx<_Tp, m, m>& a) const
operator ()	core/operations.hpp	/^    void operator()(const vector<_Tp>& vec) const$/;"	f	class:cv::VecWriterProxy	access:public	signature:(const vector<_Tp>& vec) const
operator ()	core/operations.hpp	/^    void operator()(vector<_Tp>& vec, size_t count) const$/;"	f	class:cv::VecReaderProxy	access:public	signature:(vector<_Tp>& vec, size_t count) const
operator ()	core/operations.hpp	/^_Tp& Matx<_Tp, m, n>::operator ()(int i)$/;"	f	class:cv::Matx	signature:(int i)
operator ()	core/operations.hpp	/^_Tp& Matx<_Tp, m, n>::operator ()(int i, int j)$/;"	f	class:cv::Matx	signature:(int i, int j)
operator ()	core/operations.hpp	/^const _Tp& Matx<_Tp, m, n>::operator ()(int i) const$/;"	f	class:cv::Matx	signature:(int i) const
operator ()	core/operations.hpp	/^const _Tp& Matx<_Tp, m, n>::operator ()(int i, int j) const$/;"	f	class:cv::Matx	signature:(int i, int j) const
operator ()	core/operations.hpp	/^inline unsigned RNG::operator ()() {return next();}$/;"	f	class:cv::RNG	signature:()
operator ()	core/operations.hpp	/^inline unsigned RNG::operator ()(unsigned N) {return (unsigned)uniform(0,N);}$/;"	f	class:cv::RNG	signature:(unsigned N)
operator ()	core/operations.hpp	/^template<typename _Tp, int cn> inline _Tp& Vec<_Tp, cn>::operator ()(int i)$/;"	f	class:cv::Vec	signature:(int i)
operator ()	core/operations.hpp	/^template<typename _Tp, int cn> inline const _Tp& Vec<_Tp, cn>::operator ()(int i) const$/;"	f	class:cv::Vec	signature:(int i) const
operator ()	core/wimage.hpp	/^    inline T* operator() (int c, int r)  {$/;"	f	class:cv::WImage	access:public	signature:(int c, int r)
operator ()	core/wimage.hpp	/^    inline const T* operator() (int c, int r) const  {$/;"	f	class:cv::WImage	access:public	signature:(int c, int r) const
operator ()	features2d/features2d.hpp	/^        template<typename _Tp> bool operator ()(const Mat_<_Tp>& patch) const$/;"	f	struct:cv::FernClassifier::Feature	access:public	signature:(const Mat_<_Tp>& patch) const
operator ()	features2d/features2d.hpp	/^    CV_WRAP_AS(detect) void operator()( const Mat& image,$/;"	p	class:cv::MSER	access:public	signature:( const Mat& image, CV_OUT vector<vector<Point> >& msers, const Mat& mask ) const
operator ()	features2d/features2d.hpp	/^    CV_WRAP_AS(detect) void operator()(const Mat& image,$/;"	p	class:cv::StarDetector	access:public	signature:(const Mat& image, CV_OUT vector<KeyPoint>& keypoints) const
operator ()	features2d/features2d.hpp	/^    CV_WRAP_AS(detect) void operator()(const Mat& img, const Mat& mask,$/;"	p	class:cv::SURF	access:public	signature:(const Mat& img, const Mat& mask, CV_OUT vector<KeyPoint>& keypoints) const
operator ()	features2d/features2d.hpp	/^    CV_WRAP_AS(detect) void operator()(const Mat& img, const Mat& mask,$/;"	p	class:cv::SURF	access:public	signature:(const Mat& img, const Mat& mask, CV_OUT vector<KeyPoint>& keypoints, CV_OUT vector<float>& descriptors, bool useProvidedKeypoints=false) const
operator ()	features2d/features2d.hpp	/^    ResultType operator()( const T* a, const T* b, int size ) const$/;"	f	struct:cv::L1	access:public	signature:( const T* a, const T* b, int size ) const
operator ()	features2d/features2d.hpp	/^    ResultType operator()( const T* a, const T* b, int size ) const$/;"	f	struct:cv::L2	access:public	signature:( const T* a, const T* b, int size ) const
operator ()	features2d/features2d.hpp	/^    ResultType operator()( const T* a, const T* b, int size ) const$/;"	f	struct:cv::SL2	access:public	signature:( const T* a, const T* b, int size ) const
operator ()	features2d/features2d.hpp	/^    ResultType operator()( const unsigned char* a, const unsigned char* b, int size ) const;$/;"	p	struct:cv::HammingLUT	access:public	signature:( const unsigned char* a, const unsigned char* b, int size ) const
operator ()	features2d/features2d.hpp	/^    ResultType operator()(const unsigned char* a, const unsigned char* b, int size) const;$/;"	p	struct:cv::Hamming	access:public	signature:(const unsigned char* a, const unsigned char* b, int size) const
operator ()	features2d/features2d.hpp	/^    virtual int operator()(const Mat& img, Point2f kpt, vector<float>& signature) const;$/;"	p	class:cv::FernClassifier	access:public	signature:(const Mat& img, Point2f kpt, vector<float>& signature) const
operator ()	features2d/features2d.hpp	/^    virtual int operator()(const Mat& patch, vector<float>& signature) const;$/;"	p	class:cv::FernClassifier	access:public	signature:(const Mat& patch, vector<float>& signature) const
operator ()	features2d/features2d.hpp	/^    void operator()(const Mat& image, Point2f pt, Mat& patch, Size patchSize, RNG& rng) const;$/;"	p	class:cv::PatchGenerator	access:public	signature:(const Mat& image, Point2f pt, Mat& patch, Size patchSize, RNG& rng) const
operator ()	features2d/features2d.hpp	/^    void operator()(const Mat& image, const Mat& transform, Mat& patch,$/;"	p	class:cv::PatchGenerator	access:public	signature:(const Mat& image, const Mat& transform, Mat& patch, Size patchSize, RNG& rng) const
operator ()	features2d/features2d.hpp	/^    void operator()(const Mat& image,$/;"	p	class:cv::LDetector	access:public	signature:(const Mat& image, CV_OUT vector<KeyPoint>& keypoints, int maxCount=0, bool scaleCoords=true) const
operator ()	features2d/features2d.hpp	/^    void operator()(const Mat& img, const Mat& mask,$/;"	p	class:cv::SIFT	access:public	signature:(const Mat& img, const Mat& mask, vector<KeyPoint>& keypoints) const
operator ()	features2d/features2d.hpp	/^    void operator()(const Mat& img, const Mat& mask,$/;"	p	class:cv::SIFT	access:public	signature:(const Mat& img, const Mat& mask, vector<KeyPoint>& keypoints, Mat& descriptors, bool useProvidedKeypoints=false) const
operator ()	features2d/features2d.hpp	/^    void operator()(const vector<Mat>& pyr,$/;"	p	class:cv::LDetector	access:public	signature:(const vector<Mat>& pyr, CV_OUT vector<KeyPoint>& keypoints, int maxCount=0, bool scaleCoords=true) const
operator ()	features2d/features2d.hpp	/^  inline bool operator() (uchar* patch_data) const$/;"	f	struct:cv::RTreeNode	access:public	signature:(uchar* patch_data) const
operator ()	features2d/features2d.hpp	/^  operator()(const cv::Mat &image, const cv::Mat &mask, std::vector<cv::KeyPoint> & keypoints);$/;"	p	class:cv::ORB	access:public	signature:(const cv::Mat &image, const cv::Mat &mask, std::vector<cv::KeyPoint> & keypoints)
operator ()	features2d/features2d.hpp	/^  operator()(const cv::Mat &image, const cv::Mat &mask, std::vector<cv::KeyPoint> & keypoints, cv::Mat & descriptors,$/;"	p	class:cv::ORB	access:private	signature:(const cv::Mat &image, const cv::Mat &mask, std::vector<cv::KeyPoint> & keypoints, cv::Mat & descriptors, bool do_keypoints, bool do_descriptors)
operator ()	features2d/features2d.hpp	/^  operator()(const cv::Mat &image, const cv::Mat &mask, std::vector<cv::KeyPoint> & keypoints, cv::Mat & descriptors,$/;"	p	class:cv::ORB	access:public	signature:(const cv::Mat &image, const cv::Mat &mask, std::vector<cv::KeyPoint> & keypoints, cv::Mat & descriptors, bool useProvidedKeypoints = false)
operator ()	flann/dist.h	/^    ResultType operator()(Iterator1 a, Iterator2 b, size_t size, ResultType \/*worst_dist*\/ = -1) const$/;"	f	struct:cvflann::Hamming	access:public	signature:(Iterator1 a, Iterator2 b, size_t size, ResultType = -1) const
operator ()	flann/dist.h	/^    ResultType operator()(Iterator1 a, Iterator2 b, size_t size, ResultType \/*worst_dist*\/ = -1) const$/;"	f	struct:cvflann::Hamming2	access:public	signature:(Iterator1 a, Iterator2 b, size_t size, ResultType = -1) const
operator ()	flann/dist.h	/^    ResultType operator()(Iterator1 a, Iterator2 b, size_t size, ResultType \/*worst_dist*\/ = -1) const$/;"	f	struct:cvflann::HellingerDistance	access:public	signature:(Iterator1 a, Iterator2 b, size_t size, ResultType = -1) const
operator ()	flann/dist.h	/^    ResultType operator()(Iterator1 a, Iterator2 b, size_t size, ResultType \/*worst_dist*\/ = -1) const$/;"	f	struct:cvflann::L2_Simple	access:public	signature:(Iterator1 a, Iterator2 b, size_t size, ResultType = -1) const
operator ()	flann/dist.h	/^    ResultType operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const$/;"	f	struct:cvflann::ChiSquareDistance	access:public	signature:(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const
operator ()	flann/dist.h	/^    ResultType operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const$/;"	f	struct:cvflann::HistIntersectionDistance	access:public	signature:(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const
operator ()	flann/dist.h	/^    ResultType operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const$/;"	f	struct:cvflann::KL_Divergence	access:public	signature:(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const
operator ()	flann/dist.h	/^    ResultType operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const$/;"	f	struct:cvflann::L1	access:public	signature:(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const
operator ()	flann/dist.h	/^    ResultType operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const$/;"	f	struct:cvflann::L2	access:public	signature:(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const
operator ()	flann/dist.h	/^    ResultType operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const$/;"	f	struct:cvflann::MaxDistance	access:public	signature:(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const
operator ()	flann/dist.h	/^    ResultType operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const$/;"	f	struct:cvflann::MinkowskiDistance	access:public	signature:(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const
operator ()	flann/dist.h	/^    ResultType operator()(const unsigned char* a, const unsigned char* b, int size) const$/;"	f	struct:cvflann::HammingLUT	access:public	signature:(const unsigned char* a, const unsigned char* b, int size) const
operator ()	flann/heap.h	/^        bool operator()(const T& t_1, const T& t_2) const$/;"	f	struct:cvflann::Heap::CompareT	access:public	signature:(const T& t_1, const T& t_2) const
operator ()	flann/lsh_index.h	/^        bool operator()(const ScoreIndexPair& left, const ScoreIndexPair& right) const$/;"	f	struct:cvflann::LshIndex::SortScoreIndexPairOnSecond	access:public	signature:(const ScoreIndexPair& left, const ScoreIndexPair& right) const
operator ()	gpu/gpu.hpp	/^            virtual void operator()(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null()) = 0;$/;"	p	class:cv::gpu::BaseColumnFilter_GPU	access:public	signature:(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null())
operator ()	gpu/gpu.hpp	/^            virtual void operator()(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null()) = 0;$/;"	p	class:cv::gpu::BaseFilter_GPU	access:public	signature:(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null())
operator ()	gpu/gpu.hpp	/^            virtual void operator()(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null()) = 0;$/;"	p	class:cv::gpu::BaseRowFilter_GPU	access:public	signature:(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null())
operator ()	gpu/gpu.hpp	/^            void operator() ( const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream = Stream::Null());$/;"	p	class:cv::gpu::StereoBM_GPU	access:public	signature:( const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream = Stream::Null())
operator ()	gpu/gpu.hpp	/^            void operator()(const GpuMat& data, GpuMat& disparity, Stream& stream = Stream::Null());$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(const GpuMat& data, GpuMat& disparity, Stream& stream = Stream::Null())
operator ()	gpu/gpu.hpp	/^            void operator()(const GpuMat& disparity, const GpuMat& image, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	class:cv::gpu::DisparityBilateralFilter	access:public	signature:(const GpuMat& disparity, const GpuMat& image, GpuMat& dst, Stream& stream = Stream::Null())
operator ()	gpu/gpu.hpp	/^            void operator()(const GpuMat& img, const GpuMat& mask, GpuMat& keypoints);$/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:(const GpuMat& img, const GpuMat& mask, GpuMat& keypoints)
operator ()	gpu/gpu.hpp	/^            void operator()(const GpuMat& img, const GpuMat& mask, GpuMat& keypoints, GpuMat& descriptors, $/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:(const GpuMat& img, const GpuMat& mask, GpuMat& keypoints, GpuMat& descriptors, bool useProvidedKeypoints = false)
operator ()	gpu/gpu.hpp	/^            void operator()(const GpuMat& img, const GpuMat& mask, std::vector<KeyPoint>& keypoints);$/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:(const GpuMat& img, const GpuMat& mask, std::vector<KeyPoint>& keypoints)
operator ()	gpu/gpu.hpp	/^            void operator()(const GpuMat& img, const GpuMat& mask, std::vector<KeyPoint>& keypoints, GpuMat& descriptors, $/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:(const GpuMat& img, const GpuMat& mask, std::vector<KeyPoint>& keypoints, GpuMat& descriptors, bool useProvidedKeypoints = false)
operator ()	gpu/gpu.hpp	/^            void operator()(const GpuMat& img, const GpuMat& mask, std::vector<KeyPoint>& keypoints, std::vector<float>& descriptors, $/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:(const GpuMat& img, const GpuMat& mask, std::vector<KeyPoint>& keypoints, std::vector<float>& descriptors, bool useProvidedKeypoints = false)
operator ()	gpu/gpu.hpp	/^            void operator()(const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream = Stream::Null());$/;"	p	class:cv::gpu::StereoBeliefPropagation	access:public	signature:(const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream = Stream::Null())
operator ()	gpu/gpu.hpp	/^            void operator()(const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream = Stream::Null());$/;"	p	class:cv::gpu::StereoConstantSpaceBP	access:public	signature:(const GpuMat& left, const GpuMat& right, GpuMat& disparity, Stream& stream = Stream::Null())
operator ()	gpu/gpumat.hpp	/^        GpuMat operator()( Range rowRange, Range colRange ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( Range rowRange, Range colRange ) const
operator ()	gpu/gpumat.hpp	/^        GpuMat operator()( const Rect& roi ) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:( const Rect& roi ) const
operator ()	imgproc/imgproc.hpp	/^    virtual void operator()(const uchar* src, uchar* dst,$/;"	p	class:cv::BaseRowFilter	access:public	signature:(const uchar* src, uchar* dst, int width, int cn)
operator ()	imgproc/imgproc.hpp	/^    virtual void operator()(const uchar** src, uchar* dst, int dststep,$/;"	p	class:cv::BaseColumnFilter	access:public	signature:(const uchar** src, uchar* dst, int dststep, int dstcount, int width)
operator ()	imgproc/imgproc.hpp	/^    virtual void operator()(const uchar** src, uchar* dst, int dststep,$/;"	p	class:cv::BaseFilter	access:public	signature:(const uchar** src, uchar* dst, int dststep, int dstcount, int width, int cn)
operator ()	objdetect/objdetect.hpp	/^    bool operator()(const Mat& image, CV_OUT Mat& H, CV_OUT vector<Point2f>& corners) const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const Mat& image, CV_OUT Mat& H, CV_OUT vector<Point2f>& corners) const
operator ()	objdetect/objdetect.hpp	/^    bool operator()(const vector<Mat>& pyr, const vector<KeyPoint>& keypoints,$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const vector<Mat>& pyr, const vector<KeyPoint>& keypoints, CV_OUT Mat& H, CV_OUT vector<Point2f>& corners, CV_OUT vector<int>* pairs=0) const
operator ()	video/background_segm.hpp	/^    CV_WRAP_AS(apply) virtual void operator()(InputArray image, OutputArray fgmask,$/;"	p	class:cv::BackgroundSubtractor	access:public	signature:(InputArray image, OutputArray fgmask, double learningRate=0)
operator ()	video/background_segm.hpp	/^    virtual void operator()(InputArray image, OutputArray fgmask, double learningRate=-1);$/;"	p	class:cv::BackgroundSubtractorMOG2	access:public	signature:(InputArray image, OutputArray fgmask, double learningRate=-1)
operator ()	video/background_segm.hpp	/^    virtual void operator()(InputArray image, OutputArray fgmask, double learningRate=0);$/;"	p	class:cv::BackgroundSubtractorMOG	access:public	signature:(InputArray image, OutputArray fgmask, double learningRate=0)
operator *	core/core.hpp	/^    CvFileNode* operator *();$/;"	p	class:cv::FileNode	access:public	signature:()
operator *	core/core.hpp	/^    CvFileStorage* operator *() { return fs; }$/;"	f	class:cv::FileStorage	access:public	signature:()
operator *	core/core.hpp	/^    FileNode operator *() const;$/;"	p	class:cv::FileNodeIterator	access:public	signature:() const
operator *	core/core.hpp	/^    Mat_<_Tp> operator *() const;$/;"	p	class:cv::MatCommaInitializer_	access:public	signature:() const
operator *	core/core.hpp	/^    Matx<_Tp, m, n> operator *() const;$/;"	p	class:cv::MatxCommaInitializer	access:public	signature:() const
operator *	core/core.hpp	/^    Vec<_Tp, m> operator *() const;$/;"	p	class:cv::VecCommaInitializer	access:public	signature:() const
operator *	core/core.hpp	/^    _Tp operator *() const;$/;"	p	class:cv::MatConstIterator_	access:public	signature:() const
operator *	core/core.hpp	/^    _Tp& operator *() const;$/;"	p	class:cv::MatIterator_	access:public	signature:() const
operator *	core/core.hpp	/^    _Tp& operator *() const;$/;"	p	class:cv::SparseMatIterator_	access:public	signature:() const
operator *	core/core.hpp	/^    _Tp& operator *();$/;"	p	class:cv::SeqIterator	access:public	signature:()
operator *	core/core.hpp	/^    const CvFileNode* operator* () const;$/;"	p	class:cv::FileNode	access:public	signature:() const
operator *	core/core.hpp	/^    const CvFileStorage* operator *() const { return fs; }$/;"	f	class:cv::FileStorage	access:public	signature:() const
operator *	core/core.hpp	/^    const _Tp& operator *() const;$/;"	p	class:cv::SeqIterator	access:public	signature:() const
operator *	core/core.hpp	/^    const _Tp& operator *() const;$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:() const
operator *	core/core.hpp	/^    uchar* operator *() const;$/;"	p	class:cv::MatConstIterator	access:public	signature:() const
operator *	core/core.hpp	/^    uchar* operator *();$/;"	p	class:cv::LineIterator	access:public	signature:()
operator *	core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator *	core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
operator *	core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const Mat& m, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Mat& m, const MatExpr& e)
operator *	core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const MatExpr& e, const Mat& m);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Mat& m)
operator *	core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const MatExpr& e, double s);$/;"	p	namespace:cv	signature:(const MatExpr& e, double s)
operator *	core/mat.hpp	/^CV_EXPORTS MatExpr operator * (const MatExpr& e1, const MatExpr& e2);$/;"	p	namespace:cv	signature:(const MatExpr& e1, const MatExpr& e2)
operator *	core/mat.hpp	/^CV_EXPORTS MatExpr operator * (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
operator *	core/mat.hpp	/^CV_EXPORTS MatExpr operator * (double s, const MatExpr& e);$/;"	p	namespace:cv	signature:(double s, const MatExpr& e)
operator *	core/mat.hpp	/^SparseMatConstIterator_<_Tp>::operator *() const$/;"	f	class:cv::SparseMatConstIterator_	signature:() const
operator *	core/mat.hpp	/^SparseMatIterator_<_Tp>::operator *() const$/;"	f	class:cv::SparseMatIterator_	signature:() const
operator *	core/mat.hpp	/^inline uchar* MatConstIterator::operator *() const { return ptr; }$/;"	f	class:cv::MatConstIterator	signature:() const
operator *	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> MatCommaInitializer_<_Tp>::operator *() const$/;"	f	class:cv::MatCommaInitializer_	signature:() const
operator *	core/mat.hpp	/^template<typename _Tp> inline _Tp MatConstIterator_<_Tp>::operator *() const { return *(_Tp*)(this->ptr); }$/;"	f	class:cv::MatConstIterator_	signature:() const
operator *	core/mat.hpp	/^template<typename _Tp> inline _Tp& MatIterator_<_Tp>::operator *() const { return *(_Tp*)(this->ptr); }$/;"	f	class:cv::MatIterator_	signature:() const
operator *	core/operations.hpp	/^Complex<_Tp> operator * (_Tp b, const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(_Tp b, const Complex<_Tp>& a)
operator *	core/operations.hpp	/^Complex<_Tp> operator * (const Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, _Tp b)
operator *	core/operations.hpp	/^Complex<_Tp> operator * (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
operator *	core/operations.hpp	/^Matx<_Tp, 4, 1> operator * (const Matx<_Tp, 4, 4>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, 4, 4>& a, const Point3_<_Tp>& b)
operator *	core/operations.hpp	/^Matx<_Tp, m, n> MatxCommaInitializer<_Tp, m, n>::operator *() const$/;"	f	class:cv::MatxCommaInitializer	signature:() const
operator *	core/operations.hpp	/^Matx<_Tp, m, n> operator * (const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b)
operator *	core/operations.hpp	/^Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, double alpha)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, double alpha)
operator *	core/operations.hpp	/^Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, float alpha)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, float alpha)
operator *	core/operations.hpp	/^Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, int alpha)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, int alpha)
operator *	core/operations.hpp	/^Matx<_Tp, m, n> operator * (double alpha, const Matx<_Tp, m, n>& a)$/;"	f	namespace:cv	signature:(double alpha, const Matx<_Tp, m, n>& a)
operator *	core/operations.hpp	/^Matx<_Tp, m, n> operator * (float alpha, const Matx<_Tp, m, n>& a)$/;"	f	namespace:cv	signature:(float alpha, const Matx<_Tp, m, n>& a)
operator *	core/operations.hpp	/^Matx<_Tp, m, n> operator * (int alpha, const Matx<_Tp, m, n>& a)$/;"	f	namespace:cv	signature:(int alpha, const Matx<_Tp, m, n>& a)
operator *	core/operations.hpp	/^Point3_<_Tp> operator * (const Matx<_Tp, 3, 3>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, 3, 3>& a, const Point3_<_Tp>& b)
operator *	core/operations.hpp	/^Point3_<_Tp> operator * (const Matx<_Tp, 3, 3>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, 3, 3>& a, const Point_<_Tp>& b)
operator *	core/operations.hpp	/^Point_<_Tp> operator * (const Matx<_Tp, 2, 2>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, 2, 2>& a, const Point_<_Tp>& b)
operator *	core/operations.hpp	/^Scalar operator * (const Matx<_Tp, 4, 4>& a, const Scalar& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, 4, 4>& a, const Scalar& b)
operator *	core/operations.hpp	/^Vec<_Tp, cn> VecCommaInitializer<_Tp, cn>::operator *() const$/;"	f	class:cv::VecCommaInitializer	signature:() const
operator *	core/operations.hpp	/^inline CvFileNode* FileNode::operator *() { return (CvFileNode*)node; }$/;"	f	class:cv::FileNode	signature:()
operator *	core/operations.hpp	/^inline FileNode FileNodeIterator::operator *() const$/;"	f	class:cv::FileNodeIterator	signature:() const
operator *	core/operations.hpp	/^inline const CvFileNode* FileNode::operator* () const { return node; }$/;"	f	class:cv::FileNode	signature:() const
operator *	core/operations.hpp	/^inline uchar* LineIterator::operator *() { return ptr; }$/;"	f	class:cv::LineIterator	signature:()
operator *	core/operations.hpp	/^operator * (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
operator *	core/operations.hpp	/^operator * (const Vec<_Tp, cn>& a, double alpha)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& a, double alpha)
operator *	core/operations.hpp	/^operator * (const Vec<_Tp, cn>& a, float alpha)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& a, float alpha)
operator *	core/operations.hpp	/^operator * (const Vec<_Tp, cn>& a, int alpha)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& a, int alpha)
operator *	core/operations.hpp	/^operator * (double alpha, const Vec<_Tp, cn>& a)$/;"	f	namespace:cv	signature:(double alpha, const Vec<_Tp, cn>& a)
operator *	core/operations.hpp	/^operator * (float alpha, const Vec<_Tp, cn>& a)$/;"	f	namespace:cv	signature:(float alpha, const Vec<_Tp, cn>& a)
operator *	core/operations.hpp	/^operator * (int alpha, const Vec<_Tp, cn>& a)$/;"	f	namespace:cv	signature:(int alpha, const Vec<_Tp, cn>& a)
operator *	core/operations.hpp	/^template<typename _Tp> inline _Tp& SeqIterator<_Tp>::operator *()$/;"	f	class:cv::SeqIterator	signature:()
operator *	core/operations.hpp	/^template<typename _Tp> inline const _Tp& SeqIterator<_Tp>::operator *() const$/;"	f	class:cv::SeqIterator	signature:() const
operator *	core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (const Point3_<_Tp>& a, double b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, double b)
operator *	core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (const Point3_<_Tp>& a, float b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, float b)
operator *	core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (const Point3_<_Tp>& a, int b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, int b)
operator *	core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (double a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(double a, const Point3_<_Tp>& b)
operator *	core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (float a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(float a, const Point3_<_Tp>& b)
operator *	core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator * (int a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(int a, const Point3_<_Tp>& b)
operator *	core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (const Point_<_Tp>& a, double b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, double b)
operator *	core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (const Point_<_Tp>& a, float b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, float b)
operator *	core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (const Point_<_Tp>& a, int b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, int b)
operator *	core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (double a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(double a, const Point_<_Tp>& b)
operator *	core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (float a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(float a, const Point_<_Tp>& b)
operator *	core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator * (int a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(int a, const Point_<_Tp>& b)
operator *	core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp> operator * (_Tp alpha, const Scalar_<_Tp>& a)$/;"	f	namespace:cv	signature:(_Tp alpha, const Scalar_<_Tp>& a)
operator *	core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp> operator * (const Scalar_<_Tp>& a, _Tp alpha)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, _Tp alpha)
operator *	core/operations.hpp	/^template<typename _Tp> static inline Size_<_Tp> operator * (const Size_<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Size_<_Tp>& a, _Tp b)
operator *	flann/dist.h	/^    T operator*()$/;"	f	struct:cvflann::ZeroIterator	access:public	signature:()
operator *=	core/mat.hpp	/^Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const MatExpr& b)
operator *=	core/mat.hpp	/^Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
operator *=	core/mat.hpp	/^Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, double s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, double s)
operator *=	core/mat.hpp	/^static inline Mat& operator *= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
operator *=	core/mat.hpp	/^static inline Mat& operator *= (const Mat& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat& a, const MatExpr& b)
operator *=	core/mat.hpp	/^static inline Mat& operator *= (const Mat& a, double s)$/;"	f	namespace:cv	signature:(const Mat& a, double s)
operator *=	core/operations.hpp	/^Complex<_Tp>& operator *= (Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, _Tp b)
operator *=	core/operations.hpp	/^Matx<_Tp, m, n>& operator *= (Matx<_Tp, m, n>& a, double alpha)$/;"	f	namespace:cv	signature:(Matx<_Tp, m, n>& a, double alpha)
operator *=	core/operations.hpp	/^Matx<_Tp, m, n>& operator *= (Matx<_Tp, m, n>& a, float alpha)$/;"	f	namespace:cv	signature:(Matx<_Tp, m, n>& a, float alpha)
operator *=	core/operations.hpp	/^Matx<_Tp, m, n>& operator *= (Matx<_Tp, m, n>& a, int alpha)$/;"	f	namespace:cv	signature:(Matx<_Tp, m, n>& a, int alpha)
operator *=	core/operations.hpp	/^Vec<_Tp, cn>& operator *= (Vec<_Tp, cn>& a, double alpha)$/;"	f	namespace:cv	signature:(Vec<_Tp, cn>& a, double alpha)
operator *=	core/operations.hpp	/^Vec<_Tp, cn>& operator *= (Vec<_Tp, cn>& a, float alpha)$/;"	f	namespace:cv	signature:(Vec<_Tp, cn>& a, float alpha)
operator *=	core/operations.hpp	/^Vec<_Tp, cn>& operator *= (Vec<_Tp, cn>& a, int alpha)$/;"	f	namespace:cv	signature:(Vec<_Tp, cn>& a, int alpha)
operator *=	core/operations.hpp	/^operator *= (Point3_<_Tp>& a, double b)$/;"	f	namespace:cv	signature:(Point3_<_Tp>& a, double b)
operator *=	core/operations.hpp	/^operator *= (Point3_<_Tp>& a, float b)$/;"	f	namespace:cv	signature:(Point3_<_Tp>& a, float b)
operator *=	core/operations.hpp	/^operator *= (Point3_<_Tp>& a, int b)$/;"	f	namespace:cv	signature:(Point3_<_Tp>& a, int b)
operator *=	core/operations.hpp	/^operator *= (Point_<_Tp>& a, double b)$/;"	f	namespace:cv	signature:(Point_<_Tp>& a, double b)
operator *=	core/operations.hpp	/^operator *= (Point_<_Tp>& a, float b)$/;"	f	namespace:cv	signature:(Point_<_Tp>& a, float b)
operator *=	core/operations.hpp	/^operator *= (Point_<_Tp>& a, int b)$/;"	f	namespace:cv	signature:(Point_<_Tp>& a, int b)
operator *=	core/operations.hpp	/^operator *= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
operator *=	core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp>& operator *= ( Scalar_<_Tp>& a, _Tp v )$/;"	f	namespace:cv	signature:( Scalar_<_Tp>& a, _Tp v )
operator +	core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator +	core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const Mat& a, const Scalar& s);$/;"	p	namespace:cv	signature:(const Mat& a, const Scalar& s)
operator +	core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const Mat& m, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Mat& m, const MatExpr& e)
operator +	core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const MatExpr& e, const Mat& m);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Mat& m)
operator +	core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const MatExpr& e, const Scalar& s);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Scalar& s)
operator +	core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const MatExpr& e1, const MatExpr& e2);$/;"	p	namespace:cv	signature:(const MatExpr& e1, const MatExpr& e2)
operator +	core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const Scalar& s, const Mat& a);$/;"	p	namespace:cv	signature:(const Scalar& s, const Mat& a)
operator +	core/mat.hpp	/^CV_EXPORTS MatExpr operator + (const Scalar& s, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Scalar& s, const MatExpr& e)
operator +	core/mat.hpp	/^operator + (const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)
operator +	core/mat.hpp	/^operator + (const MatIterator_<_Tp>& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatIterator_<_Tp>& a, ptrdiff_t ofs)
operator +	core/mat.hpp	/^operator + (ptrdiff_t ofs, const MatConstIterator_<_Tp>& a)$/;"	f	namespace:cv	signature:(ptrdiff_t ofs, const MatConstIterator_<_Tp>& a)
operator +	core/mat.hpp	/^operator + (ptrdiff_t ofs, const MatIterator_<_Tp>& a)$/;"	f	namespace:cv	signature:(ptrdiff_t ofs, const MatIterator_<_Tp>& a)
operator +	core/mat.hpp	/^static inline MatConstIterator operator + (const MatConstIterator& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, ptrdiff_t ofs)
operator +	core/mat.hpp	/^static inline MatConstIterator operator + (ptrdiff_t ofs, const MatConstIterator& a)$/;"	f	namespace:cv	signature:(ptrdiff_t ofs, const MatConstIterator& a)
operator +	core/operations.hpp	/^Complex<_Tp> operator + (_Tp b, const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(_Tp b, const Complex<_Tp>& a)
operator +	core/operations.hpp	/^Complex<_Tp> operator + (const Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, _Tp b)
operator +	core/operations.hpp	/^Complex<_Tp> operator + (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
operator +	core/operations.hpp	/^Matx<_Tp, m, n> operator + (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
operator +	core/operations.hpp	/^operator + (const Vec<_Tp, cn>& a, const Vec<_Tp, cn>& b)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& a, const Vec<_Tp, cn>& b)
operator +	core/operations.hpp	/^static inline Range operator + (const Range& r1, int delta)$/;"	f	namespace:cv	signature:(const Range& r1, int delta)
operator +	core/operations.hpp	/^static inline Range operator + (int delta, const Range& r1)$/;"	f	namespace:cv	signature:(int delta, const Range& r1)
operator +	core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator + (const Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, const Point3_<_Tp>& b)
operator +	core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator + (const Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, const Point_<_Tp>& b)
operator +	core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp> operator + (const Rect_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Point_<_Tp>& b)
operator +	core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp> operator + (const Rect_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Size_<_Tp>& b)
operator +	core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp> operator + (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
operator +	core/operations.hpp	/^template<typename _Tp> static inline Size_<_Tp> operator + (const Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Size_<_Tp>& a, const Size_<_Tp>& b)
operator ++	core/core.hpp	/^    FileNodeIterator operator ++ (int);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(int)
operator ++	core/core.hpp	/^    FileNodeIterator& operator ++ ();$/;"	p	class:cv::FileNodeIterator	access:public	signature:()
operator ++	core/core.hpp	/^    LineIterator operator ++(int);$/;"	p	class:cv::LineIterator	access:public	signature:(int)
operator ++	core/core.hpp	/^    LineIterator& operator ++();$/;"	p	class:cv::LineIterator	access:public	signature:()
operator ++	core/core.hpp	/^    MatConstIterator operator ++(int);$/;"	p	class:cv::MatConstIterator	access:public	signature:(int)
operator ++	core/core.hpp	/^    MatConstIterator& operator ++();$/;"	p	class:cv::MatConstIterator	access:public	signature:()
operator ++	core/core.hpp	/^    MatConstIterator_ operator ++(int);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(int)
operator ++	core/core.hpp	/^    MatConstIterator_& operator ++();$/;"	p	class:cv::MatConstIterator_	access:public	signature:()
operator ++	core/core.hpp	/^    MatIterator_ operator ++(int);$/;"	p	class:cv::MatIterator_	access:public	signature:(int)
operator ++	core/core.hpp	/^    MatIterator_& operator ++();$/;"	p	class:cv::MatIterator_	access:public	signature:()
operator ++	core/core.hpp	/^    NAryMatIterator operator ++(int);$/;"	p	class:cv::NAryMatIterator	access:public	signature:(int)
operator ++	core/core.hpp	/^    NAryMatIterator& operator ++();$/;"	p	class:cv::NAryMatIterator	access:public	signature:()
operator ++	core/core.hpp	/^    SeqIterator operator ++(int) const;$/;"	p	class:cv::SeqIterator	access:public	signature:(int) const
operator ++	core/core.hpp	/^    SeqIterator& operator ++();$/;"	p	class:cv::SeqIterator	access:public	signature:()
operator ++	core/core.hpp	/^    SparseMatConstIterator operator ++(int);$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:(int)
operator ++	core/core.hpp	/^    SparseMatConstIterator& operator ++();$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:()
operator ++	core/core.hpp	/^    SparseMatConstIterator_ operator ++(int);$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:(int)
operator ++	core/core.hpp	/^    SparseMatConstIterator_& operator ++();$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:()
operator ++	core/core.hpp	/^    SparseMatIterator operator ++(int);$/;"	p	class:cv::SparseMatIterator	access:public	signature:(int)
operator ++	core/core.hpp	/^    SparseMatIterator& operator ++();$/;"	p	class:cv::SparseMatIterator	access:public	signature:()
operator ++	core/core.hpp	/^    SparseMatIterator_ operator ++(int);$/;"	p	class:cv::SparseMatIterator_	access:public	signature:(int)
operator ++	core/core.hpp	/^    SparseMatIterator_& operator ++();$/;"	p	class:cv::SparseMatIterator_	access:public	signature:()
operator ++	core/mat.hpp	/^SparseMatConstIterator_<_Tp>::operator ++()$/;"	f	class:cv::SparseMatConstIterator_	signature:()
operator ++	core/mat.hpp	/^SparseMatConstIterator_<_Tp>::operator ++(int)$/;"	f	class:cv::SparseMatConstIterator_	signature:(int)
operator ++	core/mat.hpp	/^SparseMatIterator_<_Tp>::operator ++()$/;"	f	class:cv::SparseMatIterator_	signature:()
operator ++	core/mat.hpp	/^SparseMatIterator_<_Tp>::operator ++(int)$/;"	f	class:cv::SparseMatIterator_	signature:(int)
operator ++	core/mat.hpp	/^inline MatConstIterator MatConstIterator::operator ++(int)$/;"	f	class:cv::MatConstIterator	signature:(int)
operator ++	core/mat.hpp	/^inline MatConstIterator& MatConstIterator::operator ++()$/;"	f	class:cv::MatConstIterator	signature:()
operator ++	core/mat.hpp	/^inline SparseMatConstIterator SparseMatConstIterator::operator ++(int)$/;"	f	class:cv::SparseMatConstIterator	signature:(int)
operator ++	core/mat.hpp	/^inline SparseMatIterator SparseMatIterator::operator ++(int)$/;"	f	class:cv::SparseMatIterator	signature:(int)
operator ++	core/mat.hpp	/^inline SparseMatIterator& SparseMatIterator::operator ++()$/;"	f	class:cv::SparseMatIterator	signature:()
operator ++	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> MatConstIterator_<_Tp>::operator ++(int)$/;"	f	class:cv::MatConstIterator_	signature:(int)
operator ++	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator ++()$/;"	f	class:cv::MatConstIterator_	signature:()
operator ++	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> MatIterator_<_Tp>::operator ++(int)$/;"	f	class:cv::MatIterator_	signature:(int)
operator ++	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator ++()$/;"	f	class:cv::MatIterator_	signature:()
operator ++	core/operations.hpp	/^inline LineIterator LineIterator::operator ++(int)$/;"	f	class:cv::LineIterator	signature:(int)
operator ++	core/operations.hpp	/^inline LineIterator& LineIterator::operator ++()$/;"	f	class:cv::LineIterator	signature:()
operator ++	core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp> SeqIterator<_Tp>::operator ++(int) const$/;"	f	class:cv::SeqIterator	signature:(int) const
operator ++	core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator ++()$/;"	f	class:cv::SeqIterator	signature:()
operator ++	flann/dist.h	/^    ZeroIterator<T> operator ++(int)$/;"	f	struct:cvflann::ZeroIterator	access:public	signature:(int)
operator ++	flann/dist.h	/^    const ZeroIterator<T>& operator ++()$/;"	f	struct:cvflann::ZeroIterator	access:public	signature:()
operator +=	core/core.hpp	/^    FileNodeIterator& operator += (int);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(int)
operator +=	core/core.hpp	/^    MatConstIterator& operator += (ptrdiff_t ofs);$/;"	p	class:cv::MatConstIterator	access:public	signature:(ptrdiff_t ofs)
operator +=	core/core.hpp	/^    MatConstIterator_& operator += (ptrdiff_t ofs);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(ptrdiff_t ofs)
operator +=	core/core.hpp	/^    MatIterator_& operator += (ptrdiff_t ofs);$/;"	p	class:cv::MatIterator_	access:public	signature:(ptrdiff_t ofs)
operator +=	core/core.hpp	/^    SeqIterator& operator +=(int);$/;"	p	class:cv::SeqIterator	access:public	signature:(int)
operator +=	core/mat.hpp	/^Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const MatExpr& b)
operator +=	core/mat.hpp	/^Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
operator +=	core/mat.hpp	/^Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Scalar& s)
operator +=	core/mat.hpp	/^inline MatConstIterator& MatConstIterator::operator += (ptrdiff_t ofs)$/;"	f	class:cv::MatConstIterator	signature:(ptrdiff_t ofs)
operator +=	core/mat.hpp	/^static inline Mat& operator += (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
operator +=	core/mat.hpp	/^static inline Mat& operator += (const Mat& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat& a, const MatExpr& b)
operator +=	core/mat.hpp	/^static inline Mat& operator += (const Mat& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat& a, const Scalar& s)
operator +=	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator += (ptrdiff_t ofs)$/;"	f	class:cv::MatConstIterator_	signature:(ptrdiff_t ofs)
operator +=	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator += (ptrdiff_t ofs)$/;"	f	class:cv::MatIterator_	signature:(ptrdiff_t ofs)
operator +=	core/operations.hpp	/^Complex<_Tp>& operator += (Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, _Tp b)
operator +=	core/operations.hpp	/^Complex<_Tp>& operator += (Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, const Complex<_Tp>& b)
operator +=	core/operations.hpp	/^Matx<_Tp1, m, n>& operator += (Matx<_Tp1, m, n>& a, const Matx<_Tp2, m, n>& b)$/;"	f	namespace:cv	signature:(Matx<_Tp1, m, n>& a, const Matx<_Tp2, m, n>& b)
operator +=	core/operations.hpp	/^Vec<T1, 2>& operator += (Vec<T1, 2>& a, const Vec<T2, 2>& b)$/;"	f	namespace:cv	signature:(Vec<T1, 2>& a, const Vec<T2, 2>& b)
operator +=	core/operations.hpp	/^Vec<T1, 3>& operator += (Vec<T1, 3>& a, const Vec<T2, 3>& b)$/;"	f	namespace:cv	signature:(Vec<T1, 3>& a, const Vec<T2, 3>& b)
operator +=	core/operations.hpp	/^Vec<T1, 4>& operator += (Vec<T1, 4>& a, const Vec<T2, 4>& b)$/;"	f	namespace:cv	signature:(Vec<T1, 4>& a, const Vec<T2, 4>& b)
operator +=	core/operations.hpp	/^operator += (Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(Point3_<_Tp>& a, const Point3_<_Tp>& b)
operator +=	core/operations.hpp	/^operator += (Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(Point_<_Tp>& a, const Point_<_Tp>& b)
operator +=	core/operations.hpp	/^operator += (Vec<_Tp1, cn>& a, const Vec<_Tp2, cn>& b)$/;"	f	namespace:cv	signature:(Vec<_Tp1, cn>& a, const Vec<_Tp2, cn>& b)
operator +=	core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator +=(int delta)$/;"	f	class:cv::SeqIterator	signature:(int delta)
operator +=	core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator += ( Rect_<_Tp>& a, const Point_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Point_<_Tp>& b )
operator +=	core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator += ( Rect_<_Tp>& a, const Size_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Size_<_Tp>& b )
operator +=	core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp>& operator += (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
operator +=	core/operations.hpp	/^template<typename _Tp> static inline Size_<_Tp>& operator += (Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(Size_<_Tp>& a, const Size_<_Tp>& b)
operator +=	flann/dist.h	/^    ZeroIterator<T>& operator+=(int)$/;"	f	struct:cvflann::ZeroIterator	access:public	signature:(int)
operator ,	core/core.hpp	/^    template<typename T2> MatCommaInitializer_<_Tp>& operator , (T2 v);$/;"	p	class:cv::MatCommaInitializer_	access:public	signature:(T2 v)
operator ,	core/core.hpp	/^    template<typename T2> MatxCommaInitializer<_Tp, m, n>& operator , (T2 val);$/;"	p	class:cv::MatxCommaInitializer	access:public	signature:(T2 val)
operator ,	core/core.hpp	/^    template<typename T2> VecCommaInitializer<_Tp, m>& operator , (T2 val);$/;"	p	class:cv::VecCommaInitializer	access:public	signature:(T2 val)
operator ,	core/mat.hpp	/^MatCommaInitializer_<_Tp>::operator , (T2 v)$/;"	f	class:cv::MatCommaInitializer_	signature:(T2 v)
operator ,	core/operations.hpp	/^MatxCommaInitializer<_Tp, m, n>& MatxCommaInitializer<_Tp, m, n>::operator , (_T2 value)$/;"	f	class:cv::MatxCommaInitializer	signature:(_T2 value)
operator ,	core/operations.hpp	/^VecCommaInitializer<_Tp, cn>& VecCommaInitializer<_Tp, cn>::operator , (_T2 value)$/;"	f	class:cv::VecCommaInitializer	signature:(_T2 value)
operator -	core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator -	core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Mat& a, const Scalar& s);$/;"	p	namespace:cv	signature:(const Mat& a, const Scalar& s)
operator -	core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Mat& m);$/;"	p	namespace:cv	signature:(const Mat& m)
operator -	core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Mat& m, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Mat& m, const MatExpr& e)
operator -	core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const MatExpr& e);$/;"	p	namespace:cv	signature:(const MatExpr& e)
operator -	core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const MatExpr& e, const Mat& m);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Mat& m)
operator -	core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const MatExpr& e, const Scalar& s);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Scalar& s)
operator -	core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const MatExpr& e1, const MatExpr& e2);$/;"	p	namespace:cv	signature:(const MatExpr& e1, const MatExpr& e2)
operator -	core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Scalar& s, const Mat& a);$/;"	p	namespace:cv	signature:(const Scalar& s, const Mat& a)
operator -	core/mat.hpp	/^CV_EXPORTS MatExpr operator - (const Scalar& s, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Scalar& s, const MatExpr& e)
operator -	core/mat.hpp	/^CV_EXPORTS ptrdiff_t operator - (const MatConstIterator& b, const MatConstIterator& a);$/;"	p	namespace:cv	signature:(const MatConstIterator& b, const MatConstIterator& a)
operator -	core/mat.hpp	/^operator - (const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)
operator -	core/mat.hpp	/^operator - (const MatIterator_<_Tp>& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatIterator_<_Tp>& a, ptrdiff_t ofs)
operator -	core/mat.hpp	/^static inline MatConstIterator operator - (const MatConstIterator& a, ptrdiff_t ofs)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, ptrdiff_t ofs)
operator -	core/operations.hpp	/^Complex<_Tp> operator - (_Tp b, const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(_Tp b, const Complex<_Tp>& a)
operator -	core/operations.hpp	/^Complex<_Tp> operator - (const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a)
operator -	core/operations.hpp	/^Complex<_Tp> operator - (const Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, _Tp b)
operator -	core/operations.hpp	/^Complex<_Tp> operator - (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
operator -	core/operations.hpp	/^Matx<_Tp, m, n> operator - (const Matx<_Tp, m, n>& a)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a)
operator -	core/operations.hpp	/^Matx<_Tp, m, n> operator - (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
operator -	core/operations.hpp	/^operator - (const Vec<_Tp, cn>& a)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& a)
operator -	core/operations.hpp	/^operator - (const Vec<_Tp, cn>& a, const Vec<_Tp, cn>& b)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& a, const Vec<_Tp, cn>& b)
operator -	core/operations.hpp	/^static inline Range operator - (const Range& r1, int delta)$/;"	f	namespace:cv	signature:(const Range& r1, int delta)
operator -	core/operations.hpp	/^static inline ptrdiff_t operator - (const FileNodeIterator& it1, const FileNodeIterator& it2)$/;"	f	namespace:cv	signature:(const FileNodeIterator& it1, const FileNodeIterator& it2)
operator -	core/operations.hpp	/^template<typename _Tp> inline ptrdiff_t operator - (const SeqIterator<_Tp>& a,$/;"	f	namespace:cv	signature:(const SeqIterator<_Tp>& a, const SeqIterator<_Tp>& b)
operator -	core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator - (const Point3_<_Tp>& a)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a)
operator -	core/operations.hpp	/^template<typename _Tp> static inline Point3_<_Tp> operator - (const Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, const Point3_<_Tp>& b)
operator -	core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator - (const Point_<_Tp>& a)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a)
operator -	core/operations.hpp	/^template<typename _Tp> static inline Point_<_Tp> operator - (const Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, const Point_<_Tp>& b)
operator -	core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp> operator - (const Rect_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Point_<_Tp>& b)
operator -	core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp> operator - (const Scalar_<_Tp>& a)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a)
operator -	core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp> operator - (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
operator -	core/operations.hpp	/^template<typename _Tp> static inline Size_<_Tp> operator - (const Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Size_<_Tp>& a, const Size_<_Tp>& b)
operator --	core/core.hpp	/^    FileNodeIterator operator -- (int);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(int)
operator --	core/core.hpp	/^    FileNodeIterator& operator -- ();$/;"	p	class:cv::FileNodeIterator	access:public	signature:()
operator --	core/core.hpp	/^    MatConstIterator operator --(int);$/;"	p	class:cv::MatConstIterator	access:public	signature:(int)
operator --	core/core.hpp	/^    MatConstIterator& operator --();$/;"	p	class:cv::MatConstIterator	access:public	signature:()
operator --	core/core.hpp	/^    MatConstIterator_ operator --(int);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(int)
operator --	core/core.hpp	/^    MatConstIterator_& operator --();$/;"	p	class:cv::MatConstIterator_	access:public	signature:()
operator --	core/core.hpp	/^    MatIterator_ operator --(int);$/;"	p	class:cv::MatIterator_	access:public	signature:(int)
operator --	core/core.hpp	/^    MatIterator_& operator --();$/;"	p	class:cv::MatIterator_	access:public	signature:()
operator --	core/core.hpp	/^    SeqIterator operator --(int) const;$/;"	p	class:cv::SeqIterator	access:public	signature:(int) const
operator --	core/core.hpp	/^    SeqIterator& operator --();$/;"	p	class:cv::SeqIterator	access:public	signature:()
operator --	core/core.hpp	/^    SparseMatConstIterator operator --(int);$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:(int)
operator --	core/core.hpp	/^    SparseMatConstIterator& operator --();$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:()
operator --	core/mat.hpp	/^inline MatConstIterator MatConstIterator::operator --(int)$/;"	f	class:cv::MatConstIterator	signature:(int)
operator --	core/mat.hpp	/^inline MatConstIterator& MatConstIterator::operator --()$/;"	f	class:cv::MatConstIterator	signature:()
operator --	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp> MatConstIterator_<_Tp>::operator --(int)$/;"	f	class:cv::MatConstIterator_	signature:(int)
operator --	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator --()$/;"	f	class:cv::MatConstIterator_	signature:()
operator --	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp> MatIterator_<_Tp>::operator --(int)$/;"	f	class:cv::MatIterator_	signature:(int)
operator --	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator --()$/;"	f	class:cv::MatIterator_	signature:()
operator --	core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp> SeqIterator<_Tp>::operator --(int) const$/;"	f	class:cv::SeqIterator	signature:(int) const
operator --	core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator --()$/;"	f	class:cv::SeqIterator	signature:()
operator -=	core/core.hpp	/^    FileNodeIterator& operator -= (int);$/;"	p	class:cv::FileNodeIterator	access:public	signature:(int)
operator -=	core/core.hpp	/^    MatConstIterator& operator -= (ptrdiff_t ofs);$/;"	p	class:cv::MatConstIterator	access:public	signature:(ptrdiff_t ofs)
operator -=	core/core.hpp	/^    MatConstIterator_& operator -= (ptrdiff_t ofs);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(ptrdiff_t ofs)
operator -=	core/core.hpp	/^    MatIterator_& operator -= (ptrdiff_t ofs);$/;"	p	class:cv::MatIterator_	access:public	signature:(ptrdiff_t ofs)
operator -=	core/core.hpp	/^    SeqIterator& operator -=(int);$/;"	p	class:cv::SeqIterator	access:public	signature:(int)
operator -=	core/mat.hpp	/^Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const MatExpr& b)
operator -=	core/mat.hpp	/^Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
operator -=	core/mat.hpp	/^Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Scalar& s)
operator -=	core/mat.hpp	/^inline MatConstIterator& MatConstIterator::operator -= (ptrdiff_t ofs)$/;"	f	class:cv::MatConstIterator	signature:(ptrdiff_t ofs)
operator -=	core/mat.hpp	/^static inline Mat& operator -= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
operator -=	core/mat.hpp	/^static inline Mat& operator -= (const Mat& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat& a, const MatExpr& b)
operator -=	core/mat.hpp	/^static inline Mat& operator -= (const Mat& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat& a, const Scalar& s)
operator -=	core/mat.hpp	/^template<typename _Tp> inline MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator -= (ptrdiff_t ofs)$/;"	f	class:cv::MatConstIterator_	signature:(ptrdiff_t ofs)
operator -=	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator -= (ptrdiff_t ofs)$/;"	f	class:cv::MatIterator_	signature:(ptrdiff_t ofs)
operator -=	core/operations.hpp	/^Complex<_Tp>& operator -= (Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, _Tp b)
operator -=	core/operations.hpp	/^Complex<_Tp>& operator -= (Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, const Complex<_Tp>& b)
operator -=	core/operations.hpp	/^Matx<_Tp1, m, n>& operator -= (Matx<_Tp1, m, n>& a, const Matx<_Tp2, m, n>& b)$/;"	f	namespace:cv	signature:(Matx<_Tp1, m, n>& a, const Matx<_Tp2, m, n>& b)
operator -=	core/operations.hpp	/^operator -= (Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(Point3_<_Tp>& a, const Point3_<_Tp>& b)
operator -=	core/operations.hpp	/^operator -= (Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(Point_<_Tp>& a, const Point_<_Tp>& b)
operator -=	core/operations.hpp	/^operator -= (Vec<_Tp1, cn>& a, const Vec<_Tp2, cn>& b)$/;"	f	namespace:cv	signature:(Vec<_Tp1, cn>& a, const Vec<_Tp2, cn>& b)
operator -=	core/operations.hpp	/^template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator -=(int delta)$/;"	f	class:cv::SeqIterator	signature:(int delta)
operator -=	core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator -= ( Rect_<_Tp>& a, const Point_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Point_<_Tp>& b )
operator -=	core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator -= ( Rect_<_Tp>& a, const Size_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Size_<_Tp>& b )
operator -=	core/operations.hpp	/^template<typename _Tp> static inline Scalar_<_Tp>& operator -= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
operator -=	core/operations.hpp	/^template<typename _Tp> static inline Size_<_Tp>& operator -= (Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(Size_<_Tp>& a, const Size_<_Tp>& b)
operator ->	core/core.hpp	/^    FileNode operator ->() const;$/;"	p	class:cv::FileNodeIterator	access:public	signature:() const
operator ->	core/core.hpp	/^    _Tp* operator -> ();$/;"	p	class:cv::Ptr	access:public	signature:()
operator ->	core/core.hpp	/^    const _Tp* operator -> () const;$/;"	p	class:cv::Ptr	access:public	signature:() const
operator ->	core/operations.hpp	/^inline FileNode FileNodeIterator::operator ->() const$/;"	f	class:cv::FileNodeIterator	signature:() const
operator ->	core/operations.hpp	/^template<typename _Tp> inline _Tp* Ptr<_Tp>::operator -> () { return obj; }$/;"	f	class:cv::Ptr	signature:()
operator ->	core/operations.hpp	/^template<typename _Tp> inline const _Tp* Ptr<_Tp>::operator -> () const { return obj; }$/;"	f	class:cv::Ptr	signature:() const
operator /	core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator /	core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
operator /	core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const Mat& m, const MatExpr& e);$/;"	p	namespace:cv	signature:(const Mat& m, const MatExpr& e)
operator /	core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const MatExpr& e, const Mat& m);$/;"	p	namespace:cv	signature:(const MatExpr& e, const Mat& m)
operator /	core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const MatExpr& e, double s);$/;"	p	namespace:cv	signature:(const MatExpr& e, double s)
operator /	core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (const MatExpr& e1, const MatExpr& e2);    $/;"	p	namespace:cv	signature:(const MatExpr& e1, const MatExpr& e2)
operator /	core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
operator /	core/mat.hpp	/^CV_EXPORTS MatExpr operator \/ (double s, const MatExpr& e);$/;"	p	namespace:cv	signature:(double s, const MatExpr& e)
operator /	core/operations.hpp	/^Complex<_Tp> operator \/ (_Tp b, const Complex<_Tp>& a)$/;"	f	namespace:cv	signature:(_Tp b, const Complex<_Tp>& a)
operator /	core/operations.hpp	/^Complex<_Tp> operator \/ (const Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, _Tp b)
operator /	core/operations.hpp	/^Complex<_Tp> operator \/ (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
operator /	core/operations.hpp	/^Scalar_<_Tp> operator \/ (_Tp a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(_Tp a, const Scalar_<_Tp>& b)
operator /	core/operations.hpp	/^Scalar_<_Tp> operator \/ (const Scalar_<_Tp>& a, _Tp alpha)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, _Tp alpha)
operator /	core/operations.hpp	/^Scalar_<_Tp> operator \/ (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
operator /	core/operations.hpp	/^Scalar_<double> operator \/ (const Scalar_<double>& a, double alpha)$/;"	f	namespace:cv	signature:(const Scalar_<double>& a, double alpha)
operator /	core/operations.hpp	/^Scalar_<float> operator \/ (const Scalar_<float>& a, float alpha)$/;"	f	namespace:cv	signature:(const Scalar_<float>& a, float alpha)
operator /=	core/mat.hpp	/^Mat_<_Tp>& operator \/= (const Mat_<_Tp>& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const MatExpr& b)
operator /=	core/mat.hpp	/^Mat_<_Tp>& operator \/= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
operator /=	core/mat.hpp	/^Mat_<_Tp>& operator \/= (const Mat_<_Tp>& a, double s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, double s)
operator /=	core/mat.hpp	/^static inline Mat& operator \/= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
operator /=	core/mat.hpp	/^static inline Mat& operator \/= (const Mat& a, const MatExpr& b)$/;"	f	namespace:cv	signature:(const Mat& a, const MatExpr& b)
operator /=	core/mat.hpp	/^static inline Mat& operator \/= (const Mat& a, double s)$/;"	f	namespace:cv	signature:(const Mat& a, double s)
operator /=	core/operations.hpp	/^Complex<_Tp> operator \/= (const Complex<_Tp>& a, _Tp b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, _Tp b)
operator /=	core/operations.hpp	/^Complex<_Tp>& operator \/= (Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(Complex<_Tp>& a, const Complex<_Tp>& b)
operator /=	core/operations.hpp	/^Scalar_<_Tp>& operator \/= (Scalar_<_Tp>& a, _Tp alpha)$/;"	f	namespace:cv	signature:(Scalar_<_Tp>& a, _Tp alpha)
operator /=	core/operations.hpp	/^Scalar_<_Tp>& operator \/= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)$/;"	f	namespace:cv	signature:(Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
operator <	core/mat.hpp	/^CV_EXPORTS MatExpr operator < (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator <	core/mat.hpp	/^CV_EXPORTS MatExpr operator < (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
operator <	core/mat.hpp	/^CV_EXPORTS MatExpr operator < (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
operator <	core/mat.hpp	/^operator < (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
operator <	core/operations.hpp	/^static inline bool operator < (const FileNodeIterator& it1, const FileNodeIterator& it2)$/;"	f	namespace:cv	signature:(const FileNodeIterator& it1, const FileNodeIterator& it2)
operator <	features2d/features2d.hpp	/^    bool operator<( const DMatch &m ) const$/;"	f	struct:cv::DMatch	access:public	signature:( const DMatch &m ) const
operator <	flann/result_set.h	/^        bool operator<(const DistIndex dist_index) const$/;"	f	struct:cvflann::UniqueResultSet::DistIndex	access:public	signature:(const DistIndex dist_index) const
operator <	flann/result_set.h	/^    bool operator<(const BranchStruct<T, DistanceType>& rhs) const$/;"	f	struct:cvflann::BranchStruct	access:public	signature:(const BranchStruct<T, DistanceType>& rhs) const
operator <<	contrib/contrib.hpp	/^    CV_EXPORTS std::ostream& operator<<(std::ostream& out, const TickMeter& tm);$/;"	p	namespace:cv	signature:(std::ostream& out, const TickMeter& tm)
operator <<	core/mat.hpp	/^operator << (const Mat_<_Tp>& m, T2 val)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& m, T2 val)
operator <<	core/operations.hpp	/^CV_EXPORTS FileStorage& operator << (FileStorage& fs, const string& str);$/;"	p	namespace:cv	signature:(FileStorage& fs, const string& str)
operator <<	core/operations.hpp	/^MatxCommaInitializer<_Tp, m, n> operator << (const Matx<_Tp, m, n>& mtx, _T2 val)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& mtx, _T2 val)
operator <<	core/operations.hpp	/^VecCommaInitializer<_Tp, cn> operator << (const Vec<_Tp, cn>& vec, _T2 val)$/;"	f	namespace:cv	signature:(const Vec<_Tp, cn>& vec, _T2 val)
operator <<	core/operations.hpp	/^operator << ( FileStorage& fs, const vector<_Tp>& vec )$/;"	f	namespace:cv	signature:( FileStorage& fs, const vector<_Tp>& vec )
operator <<	core/operations.hpp	/^static inline FileStorage& operator << (FileStorage& fs, const char* str)$/;"	f	namespace:cv	signature:(FileStorage& fs, const char* str)
operator <<	core/operations.hpp	/^static inline std::ostream& operator << (std::ostream& out, const Formatted& fmtd)$/;"	f	namespace:cv	signature:(std::ostream& out, const Formatted& fmtd)
operator <<	core/operations.hpp	/^static inline std::ostream& operator << (std::ostream& out, const Mat& mtx)$/;"	f	namespace:cv	signature:(std::ostream& out, const Mat& mtx)
operator <<	core/operations.hpp	/^template<typename _Tp> inline std::ostream& operator<<(std::ostream& out, const Point3_<_Tp>& p)$/;"	f	namespace:cv	signature:(std::ostream& out, const Point3_<_Tp>& p)
operator <<	core/operations.hpp	/^template<typename _Tp> inline std::ostream& operator<<(std::ostream& out, const Point_<_Tp>& p)$/;"	f	namespace:cv	signature:(std::ostream& out, const Point_<_Tp>& p)
operator <<	core/operations.hpp	/^template<typename _Tp> static inline FileStorage& operator << (FileStorage& fs, const _Tp& value)$/;"	f	namespace:cv	signature:(FileStorage& fs, const _Tp& value)
operator <<	core/operations.hpp	/^template<typename _Tp> static inline std::ostream& operator << (std::ostream& out,$/;"	f	namespace:cv	signature:(std::ostream& out, const vector<Point3_<_Tp> >& vec)
operator <<	core/operations.hpp	/^template<typename _Tp> static inline std::ostream& operator << (std::ostream& out,$/;"	f	namespace:cv	signature:(std::ostream& out, const vector<Point_<_Tp> >& vec)
operator <<	flann/any.h	/^    friend std::ostream& operator <<(std::ostream& out, const any& any_val);$/;"	p	struct:cdiggins::any	access:friend	signature:(std::ostream& out, const any& any_val)
operator <<	flann/any.h	/^inline std::ostream& operator <<(std::ostream& out, const any& any_val)$/;"	f	namespace:cdiggins	signature:(std::ostream& out, const any& any_val)
operator <<	flann/lsh_table.h	/^inline std::ostream& operator <<(std::ostream& out, const LshStats& stats)$/;"	f	namespace:cvflann::lsh	signature:(std::ostream& out, const LshStats& stats)
operator <<	highgui/highgui.hpp	/^    virtual VideoWriter& operator << (const Mat& image);$/;"	p	class:cv::VideoWriter	access:public	signature:(const Mat& image)
operator <=	core/mat.hpp	/^CV_EXPORTS MatExpr operator <= (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator <=	core/mat.hpp	/^CV_EXPORTS MatExpr operator <= (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
operator <=	core/mat.hpp	/^CV_EXPORTS MatExpr operator <= (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
operator <=	core/mat.hpp	/^operator <= (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
operator =	contrib/contrib.hpp	/^        SelfSimDescriptor& operator = (const SelfSimDescriptor& ss);$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:(const SelfSimDescriptor& ss)
operator =	core/core.hpp	/^        MStep& operator = (const MStep&);$/;"	p	struct:cv::Mat::MStep	access:protected	signature:(const MStep&)
operator =	core/core.hpp	/^        MStep& operator = (size_t s);$/;"	p	struct:cv::Mat::MStep	access:public	signature:(size_t s)
operator =	core/core.hpp	/^    Mat& operator = (const Mat& m);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m)
operator =	core/core.hpp	/^    Mat& operator = (const MatExpr& expr);$/;"	p	class:cv::Mat	access:public	signature:(const MatExpr& expr)
operator =	core/core.hpp	/^    Mat& operator = (const Scalar& s);$/;"	p	class:cv::Mat	access:public	signature:(const Scalar& s)
operator =	core/core.hpp	/^    MatConstIterator& operator = (const MatConstIterator& it);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const MatConstIterator& it)
operator =	core/core.hpp	/^    MatConstIterator_& operator = (const MatConstIterator_& it);$/;"	p	class:cv::MatConstIterator_	access:public	signature:(const MatConstIterator_& it)
operator =	core/core.hpp	/^    MatIterator_& operator = (const MatIterator_<_Tp>& it );$/;"	p	class:cv::MatIterator_	access:public	signature:(const MatIterator_<_Tp>& it )
operator =	core/core.hpp	/^    Mat_& operator = (const Mat& m);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat& m)
operator =	core/core.hpp	/^    Mat_& operator = (const MatExpr& e);$/;"	p	class:cv::Mat_	access:public	signature:(const MatExpr& e)
operator =	core/core.hpp	/^    Mat_& operator = (const Mat_& m);$/;"	p	class:cv::Mat_	access:public	signature:(const Mat_& m)
operator =	core/core.hpp	/^    Mat_& operator = (const _Tp& s);$/;"	p	class:cv::Mat_	access:public	signature:(const _Tp& s)
operator =	core/core.hpp	/^    Point3_& operator = (const Point3_& pt);$/;"	p	class:cv::Point3_	access:public	signature:(const Point3_& pt)
operator =	core/core.hpp	/^    Point_& operator = (const Point_& pt);$/;"	p	class:cv::Point_	access:public	signature:(const Point_& pt)
operator =	core/core.hpp	/^    Ptr& operator = (const Ptr& ptr);$/;"	p	class:cv::Ptr	access:public	signature:(const Ptr& ptr)
operator =	core/core.hpp	/^    Rect_& operator = ( const Rect_& r );$/;"	p	class:cv::Rect_	access:public	signature:( const Rect_& r )
operator =	core/core.hpp	/^    Size_& operator = (const Size_& sz);$/;"	p	class:cv::Size_	access:public	signature:(const Size_& sz)
operator =	core/core.hpp	/^    SparseMat& operator = (const Mat& m);$/;"	p	class:cv::SparseMat	access:public	signature:(const Mat& m)
operator =	core/core.hpp	/^    SparseMat& operator = (const SparseMat& m);$/;"	p	class:cv::SparseMat	access:public	signature:(const SparseMat& m)
operator =	core/core.hpp	/^    SparseMatConstIterator& operator = (const SparseMatConstIterator& it);$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:(const SparseMatConstIterator& it)
operator =	core/core.hpp	/^    SparseMatConstIterator_& operator = (const SparseMatConstIterator_& it);$/;"	p	class:cv::SparseMatConstIterator_	access:public	signature:(const SparseMatConstIterator_& it)
operator =	core/core.hpp	/^    SparseMatIterator& operator = (const SparseMatIterator& it);$/;"	p	class:cv::SparseMatIterator	access:public	signature:(const SparseMatIterator& it)
operator =	core/core.hpp	/^    SparseMatIterator_& operator = (const SparseMatIterator_& it);$/;"	p	class:cv::SparseMatIterator_	access:public	signature:(const SparseMatIterator_& it)
operator =	core/core.hpp	/^    SparseMat_& operator = (const Mat& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const Mat& m)
operator =	core/core.hpp	/^    SparseMat_& operator = (const SparseMat& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const SparseMat& m)
operator =	core/core.hpp	/^    SparseMat_& operator = (const SparseMat_& m);$/;"	p	class:cv::SparseMat_	access:public	signature:(const SparseMat_& m)
operator =	core/mat.hpp	/^    MatConstIterator_<_Tp>::operator = (const MatConstIterator_& it )$/;"	f	class:cv::MatConstIterator_	signature:(const MatConstIterator_& it )
operator =	core/mat.hpp	/^SparseMatConstIterator_<_Tp>::operator = (const SparseMatConstIterator_<_Tp>& it)$/;"	f	class:cv::SparseMatConstIterator_	signature:(const SparseMatConstIterator_<_Tp>& it)
operator =	core/mat.hpp	/^SparseMatIterator_<_Tp>::operator = (const SparseMatIterator_<_Tp>& it)$/;"	f	class:cv::SparseMatIterator_	signature:(const SparseMatIterator_<_Tp>& it)
operator =	core/mat.hpp	/^SparseMat_<_Tp>::operator = (const Mat& m)$/;"	f	class:cv::SparseMat_	signature:(const Mat& m)
operator =	core/mat.hpp	/^SparseMat_<_Tp>::operator = (const SparseMat& m)$/;"	f	class:cv::SparseMat_	signature:(const SparseMat& m)
operator =	core/mat.hpp	/^SparseMat_<_Tp>::operator = (const SparseMat_<_Tp>& m)$/;"	f	class:cv::SparseMat_	signature:(const SparseMat_<_Tp>& m)
operator =	core/mat.hpp	/^inline Mat& Mat::operator = (const Mat& m)$/;"	f	class:cv::Mat	signature:(const Mat& m)
operator =	core/mat.hpp	/^inline Mat& Mat::operator = (const MatExpr& e)$/;"	f	class:cv::Mat	signature:(const MatExpr& e)
operator =	core/mat.hpp	/^inline Mat::MStep& Mat::MStep::operator = (size_t s)$/;"	f	class:cv::Mat::MStep	signature:(size_t s)
operator =	core/mat.hpp	/^inline MatConstIterator& MatConstIterator::operator = (const MatConstIterator& it )$/;"	f	class:cv::MatConstIterator	signature:(const MatConstIterator& it )
operator =	core/mat.hpp	/^inline SparseMat& SparseMat::operator = (const Mat& m)$/;"	f	class:cv::SparseMat	signature:(const Mat& m)
operator =	core/mat.hpp	/^inline SparseMat& SparseMat::operator = (const SparseMat& m)$/;"	f	class:cv::SparseMat	signature:(const SparseMat& m)
operator =	core/mat.hpp	/^inline SparseMatConstIterator& SparseMatConstIterator::operator = (const SparseMatConstIterator& it)$/;"	f	class:cv::SparseMatConstIterator	signature:(const SparseMatConstIterator& it)
operator =	core/mat.hpp	/^inline SparseMatIterator& SparseMatIterator::operator = (const SparseMatIterator& it)$/;"	f	class:cv::SparseMatIterator	signature:(const SparseMatIterator& it)
operator =	core/mat.hpp	/^template<typename _Tp> Mat_<_Tp>& Mat_<_Tp>::operator = (const MatExpr& e)$/;"	f	class:cv::Mat_	signature:(const MatExpr& e)
operator =	core/mat.hpp	/^template<typename _Tp> inline MatIterator_<_Tp>& MatIterator_<_Tp>::operator = (const MatIterator_<_Tp>& it )$/;"	f	class:cv::MatIterator_	signature:(const MatIterator_<_Tp>& it )
operator =	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::operator = (const Mat& m)$/;"	f	class:cv::Mat_	signature:(const Mat& m)
operator =	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::operator = (const Mat_& m)$/;"	f	class:cv::Mat_	signature:(const Mat_& m)
operator =	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>& Mat_<_Tp>::operator = (const _Tp& s)$/;"	f	class:cv::Mat_	signature:(const _Tp& s)
operator =	core/operations.hpp	/^    Vector<_Tp>& operator = (const Vector& d)$/;"	f	class:cv::Vector	access:public	signature:(const Vector& d)
operator =	core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>& Point3_<_Tp>::operator = (const Point3_& pt)$/;"	f	class:cv::Point3_	signature:(const Point3_& pt)
operator =	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>& Point_<_Tp>::operator = (const Point_& pt)$/;"	f	class:cv::Point_	signature:(const Point_& pt)
operator =	core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>& Ptr<_Tp>::operator = (const Ptr<_Tp>& ptr)$/;"	f	class:cv::Ptr	signature:(const Ptr<_Tp>& ptr)
operator =	core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>& Rect_<_Tp>::operator = ( const Rect_<_Tp>& r )$/;"	f	class:cv::Rect_	signature:( const Rect_<_Tp>& r )
operator =	core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>& Size_<_Tp>::operator = (const Size_<_Tp>& sz)$/;"	f	class:cv::Size_	signature:(const Size_<_Tp>& sz)
operator =	core/wimage.hpp	/^    WImageView& operator=(const WImage<T>& img) {$/;"	f	class:cv::WImageView	access:public	signature:(const WImage<T>& img)
operator =	core/wimage.hpp	/^    WImageViewC& operator=(const WImageC<T, C>& img) {$/;"	f	class:cv::WImageViewC	access:public	signature:(const WImageC<T, C>& img)
operator =	core/wimage.hpp	/^    WImageViewC& operator=(const WImageViewC<T, C>& img) {$/;"	f	class:cv::WImageViewC	access:public	signature:(const WImageViewC<T, C>& img)
operator =	core/wimage.hpp	/^    void operator=(const WImage&);$/;"	p	class:cv::WImage	access:protected	signature:(const WImage&)
operator =	core/wimage.hpp	/^    void operator=(const WImageBuffer&);$/;"	p	class:cv::WImageBuffer	access:private	signature:(const WImageBuffer&)
operator =	core/wimage.hpp	/^    void operator=(const WImageBufferC&);$/;"	p	class:cv::WImageBufferC	access:private	signature:(const WImageBufferC&)
operator =	core/wimage.hpp	/^    void operator=(const WImageC&);$/;"	p	class:cv::WImageC	access:protected	signature:(const WImageC&)
operator =	features2d/features2d.hpp	/^	DynamicAdaptedFeatureDetector& operator=(const DynamicAdaptedFeatureDetector&);$/;"	p	class:cv::DynamicAdaptedFeatureDetector	access:private	signature:(const DynamicAdaptedFeatureDetector&)
operator =	features2d/features2d.hpp	/^        DefaultRngAuto& operator=(const DefaultRngAuto&);$/;"	p	struct:cv::DefaultRngAuto	access:public	signature:(const DefaultRngAuto&)
operator =	flann/any.h	/^    any& operator=(const T& x)$/;"	f	struct:cdiggins::any	access:public	signature:(const T& x)
operator =	flann/any.h	/^    any& operator=(const char* x)$/;"	f	struct:cdiggins::any	access:public	signature:(const char* x)
operator =	flann/autotuned_index.h	/^    AutotunedIndex& operator=(const AutotunedIndex&);$/;"	p	class:cvflann::AutotunedIndex	access:public	signature:(const AutotunedIndex&)
operator =	flann/composite_index.h	/^    CompositeIndex& operator=(const CompositeIndex&);$/;"	p	class:cvflann::CompositeIndex	access:public	signature:(const CompositeIndex&)
operator =	flann/hierarchical_clustering_index.h	/^    HierarchicalClusteringIndex& operator=(const HierarchicalClusteringIndex&);$/;"	p	class:cvflann::HierarchicalClusteringIndex	access:public	signature:(const HierarchicalClusteringIndex&)
operator =	flann/kdtree_index.h	/^    KDTreeIndex& operator=(const KDTreeIndex&);$/;"	p	class:cvflann::KDTreeIndex	access:public	signature:(const KDTreeIndex&)
operator =	flann/kdtree_single_index.h	/^    KDTreeSingleIndex& operator=(const KDTreeSingleIndex&);$/;"	p	class:cvflann::KDTreeSingleIndex	access:public	signature:(const KDTreeSingleIndex&)
operator =	flann/kmeans_index.h	/^    KMeansIndex& operator=(const KMeansIndex&);$/;"	p	class:cvflann::KMeansIndex	access:public	signature:(const KMeansIndex&)
operator =	flann/linear_index.h	/^    LinearIndex& operator=(const LinearIndex&);$/;"	p	class:cvflann::LinearIndex	access:public	signature:(const LinearIndex&)
operator =	flann/lsh_index.h	/^    LshIndex& operator=(const LshIndex&);$/;"	p	class:cvflann::LshIndex	access:public	signature:(const LshIndex&)
operator =	gpu/NCV.hpp	/^    NCVMatrixAlloc& operator=(const NCVMatrixAlloc &);$/;"	p	class:NCVMatrixAlloc	access:private	signature:(const NCVMatrixAlloc &)
operator =	gpu/NCV.hpp	/^    NCVVectorAlloc& operator=(const NCVVectorAlloc<T>&);	$/;"	p	class:NCVVectorAlloc	access:private	signature:(const NCVVectorAlloc<T>&)
operator =	gpu/gpu.hpp	/^            CudaMem& operator = (const CudaMem& m);$/;"	p	class:cv::gpu::CudaMem	access:public	signature:(const CudaMem& m)
operator =	gpu/gpu.hpp	/^            Stream& operator=(const Stream&);$/;"	p	class:cv::gpu::Stream	access:public	signature:(const Stream&)
operator =	gpu/gpumat.hpp	/^        GpuMat& operator = (const GpuMat& m);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const GpuMat& m)
operator =	gpu/gpumat.hpp	/^        GpuMat& operator = (const Mat& m);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Mat& m)
operator =	gpu/gpumat.hpp	/^        GpuMat& operator = (const Scalar& s);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Scalar& s)
operator =	gpu/matrix_operations.hpp	/^inline CudaMem& CudaMem::operator = (const CudaMem& m)$/;"	f	class:cv::gpu::CudaMem	signature:(const CudaMem& m)
operator =	legacy/legacy.hpp	/^    CvImage& operator = (const CvImage& img)$/;"	f	class:CvImage	access:public	signature:(const CvImage& img)
operator =	legacy/legacy.hpp	/^    CvMatrix& operator = (const CvMatrix& _m)$/;"	f	class:CvMatrix	access:public	signature:(const CvMatrix& _m)
operator ==	core/core.hpp	/^        bool operator == (const MSize& sz) const;$/;"	p	struct:cv::Mat::MSize	access:public	signature:(const MSize& sz) const
operator ==	core/mat.hpp	/^CV_EXPORTS MatExpr operator == (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator ==	core/mat.hpp	/^CV_EXPORTS MatExpr operator == (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
operator ==	core/mat.hpp	/^CV_EXPORTS MatExpr operator == (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
operator ==	core/mat.hpp	/^inline bool Mat::MSize::operator == (const MSize& sz) const$/;"	f	class:cv::Mat::MSize	signature:(const MSize& sz) const
operator ==	core/mat.hpp	/^operator == (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
operator ==	core/mat.hpp	/^operator == (const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)$/;"	f	namespace:cv	signature:(const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)
operator ==	core/mat.hpp	/^operator == (const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)$/;"	f	namespace:cv	signature:(const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)
operator ==	core/mat.hpp	/^static inline bool operator == (const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)$/;"	f	namespace:cv	signature:(const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)
operator ==	core/operations.hpp	/^bool operator == (const Complex<_Tp>& a, const Complex<_Tp>& b)$/;"	f	namespace:cv	signature:(const Complex<_Tp>& a, const Complex<_Tp>& b)
operator ==	core/operations.hpp	/^bool operator == (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
operator ==	core/operations.hpp	/^static inline bool operator == (const FileNodeIterator& it1, const FileNodeIterator& it2)$/;"	f	namespace:cv	signature:(const FileNodeIterator& it1, const FileNodeIterator& it2)
operator ==	core/operations.hpp	/^static inline bool operator == (const Range& r1, const Range& r2)$/;"	f	namespace:cv	signature:(const Range& r1, const Range& r2)
operator ==	core/operations.hpp	/^template<typename _Tp> inline bool operator == (const SeqIterator<_Tp>& a,$/;"	f	namespace:cv	signature:(const SeqIterator<_Tp>& a, const SeqIterator<_Tp>& b)
operator ==	core/operations.hpp	/^template<typename _Tp> static inline bool operator == ( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )$/;"	f	namespace:cv	signature:( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )
operator ==	core/operations.hpp	/^template<typename _Tp> static inline bool operator == (const Point3_<_Tp>& a, const Point3_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point3_<_Tp>& a, const Point3_<_Tp>& b)
operator ==	core/operations.hpp	/^template<typename _Tp> static inline bool operator == (const Point_<_Tp>& a, const Point_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Point_<_Tp>& a, const Point_<_Tp>& b)
operator ==	core/operations.hpp	/^template<typename _Tp> static inline bool operator == (const Rect_<_Tp>& a, const Rect_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Rect_<_Tp>& b)
operator ==	core/operations.hpp	/^template<typename _Tp> static inline bool operator == (const Size_<_Tp>& a, const Size_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Size_<_Tp>& a, const Size_<_Tp>& b)
operator >	core/mat.hpp	/^CV_EXPORTS MatExpr operator > (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator >	core/mat.hpp	/^CV_EXPORTS MatExpr operator > (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
operator >	core/mat.hpp	/^CV_EXPORTS MatExpr operator > (double s, const Mat& a);    $/;"	p	namespace:cv	signature:(double s, const Mat& a)
operator >	core/mat.hpp	/^operator > (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
operator >=	core/mat.hpp	/^CV_EXPORTS MatExpr operator >= (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator >=	core/mat.hpp	/^CV_EXPORTS MatExpr operator >= (const Mat& a, double s);$/;"	p	namespace:cv	signature:(const Mat& a, double s)
operator >=	core/mat.hpp	/^CV_EXPORTS MatExpr operator >= (double s, const Mat& a);$/;"	p	namespace:cv	signature:(double s, const Mat& a)
operator >=	core/mat.hpp	/^operator >= (const MatConstIterator& a, const MatConstIterator& b)$/;"	f	namespace:cv	signature:(const MatConstIterator& a, const MatConstIterator& b)
operator >>	core/operations.hpp	/^FileNodeIterator& operator >> (FileNodeIterator& it, vector<_Tp>& vec)$/;"	f	namespace:cv	signature:(FileNodeIterator& it, vector<_Tp>& vec)
operator >>	core/operations.hpp	/^template<typename _Tp> static inline FileNodeIterator& operator >> (FileNodeIterator& it, _Tp& value)$/;"	f	namespace:cv	signature:(FileNodeIterator& it, _Tp& value)
operator >>	core/operations.hpp	/^template<typename _Tp> static inline void operator >> (const FileNode& n, _Tp& value)$/;"	f	namespace:cv	signature:(const FileNode& n, _Tp& value)
operator >>	core/operations.hpp	/^template<typename _Tp> static inline void operator >> (const FileNode& n, vector<_Tp>& vec)$/;"	f	namespace:cv	signature:(const FileNode& n, vector<_Tp>& vec)
operator >>	highgui/highgui.hpp	/^    virtual VideoCapture& operator >> (CV_OUT Mat& image);$/;"	p	class:cv::VideoCapture	access:public	signature:(CV_OUT Mat& image)
operator Complex<T2>	core/core.hpp	/^    template<typename T2> operator Complex<T2>() const;$/;"	p	class:cv::Complex	access:public	signature:() const
operator Complex<T2>	core/operations.hpp	/^template<typename _Tp> template<typename T2> inline Complex<_Tp>::operator Complex<T2>() const$/;"	f	class:cv::Complex	signature:() const
operator CvBox2D	core/core.hpp	/^    operator CvBox2D() const;$/;"	p	class:cv::RotatedRect	access:public	signature:() const
operator CvBox2D	core/operations.hpp	/^inline RotatedRect::operator CvBox2D() const$/;"	f	class:cv::RotatedRect	signature:() const
operator CvMat	core/core.hpp	/^    operator CvMat() const;$/;"	p	class:cv::Mat	access:public	signature:() const
operator CvMat	core/mat.hpp	/^inline Mat::operator CvMat() const$/;"	f	class:cv::Mat	signature:() const
operator CvMat	core/operations.hpp	/^    operator CvMat() const$/;"	f	class:cv::Vector	access:public	signature:() const
operator CvMat*	legacy/legacy.hpp	/^    operator CvMat* () { return matrix; }$/;"	f	class:CvMatrix	access:public	signature:()
operator CvMatND	core/core.hpp	/^    operator CvMatND() const;$/;"	p	class:cv::Mat	access:public	signature:() const
operator CvMoments	imgproc/imgproc.hpp	/^    operator CvMoments() const;$/;"	p	class:cv::Moments	access:public	signature:() const
operator CvPoint	core/core.hpp	/^    operator CvPoint() const;$/;"	p	class:cv::Point_	access:public	signature:() const
operator CvPoint	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::operator CvPoint() const$/;"	f	class:cv::Point_	signature:() const
operator CvPoint2D32f	core/core.hpp	/^    operator CvPoint2D32f() const;$/;"	p	class:cv::Point_	access:public	signature:() const
operator CvPoint2D32f	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::operator CvPoint2D32f() const$/;"	f	class:cv::Point_	signature:() const
operator CvPoint3D32f	core/core.hpp	/^    operator CvPoint3D32f() const;$/;"	p	class:cv::Point3_	access:public	signature:() const
operator CvPoint3D32f	core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::operator CvPoint3D32f() const$/;"	f	class:cv::Point3_	signature:() const
operator CvRect	core/core.hpp	/^    operator CvRect() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
operator CvRect	core/operations.hpp	/^template<typename _Tp> inline Rect_<_Tp>::operator CvRect() const$/;"	f	class:cv::Rect_	signature:() const
operator CvScalar	core/core.hpp	/^    operator CvScalar() const;$/;"	p	class:cv::Scalar_	access:public	signature:() const
operator CvScalar	core/core.hpp	/^    operator CvScalar() const;$/;"	p	class:cv::Vec	access:public	signature:() const
operator CvScalar	core/operations.hpp	/^template<typename _Tp, int cn> inline Vec<_Tp, cn>::operator CvScalar() const$/;"	f	class:cv::Vec	signature:() const
operator CvScalar	core/operations.hpp	/^template<typename _Tp> inline Scalar_<_Tp>::operator CvScalar() const$/;"	f	class:cv::Scalar_	signature:() const
operator CvSize	core/core.hpp	/^    operator CvSize() const;$/;"	p	class:cv::Size_	access:public	signature:() const
operator CvSize	core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::operator CvSize() const$/;"	f	class:cv::Size_	signature:() const
operator CvSize2D32f	core/core.hpp	/^    operator CvSize2D32f() const;$/;"	p	class:cv::Size_	access:public	signature:() const
operator CvSize2D32f	core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp>::operator CvSize2D32f() const$/;"	f	class:cv::Size_	signature:() const
operator CvSlice	core/core.hpp	/^    operator CvSlice() const;$/;"	p	class:cv::Range	access:public	signature:() const
operator CvSlice	core/operations.hpp	/^inline Range::operator CvSlice() const$/;"	f	class:cv::Range	signature:() const
operator CvSparseMat*	core/core.hpp	/^    operator CvSparseMat*() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
operator CvSparseMat*	core/core.hpp	/^    operator CvSparseMat*() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
operator CvSparseMat*	core/mat.hpp	/^SparseMat_<_Tp>::operator CvSparseMat*() const$/;"	f	class:cv::SparseMat_	signature:() const
operator CvTermCriteria	core/core.hpp	/^    operator CvTermCriteria() const;$/;"	p	class:cv::TermCriteria	access:public	signature:() const
operator CvTermCriteria	core/operations.hpp	/^inline TermCriteria::operator CvTermCriteria() const$/;"	f	class:cv::TermCriteria	signature:() const
operator DevMem2D_<T>	gpu/gpumat.hpp	/^        template <class T> operator DevMem2D_<T>() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
operator DevMem2D_<T>	gpu/gpumat.hpp	/^    template <class T> inline GpuMat::operator DevMem2D_<T>() const { return DevMem2D_<T>(rows, cols, (T*)data, step); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
operator GpuMat	gpu/gpu.hpp	/^            operator GpuMat() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
operator GpuMat	gpu/matrix_operations.hpp	/^inline CudaMem::operator GpuMat() const { return createGpuMatHeader(); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
operator IplImage	core/core.hpp	/^    operator IplImage() const;$/;"	p	class:cv::Mat	access:public	signature:() const
operator IplImage*	legacy/legacy.hpp	/^    operator IplImage* () { return image; }$/;"	f	class:CvImage	access:public	signature:()
operator Mat	core/mat.hpp	/^    operator Mat() const$/;"	f	class:cv::MatExpr	access:public	signature:() const
operator Mat	gpu/gpu.hpp	/^            operator Mat() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
operator Mat	gpu/gpumat.hpp	/^        operator Mat() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
operator Mat	gpu/matrix_operations.hpp	/^inline CudaMem::operator Mat() const { return createMatHeader(); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
operator Mat_<T2>	core/core.hpp	/^    template<typename T2> operator Mat_<T2>() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
operator Mat_<T2>	core/mat.hpp	/^template<typename _Tp> template<typename T2> inline Mat_<_Tp>::operator Mat_<T2>() const$/;"	f	class:cv::Mat_	signature:() const
operator Mat_<_Tp>	core/core.hpp	/^    operator Mat_<_Tp>() const;$/;"	p	class:cv::MatCommaInitializer_	access:public	signature:() const
operator Mat_<_Tp>	core/mat.hpp	/^    template<typename _Tp> operator Mat_<_Tp>() const$/;"	f	class:cv::MatExpr	access:public	signature:() const
operator Mat_<_Tp>	core/mat.hpp	/^template<typename _Tp> inline MatCommaInitializer_<_Tp>::operator Mat_<_Tp>() const$/;"	f	class:cv::MatCommaInitializer_	signature:() const
operator Matx<T2, m, n>	core/core.hpp	/^    template<typename T2> operator Matx<T2, m, n>() const;$/;"	p	class:cv::Matx	access:public	signature:() const
operator Matx<T2, m, n>	core/operations.hpp	/^inline Matx<_Tp, m, n>::operator Matx<T2, m, n>() const$/;"	f	class:cv::Matx	signature:() const
operator Matx<_Tp, m, n>	core/core.hpp	/^    template<typename _Tp, int m, int n> operator Matx<_Tp, m, n>() const;$/;"	p	class:cv::Mat	access:public	signature:() const
operator Matx<_Tp, m, n>	core/mat.hpp	/^template<typename _Tp, int m, int n> inline Mat::operator Matx<_Tp, m, n>() const$/;"	f	class:cv::Mat	signature:() const
operator Matx<typename DataType<_Tp>::channel_type, m, n>	core/core.hpp	/^    template<int m, int n> operator Matx<typename DataType<_Tp>::channel_type, m, n>() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
operator Matx<typename DataType<_Tp>::channel_type, m, n>	core/mat.hpp	/^template<typename _Tp> template<int m, int n> inline Mat_<_Tp>::operator Matx<typename DataType<_Tp>::channel_type, m, n>() const$/;"	f	class:cv::Mat_	signature:() const
operator Point3_<_Tp2>	core/core.hpp	/^    template<typename _Tp2> operator Point3_<_Tp2>() const;$/;"	p	class:cv::Point3_	access:public	signature:() const
operator Point3_<_Tp2>	core/operations.hpp	/^template<typename _Tp> template<typename _Tp2> inline Point3_<_Tp>::operator Point3_<_Tp2>() const$/;"	f	class:cv::Point3_	signature:() const
operator Point_<_Tp2>	core/core.hpp	/^    template<typename _Tp2> operator Point_<_Tp2>() const;$/;"	p	class:cv::Point_	access:public	signature:() const
operator Point_<_Tp2>	core/operations.hpp	/^template<typename _Tp> template<typename _Tp2> inline Point_<_Tp>::operator Point_<_Tp2>() const$/;"	f	class:cv::Point_	signature:() const
operator PtrStep_<T>	gpu/gpumat.hpp	/^        template <class T> operator PtrStep_<T>() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
operator PtrStep_<T>	gpu/gpumat.hpp	/^    template <class T> inline GpuMat::operator PtrStep_<T>() const { return PtrStep_<T>(static_cast< DevMem2D_<T> >(*this)); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
operator Rect_<_Tp2>	core/core.hpp	/^    template<typename _Tp2> operator Rect_<_Tp2>() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
operator Rect_<_Tp2>	core/operations.hpp	/^template<typename _Tp> template<typename _Tp2> inline Rect_<_Tp>::operator Rect_<_Tp2>() const$/;"	f	class:cv::Rect_	signature:() const
operator Scalar_<T2>	core/core.hpp	/^    template<typename T2> operator Scalar_<T2>() const;$/;"	p	class:cv::Scalar_	access:public	signature:() const
operator Scalar_<T2>	core/operations.hpp	/^template<typename _Tp> template<typename T2> inline Scalar_<_Tp>::operator Scalar_<T2>() const$/;"	f	class:cv::Scalar_	signature:() const
operator Size_<_Tp2>	core/core.hpp	/^    template<typename _Tp2> operator Size_<_Tp2>() const;$/;"	p	class:cv::Size_	access:public	signature:() const
operator Size_<_Tp2>	core/operations.hpp	/^template<typename _Tp> template<typename _Tp2> inline Size_<_Tp>::operator Size_<_Tp2>() const$/;"	f	class:cv::Size_	signature:() const
operator T*	gpu/devmem2d.hpp	/^			__CV_GPU_HOST_DEVICE__ operator T*() const { return data; }$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:() const
operator Vec<T2, cn>	core/core.hpp	/^    template<typename T2> operator Vec<T2, cn>() const;$/;"	p	class:cv::Vec	access:public	signature:() const
operator Vec<T2, cn>	core/operations.hpp	/^inline Vec<_Tp, cn>::operator Vec<T2, cn>() const$/;"	f	class:cv::Vec	signature:() const
operator Vec<_Tp, 2>	core/core.hpp	/^    operator Vec<_Tp, 2>() const;$/;"	p	class:cv::Point_	access:public	signature:() const
operator Vec<_Tp, 2>	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp>::operator Vec<_Tp, 2>() const$/;"	f	class:cv::Point_	signature:() const
operator Vec<_Tp, 3>	core/core.hpp	/^    operator Vec<_Tp, 3>() const;$/;"	p	class:cv::Point3_	access:public	signature:() const
operator Vec<_Tp, 3>	core/operations.hpp	/^template<typename _Tp> inline Point3_<_Tp>::operator Vec<_Tp, 3>() const$/;"	f	class:cv::Point3_	signature:() const
operator Vec<_Tp, n>	core/core.hpp	/^    template<typename _Tp, int n> operator Vec<_Tp, n>() const;$/;"	p	class:cv::Mat	access:public	signature:() const
operator Vec<_Tp, n>	core/mat.hpp	/^template<typename _Tp, int n> inline Mat::operator Vec<_Tp, n>() const$/;"	f	class:cv::Mat	signature:() const
operator Vec<typename DataType<_Tp>::channel_type, n>	core/core.hpp	/^    template<int n> operator Vec<typename DataType<_Tp>::channel_type, n>() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
operator Vec<typename DataType<_Tp>::channel_type, n>	core/mat.hpp	/^template<typename _Tp> template<int n> inline Mat_<_Tp>::operator Vec<typename DataType<_Tp>::channel_type, n>() const$/;"	f	class:cv::Mat_	signature:() const
operator []	core/core.hpp	/^        const int& operator[](int i) const;$/;"	p	struct:cv::Mat::MSize	access:public	signature:(int i) const
operator []	core/core.hpp	/^        const size_t& operator[](int i) const;$/;"	p	struct:cv::Mat::MStep	access:public	signature:(int i) const
operator []	core/core.hpp	/^        int& operator[](int i);$/;"	p	struct:cv::Mat::MSize	access:public	signature:(int i)
operator []	core/core.hpp	/^        size_t& operator[](int i);$/;"	p	struct:cv::Mat::MStep	access:public	signature:(int i)
operator []	core/core.hpp	/^    CV_WRAP FileNode operator[](const char* nodename) const;$/;"	p	class:cv::FileNode	access:public	signature:(const char* nodename) const
operator []	core/core.hpp	/^    CV_WRAP FileNode operator[](const char* nodename) const;$/;"	p	class:cv::FileStorage	access:public	signature:(const char* nodename) const
operator []	core/core.hpp	/^    CV_WRAP FileNode operator[](int i) const;$/;"	p	class:cv::FileNode	access:public	signature:(int i) const
operator []	core/core.hpp	/^    FileNode operator[](const string& nodename) const;$/;"	p	class:cv::FileNode	access:public	signature:(const string& nodename) const
operator []	core/core.hpp	/^    FileNode operator[](const string& nodename) const;$/;"	p	class:cv::FileStorage	access:public	signature:(const string& nodename) const
operator []	core/core.hpp	/^    _Tp operator [](ptrdiff_t i) const;$/;"	p	class:cv::MatConstIterator_	access:public	signature:(ptrdiff_t i) const
operator []	core/core.hpp	/^    _Tp& operator [](int idx);$/;"	p	class:cv::Seq	access:public	signature:(int idx)
operator []	core/core.hpp	/^    _Tp& operator [](ptrdiff_t i) const;$/;"	p	class:cv::MatIterator_	access:public	signature:(ptrdiff_t i) const
operator []	core/core.hpp	/^    _Tp& operator[](int i);$/;"	p	class:cv::Vec	access:public	signature:(int i)
operator []	core/core.hpp	/^    _Tp* operator [](int y);$/;"	p	class:cv::Mat_	access:public	signature:(int y)
operator []	core/core.hpp	/^    const _Tp& operator [](int i) const;$/;"	p	class:cv::Vec	access:public	signature:(int i) const
operator []	core/core.hpp	/^    const _Tp& operator[](int idx) const;$/;"	p	class:cv::Seq	access:public	signature:(int idx) const
operator []	core/core.hpp	/^    const _Tp* operator [](int y) const;$/;"	p	class:cv::Mat_	access:public	signature:(int y) const
operator []	core/core.hpp	/^    uchar* operator [](ptrdiff_t i) const;$/;"	p	class:cv::MatConstIterator	access:public	signature:(ptrdiff_t i) const
operator []	core/mat.hpp	/^inline const int& Mat::MSize::operator[](int i) const { return p[i]; }$/;"	f	class:cv::Mat::MSize	signature:(int i) const
operator []	core/mat.hpp	/^inline const size_t& Mat::MStep::operator[](int i) const { return p[i]; }$/;"	f	class:cv::Mat::MStep	signature:(int i) const
operator []	core/mat.hpp	/^inline int& Mat::MSize::operator[](int i) { return p[i]; }$/;"	f	class:cv::Mat::MSize	signature:(int i)
operator []	core/mat.hpp	/^inline size_t& Mat::MStep::operator[](int i) { return p[i]; }$/;"	f	class:cv::Mat::MStep	signature:(int i)
operator []	core/mat.hpp	/^inline uchar* MatConstIterator::operator [](ptrdiff_t i) const$/;"	f	class:cv::MatConstIterator	signature:(ptrdiff_t i) const
operator []	core/mat.hpp	/^template<typename _Tp> inline _Tp MatConstIterator_<_Tp>::operator [](ptrdiff_t i) const$/;"	f	class:cv::MatConstIterator_	signature:(ptrdiff_t i) const
operator []	core/mat.hpp	/^template<typename _Tp> inline _Tp& MatIterator_<_Tp>::operator [](ptrdiff_t i) const$/;"	f	class:cv::MatIterator_	signature:(ptrdiff_t i) const
operator []	core/mat.hpp	/^template<typename _Tp> inline _Tp* Mat_<_Tp>::operator [](int y)$/;"	f	class:cv::Mat_	signature:(int y)
operator []	core/mat.hpp	/^template<typename _Tp> inline const _Tp* Mat_<_Tp>::operator [](int y) const$/;"	f	class:cv::Mat_	signature:(int y) const
operator []	core/operations.hpp	/^    _Tp& operator [] (size_t i) { CV_DbgAssert( i < size() ); return hdr.data[i]; }$/;"	f	class:cv::Vector	access:public	signature:(size_t i)
operator []	core/operations.hpp	/^    const _Tp& operator [] (size_t i) const { CV_DbgAssert( i < size() ); return hdr.data[i]; }$/;"	f	class:cv::Vector	access:public	signature:(size_t i) const
operator []	core/operations.hpp	/^template<typename _Tp, int cn> inline _Tp& Vec<_Tp, cn>::operator [](int i)$/;"	f	class:cv::Vec	signature:(int i)
operator []	core/operations.hpp	/^template<typename _Tp, int cn> inline const _Tp& Vec<_Tp, cn>::operator [](int i) const$/;"	f	class:cv::Vec	signature:(int i) const
operator []	core/operations.hpp	/^template<typename _Tp> inline _Tp& Seq<_Tp>::operator [](int idx)$/;"	f	class:cv::Seq	signature:(int idx)
operator []	core/operations.hpp	/^template<typename _Tp> inline const _Tp& Seq<_Tp>::operator [](int idx) const$/;"	f	class:cv::Seq	signature:(int idx) const
operator []	flann/dist.h	/^    T operator[](int)$/;"	f	struct:cvflann::ZeroIterator	access:public	signature:(int)
operator []	flann/matrix.h	/^    T* operator[](size_t index) const$/;"	f	class:cvflann::Matrix	access:public	signature:(size_t index) const
operator ^	core/mat.hpp	/^CV_EXPORTS MatExpr operator ^ (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator ^	core/mat.hpp	/^CV_EXPORTS MatExpr operator ^ (const Mat& a, const Scalar& s);$/;"	p	namespace:cv	signature:(const Mat& a, const Scalar& s)
operator ^	core/mat.hpp	/^CV_EXPORTS MatExpr operator ^ (const Scalar& s, const Mat& a);$/;"	p	namespace:cv	signature:(const Scalar& s, const Mat& a)
operator ^=	core/mat.hpp	/^operator ^= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
operator ^=	core/mat.hpp	/^operator ^= (const Mat_<_Tp>& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Scalar& s)
operator ^=	core/mat.hpp	/^static inline Mat& operator ^= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
operator ^=	core/mat.hpp	/^static inline Mat& operator ^= (const Mat& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat& a, const Scalar& s)
operator _Tp*	core/core.hpp	/^    operator _Tp* ();$/;"	p	class:cv::AutoBuffer	access:public	signature:()
operator _Tp*	core/core.hpp	/^    operator _Tp* ();$/;"	p	class:cv::Ptr	access:public	signature:()
operator _Tp*	core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::operator _Tp* ()$/;"	f	class:cv::AutoBuffer	signature:()
operator _Tp*	core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::operator _Tp* () { return obj; }$/;"	f	class:cv::Ptr	signature:()
operator bool	gpu/gpu.hpp	/^            operator bool() const;$/;"	p	class:cv::gpu::Stream	access:public	signature:() const
operator const CvMat*	legacy/legacy.hpp	/^    operator const CvMat* () const { return matrix; }$/;"	f	class:CvMatrix	access:public	signature:() const
operator const IplImage*	legacy/legacy.hpp	/^    operator const IplImage* () const { return image; }$/;"	f	class:CvImage	access:public	signature:() const
operator const _Tp*	core/core.hpp	/^    operator const _Tp* () const;$/;"	p	class:cv::AutoBuffer	access:public	signature:() const
operator const _Tp*	core/core.hpp	/^    operator const _Tp*() const;$/;"	p	class:cv::Ptr	access:public	signature:() const
operator const _Tp*	core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::operator const _Tp* () const$/;"	f	class:cv::AutoBuffer	signature:() const
operator const _Tp*	core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::operator const _Tp*() const { return obj; }$/;"	f	class:cv::Ptr	signature:() const
operator const int*	core/core.hpp	/^        operator const int*() const;$/;"	p	struct:cv::Mat::MSize	access:public	signature:() const
operator const int*	core/mat.hpp	/^inline Mat::MSize::operator const int*() const { return p; }$/;"	f	class:cv::Mat::MSize	signature:() const
operator double	core/core.hpp	/^    operator double() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
operator double	core/core.hpp	/^    operator double();$/;"	p	class:cv::RNG	access:public	signature:()
operator double	core/operations.hpp	/^inline FileNode::operator double() const$/;"	f	class:cv::FileNode	signature:() const
operator double	core/operations.hpp	/^inline RNG::operator double()$/;"	f	class:cv::RNG	signature:()
operator float	core/core.hpp	/^    operator float() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
operator float	core/core.hpp	/^    operator float();$/;"	p	class:cv::RNG	access:public	signature:()
operator float	core/operations.hpp	/^inline FileNode::operator float() const$/;"	f	class:cv::FileNode	signature:() const
operator float	core/operations.hpp	/^inline RNG::operator float() { return next()*2.3283064365386962890625e-10f; }$/;"	f	class:cv::RNG	signature:()
operator int	core/core.hpp	/^    operator int() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
operator int	core/core.hpp	/^    operator int();$/;"	p	class:cv::RNG	access:public	signature:()
operator int	core/operations.hpp	/^inline FileNode::operator int() const$/;"	f	class:cv::FileNode	signature:() const
operator int	core/operations.hpp	/^inline RNG::operator int() { return (int)next(); }$/;"	f	class:cv::RNG	signature:()
operator schar	core/core.hpp	/^    operator schar();$/;"	p	class:cv::RNG	access:public	signature:()
operator schar	core/operations.hpp	/^inline RNG::operator schar() { return (schar)next(); }$/;"	f	class:cv::RNG	signature:()
operator short	core/core.hpp	/^    operator short();$/;"	p	class:cv::RNG	access:public	signature:()
operator short	core/operations.hpp	/^inline RNG::operator short() { return (short)next(); }$/;"	f	class:cv::RNG	signature:()
operator size_t	core/core.hpp	/^        operator size_t() const;$/;"	p	struct:cv::Mat::MStep	access:public	signature:() const
operator size_t	core/mat.hpp	/^inline Mat::MStep::operator size_t() const$/;"	f	class:cv::Mat::MStep	signature:() const
operator std::complex<_Tp>	core/core.hpp	/^    operator std::complex<_Tp>() const;$/;"	p	class:cv::Complex	access:public	signature:() const
operator string	core/core.hpp	/^    operator string() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
operator string	core/operations.hpp	/^inline FileNode::operator string() const$/;"	f	class:cv::FileNode	signature:() const
operator uchar	core/core.hpp	/^    operator uchar();$/;"	p	class:cv::RNG	access:public	signature:()
operator uchar	core/operations.hpp	/^inline RNG::operator uchar() { return (uchar)next(); }$/;"	f	class:cv::RNG	signature:()
operator unsigned	core/core.hpp	/^    operator unsigned();$/;"	p	class:cv::RNG	access:public	signature:()
operator unsigned	core/operations.hpp	/^inline RNG::operator unsigned() { return next(); }$/;"	f	class:cv::RNG	signature:()
operator ushort	core/core.hpp	/^    operator ushort();$/;"	p	class:cv::RNG	access:public	signature:()
operator ushort	core/operations.hpp	/^inline RNG::operator ushort() { return (ushort)next(); }$/;"	f	class:cv::RNG	signature:()
operator vector<_Tp>	core/core.hpp	/^    operator vector<_Tp>() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
operator vector<_Tp>	core/core.hpp	/^    operator vector<_Tp>() const;$/;"	p	class:cv::Seq	access:public	signature:() const
operator vector<_Tp>	core/core.hpp	/^    template<typename _Tp> operator vector<_Tp>() const;$/;"	p	class:cv::Mat	access:public	signature:() const
operator vector<_Tp>	core/mat.hpp	/^template<typename _Tp> inline Mat::operator vector<_Tp>() const$/;"	f	class:cv::Mat	signature:() const
operator vector<_Tp>	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp>::operator vector<_Tp>() const$/;"	f	class:cv::Mat_	signature:() const
operator vector<_Tp>	core/operations.hpp	/^template<typename _Tp> inline Seq<_Tp>::operator vector<_Tp>() const$/;"	f	class:cv::Seq	signature:() const
operator |	core/mat.hpp	/^CV_EXPORTS MatExpr operator | (const Mat& a, const Mat& b);$/;"	p	namespace:cv	signature:(const Mat& a, const Mat& b)
operator |	core/mat.hpp	/^CV_EXPORTS MatExpr operator | (const Mat& a, const Scalar& s);$/;"	p	namespace:cv	signature:(const Mat& a, const Scalar& s)
operator |	core/mat.hpp	/^CV_EXPORTS MatExpr operator | (const Scalar& s, const Mat& a);$/;"	p	namespace:cv	signature:(const Scalar& s, const Mat& a)
operator |	core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp> operator | (const Rect_<_Tp>& a, const Rect_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Rect_<_Tp>& a, const Rect_<_Tp>& b)
operator |=	core/mat.hpp	/^operator |= (const Mat_<_Tp>& a, const Mat_<_Tp>& b)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
operator |=	core/mat.hpp	/^operator |= (const Mat_<_Tp>& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat_<_Tp>& a, const Scalar& s)
operator |=	core/mat.hpp	/^static inline Mat& operator |= (const Mat& a, const Mat& b)$/;"	f	namespace:cv	signature:(const Mat& a, const Mat& b)
operator |=	core/mat.hpp	/^static inline Mat& operator |= (const Mat& a, const Scalar& s)$/;"	f	namespace:cv	signature:(const Mat& a, const Scalar& s)
operator |=	core/operations.hpp	/^template<typename _Tp> static inline Rect_<_Tp>& operator |= ( Rect_<_Tp>& a, const Rect_<_Tp>& b )$/;"	f	namespace:cv	signature:( Rect_<_Tp>& a, const Rect_<_Tp>& b )
operator ~	core/mat.hpp	/^CV_EXPORTS MatExpr operator ~(const Mat& m);$/;"	p	namespace:cv	signature:(const Mat& m)
optimize	contrib/contrib.hpp	/^        virtual void optimize(CvMat &_vis); \/\/main function that runs minimization$/;"	p	class:cv::LevMarqSparse	access:public	signature:(CvMat &_vis)
optimize	flann/lsh_table.h	/^    void optimize()$/;"	f	class:cvflann::lsh::LshTable	access:private	signature:()
optimizeKDTree	flann/autotuned_index.h	/^    void optimizeKDTree(std::vector<CostData>& costs)$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:(std::vector<CostData>& costs)
optimizeKMeans	flann/autotuned_index.h	/^    void optimizeKMeans(std::vector<CostData>& costs)$/;"	f	class:cvflann::AutotunedIndex	access:private	signature:(std::vector<CostData>& costs)
optimizeSimplexDownhill	flann/simplex_downhill.h	/^float optimizeSimplexDownhill(T* points, int n, F func, float* vals = NULL )$/;"	f	namespace:cvflann	signature:(T* points, int n, F func, float* vals = NULL )
orb_	features2d/features2d.hpp	/^  mutable ORB orb_;$/;"	m	class:cv::OrbDescriptorExtractor	access:private
orb_	features2d/features2d.hpp	/^  mutable ORB orb_;$/;"	m	class:cv::OrbFeatureDetector	access:private
ord	ml/ml.hpp	/^        ord;$/;"	m	union:CvDTreeSplit::__anon77	typeref:struct:CvDTreeSplit::__anon77::__anon78	access:public
ord_var_count	ml/ml.hpp	/^    int ord_var_count, cat_var_count, work_var_count;$/;"	m	struct:CvDTreeTrainData	access:public
order	flann/dist.h	/^    int order;$/;"	m	struct:cvflann::MinkowskiDistance	access:public
orientation_horizontal_offsets_	features2d/features2d.hpp	/^  std::vector<std::vector<int> > orientation_horizontal_offsets_;$/;"	m	class:cv::ORB	access:private
orientation_vertical_offsets_	features2d/features2d.hpp	/^  std::vector<std::vector<int> > orientation_vertical_offsets_;$/;"	m	class:cv::ORB	access:private
origWinSize	objdetect/objdetect.hpp	/^        Size origWinSize;$/;"	m	class:cv::CascadeClassifier::Data	access:public
orig_response	ml/ml.hpp	/^    CvMat* orig_response;$/;"	m	class:CvBoost	access:protected
orig_response	ml/ml.hpp	/^    CvMat* orig_response;$/;"	m	class:CvGBTrees	access:protected
orig_window_size	objdetect/objdetect.hpp	/^    CvSize orig_window_size;$/;"	m	struct:CvHaarClassifierCascade	access:public
origin	core/types_c.h	/^    CvPoint  origin;$/;"	m	struct:CvChain	access:public
origin	core/types_c.h	/^    int  origin;            \/* 0 - top-left origin,$/;"	m	struct:_IplImage	access:public
origin	legacy/legacy.hpp	/^    int origin() const { return image ? image->origin : 0; }$/;"	f	class:CvImage	access:public	signature:() const
original	objdetect/objdetect.hpp	/^  CvMat *original;$/;"	m	struct:CvDataMatrixCode	access:public
original	objdetect/objdetect.hpp	/^  Mat original;$/;"	m	struct:cv::DataMatrixCode	access:public
original_num_classes	features2d/features2d.hpp	/^  inline int original_num_classes() const { return original_num_classes_; }$/;"	f	class:cv::RTreeClassifier	access:public	signature:() const
original_num_classes_	features2d/features2d.hpp	/^  int original_num_classes_;$/;"	m	class:cv::RTreeClassifier	access:private
other	core/core.hpp	/^    template<typename U> class rebind { typedef Allocator<U> other; };$/;"	t	class:cv::Allocator::rebind	access:private
out	contrib/contrib.hpp	/^        std::ostream* out;$/;"	m	class:cv::SpinImageModel	access:protected
out	gpu/gpu.hpp	/^            GpuMat out;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
out	gpu/gpu.hpp	/^            GpuMat out;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
overlap	features2d/features2d.hpp	/^    static float overlap(const KeyPoint& kp1, const KeyPoint& kp2);$/;"	p	class:cv::KeyPoint	access:public	signature:(const KeyPoint& kp1, const KeyPoint& kp2)
p	core/core.hpp	/^        int* p;$/;"	m	struct:cv::Mat::MSize	access:public
p	core/core.hpp	/^        size_t* p;$/;"	m	struct:cv::Mat::MStep	access:public
p	legacy/legacy.hpp	/^    CvPoint2D32f p; \/\/ pgruebele: So we do not loose precision, this needs to be float$/;"	m	struct:__anon185	access:public
p	legacy/legacy.hpp	/^    CvPoint3D32f p;             \/\/ location of the tracked object$/;"	m	struct:__anon186	access:public
p	ml/ml.hpp	/^    CV_PROP_RW double      p; \/\/ for CV_SVM_EPS_SVR$/;"	m	struct:CvSVMParams	access:public
p1	legacy/legacy.hpp	/^    CvPoint p1;            \/* the first point of the binary tree root segment *\/$/;"	m	struct:CvContourTree	access:public
p2	legacy/legacy.hpp	/^    CvPoint p2;            \/* the last point of the binary tree root segment *\/$/;"	m	struct:CvContourTree	access:public
pBD	legacy/blobtrack.hpp	/^    CvBlobDetector*         pBD;           \/* Selected blob detector module. 					    *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
pBT	legacy/blobtrack.hpp	/^    CvBlobTracker*          pBT;           \/* Selected blob tracking module.					    *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
pBTA	legacy/blobtrack.hpp	/^    CvBlobTrackAnalysis*    pBTA;          \/* Selected blob trajectory analysis module.                             *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
pBTGen	legacy/blobtrack.hpp	/^    CvBlobTrackGen*         pBTGen;        \/* Selected blob trajectory generator.				    *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
pBTPP	legacy/blobtrack.hpp	/^    CvBlobTrackPostProc*    pBTPP;         \/* Selected blob trajectory postprocessing module.			    *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
pBlobSeq	legacy/blobtrack.hpp	/^    CvBlobSeq*  pBlobSeq;$/;"	m	struct:CvBlobTrack	access:public
pComment	legacy/blobtrack.hpp	/^    char*               pComment;$/;"	m	struct:CvDefParam	access:public
pDouble	legacy/blobtrack.hpp	/^    double*             pDouble;$/;"	m	struct:CvDefParam	access:public
pFG	legacy/blobtrack.hpp	/^    CvFGDetector*           pFG;           \/* FGDetector module. If this field is NULL the Process FG mask is used. *\/$/;"	m	struct:CvBlobTrackerAutoParam1	access:public
pFloat	legacy/blobtrack.hpp	/^    float*              pFloat;$/;"	m	struct:CvDefParam	access:public
pInt	legacy/blobtrack.hpp	/^    int*                pInt;$/;"	m	struct:CvDefParam	access:public
pName	legacy/blobtrack.hpp	/^    char*               pName;$/;"	m	struct:CvDefParam	access:public
pStr	legacy/blobtrack.hpp	/^    char**              pStr;$/;"	m	struct:CvDefParam	access:public
packRandomScaledSpins	contrib/contrib.hpp	/^        Mat packRandomScaledSpins(bool separateScale = false, size_t xCount = 10, size_t yCount = 10) const;$/;"	p	class:cv::SpinImageModel	access:public	signature:(bool separateScale = false, size_t xCount = 10, size_t yCount = 10) const
parallel_do	core/internal.hpp	/^        void parallel_do( Iterator first, Iterator last, const Body& body )$/;"	f	namespace:cv	signature:( Iterator first, Iterator last, const Body& body )
parallel_for	core/internal.hpp	/^        static void parallel_for( const BlockedRange& range, const Body& body )$/;"	f	signature:( const BlockedRange& range, const Body& body )
parallel_for	core/internal.hpp	/^        void parallel_for( const BlockedRange& range, const Body& body )$/;"	f	namespace:cv	signature:( const BlockedRange& range, const Body& body )
parallel_reduce	core/internal.hpp	/^        void parallel_reduce( const BlockedRange& range, Body& body )$/;"	f	namespace:cv	signature:( const BlockedRange& range, Body& body )
param	calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> param;$/;"	m	class:CvLevMarq	access:public
param	legacy/compat.hpp	/^    CvScalar  param[2]; \/* parameters of RNG *\/$/;"	m	struct:CvRandState	access:public
params	core/operations.hpp	/^    vector<int> params;$/;"	m	struct:cv::Formatted	access:public
params	features2d/features2d.hpp	/^    Params params;$/;"	m	class:cv::DenseFeatureDetector	access:protected
params	features2d/features2d.hpp	/^    Params params;$/;"	m	class:cv::FernDescriptorMatcher	access:protected
params	features2d/features2d.hpp	/^    Params params;$/;"	m	class:cv::GoodFeaturesToTrackDetector	access:protected
params	features2d/features2d.hpp	/^    Params params;$/;"	m	class:cv::OneWayDescriptorMatcher	access:protected
params	features2d/features2d.hpp	/^  Params params;$/;"	m	class:cv::SimpleBlobDetector	access:protected
params	flann/autotuned_index.h	/^        IndexParams params;$/;"	m	struct:cvflann::AutotunedIndex::CostData	access:public
params	flann/hierarchical_clustering_index.h	/^    IndexParams params;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
params	flann/miniflann.hpp	/^    void* params;$/;"	m	struct:cv::flann::IndexParams	access:public
params	ml/ml.hpp	/^    CvANN_MLP_TrainParams params;$/;"	m	class:CvANN_MLP	access:protected
params	ml/ml.hpp	/^    CvBoostParams params;$/;"	m	class:CvBoost	access:protected
params	ml/ml.hpp	/^    CvDTreeParams params;$/;"	m	struct:CvDTreeTrainData	access:public
params	ml/ml.hpp	/^    CvEMParams params;$/;"	m	class:CvEM	access:protected
params	ml/ml.hpp	/^    CvGBTreesParams params;$/;"	m	class:CvGBTrees	access:protected
params	ml/ml.hpp	/^    CvSVMParams params;$/;"	m	class:CvSVM	access:protected
params	ml/ml.hpp	/^    const CvSVMParams* params;$/;"	m	class:CvSVMSolver	access:public
params	ml/ml.hpp	/^    const CvSVMParams* params;$/;"	m	struct:CvSVMKernel	access:public
params	video/background_segm.hpp	/^    CvFGDStatModelParams   params;$/;"	m	struct:CvFGDStatModel	access:public
params	video/background_segm.hpp	/^    CvGaussBGStatModelParams   params;    $/;"	m	struct:CvGaussBGModel	access:public
params_	features2d/features2d.hpp	/^    CvStarDetectorParams params_; \/\/todo use these instead of thresh_$/;"	m	class:cv::StarAdjuster	access:protected
params_	features2d/features2d.hpp	/^  CommonParams params_;$/;"	m	class:cv::ORB	access:private
params_	features2d/features2d.hpp	/^  ORB::CommonParams params_;$/;"	m	class:cv::OrbDescriptorExtractor	access:private
params_	features2d/features2d.hpp	/^  ORB::CommonParams params_;$/;"	m	class:cv::OrbFeatureDetector	access:private
parent	core/core_c.h	/^CVAPI(CvMemStorage*)  cvCreateChildMemStorage( CvMemStorage* parent );$/;"	v
parent	core/types_c.h	/^    struct  CvMemStorage* parent; \/* We get new blocks from parent as needed. *\/$/;"	m	struct:CvMemStorage	typeref:struct:CvMemStorage::CvMemStorage	access:public
parent	ml/ml.hpp	/^    CvDTreeNode* parent;$/;"	m	struct:CvDTreeNode	access:public
parent	objdetect/objdetect.hpp	/^    int parent;$/;"	m	struct:CvHaarStageClassifier	access:public
partition	core/operations.hpp	/^partition( const vector<_Tp>& _vec, vector<int>& labels,$/;"	f	namespace:cv	signature:( const vector<_Tp>& _vec, vector<int>& labels, _EqPredicate predicate=_EqPredicate())
patchGenerator	features2d/features2d.hpp	/^        PatchGenerator patchGenerator;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
patchSize	features2d/features2d.hpp	/^        Size patchSize;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
patchSize	features2d/features2d.hpp	/^        int patchSize;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
patchSize	features2d/features2d.hpp	/^    Size patchSize;$/;"	m	class:cv::FernClassifier	access:protected
patch_size_	features2d/features2d.hpp	/^    int patch_size_;$/;"	m	struct:cv::ORB::CommonParams	access:protected
patterns_	features2d/features2d.hpp	/^  std::vector<OrbPatterns*> patterns_;$/;"	m	class:cv::ORB	access:private
pcaFilename	features2d/features2d.hpp	/^        string pcaFilename;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
penalization	contrib/contrib.hpp	/^        CV_PROP_RW int		penalization;$/;"	m	class:cv::StereoVar	access:public
perform_morphing	video/background_segm.hpp	/^    int    perform_morphing;	\/* Number of erode-dilate-erode foreground-blob cleanup iterations.						*\/$/;"	m	struct:CvFGDStatModelParams	access:public
perspectiveTransform	core/core.hpp	/^CV_EXPORTS_W void perspectiveTransform(InputArray src, OutputArray dst, InputArray m );$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, InputArray m )
phase	core/core.hpp	/^CV_EXPORTS_W void phase(InputArray x, InputArray y, OutputArray angle,$/;"	p	namespace:cv	signature:(InputArray x, InputArray y, OutputArray angle, bool angleInDegrees=false)
phase	gpu/gpu.hpp	/^        CV_EXPORTS void phase(const GpuMat& x, const GpuMat& y, GpuMat& angle, bool angleInDegrees = false, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& x, const GpuMat& y, GpuMat& angle, bool angleInDegrees = false, Stream& stream = Stream::Null())
phi	features2d/features2d.hpp	/^    float phi;$/;"	m	class:cv::CvAffinePose	access:public
phiMax	features2d/features2d.hpp	/^    double phiMin, phiMax;$/;"	m	class:cv::PatchGenerator	access:public
phiMin	features2d/features2d.hpp	/^    double phiMin, phiMax;$/;"	m	class:cv::PatchGenerator	access:public
pitch	gpu/NCV.hpp	/^    Ncv32u pitch() const {return this->_pitch;}$/;"	f	class:NCVMatrix	access:public	signature:() const
pivot	flann/hierarchical_clustering_index.h	/^        int pivot;$/;"	m	struct:cvflann::HierarchicalClusteringIndex::Node	access:public
pivot	flann/kmeans_index.h	/^        DistanceType* pivot;$/;"	m	struct:cvflann::KMeansIndex::KMeansNode	access:public
pix_size	legacy/legacy.hpp	/^    int pix_size() const { return image ? ((image->depth & 255)>>3)*image->nChannels : 0; }$/;"	f	class:CvImage	access:public	signature:() const
pix_size	legacy/legacy.hpp	/^    int pix_size() const { return matrix ? CV_ELEM_SIZE(matrix->type) : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
pixel_stat	video/background_segm.hpp	/^    CvBGPixelStat*         pixel_stat;$/;"	m	struct:CvFGDStatModel	access:public
planeSplit	flann/kdtree_index.h	/^    void planeSplit(int* ind, int count, int cutfeat, DistanceType cutval, int& lim1, int& lim2)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(int* ind, int count, int cutfeat, DistanceType cutval, int& lim1, int& lim2)
planeSplit	flann/kdtree_single_index.h	/^    void planeSplit(int* ind, int count, int cutfeat, DistanceType cutval, int& lim1, int& lim2)$/;"	f	class:cvflann::KDTreeSingleIndex	access:private	signature:(int* ind, int count, int cutfeat, DistanceType cutval, int& lim1, int& lim2)
planes	core/core.hpp	/^    Mat* planes;$/;"	m	class:cv::NAryMatIterator	access:public
plusDelta	core/core.hpp	/^    int minusDelta, plusDelta;$/;"	m	class:cv::LineIterator	access:public
plusStep	core/core.hpp	/^    int minusStep, plusStep;$/;"	m	class:cv::LineIterator	access:public
plus_delta	core/types_c.h	/^    int  plus_delta;$/;"	m	struct:CvLineIterator	access:public
plus_step	core/types_c.h	/^    int  plus_step;$/;"	m	struct:CvLineIterator	access:public
pointCount	features2d/features2d.hpp	/^        int pointCount;$/;"	m	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:protected
pointPolygonTest	imgproc/imgproc.hpp	/^CV_EXPORTS_W double pointPolygonTest( InputArray contour, Point2f pt, bool measureDist );$/;"	p	namespace:cv	signature:( InputArray contour, Point2f pt, bool measureDist )
pointer	core/core.hpp	/^    typedef _Tp* pointer;$/;"	t	class:cv::MatIterator_	access:public
pointer	core/core.hpp	/^    typedef const _Tp* pointer;$/;"	t	class:cv::MatConstIterator_	access:public
pointer	core/core.hpp	/^    typedef const uchar** pointer;$/;"	t	class:cv::MatConstIterator	access:public
pointer	core/core.hpp	/^    typedef value_type* pointer;$/;"	t	class:cv::Allocator	access:public
points	contrib/contrib.hpp	/^        vector<Point3f> points;$/;"	m	class:cv::Octree	access:private
points	contrib/contrib.hpp	/^    std::vector<CvFuzzyPoint> points;$/;"	m	class:CvFuzzyCurve	access:private
points	core/core.hpp	/^    CV_PROP Mat points; \/\/!< all the points. It can be a reordered copy of the input vector set or the original vector set.$/;"	m	class:cv::KDTree	access:public
points	core/core.hpp	/^    void points(Point2f pts[]) const;$/;"	p	class:cv::RotatedRect	access:public	signature:(Point2f pts[]) const
points	imgproc/imgproc_c.h	/^CVAPI(CvBox2D) cvFitEllipse2( const CvArr* points );$/;"	v
points	legacy/legacy.hpp	/^    CvPoint2D32f* points[MAX_CAMERAS];$/;"	m	class:CvCalibFilter	access:protected
polarToCart	core/core.hpp	/^CV_EXPORTS_W void polarToCart(InputArray magnitude, InputArray angle,$/;"	p	namespace:cv	signature:(InputArray magnitude, InputArray angle, OutputArray x, OutputArray y, bool angleInDegrees=false)
polarToCart	gpu/gpu.hpp	/^        CV_EXPORTS void polarToCart(const GpuMat& magnitude, const GpuMat& angle, GpuMat& x, GpuMat& y, bool angleInDegrees = false, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& magnitude, const GpuMat& angle, GpuMat& x, GpuMat& y, bool angleInDegrees = false, Stream& stream = Stream::Null())
policy	flann/any.h	/^    anyimpl::base_any_policy* policy;$/;"	m	struct:cdiggins::any	access:private
poly_n	contrib/contrib.hpp	/^        CV_PROP_RW int		poly_n;$/;"	m	class:cv::StereoVar	access:public
poly_sigma	contrib/contrib.hpp	/^        CV_PROP_RW double	poly_sigma;$/;"	m	class:cv::StereoVar	access:public
polyfit	contrib/contrib.hpp	/^    CV_EXPORTS void polyfit(const Mat& srcx, const Mat& srcy, Mat& dst, int order);$/;"	p	namespace:cv	signature:(const Mat& srcx, const Mat& srcy, Mat& dst, int order)
polylines	core/core.hpp	/^CV_EXPORTS void polylines(Mat& img, const Point** pts, const int* npts,$/;"	p	namespace:cv	signature:(Mat& img, const Point** pts, const int* npts, int ncontours, bool isClosed, const Scalar& color, int thickness=1, int lineType=8, int shift=0 )
polylines	core/core.hpp	/^CV_EXPORTS_W void polylines(InputOutputArray img, InputArrayOfArrays pts,$/;"	p	namespace:cv	signature:(InputOutputArray img, InputArrayOfArrays pts, bool isClosed, const Scalar& color, int thickness=1, int lineType=8, int shift=0 )
pool	core/core.hpp	/^        vector<uchar> pool;$/;"	m	struct:cv::SparseMat::Hdr	access:public
pool	flann/hierarchical_clustering_index.h	/^    PooledAllocator pool;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
pool_	flann/kdtree_index.h	/^    PooledAllocator pool_;$/;"	m	class:cvflann::KDTreeIndex	access:private
pool_	flann/kdtree_single_index.h	/^    PooledAllocator pool_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
pool_	flann/kmeans_index.h	/^    PooledAllocator pool_;$/;"	m	class:cvflann::KMeansIndex	access:private
popMin	flann/heap.h	/^    bool popMin(T& value)$/;"	f	class:cvflann::Heap	access:public	signature:(T& value)
pop_back	core/core.hpp	/^    void pop_back();$/;"	p	class:cv::Seq	access:public	signature:()
pop_back	core/core.hpp	/^    void pop_back(_Tp* elems, size_t count);$/;"	p	class:cv::Seq	access:public	signature:(_Tp* elems, size_t count)
pop_back	core/core.hpp	/^    void pop_back(size_t nelems=1);$/;"	p	class:cv::Mat	access:public	signature:(size_t nelems=1)
pop_back	core/operations.hpp	/^    Vector<_Tp>& pop_back()$/;"	f	class:cv::Vector	access:public	signature:()
pop_back	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::pop_back()$/;"	f	class:cv::Seq	signature:()
pop_back	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::pop_back(_Tp* elem, size_t count)$/;"	f	class:cv::Seq	signature:(_Tp* elem, size_t count)
pop_front	core/core.hpp	/^    void pop_front();$/;"	p	class:cv::Seq	access:public	signature:()
pop_front	core/core.hpp	/^    void pop_front(_Tp* elems, size_t count);$/;"	p	class:cv::Seq	access:public	signature:(_Tp* elems, size_t count)
pop_front	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::pop_front()$/;"	f	class:cv::Seq	signature:()
pop_front	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::pop_front(_Tp* elem, size_t count)$/;"	f	class:cv::Seq	signature:(_Tp* elem, size_t count)
popcnt32	flann/dist.h	/^    unsigned int popcnt32(uint32_t n) const$/;"	f	struct:cvflann::Hamming2	access:public	signature:(uint32_t n) const
popcnt64	flann/dist.h	/^    unsigned int popcnt64(uint64_t n) const$/;"	f	struct:cvflann::Hamming2	access:public	signature:(uint64_t n) const
portion	ml/ml.hpp	/^        float portion;$/;"	m	union:CvTrainTestSplit::__anon85	access:public
pos	core/core.hpp	/^    Point pos() const;$/;"	p	class:cv::LineIterator	access:public	signature:() const
pos	core/core.hpp	/^    Point pos() const;$/;"	p	class:cv::MatConstIterator	access:public	signature:() const
pos	core/core.hpp	/^    Point pos() const;$/;"	p	class:cv::MatConstIterator_	access:public	signature:() const
pos	core/core.hpp	/^    void pos(int* _idx) const;$/;"	p	class:cv::MatConstIterator	access:public	signature:(int* _idx) const
pos	core/mat.hpp	/^template<typename _Tp> inline Point MatConstIterator_<_Tp>::pos() const$/;"	f	class:cv::MatConstIterator_	signature:() const
pos	core/operations.hpp	/^inline Point LineIterator::pos() const$/;"	f	class:cv::LineIterator	signature:() const
poseCount	features2d/features2d.hpp	/^        int poseCount;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
posit_object	calib3d/calib3d.hpp	/^CVAPI(void)  cvReleasePOSITObject( CvPOSITObject**  posit_object );$/;"	v
posteriors	features2d/features2d.hpp	/^    vector<float> posteriors;$/;"	m	class:cv::FernClassifier	access:protected
posteriors2_	features2d/features2d.hpp	/^  uchar **posteriors2_;     \/\/ 16-bytes aligned posteriors$/;"	m	class:cv::RandomizedTree	access:private
posteriors_	features2d/features2d.hpp	/^  float **posteriors_;        \/\/ 16-bytes aligned posteriors$/;"	m	class:cv::RandomizedTree	access:private
posteriors_	features2d/features2d.hpp	/^  mutable uchar **posteriors_;$/;"	m	class:cv::RTreeClassifier	access:private
pow	core/core.hpp	/^CV_EXPORTS_W void pow(InputArray src, double power, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src, double power, OutputArray dst)
pow	gpu/gpu.hpp	/^        CV_EXPORTS void pow(const GpuMat& src, double power, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, double power, GpuMat& dst, Stream& stream = Stream::Null())
ppFaceTracker	legacy/legacy.hpp	/^CVAPI(void) cvReleaseFaceTracker(CvFaceTracker** ppFaceTracker);$/;"	v
preCornerDetect	imgproc/imgproc.hpp	/^CV_EXPORTS_W void preCornerDetect( InputArray src, OutputArray dst, int ksize,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int ksize, int borderType=BORDER_DEFAULT )
preFilterCap	calib3d/calib3d.hpp	/^    CV_PROP_RW int preFilterCap;$/;"	m	class:cv::StereoSGBM	access:public
preFilterCap	calib3d/calib3d.hpp	/^    int preFilterCap; \/\/ the output of pre-filtering is clipped by [-preFilterCap,preFilterCap]$/;"	m	struct:CvStereoBMState	access:public
preFilterSize	calib3d/calib3d.hpp	/^    int preFilterSize; \/\/ averaging window size: ~5x5..21x21$/;"	m	struct:CvStereoBMState	access:public
preFilterType	calib3d/calib3d.hpp	/^    int preFilterType; \/\/ =CV_STEREO_BM_NORMALIZED_RESPONSE now$/;"	m	struct:CvStereoBMState	access:public
preFilteredImg0	calib3d/calib3d.hpp	/^    CvMat* preFilteredImg0;$/;"	m	struct:CvStereoBMState	access:public
preFilteredImg1	calib3d/calib3d.hpp	/^    CvMat* preFilteredImg1;$/;"	m	struct:CvStereoBMState	access:public
predict	ml/ml.hpp	/^    CV_WRAP virtual CvDTreeNode* predict( const cv::Mat& sample, const cv::Mat& missingDataMask=cv::Mat(),$/;"	p	class:CvDTree	access:public	signature:( const cv::Mat& sample, const cv::Mat& missingDataMask=cv::Mat(), bool preprocessedInput=false ) const
predict	ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& inputs, cv::Mat& outputs ) const;$/;"	p	class:CvANN_MLP	access:public	signature:( const cv::Mat& inputs, cv::Mat& outputs ) const
predict	ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& sample, CV_OUT cv::Mat* probs=0 ) const;$/;"	p	class:CvEM	access:public	signature:( const cv::Mat& sample, CV_OUT cv::Mat* probs=0 ) const
predict	ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& sample, bool returnDFVal=false ) const;$/;"	p	class:CvSVM	access:public	signature:( const cv::Mat& sample, bool returnDFVal=false ) const
predict	ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& sample, const cv::Mat& missing = cv::Mat() ) const;$/;"	p	class:CvRTrees	access:public	signature:( const cv::Mat& sample, const cv::Mat& missing = cv::Mat() ) const
predict	ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& sample, const cv::Mat& missing=cv::Mat(),$/;"	p	class:CvBoost	access:public	signature:( const cv::Mat& sample, const cv::Mat& missing=cv::Mat(), const cv::Range& slice=cv::Range::all(), bool rawMode=false, bool returnSum=false ) const
predict	ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& sample, const cv::Mat& missing=cv::Mat(),$/;"	p	class:CvGBTrees	access:public	signature:( const cv::Mat& sample, const cv::Mat& missing=cv::Mat(), const cv::Range& slice = cv::Range::all(), int k=-1 ) const
predict	ml/ml.hpp	/^    CV_WRAP virtual float predict( const cv::Mat& samples, CV_OUT cv::Mat* results=0 ) const;$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const cv::Mat& samples, CV_OUT cv::Mat* results=0 ) const
predict	ml/ml.hpp	/^    virtual CvDTreeNode* predict( const CvMat* sample, const CvMat* missingDataMask=0,$/;"	p	class:CvDTree	access:public	signature:( const CvMat* sample, const CvMat* missingDataMask=0, bool preprocessedInput=false ) const
predict	ml/ml.hpp	/^    virtual float predict( const CvMat* inputs, CV_OUT CvMat* outputs ) const;$/;"	p	class:CvANN_MLP	access:public	signature:( const CvMat* inputs, CV_OUT CvMat* outputs ) const
predict	ml/ml.hpp	/^    virtual float predict( const CvMat* sample, CV_OUT CvMat* probs ) const;$/;"	p	class:CvEM	access:public	signature:( const CvMat* sample, CV_OUT CvMat* probs ) const
predict	ml/ml.hpp	/^    virtual float predict( const CvMat* sample, bool returnDFVal=false ) const;$/;"	p	class:CvSVM	access:public	signature:( const CvMat* sample, bool returnDFVal=false ) const
predict	ml/ml.hpp	/^    virtual float predict( const CvMat* sample, const CvMat* missing = 0 ) const;$/;"	p	class:CvRTrees	access:public	signature:( const CvMat* sample, const CvMat* missing = 0 ) const
predict	ml/ml.hpp	/^    virtual float predict( const CvMat* sample, const CvMat* missing=0,$/;"	p	class:CvBoost	access:public	signature:( const CvMat* sample, const CvMat* missing=0, CvMat* weak_responses=0, CvSlice slice=CV_WHOLE_SEQ, bool raw_mode=false, bool return_sum=false ) const
predict	ml/ml.hpp	/^    virtual float predict( const CvMat* sample, const CvMat* missing=0,$/;"	p	class:CvGBTrees	access:public	signature:( const CvMat* sample, const CvMat* missing=0, CvMat* weakResponses=0, CvSlice slice = CV_WHOLE_SEQ, int k=-1 ) const
predict	ml/ml.hpp	/^    virtual float predict( const CvMat* samples, CV_OUT CvMat* results=0 ) const;$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const CvMat* samples, CV_OUT CvMat* results=0 ) const
predict	ml/ml.hpp	/^    virtual float predict( const CvMat* samples, CvMat* results ) const;$/;"	p	class:CvSVM	access:public	signature:( const CvMat* samples, CvMat* results ) const
predict	ml/ml.hpp	/^    virtual float predict( const float* row_sample, int row_len, bool returnDFVal=false ) const;$/;"	p	class:CvSVM	access:protected	signature:( const float* row_sample, int row_len, bool returnDFVal=false ) const
predict	video/tracking.hpp	/^    CV_WRAP const Mat& predict(const Mat& control=Mat());$/;"	p	class:cv::KalmanFilter	access:public	signature:(const Mat& control=Mat())
predictCategorical	objdetect/objdetect.hpp	/^    friend int predictCategorical( CascadeClassifier& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight);$/;"	p	class:cv::CascadeClassifier	access:friend	signature:( CascadeClassifier& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight)
predictCategoricalStump	objdetect/objdetect.hpp	/^    friend int predictCategoricalStump( CascadeClassifier& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight);$/;"	p	class:cv::CascadeClassifier	access:friend	signature:( CascadeClassifier& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight)
predictOrdered	objdetect/objdetect.hpp	/^    friend int predictOrdered( CascadeClassifier& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight);$/;"	p	class:cv::CascadeClassifier	access:friend	signature:( CascadeClassifier& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight)
predictOrderedStump	objdetect/objdetect.hpp	/^    friend int predictOrderedStump( CascadeClassifier& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight);$/;"	p	class:cv::CascadeClassifier	access:friend	signature:( CascadeClassifier& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight)
predict_prob	ml/ml.hpp	/^    CV_WRAP virtual float predict_prob( const cv::Mat& sample, const cv::Mat& missing = cv::Mat() ) const;$/;"	p	class:CvRTrees	access:public	signature:( const cv::Mat& sample, const cv::Mat& missing = cv::Mat() ) const
predict_prob	ml/ml.hpp	/^    virtual float predict_prob( const CvMat* sample, const CvMat* missing = 0 ) const;$/;"	p	class:CvRTrees	access:public	signature:( const CvMat* sample, const CvMat* missing = 0 ) const
predict_serial	ml/ml.hpp	/^    virtual float predict_serial( const CvMat* sample, const CvMat* missing=0,$/;"	p	class:CvGBTrees	access:public	signature:( const CvMat* sample, const CvMat* missing=0, CvMat* weakResponses=0, CvSlice slice = CV_WHOLE_SEQ, int k=-1 ) const
prepare	features2d/features2d.hpp	/^    virtual void prepare(int _nclasses, int _patchSize, int _signatureSize,$/;"	p	class:cv::FernClassifier	access:protected	signature:(int _nclasses, int _patchSize, int _signatureSize, int _nstructs, int _structSize, int _nviews, int _compressionMethod)
prepare_to_train	ml/ml.hpp	/^    virtual bool prepare_to_train( const CvMat* _inputs, const CvMat* _outputs,$/;"	p	class:CvANN_MLP	access:protected	signature:( const CvMat* _inputs, const CvMat* _outputs, const CvMat* _sample_weights, const CvMat* sampleIdx, CvVectors* _ivecs, CvVectors* _ovecs, double** _sw, int _flags )
preset	gpu/gpu.hpp	/^            int preset;$/;"	m	class:cv::gpu::StereoBM_GPU	access:public
prev	core/types_c.h	/^    struct CvMemBlock*  prev;$/;"	m	struct:CvMemBlock	typeref:struct:CvMemBlock::CvMemBlock	access:public
prev	core/types_c.h	/^    struct CvSeqBlock*  prev; \/* Previous sequence block.                   *\/$/;"	m	struct:CvSeqBlock	typeref:struct:CvSeqBlock::CvSeqBlock	access:public
prev	core/types_c.h	/^    struct CvTypeInfo* prev;$/;"	m	struct:CvTypeInfo	typeref:struct:CvTypeInfo::CvTypeInfo	access:public
prev	ml/ml.hpp	/^    CvSVMKernelRow* prev;$/;"	m	struct:CvSVMKernelRow	access:public
prevErrNorm	calib3d/calib3d.hpp	/^    double prevErrNorm, errNorm;$/;"	m	class:CvLevMarq	access:public
prevErrNorm	contrib/contrib.hpp	/^        double prevErrNorm, errNorm;$/;"	m	class:cv::LevMarqSparse	access:public
prevP	contrib/contrib.hpp	/^        CvMat* prevP; \/\/current already accepted parameter. $/;"	m	class:cv::LevMarqSparse	access:public
prevParam	calib3d/calib3d.hpp	/^    cv::Ptr<CvMat> prevParam;$/;"	m	class:CvLevMarq	access:public
prevTrainCount	features2d/features2d.hpp	/^    int prevTrainCount;$/;"	m	class:cv::FernDescriptorMatcher	access:protected
prevTrainCount	features2d/features2d.hpp	/^    int prevTrainCount;$/;"	m	class:cv::OneWayDescriptorMatcher	access:protected
prev_frame	video/background_segm.hpp	/^    IplImage*              prev_frame;$/;"	m	struct:CvFGDStatModel	access:public
principal_point	legacy/legacy.hpp	/^    CvPoint2D32f principal_point; \/* copied from intrinsics so this structure *\/$/;"	m	struct:__anon187	access:public
principal_point	legacy/legacy.hpp	/^    CvPoint2D32f principal_point;$/;"	m	struct:__anon188	access:public
print	flann/any.h	/^    virtual void print(std::ostream& out, void* const* src) = 0;$/;"	p	struct:cdiggins::anyimpl::base_any_policy	access:public	signature:(std::ostream& out, void* const* src)
print	flann/any.h	/^    virtual void print(std::ostream& out, void* const* src) { out << *reinterpret_cast<T const*>(*src); }$/;"	f	struct:cdiggins::anyimpl::big_any_policy	access:public	signature:(std::ostream& out, void* const* src)
print	flann/any.h	/^    virtual void print(std::ostream& out, void* const* src) { out << *reinterpret_cast<T const*>(src); }$/;"	f	struct:cdiggins::anyimpl::small_any_policy	access:public	signature:(std::ostream& out, void* const* src)
printParams	core/core.hpp	/^    void printParams();$/;"	p	class:cv::CommandLineParser	access:public	signature:()
printSetup	contrib/retina.hpp	/^        const std::string printSetup();$/;"	p	class:cv::Retina	access:public	signature:()
print_params	flann/params.h	/^inline void print_params(const IndexParams& params)$/;"	f	namespace:cvflann	signature:(const IndexParams& params)
priors	ml/ml.hpp	/^    CvMat* priors;$/;"	m	struct:CvDTreeTrainData	access:public
priors	ml/ml.hpp	/^    const float* priors;$/;"	m	struct:CvDTreeParams	access:public
priors_mult	ml/ml.hpp	/^    CvMat* priors_mult;$/;"	m	struct:CvDTreeTrainData	access:public
problem_type	ml/ml.hpp	/^    virtual bool problem_type() const;$/;"	p	class:CvGBTrees	access:protected	signature:() const
probs	ml/ml.hpp	/^    CvMat* probs;$/;"	m	class:CvEM	access:protected
probs	ml/ml.hpp	/^    const CvMat* probs;$/;"	m	struct:CvEMParams	access:public
proceed	imgproc/imgproc.hpp	/^    virtual int proceed(const uchar* src, int srcStep, int srcCount,$/;"	p	class:cv::FilterEngine	access:public	signature:(const uchar* src, int srcStep, int srcCount, uchar* dst, int dstStep)
process	contrib/contrib.hpp	/^    virtual void process(IplImage *inputBGRImage, IplImage *outputHueMask);$/;"	p	class:CvAdaptiveSkinDetector	access:public	signature:(IplImage *inputBGRImage, IplImage *outputHueMask)
process	core/mat.hpp	/^process( const Mat_<T1>& m1, Mat_<T2>& m2, Op op )$/;"	f	namespace:cv	signature:( const Mat_<T1>& m1, Mat_<T2>& m2, Op op )
process	core/mat.hpp	/^process( const Mat_<T1>& m1, const Mat_<T2>& m2, Mat_<T3>& m3, Op op )$/;"	f	namespace:cv	signature:( const Mat_<T1>& m1, const Mat_<T2>& m2, Mat_<T3>& m3, Op op )
processNoiseCov	video/tracking.hpp	/^    Mat processNoiseCov;    \/\/!< process noise covariance matrix (Q)$/;"	m	class:cv::KalmanFilter	access:public
process_noise_cov	video/tracking.hpp	/^    CvMat* process_noise_cov;   \/* process noise covariance matrix (Q) *\/$/;"	m	struct:CvKalman	access:public
productsum	ml/ml.hpp	/^    CvMat** productsum;$/;"	m	class:CvNormalBayesClassifier	access:protected
project	core/core.hpp	/^    Mat project(InputArray vec) const;$/;"	p	class:cv::PCA	access:public	signature:(InputArray vec) const
project	core/core.hpp	/^    void project(InputArray vec, OutputArray result) const;$/;"	p	class:cv::PCA	access:public	signature:(InputArray vec, OutputArray result) const
projectPoints	calib3d/calib3d.hpp	/^CV_EXPORTS_W void projectPoints( InputArray objectPoints,$/;"	p	namespace:cv	signature:( InputArray objectPoints, InputArray rvec, InputArray tvec, InputArray cameraMatrix, InputArray distCoeffs, OutputArray imagePoints, OutputArray jacobian=noArray(), double aspectRatio=0 )
projectPoints	gpu/gpu.hpp	/^        CV_EXPORTS void projectPoints(const GpuMat& src, const Mat& rvec, const Mat& tvec,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, const Mat& rvec, const Mat& tvec, const Mat& camera_mat, const Mat& dist_coef, GpuMat& dst, Stream& stream = Stream::Null())
prune	ml/ml.hpp	/^    CV_WRAP virtual void prune( CvSlice slice );$/;"	p	class:CvBoost	access:public	signature:( CvSlice slice )
prune_cv	ml/ml.hpp	/^    virtual void prune_cv();$/;"	p	class:CvDTree	access:protected	signature:()
pruned_tree_idx	ml/ml.hpp	/^    int pruned_tree_idx;$/;"	m	class:CvDTree	access:public
pt	features2d/features2d.hpp	/^    CV_PROP_RW Point2f pt; \/\/!< coordinates of the keypoints$/;"	m	class:cv::KeyPoint	access:public
pt	features2d/features2d.hpp	/^    CvPoint pt;$/;"	m	struct:CvStarKeypoint	access:public
pt	features2d/features2d.hpp	/^    CvPoint2D32f pt;$/;"	m	struct:CvSURFPoint	access:public
pt	imgproc/imgproc.hpp	/^        Point2f pt;$/;"	m	struct:cv::Subdiv2D::Vertex	access:public
pt	imgproc/imgproc.hpp	/^        int pt[4];$/;"	m	struct:cv::Subdiv2D::QuadEdge	access:public
pt	imgproc/types_c.h	/^    CvPoint   pt;$/;"	m	struct:CvChainPtReader	access:public
ptemp_	features2d/features2d.hpp	/^  mutable unsigned short *ptemp_;$/;"	m	class:cv::RTreeClassifier	access:private
ptr	core/core.hpp	/^    _Tp* ptr;$/;"	m	class:cv::AutoBuffer	access:protected
ptr	core/core.hpp	/^    const uchar* ptr(const int* idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const int* idx) const
ptr	core/core.hpp	/^    const uchar* ptr(int i0, int i1) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1) const
ptr	core/core.hpp	/^    const uchar* ptr(int i0, int i1, int i2) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2) const
ptr	core/core.hpp	/^    const uchar* ptr(int i0=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0=0) const
ptr	core/core.hpp	/^    template<int n> const uchar* ptr(const Vec<int, n>& idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx) const
ptr	core/core.hpp	/^    template<int n> uchar* ptr(const Vec<int, n>& idx);$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx)
ptr	core/core.hpp	/^    template<typename _Tp, int n> _Tp* ptr(const Vec<int, n>& idx);$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx)
ptr	core/core.hpp	/^    template<typename _Tp, int n> const _Tp* ptr(const Vec<int, n>& idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const Vec<int, n>& idx) const
ptr	core/core.hpp	/^    template<typename _Tp> _Tp* ptr(const int* idx);$/;"	p	class:cv::Mat	access:public	signature:(const int* idx)
ptr	core/core.hpp	/^    template<typename _Tp> _Tp* ptr(int i0, int i1);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1)
ptr	core/core.hpp	/^    template<typename _Tp> _Tp* ptr(int i0, int i1, int i2);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2)
ptr	core/core.hpp	/^    template<typename _Tp> _Tp* ptr(int i0=0);$/;"	p	class:cv::Mat	access:public	signature:(int i0=0)
ptr	core/core.hpp	/^    template<typename _Tp> const _Tp* ptr(const int* idx) const;$/;"	p	class:cv::Mat	access:public	signature:(const int* idx) const
ptr	core/core.hpp	/^    template<typename _Tp> const _Tp* ptr(int i0, int i1) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1) const
ptr	core/core.hpp	/^    template<typename _Tp> const _Tp* ptr(int i0, int i1, int i2) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2) const
ptr	core/core.hpp	/^    template<typename _Tp> const _Tp* ptr(int i0=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int i0=0) const
ptr	core/core.hpp	/^    uchar* ptr(const int* idx);$/;"	p	class:cv::Mat	access:public	signature:(const int* idx)
ptr	core/core.hpp	/^    uchar* ptr(const int* idx, bool createMissing, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, bool createMissing, size_t* hashval=0)
ptr	core/core.hpp	/^    uchar* ptr(int i0, bool createMissing, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, bool createMissing, size_t* hashval=0)
ptr	core/core.hpp	/^    uchar* ptr(int i0, int i1);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1)
ptr	core/core.hpp	/^    uchar* ptr(int i0, int i1, bool createMissing, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, bool createMissing, size_t* hashval=0)
ptr	core/core.hpp	/^    uchar* ptr(int i0, int i1, int i2);$/;"	p	class:cv::Mat	access:public	signature:(int i0, int i1, int i2)
ptr	core/core.hpp	/^    uchar* ptr(int i0, int i1, int i2, bool createMissing, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2, bool createMissing, size_t* hashval=0)
ptr	core/core.hpp	/^    uchar* ptr(int i0=0);$/;"	p	class:cv::Mat	access:public	signature:(int i0=0)
ptr	core/core.hpp	/^    uchar* ptr;$/;"	m	class:cv::LineIterator	access:public
ptr	core/core.hpp	/^    uchar* ptr;$/;"	m	class:cv::MatConstIterator	access:public
ptr	core/core.hpp	/^    uchar* ptr;$/;"	m	class:cv::SparseMatConstIterator	access:public
ptr	core/core_c.h	/^    uchar* ptr[CV_MAX_ARR]; \/* pointers to the array slices *\/$/;"	m	struct:CvNArrayIterator	access:public
ptr	core/mat.hpp	/^inline const uchar* Mat::ptr(const int* idx) const$/;"	f	class:cv::Mat	signature:(const int* idx) const
ptr	core/mat.hpp	/^inline const uchar* Mat::ptr(int i0, int i1) const$/;"	f	class:cv::Mat	signature:(int i0, int i1) const
ptr	core/mat.hpp	/^inline const uchar* Mat::ptr(int i0, int i1, int i2) const$/;"	f	class:cv::Mat	signature:(int i0, int i1, int i2) const
ptr	core/mat.hpp	/^inline const uchar* Mat::ptr(int y) const$/;"	f	class:cv::Mat	signature:(int y) const
ptr	core/mat.hpp	/^inline uchar* Mat::ptr(const int* idx)$/;"	f	class:cv::Mat	signature:(const int* idx)
ptr	core/mat.hpp	/^inline uchar* Mat::ptr(int i0, int i1)$/;"	f	class:cv::Mat	signature:(int i0, int i1)
ptr	core/mat.hpp	/^inline uchar* Mat::ptr(int i0, int i1, int i2)$/;"	f	class:cv::Mat	signature:(int i0, int i1, int i2)
ptr	core/mat.hpp	/^inline uchar* Mat::ptr(int y)$/;"	f	class:cv::Mat	signature:(int y)
ptr	core/mat.hpp	/^template<typename _Tp> inline _Tp* Mat::ptr(int i0, int i1)$/;"	f	class:cv::Mat	signature:(int i0, int i1)
ptr	core/mat.hpp	/^template<typename _Tp> inline _Tp* Mat::ptr(int i0, int i1, int i2)$/;"	f	class:cv::Mat	signature:(int i0, int i1, int i2)
ptr	core/mat.hpp	/^template<typename _Tp> inline _Tp* Mat::ptr(int y)$/;"	f	class:cv::Mat	signature:(int y)
ptr	core/mat.hpp	/^template<typename _Tp> inline const _Tp* Mat::ptr(int i0, int i1) const$/;"	f	class:cv::Mat	signature:(int i0, int i1) const
ptr	core/mat.hpp	/^template<typename _Tp> inline const _Tp* Mat::ptr(int i0, int i1, int i2) const$/;"	f	class:cv::Mat	signature:(int i0, int i1, int i2) const
ptr	core/mat.hpp	/^template<typename _Tp> inline const _Tp* Mat::ptr(int y) const$/;"	f	class:cv::Mat	signature:(int y) const
ptr	core/types_c.h	/^        uchar* ptr;$/;"	m	union:CvMat::__anon151	access:public
ptr	core/types_c.h	/^        uchar* ptr;$/;"	m	union:CvMatND::__anon154	access:public
ptr	core/types_c.h	/^    CvPoint2D32f* ptr;$/;"	m	struct:CvGraphVtx2D	access:public
ptr	core/types_c.h	/^    char* ptr;$/;"	m	struct:CvString	access:public
ptr	core/types_c.h	/^    uchar* ptr;$/;"	m	struct:CvLineIterator	access:public
ptr	gpu/NCV.hpp	/^    T *ptr() const {return this->_ptr;}$/;"	f	class:NCVMatrix	access:public	signature:() const
ptr	gpu/NCV.hpp	/^    T *ptr() const {return this->_ptr;}$/;"	f	class:NCVVector	access:public	signature:() const
ptr	gpu/NCV.hpp	/^    void *ptr;$/;"	m	struct:NCVMemPtr	access:public
ptr	gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ T* ptr(int y = 0) { return (T*)( (char*)data + y * step ); }$/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:(int y = 0)
ptr	gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ T* ptr(int y = 0) { return (T*)( (char*)data + y * step); }$/;"	f	struct:cv::gpu::PtrStep_	access:public	signature:(int y = 0)
ptr	gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ T* ptr(int y = 0) { return PtrStep_<T>::data + y * PtrStep_<T>::step; }$/;"	f	struct:cv::gpu::PtrElemStep_	access:public	signature:(int y = 0)
ptr	gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ const T* ptr(int y = 0) const { return (const T*)( (const char*)data + y * step ); }            $/;"	f	struct:cv::gpu::DevMem2D_	access:public	signature:(int y = 0) const
ptr	gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ const T* ptr(int y = 0) const { return (const T*)( (const char*)data + y * step); }$/;"	f	struct:cv::gpu::PtrStep_	access:public	signature:(int y = 0) const
ptr	gpu/devmem2d.hpp	/^            __CV_GPU_HOST_DEVICE__ const T* ptr(int y = 0) const { return PtrStep_<T>::data + y * PtrStep_<T>::step; }                    $/;"	f	struct:cv::gpu::PtrElemStep_	access:public	signature:(int y = 0) const
ptr	gpu/gpumat.hpp	/^        const uchar* ptr(int y = 0) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int y = 0) const
ptr	gpu/gpumat.hpp	/^        template<typename _Tp> _Tp* ptr(int y = 0);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int y = 0)
ptr	gpu/gpumat.hpp	/^        template<typename _Tp> const _Tp* ptr(int y = 0) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int y = 0) const
ptr	gpu/gpumat.hpp	/^        uchar* ptr(int y = 0);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int y = 0)
ptr	gpu/gpumat.hpp	/^    template<typename _Tp> inline _Tp* GpuMat::ptr(int y)$/;"	f	class:cv::gpu::GpuMat	signature:(int y)
ptr	gpu/gpumat.hpp	/^    template<typename _Tp> inline const _Tp* GpuMat::ptr(int y) const$/;"	f	class:cv::gpu::GpuMat	signature:(int y) const
ptr	ml/ml.hpp	/^        uchar** ptr;$/;"	m	union:CvVectors::__anon70	access:public
ptr0	core/core.hpp	/^    const uchar* ptr0;$/;"	m	class:cv::LineIterator	access:public
ptrLeft	calib3d/calib3d.hpp	/^    CvMat* ptrLeft;$/;"	m	struct:CvStereoGCState	access:public
ptrRight	calib3d/calib3d.hpp	/^    CvMat* ptrRight;$/;"	m	struct:CvStereoGCState	access:public
ptrs	core/core.hpp	/^    uchar** ptrs;$/;"	m	class:cv::NAryMatIterator	access:public
push_back	core/core.hpp	/^    template<typename _Tp> void push_back(const Mat_<_Tp>& elem);$/;"	p	class:cv::Mat	access:public	signature:(const Mat_<_Tp>& elem)
push_back	core/core.hpp	/^    template<typename _Tp> void push_back(const _Tp& elem);$/;"	p	class:cv::Mat	access:public	signature:(const _Tp& elem)
push_back	core/core.hpp	/^    void push_back(const Mat& m);$/;"	p	class:cv::Mat	access:public	signature:(const Mat& m)
push_back	core/core.hpp	/^    void push_back(const _Tp& elem);$/;"	p	class:cv::Seq	access:public	signature:(const _Tp& elem)
push_back	core/core.hpp	/^    void push_back(const _Tp* elems, size_t count);$/;"	p	class:cv::Seq	access:public	signature:(const _Tp* elems, size_t count)
push_back	core/mat.hpp	/^template<typename _Tp> inline void Mat::push_back(const Mat_<_Tp>& m)$/;"	f	class:cv::Mat	signature:(const Mat_<_Tp>& m)
push_back	core/mat.hpp	/^template<typename _Tp> inline void Mat::push_back(const _Tp& elem)$/;"	f	class:cv::Mat	signature:(const _Tp& elem)
push_back	core/operations.hpp	/^    Vector<_Tp>& push_back(const _Tp& elem)$/;"	f	class:cv::Vector	access:public	signature:(const _Tp& elem)
push_back	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::push_back(const _Tp& elem)$/;"	f	class:cv::Seq	signature:(const _Tp& elem)
push_back	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::push_back(const _Tp* elem, size_t count)$/;"	f	class:cv::Seq	signature:(const _Tp* elem, size_t count)
push_back_	core/core.hpp	/^    void push_back_(const void* elem);$/;"	p	class:cv::Mat	access:public	signature:(const void* elem)
push_front	core/core.hpp	/^    void push_front(const _Tp& elem);$/;"	p	class:cv::Seq	access:public	signature:(const _Tp& elem)
push_front	core/core.hpp	/^    void push_front(const _Tp* elems, size_t count);$/;"	p	class:cv::Seq	access:public	signature:(const _Tp* elems, size_t count)
push_front	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::push_front(const _Tp& elem)$/;"	f	class:cv::Seq	signature:(const _Tp& elem)
push_front	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::push_front(const _Tp* elem, size_t count)$/;"	f	class:cv::Seq	signature:(const _Tp* elem, size_t count)
putText	core/core.hpp	/^CV_EXPORTS_W void putText( Mat& img, const string& text, Point org,$/;"	p	namespace:cv	signature:( Mat& img, const string& text, Point org, int fontFace, double fontScale, Scalar color, int thickness=1, int linetype=8, bool bottomLeftOrigin=false )
pyrDown	gpu/gpu.hpp	/^            friend void pyrDown(const GpuMat&, GpuMat&, PyrDownBuf&, Stream& stream);$/;"	p	struct:cv::gpu::PyrDownBuf	access:friend	signature:(const GpuMat&, GpuMat&, PyrDownBuf&, Stream& stream)
pyrDown	gpu/gpu.hpp	/^        CV_EXPORTS void pyrDown(const GpuMat& src, GpuMat& dst, PyrDownBuf& buf, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, PyrDownBuf& buf, Stream& stream = Stream::Null())
pyrDown	gpu/gpu.hpp	/^        CV_EXPORTS void pyrDown(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null())
pyrDown	imgproc/imgproc.hpp	/^CV_EXPORTS_W void pyrDown( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, const Size& dstsize=Size())
pyrMeanShiftFiltering	imgproc/imgproc.hpp	/^CV_EXPORTS_W void pyrMeanShiftFiltering( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, double sp, double sr, int maxLevel=1, TermCriteria termcrit=TermCriteria( TermCriteria::MAX_ITER+TermCriteria::EPS,5,1) )
pyrScale	contrib/contrib.hpp	/^        CV_PROP_RW double	pyrScale;$/;"	m	class:cv::StereoVar	access:public
pyrUp	gpu/gpu.hpp	/^            friend void pyrUp(const GpuMat&, GpuMat&, PyrUpBuf&, Stream& stream);$/;"	p	struct:cv::gpu::PyrUpBuf	access:friend	signature:(const GpuMat&, GpuMat&, PyrUpBuf&, Stream& stream)
pyrUp	gpu/gpu.hpp	/^        CV_EXPORTS void pyrUp(const GpuMat& src, GpuMat& dst, PyrUpBuf& buf, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, PyrUpBuf& buf, Stream& stream = Stream::Null())
pyrUp	gpu/gpu.hpp	/^        CV_EXPORTS void pyrUp(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Stream& stream = Stream::Null())
pyrUp	imgproc/imgproc.hpp	/^CV_EXPORTS_W void pyrUp( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, const Size& dstsize=Size())
qangle	gpu/gpu.hpp	/^            GpuMat grad, qangle, grad_buf, qangle_buf;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
qangle_buf	gpu/gpu.hpp	/^            GpuMat grad, qangle, grad_buf, qangle_buf;$/;"	m	struct:cv::gpu::HOGDescriptor	access:protected
qedges	imgproc/imgproc.hpp	/^    vector<QuadEdge> qedges;$/;"	m	class:cv::Subdiv2D	access:protected
quad	legacy/legacy.hpp	/^    CvPoint2D32f quad[2][4]; \/* coordinates of destination quadrangle after$/;"	m	struct:CvStereoCamera	access:public
quality	ml/ml.hpp	/^    float quality;$/;"	m	struct:CvDTreeSplit	access:public
qualityLevel	features2d/features2d.hpp	/^        double qualityLevel;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
quantizeVector	features2d/features2d.hpp	/^  static void quantizeVector(float *src, int dim, int N, float bnds[2], uchar *dst);$/;"	p	class:cv::RandomizedTree	access:public	signature:(float *src, int dim, int N, float bnds[2], uchar *dst)
quantizeVector	features2d/features2d.hpp	/^  static void quantizeVector(float *vec, int dim, int N, float bnds[2], int clamp_mode=0);$/;"	p	class:cv::RandomizedTree	access:public	signature:(float *vec, int dim, int N, float bnds[2], int clamp_mode=0)
query	gpu/gpu.hpp	/^            void query();$/;"	p	class:cv::gpu::DeviceInfo	access:private	signature:()
query	legacy/legacy.hpp	/^    float query( int* bin ) const$/;"	f	class:CvCamShiftTracker	access:public	signature:( int* bin ) const
queryIdx	features2d/features2d.hpp	/^    int queryIdx; \/\/ query descriptor index$/;"	m	struct:cv::DMatch	access:public
queryIfComplete	gpu/gpu.hpp	/^            bool queryIfComplete();$/;"	p	class:cv::gpu::Stream	access:public	signature:()
queryMemory	gpu/gpu.hpp	/^            void queryMemory(size_t& free_memory, size_t& total_memory) const;$/;"	p	class:cv::gpu::DeviceInfo	access:private	signature:(size_t& free_memory, size_t& total_memory) const
r	gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
r	gpu/gpu.hpp	/^            GpuMat u[2], d[2], l[2], r[2];$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
r	ml/ml.hpp	/^    double r;   \/\/ for Solver_NU$/;"	m	struct:CvSVMSolutionInfo	access:public
r	objdetect/objdetect.hpp	/^        CvRect r;$/;"	m	struct:CvHaarFeature::__anon195	access:public
r2	gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
radius	features2d/features2d.hpp	/^      double radius;$/;"	m	struct:cv::SimpleBlobDetector::Center	access:public
radius	features2d/features2d.hpp	/^    int radius;$/;"	m	class:cv::LDetector	access:public
radius	flann/kmeans_index.h	/^        DistanceType radius;$/;"	m	struct:cvflann::KMeansIndex::KMeansNode	access:public
radius	flann/result_set.h	/^    DistanceType radius;$/;"	m	class:cvflann::RadiusResultSet	access:private
radius	gpu/gpu.hpp	/^            int radius;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
radiusMatch	features2d/features2d.hpp	/^    void radiusMatch( const Mat& queryDescriptors, const Mat& trainDescriptors,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, const Mat& trainDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const Mat& mask=Mat(), bool compactResult=false ) const
radiusMatch	features2d/features2d.hpp	/^    void radiusMatch( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance,$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
radiusMatch	features2d/features2d.hpp	/^    void radiusMatch( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, const Mat& trainImage, vector<KeyPoint>& trainKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const Mat& mask=Mat(), bool compactResult=false ) const
radiusMatch	features2d/features2d.hpp	/^    void radiusMatch( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
radiusMatch	gpu/gpu.hpp	/^            void radiusMatch(const GpuMat& queryDescs, const GpuMat& trainDescs,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& queryDescs, const GpuMat& trainDescs, GpuMat& trainIdx, GpuMat& nMatches, GpuMat& distance, float maxDistance, const GpuMat& mask = GpuMat(), Stream& stream = Stream::Null())
radiusMatch	gpu/gpu.hpp	/^            void radiusMatch(const GpuMat& queryDescs, const GpuMat& trainDescs,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& queryDescs, const GpuMat& trainDescs, std::vector< std::vector<DMatch> >& matches, float maxDistance, const GpuMat& mask = GpuMat(), bool compactResult = false)
radiusMatch	gpu/gpu.hpp	/^            void radiusMatch(const GpuMat& queryDescs, std::vector< std::vector<DMatch> >& matches, float maxDistance,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& queryDescs, std::vector< std::vector<DMatch> >& matches, float maxDistance, const std::vector<GpuMat>& masks = std::vector<GpuMat>(), bool compactResult = false)
radiusMatchConvert	gpu/gpu.hpp	/^            static void radiusMatchConvert(const Mat& trainIdx, const Mat& nMatches, const Mat& distance,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const Mat& trainIdx, const Mat& nMatches, const Mat& distance, std::vector< std::vector<DMatch> >& matches, bool compactResult = false)
radiusMatchDownload	gpu/gpu.hpp	/^            static void radiusMatchDownload(const GpuMat& trainIdx, const GpuMat& nMatches, const GpuMat& distance,$/;"	p	class:cv::gpu::BruteForceMatcher_GPU_base	access:public	signature:(const GpuMat& trainIdx, const GpuMat& nMatches, const GpuMat& distance, std::vector< std::vector<DMatch> >& matches, bool compactResult = false)
radiusMatchImpl	features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance,$/;"	p	class:cv::BruteForceMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
radiusMatchImpl	features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance,$/;"	p	class:cv::DescriptorMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
radiusMatchImpl	features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance,$/;"	p	class:cv::FlannBasedMatcher	access:protected	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks=vector<Mat>(), bool compactResult=false )
radiusMatchImpl	features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::FernDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
radiusMatchImpl	features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::GenericDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
radiusMatchImpl	features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::OneWayDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
radiusMatchImpl	features2d/features2d.hpp	/^    virtual void radiusMatchImpl( const Mat& queryImage, vector<KeyPoint>& queryKeypoints,$/;"	p	class:cv::VectorDescriptorMatcher	access:protected	signature:( const Mat& queryImage, vector<KeyPoint>& queryKeypoints, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
radiusMatchImpl	features2d/features2d.hpp	/^void BruteForceMatcher<Distance>::radiusMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches,$/;"	f	class:cv::BruteForceMatcher	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
radiusMatchImpl	features2d/features2d.hpp	/^void BruteForceMatcher<L2<float> >::radiusMatchImpl( const Mat& queryDescriptors, vector<vector<DMatch> >& matches,$/;"	p	class:cv::BruteForceMatcher	signature:( const Mat& queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, const vector<Mat>& masks, bool compactResult )
radiusSearch	flann/flann.hpp	/^	int radiusSearch(const Mat& query, Mat& indices, Mat& dists, DistanceType radius, const ::cvflann::SearchParams& params);$/;"	p	class:cv::flann::Index_	access:public	signature:(const Mat& query, Mat& indices, Mat& dists, DistanceType radius, const ::cvflann::SearchParams& params)
radiusSearch	flann/flann.hpp	/^	int radiusSearch(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, DistanceType radius, const ::cvflann::SearchParams& params);$/;"	p	class:cv::flann::Index_	access:public	signature:(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, DistanceType radius, const ::cvflann::SearchParams& params)
radiusSearch	flann/flann.hpp	/^        int radiusSearch(const Mat& query, Mat& indices, Mat& dists, $/;"	p	class:cv::flann::GenericIndex	access:public	signature:(const Mat& query, Mat& indices, Mat& dists, DistanceType radius, const ::cvflann::SearchParams& params)
radiusSearch	flann/flann.hpp	/^        int radiusSearch(const vector<ElementType>& query, vector<int>& indices, $/;"	p	class:cv::flann::GenericIndex	access:public	signature:(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, DistanceType radius, const ::cvflann::SearchParams& params)
radiusSearch	flann/flann.hpp	/^int GenericIndex<Distance>::radiusSearch(const Mat& query, Mat& indices, Mat& dists, DistanceType radius, const ::cvflann::SearchParams& searchParams)$/;"	f	class:cv::flann::GenericIndex	signature:(const Mat& query, Mat& indices, Mat& dists, DistanceType radius, const ::cvflann::SearchParams& searchParams)
radiusSearch	flann/flann.hpp	/^int GenericIndex<Distance>::radiusSearch(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, DistanceType radius, const ::cvflann::SearchParams& searchParams)$/;"	f	class:cv::flann::GenericIndex	signature:(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, DistanceType radius, const ::cvflann::SearchParams& searchParams)
radiusSearch	flann/flann.hpp	/^int Index_<T>::radiusSearch(const Mat& query, Mat& indices, Mat& dists, DistanceType radius, const ::cvflann::SearchParams& searchParams)$/;"	f	class:cv::flann::Index_	signature:(const Mat& query, Mat& indices, Mat& dists, DistanceType radius, const ::cvflann::SearchParams& searchParams)
radiusSearch	flann/flann.hpp	/^int Index_<T>::radiusSearch(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, DistanceType radius, const ::cvflann::SearchParams& searchParams)$/;"	f	class:cv::flann::Index_	signature:(const vector<ElementType>& query, vector<int>& indices, vector<DistanceType>& dists, DistanceType radius, const ::cvflann::SearchParams& searchParams)
radiusSearch	flann/flann_base.hpp	/^    int radiusSearch(const Matrix<ElementType>& query, Matrix<int>& indices, Matrix<DistanceType>& dists, float radius, const SearchParams& params)$/;"	f	class:cvflann::Index	access:public	signature:(const Matrix<ElementType>& query, Matrix<int>& indices, Matrix<DistanceType>& dists, float radius, const SearchParams& params)
radiusSearch	flann/miniflann.hpp	/^    CV_WRAP virtual int radiusSearch(InputArray query, OutputArray indices,$/;"	p	class:cv::flann::Index	access:public	signature:(InputArray query, OutputArray indices, OutputArray dists, double radius, int maxResults, const SearchParams& params=SearchParams())
radiusSearch	flann/nn_index.h	/^    virtual int radiusSearch(const Matrix<ElementType>& query, Matrix<int>& indices, Matrix<DistanceType>& dists, float radius, const SearchParams& params)$/;"	f	class:cvflann::NNIndex	access:public	signature:(const Matrix<ElementType>& query, Matrix<int>& indices, Matrix<DistanceType>& dists, float radius, const SearchParams& params)
radius_	flann/result_set.h	/^    DistanceType radius_;$/;"	m	class:cvflann::KNNRadiusUniqueResultSet	access:private
randShuffle	core/core.hpp	/^CV_EXPORTS void randShuffle(InputOutputArray dst, double iterFactor=1., RNG* rng=0);$/;"	p	namespace:cv	signature:(InputOutputArray dst, double iterFactor=1., RNG* rng=0)
randShuffle_	core/core.hpp	/^CV_EXPORTS_AS(randShuffle) void randShuffle_(InputOutputArray dst, double iterFactor=1.);$/;"	p	namespace:cv	signature:(InputOutputArray dst, double iterFactor=1.)
rand_double	flann/random.h	/^inline double rand_double(double high = 1.0, double low = 0)$/;"	f	namespace:cvflann	signature:(double high = 1.0, double low = 0)
rand_int	flann/random.h	/^inline int rand_int(int high = RAND_MAX, int low = 0)$/;"	f	namespace:cvflann	signature:(int high = RAND_MAX, int low = 0)
randn	core/core.hpp	/^    static Matx randn(_Tp a, _Tp b);$/;"	p	class:cv::Matx	access:public	signature:(_Tp a, _Tp b)
randn	core/core.hpp	/^CV_EXPORTS_W void randn(InputOutputArray dst, InputArray mean, InputArray stddev);$/;"	p	namespace:cv	signature:(InputOutputArray dst, InputArray mean, InputArray stddev)
randn	core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::randn(_Tp a, _Tp b)$/;"	f	class:cv::Matx	signature:(_Tp a, _Tp b)
randomBlur	features2d/features2d.hpp	/^    bool randomBlur;$/;"	m	class:cv::PatchGenerator	access:public
random_sample	flann/sampling.h	/^Matrix<T> random_sample(Matrix<T>& srcMatrix, long size, bool remove = false)$/;"	f	namespace:cvflann	signature:(Matrix<T>& srcMatrix, long size, bool remove = false)
random_sample	flann/sampling.h	/^Matrix<T> random_sample(const Matrix<T>& srcMatrix, size_t size)$/;"	f	namespace:cvflann	signature:(const Matrix<T>& srcMatrix, size_t size)
randu	core/core.hpp	/^    static Matx randu(_Tp a, _Tp b);$/;"	p	class:cv::Matx	access:public	signature:(_Tp a, _Tp b)
randu	core/core.hpp	/^CV_EXPORTS_W void randu(InputOutputArray dst, InputArray low, InputArray high);$/;"	p	namespace:cv	signature:(InputOutputArray dst, InputArray low, InputArray high)
randu	core/core.hpp	/^template<typename _Tp> static inline _Tp randu() { return (_Tp)theRNG(); }$/;"	f	namespace:cv	signature:()
randu	core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::randu(_Tp a, _Tp b)$/;"	f	class:cv::Matx	signature:(_Tp a, _Tp b)
re	core/core.hpp	/^    _Tp re, im; \/\/< the real and the imaginary parts$/;"	m	class:cv::Complex	access:public
read	core/operations.hpp	/^    static void* read(CvFileStorage* fs, CvFileNode* n)$/;"	f	struct:cv::RTTIImpl	access:public	signature:(CvFileStorage* fs, CvFileNode* n)
read	core/operations.hpp	/^CV_EXPORTS void read(const FileNode& node, SparseMat& mat, const SparseMat& default_mat=SparseMat() );    $/;"	p	namespace:cv	signature:(const FileNode& node, SparseMat& mat, const SparseMat& default_mat=SparseMat() )
read	core/operations.hpp	/^CV_EXPORTS_W void read(const FileNode& node, Mat& mat, const Mat& default_mat=Mat() );$/;"	p	namespace:cv	signature:(const FileNode& node, Mat& mat, const Mat& default_mat=Mat() )
read	core/operations.hpp	/^read( FileNode& node, vector<_Tp>& vec, const vector<_Tp>& default_value=vector<_Tp>() )$/;"	f	namespace:cv	signature:( FileNode& node, vector<_Tp>& vec, const vector<_Tp>& default_value=vector<_Tp>() )
read	core/operations.hpp	/^read( FileNodeIterator& it, vector<_Tp>& vec, size_t maxCount=(size_t)INT_MAX )$/;"	f	namespace:cv	signature:( FileNodeIterator& it, vector<_Tp>& vec, size_t maxCount=(size_t)INT_MAX )
read	core/operations.hpp	/^static inline void read(const FileNode& node, bool& value, bool default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, bool& value, bool default_value)
read	core/operations.hpp	/^static inline void read(const FileNode& node, double& value, double default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, double& value, double default_value)
read	core/operations.hpp	/^static inline void read(const FileNode& node, float& value, float default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, float& value, float default_value)
read	core/operations.hpp	/^static inline void read(const FileNode& node, int& value, int default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, int& value, int default_value)
read	core/operations.hpp	/^static inline void read(const FileNode& node, schar& value, schar default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, schar& value, schar default_value)
read	core/operations.hpp	/^static inline void read(const FileNode& node, short& value, short default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, short& value, short default_value)
read	core/operations.hpp	/^static inline void read(const FileNode& node, string& value, const string& default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, string& value, const string& default_value)
read	core/operations.hpp	/^static inline void read(const FileNode& node, uchar& value, uchar default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, uchar& value, uchar default_value)
read	core/operations.hpp	/^static inline void read(const FileNode& node, ushort& value, ushort default_value)$/;"	f	namespace:cv	signature:(const FileNode& node, ushort& value, ushort default_value)
read	core/types_c.h	/^    CvReadFunc read;$/;"	m	struct:CvTypeInfo	access:public
read	features2d/features2d.hpp	/^        void read( const FileNode& fn );$/;"	p	class:cv::DenseFeatureDetector::Params	access:public	signature:( const FileNode& fn )
read	features2d/features2d.hpp	/^        void read( const FileNode& fn );$/;"	p	class:cv::GoodFeaturesToTrackDetector::Params	access:public	signature:( const FileNode& fn )
read	features2d/features2d.hpp	/^      void read( const FileNode& fn );$/;"	p	struct:cv::SimpleBlobDetector::Params	access:public	signature:( const FileNode& fn )
read	features2d/features2d.hpp	/^    virtual void read( const FileNode &fn );$/;"	p	class:cv::CalonderDescriptorExtractor	access:public	signature:( const FileNode &fn )
read	features2d/features2d.hpp	/^    virtual void read( const FileNode &fn );$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:( const FileNode &fn )
read	features2d/features2d.hpp	/^    virtual void read( const FileNode &fn );$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:( const FileNode &fn )
read	features2d/features2d.hpp	/^    virtual void read( const FileNode &fn );$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:( const FileNode &fn )
read	features2d/features2d.hpp	/^    virtual void read( const FileNode &fn );$/;"	p	class:cv::SurfDescriptorExtractor	access:public	signature:( const FileNode &fn )
read	features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::BriefDescriptorExtractor	access:public	signature:( const FileNode& )
read	features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::DescriptorExtractor	access:public	signature:( const FileNode& )
read	features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( const FileNode& )
read	features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::FeatureDetector	access:public	signature:( const FileNode& )
read	features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:( const FileNode& )
read	features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( const FileNode& )
read	features2d/features2d.hpp	/^    virtual void read( const FileNode& );$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:public	signature:( const FileNode& )
read	features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::DenseFeatureDetector	access:public	signature:( const FileNode& fn )
read	features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::FastFeatureDetector	access:public	signature:( const FileNode& fn )
read	features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::GoodFeaturesToTrackDetector	access:public	signature:( const FileNode& fn )
read	features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::MserFeatureDetector	access:public	signature:( const FileNode& fn )
read	features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::SiftFeatureDetector	access:public	signature:( const FileNode& fn )
read	features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::StarFeatureDetector	access:public	signature:( const FileNode& fn )
read	features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::SurfFeatureDetector	access:public	signature:( const FileNode& fn )
read	features2d/features2d.hpp	/^    virtual void read( const FileNode& fn );$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:( const FileNode& fn )
read	features2d/features2d.hpp	/^    virtual void read(const FileNode& n);$/;"	p	class:cv::FernClassifier	access:public	signature:(const FileNode& n)
read	features2d/features2d.hpp	/^    void read(const FileNode& fn);$/;"	p	struct:cv::ORB::CommonParams	access:public	signature:(const FileNode& fn)
read	features2d/features2d.hpp	/^    void read(const FileNode& node);$/;"	p	class:cv::LDetector	access:public	signature:(const FileNode& node)
read	features2d/features2d.hpp	/^  virtual void read( const FileNode& fn );$/;"	p	class:cv::SimpleBlobDetector	access:public	signature:( const FileNode& fn )
read	features2d/features2d.hpp	/^  virtual void read(const cv::FileNode&);$/;"	p	class:cv::OrbDescriptorExtractor	access:public	signature:(const cv::FileNode&)
read	features2d/features2d.hpp	/^  virtual void read(const cv::FileNode&);$/;"	p	class:cv::OrbFeatureDetector	access:public	signature:(const cv::FileNode&)
read	features2d/features2d.hpp	/^  void read(const char* file_name);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(const char* file_name)
read	features2d/features2d.hpp	/^  void read(const char* file_name, int num_quant_bits);$/;"	p	class:cv::RandomizedTree	access:public	signature:(const char* file_name, int num_quant_bits)
read	features2d/features2d.hpp	/^  void read(std::istream &is);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::istream &is)
read	features2d/features2d.hpp	/^  void read(std::istream &is, int num_quant_bits);$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::istream &is, int num_quant_bits)
read	features2d/features2d.hpp	/^CV_EXPORTS void read(const FileNode& node, CV_OUT vector<KeyPoint>& keypoints);    $/;"	p	namespace:cv	signature:(const FileNode& node, CV_OUT vector<KeyPoint>& keypoints)
read	features2d/features2d.hpp	/^void CalonderDescriptorExtractor<T>::read( const FileNode& )$/;"	f	class:cv::CalonderDescriptorExtractor	signature:( const FileNode& )
read	highgui/highgui.hpp	/^    CV_WRAP virtual bool read(CV_OUT Mat& image);$/;"	p	class:cv::VideoCapture	access:public	signature:(CV_OUT Mat& image)
read	legacy/legacy.hpp	/^    bool read( CvFileStorage* fs, const char* mapname, const char* imgname );$/;"	p	class:CvImage	access:public	signature:( CvFileStorage* fs, const char* mapname, const char* imgname )
read	legacy/legacy.hpp	/^    bool read( CvFileStorage* fs, const char* mapname, const char* matname );$/;"	p	class:CvMatrix	access:public	signature:( CvFileStorage* fs, const char* mapname, const char* matname )
read	legacy/legacy.hpp	/^    bool read( CvFileStorage* fs, const char* seqname, int idx );$/;"	p	class:CvImage	access:public	signature:( CvFileStorage* fs, const char* seqname, int idx )
read	legacy/legacy.hpp	/^    bool read( CvFileStorage* fs, const char* seqname, int idx );$/;"	p	class:CvMatrix	access:public	signature:( CvFileStorage* fs, const char* seqname, int idx )
read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvANN_MLP	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvBoostTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvDTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvEM	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvForestTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvGBTrees	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvRTrees	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node, CvRTrees* forest, CvDTreeTrainData* _data );$/;"	p	class:CvForestTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node, CvRTrees* forest, CvDTreeTrainData* _data )
read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node,$/;"	p	class:CvBoostTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node, CvBoost* ensemble, CvDTreeTrainData* _data )
read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node,$/;"	p	class:CvBoostTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node, CvDTreeTrainData* data )
read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node,$/;"	p	class:CvDTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node, CvDTreeTrainData* data )
read	ml/ml.hpp	/^    virtual void read( CvFileStorage* fs, CvFileNode* node,$/;"	p	class:CvForestTree	access:public	signature:( CvFileStorage* fs, CvFileNode* node, CvDTreeTrainData* data )
read	ml/ml.hpp	/^    virtual void read( CvFileStorage* storage, CvFileNode* node );$/;"	p	class:CvBoost	access:public	signature:( CvFileStorage* storage, CvFileNode* node )
read	ml/ml.hpp	/^    virtual void read( CvFileStorage* storage, CvFileNode* node );$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( CvFileStorage* storage, CvFileNode* node )
read	ml/ml.hpp	/^    virtual void read( CvFileStorage* storage, CvFileNode* node );$/;"	p	class:CvSVM	access:public	signature:( CvFileStorage* storage, CvFileNode* node )
read	ml/ml.hpp	/^    virtual void read( CvFileStorage* storage, CvFileNode* node );$/;"	p	class:CvStatModel	access:public	signature:( CvFileStorage* storage, CvFileNode* node )
read	objdetect/objdetect.hpp	/^        bool read(const FileNode &node);$/;"	p	class:cv::CascadeClassifier::Data	access:public	signature:(const FileNode &node)
read	objdetect/objdetect.hpp	/^    virtual bool read( const FileNode& node );$/;"	p	class:cv::CascadeClassifier	access:public	signature:( const FileNode& node )
read	objdetect/objdetect.hpp	/^    virtual bool read(FileNode& fn);$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(FileNode& fn)
read	objdetect/objdetect.hpp	/^    virtual bool read(const FileNode& node);$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(const FileNode& node)
read	objdetect/objdetect.hpp	/^    void read(const FileNode& node);$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const FileNode& node)
readObj	core/core.hpp	/^    void* readObj() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
readRaw	core/core.hpp	/^    FileNodeIterator& readRaw( const string& fmt, uchar* vec,$/;"	p	class:cv::FileNodeIterator	access:public	signature:( const string& fmt, uchar* vec, size_t maxCount=(size_t)INT_MAX )
readRaw	core/core.hpp	/^    void readRaw( const string& fmt, uchar* vec, size_t len ) const;$/;"	p	class:cv::FileNode	access:public	signature:( const string& fmt, uchar* vec, size_t len ) const
readRaw	core/operations.hpp	/^inline void FileNode::readRaw( const string& fmt, uchar* vec, size_t len ) const$/;"	f	class:cv::FileNode	signature:( const string& fmt, uchar* vec, size_t len ) const
read_csv	ml/ml.hpp	/^    int read_csv( const char* filename );$/;"	p	class:CvMLData	access:public	signature:( const char* filename )
read_node	ml/ml.hpp	/^    virtual CvDTreeNode* read_node( CvFileStorage* fs, CvFileNode* node, CvDTreeNode* parent );$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs, CvFileNode* node, CvDTreeNode* parent )
read_params	ml/ml.hpp	/^    virtual void read_params( CvFileStorage* fs, CvFileNode* fnode );$/;"	p	class:CvGBTrees	access:protected	signature:( CvFileStorage* fs, CvFileNode* fnode )
read_params	ml/ml.hpp	/^    virtual void read_params( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvANN_MLP	access:protected	signature:( CvFileStorage* fs, CvFileNode* node )
read_params	ml/ml.hpp	/^    virtual void read_params( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvBoost	access:protected	signature:( CvFileStorage* fs, CvFileNode* node )
read_params	ml/ml.hpp	/^    virtual void read_params( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvEM	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
read_params	ml/ml.hpp	/^    virtual void read_params( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvSVM	access:protected	signature:( CvFileStorage* fs, CvFileNode* node )
read_params	ml/ml.hpp	/^    virtual void read_params( CvFileStorage* fs, CvFileNode* node );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvFileStorage* fs, CvFileNode* node )
read_split	ml/ml.hpp	/^    virtual CvDTreeSplit* read_split( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs, CvFileNode* node )
read_tree_nodes	ml/ml.hpp	/^    virtual void read_tree_nodes( CvFileStorage* fs, CvFileNode* node );$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs, CvFileNode* node )
reader	core/core.hpp	/^    CvSeqReader reader;$/;"	m	class:cv::FileNodeIterator	access:public
reader	core/core_c.h	/^CVAPI(int)  cvGetSeqReaderPos( CvSeqReader* reader );$/;"	v
reader	imgproc/imgproc_c.h	/^CVAPI(CvPoint) cvReadChainPoint( CvChainPtReader* reader );$/;"	v
real_window_size	objdetect/objdetect.hpp	/^    CvSize real_window_size;$/;"	m	struct:CvHaarClassifierCascade	access:public
rebind	core/core.hpp	/^    template<typename U> class rebind { typedef Allocator<U> other; };$/;"	c	class:cv::Allocator	access:public
recalculateAngles	features2d/features2d.hpp	/^        bool recalculateAngles;$/;"	m	struct:cv::SIFT::DescriptorParams	access:public
recentEdge	imgproc/imgproc.hpp	/^    int recentEdge;$/;"	m	class:cv::Subdiv2D	access:protected
rect	imgproc/types_c.h	/^    CvRect rect;    \/* ROI of the component  *\/$/;"	m	struct:CvConnectedComp	access:public
rect	objdetect/objdetect.hpp	/^	CvRect rect;$/;"	m	struct:CvObjectDetection	access:public
rect	objdetect/objdetect.hpp	/^    CvRect rect;$/;"	m	struct:CvAvgComp	access:public
rect	objdetect/objdetect.hpp	/^    } rect[CV_HAAR_FEATURE_MAX];$/;"	m	struct:CvHaarFeature	typeref:struct:CvHaarFeature::__anon195	access:public
rectMap	legacy/legacy.hpp	/^    CvMat*  rectMap[MAX_CAMERAS][2];$/;"	m	class:CvCalibFilter	access:protected
rectStdDev	gpu/gpu.hpp	/^        CV_EXPORTS void rectStdDev(const GpuMat& src, const GpuMat& sqr, GpuMat& dst, const Rect& rect, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, const GpuMat& sqr, GpuMat& dst, const Rect& rect, Stream& stream = Stream::Null())
rectangle	core/core.hpp	/^CV_EXPORTS void rectangle(Mat& img, Rect rec,$/;"	p	namespace:cv	signature:(Mat& img, Rect rec, const Scalar& color, int thickness=1, int lineType=8, int shift=0)
rectangle	core/core.hpp	/^CV_EXPORTS_W void rectangle(Mat& img, Point pt1, Point pt2,$/;"	p	namespace:cv	signature:(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness=1, int lineType=8, int shift=0)
rectify3Collinear	calib3d/calib3d.hpp	/^CV_EXPORTS_W float rectify3Collinear( InputArray cameraMatrix1, InputArray distCoeffs1,$/;"	p	namespace:cv	signature:( InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, InputArray cameraMatrix3, InputArray distCoeffs3, InputArrayOfArrays imgpt1, InputArrayOfArrays imgpt3, Size imageSize, InputArray R12, InputArray T12, InputArray R13, InputArray T13, OutputArray R1, OutputArray R2, OutputArray R3, OutputArray P1, OutputArray P2, OutputArray P3, OutputArray Q, double alpha, Size newImgSize, CV_OUT Rect* roi1, CV_OUT Rect* roi2, int flags )
redirectError	core/core.hpp	/^CV_EXPORTS ErrorCallback redirectError( ErrorCallback errCallback,$/;"	p	namespace:cv	signature:( ErrorCallback errCallback, void* userdata=0, void** prevUserdata=0)
reduce	core/core.hpp	/^CV_EXPORTS_W void reduce(InputArray src, OutputArray dst, int dim, int rtype, int dtype=-1);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, int dim, int rtype, int dtype=-1)
ref	core/core.hpp	/^    _Tp& ref(const int* idx, size_t* hashval=0);$/;"	p	class:cv::SparseMat_	access:public	signature:(const int* idx, size_t* hashval=0)
ref	core/core.hpp	/^    _Tp& ref(int i0, int i1, int i2, size_t* hashval=0);$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0)
ref	core/core.hpp	/^    _Tp& ref(int i0, int i1, size_t* hashval=0);$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, int i1, size_t* hashval=0)
ref	core/core.hpp	/^    _Tp& ref(int i0, size_t* hashval=0);$/;"	p	class:cv::SparseMat_	access:public	signature:(int i0, size_t* hashval=0)
ref	core/core.hpp	/^    template<typename _Tp> _Tp& ref(const int* idx, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, size_t* hashval=0)
ref	core/core.hpp	/^    template<typename _Tp> _Tp& ref(int i0, int i1, int i2, size_t* hashval=0);$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0)
ref	core/core.hpp	/^    template<typename _Tp> _Tp& ref(int i0, int i1, size_t* hashval=0);   $/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, size_t* hashval=0)
ref	core/core.hpp	/^    template<typename _Tp> _Tp& ref(int i0, size_t* hashval=0);   $/;"	p	class:cv::SparseMat	access:public	signature:(int i0, size_t* hashval=0)
ref	core/mat.hpp	/^SparseMat_<_Tp>::ref(const int* idx, size_t* hashval)$/;"	f	class:cv::SparseMat_	signature:(const int* idx, size_t* hashval)
ref	core/mat.hpp	/^SparseMat_<_Tp>::ref(int i0, int i1, int i2, size_t* hashval)$/;"	f	class:cv::SparseMat_	signature:(int i0, int i1, int i2, size_t* hashval)
ref	core/mat.hpp	/^SparseMat_<_Tp>::ref(int i0, int i1, size_t* hashval)$/;"	f	class:cv::SparseMat_	signature:(int i0, int i1, size_t* hashval)
ref	core/mat.hpp	/^SparseMat_<_Tp>::ref(int i0, size_t* hashval)$/;"	f	class:cv::SparseMat_	signature:(int i0, size_t* hashval)
ref	core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMat::ref(const int* idx, size_t* hashval)$/;"	f	class:cv::SparseMat	signature:(const int* idx, size_t* hashval)
ref	core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMat::ref(int i0, int i1, int i2, size_t* hashval)$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, int i2, size_t* hashval)
ref	core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMat::ref(int i0, int i1, size_t* hashval)$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, size_t* hashval)
ref	core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMat::ref(int i0, size_t* hashval)$/;"	f	class:cv::SparseMat	signature:(int i0, size_t* hashval)
refcount	core/core.hpp	/^        int refcount;$/;"	m	struct:cv::SparseMat::Hdr	access:public
refcount	core/core.hpp	/^    int* refcount; \/\/< the associated reference counter$/;"	m	class:cv::Ptr	access:protected
refcount	core/core.hpp	/^    int* refcount;$/;"	m	class:cv::Mat	access:public
refcount	core/operations.hpp	/^        int* refcount;$/;"	m	struct:cv::Vector::Hdr	access:public
refcount	core/types_c.h	/^    int* refcount;$/;"	m	struct:CvMat	access:public
refcount	core/types_c.h	/^    int* refcount;$/;"	m	struct:CvMatND	access:public
refcount	core/types_c.h	/^    int* refcount;$/;"	m	struct:CvSparseMat	access:public
refcount	gpu/gpu.hpp	/^            int* refcount;$/;"	m	class:cv::gpu::CudaMem	access:public
refcount	gpu/gpumat.hpp	/^        int* refcount;$/;"	m	class:cv::gpu::GpuMat	access:public
refcount	legacy/legacy.hpp	/^    int* refcount;$/;"	m	class:CvImage	access:protected
reference	core/core.hpp	/^    typedef _Tp& reference;$/;"	t	class:cv::MatIterator_	access:public
reference	core/core.hpp	/^    typedef const _Tp& reference;$/;"	t	class:cv::MatConstIterator_	access:public
reference	core/core.hpp	/^    typedef uchar* reference;$/;"	t	class:cv::MatConstIterator	access:public
reference	core/core.hpp	/^    typedef value_type& reference;$/;"	t	class:cv::Allocator	access:public
reference	core/operations.hpp	/^    typedef _Tp& reference;$/;"	t	class:cv::Vector	access:public
registerPageLocked	gpu/gpu.hpp	/^        CV_EXPORTS void registerPageLocked(Mat& m);$/;"	p	namespace:cv::gpu	signature:(Mat& m)
regression	ml/ml.hpp	/^    bool regression;$/;"	m	class:CvKNearest	access:protected
regression_accuracy	ml/ml.hpp	/^    CV_PROP_RW float regression_accuracy;$/;"	m	struct:CvDTreeParams	access:public
release	core/core.hpp	/^    CV_WRAP virtual void release();$/;"	p	class:cv::FileStorage	access:public	signature:()
release	core/core.hpp	/^    virtual void release() const;$/;"	p	class:cv::_OutputArray	access:public	signature:() const
release	core/core.hpp	/^    void release();$/;"	p	class:cv::Mat	access:public	signature:()
release	core/core.hpp	/^    void release();$/;"	p	class:cv::Ptr	access:public	signature:()
release	core/core.hpp	/^    void release();$/;"	p	class:cv::SparseMat	access:public	signature:()
release	core/mat.hpp	/^inline void Mat::release()$/;"	f	class:cv::Mat	signature:()
release	core/mat.hpp	/^inline void SparseMat::release()$/;"	f	class:cv::SparseMat	signature:()
release	core/operations.hpp	/^    static void release(void** dbptr)$/;"	f	struct:cv::RTTIImpl	access:public	signature:(void** dbptr)
release	core/operations.hpp	/^    void release()$/;"	f	class:cv::Vector	access:public	signature:()
release	core/operations.hpp	/^template<typename _Tp> inline void Ptr<_Tp>::release()$/;"	f	class:cv::Ptr	signature:()
release	core/types_c.h	/^    CvReleaseFunc release;$/;"	m	struct:CvTypeInfo	access:public
release	flann/miniflann.hpp	/^    CV_WRAP virtual void release();$/;"	p	class:cv::flann::Index	access:public	signature:()
release	gpu/gpu.hpp	/^            void release();$/;"	p	class:cv::gpu::CascadeClassifier_GPU	access:public	signature:()
release	gpu/gpu.hpp	/^            void release();$/;"	p	class:cv::gpu::CudaMem	access:public	signature:()
release	gpu/gpu.hpp	/^            void release();$/;"	p	class:cv::gpu::Stream	access:private	signature:()
release	gpu/gpu.hpp	/^            void release();$/;"	p	struct:cv::gpu::CannyBuf	access:public	signature:()
release	gpu/gpumat.hpp	/^        void release();$/;"	p	class:cv::gpu::GpuMat	access:public	signature:()
release	highgui/highgui.hpp	/^    CV_WRAP virtual void release();$/;"	p	class:cv::VideoCapture	access:public	signature:()
release	legacy/legacy.hpp	/^    void release() { detach(); }$/;"	f	class:CvImage	access:public	signature:()
release	legacy/legacy.hpp	/^    void release()$/;"	f	class:CvMatrix	access:public	signature:()
releaseMemory	gpu/gpu.hpp	/^            void releaseMemory();$/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:()
remaining	core/core.hpp	/^    size_t remaining;$/;"	m	class:cv::FileNodeIterator	access:public
remaining	flann/allocator.h	/^    int     remaining;  \/* Number of bytes left in current block of storage. *\/$/;"	m	class:cvflann::PooledAllocator	access:private
remainingInputRows	imgproc/imgproc.hpp	/^    int remainingInputRows() const;$/;"	p	class:cv::FilterEngine	access:public	signature:() const
remainingOutputRows	imgproc/imgproc.hpp	/^    int remainingOutputRows() const;$/;"	p	class:cv::FilterEngine	access:public	signature:() const
remap	gpu/gpu.hpp	/^        CV_EXPORTS void remap(const GpuMat& src, GpuMat& dst, const GpuMat& xmap, const GpuMat& ymap);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, const GpuMat& xmap, const GpuMat& ymap)
remap	imgproc/imgproc.hpp	/^CV_EXPORTS_W void remap( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode=BORDER_CONSTANT, const Scalar& borderValue=Scalar())
remove	core/core.hpp	/^    void remove(const Range& r);$/;"	p	class:cv::Seq	access:public	signature:(const Range& r)
remove	core/core.hpp	/^    void remove(int idx);$/;"	p	class:cv::Seq	access:public	signature:(int idx)
remove	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::remove(const Range& r)$/;"	f	class:cv::Seq	signature:(const Range& r)
remove	core/operations.hpp	/^template<typename _Tp> inline void Seq<_Tp>::remove(int idx)$/;"	f	class:cv::Seq	signature:(int idx)
removeBorderKeypoints	features2d/features2d.hpp	/^    static void removeBorderKeypoints( vector<KeyPoint>& keypoints,$/;"	p	class:cv::DescriptorExtractor	access:protected	signature:( vector<KeyPoint>& keypoints, Size imageSize, int borderSize )
removeDuplicated	features2d/features2d.hpp	/^    static void removeDuplicated( vector<KeyPoint>& keypoints );$/;"	p	class:cv::KeyPointsFilter	access:public	signature:( vector<KeyPoint>& keypoints )
removeInvalidPoints	features2d/features2d.hpp	/^    static void removeInvalidPoints( const Mat& mask, vector<KeyPoint>& keypoints );$/;"	p	class:cv::FeatureDetector	access:protected	signature:( const Mat& mask, vector<KeyPoint>& keypoints )
removeNode	core/core.hpp	/^    void removeNode(size_t hidx, size_t nidx, size_t previdx);$/;"	p	class:cv::SparseMat	access:public	signature:(size_t hidx, size_t nidx, size_t previdx)
reorder_	flann/kdtree_single_index.h	/^    bool reorder_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
repackSpinImages	contrib/contrib.hpp	/^        void repackSpinImages(const vector<uchar>& mask, Mat& spinImages, bool reAlloc = true) const;$/;"	p	class:cv::SpinImageModel	access:protected	signature:(const vector<uchar>& mask, Mat& spinImages, bool reAlloc = true) const
repeat	core/core.hpp	/^CV_EXPORTS Mat repeat(const Mat& src, int ny, int nx);$/;"	p	namespace:cv	signature:(const Mat& src, int ny, int nx)
repeat	core/core.hpp	/^CV_EXPORTS_W void repeat(InputArray src, int ny, int nx, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src, int ny, int nx, OutputArray dst)
reprojectImageTo3D	calib3d/calib3d.hpp	/^CV_EXPORTS_W void reprojectImageTo3D( InputArray disparity,$/;"	p	namespace:cv	signature:( InputArray disparity, OutputArray _3dImage, InputArray Q, bool handleMissingValues=false, int ddepth=-1 )
reprojectImageTo3D	gpu/gpu.hpp	/^        CV_EXPORTS void reprojectImageTo3D(const GpuMat& disp, GpuMat& xyzw, const Mat& Q, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& disp, GpuMat& xyzw, const Mat& Q, Stream& stream = Stream::Null())
reserve	core/core.hpp	/^    void reserve(size_t sz);$/;"	p	class:cv::Mat	access:public	signature:(size_t sz)
reserve	core/operations.hpp	/^    void reserve(size_t newCapacity)$/;"	f	class:cv::Vector	access:public	signature:(size_t newCapacity)
reset	contrib/contrib.hpp	/^        void reset();$/;"	p	class:cv::TickMeter	access:public	signature:()
reset	flann/any.h	/^    void reset()$/;"	f	struct:cdiggins::any	access:public	signature:()
reset	flann/dynamic_bitset.h	/^    void reset()$/;"	f	class:DynamicBitset	access:public	signature:()
reset	flann/dynamic_bitset.h	/^    void reset(size_t index)$/;"	f	class:DynamicBitset	access:public	signature:(size_t index)
reset	flann/timer.h	/^    void reset()$/;"	f	class:cvflann::StartStopTimer	access:public	signature:()
reset	imgproc/imgproc.hpp	/^    virtual void reset();$/;"	p	class:cv::BaseColumnFilter	access:public	signature:()
reset	imgproc/imgproc.hpp	/^    virtual void reset();$/;"	p	class:cv::BaseFilter	access:public	signature:()
resetDevice	gpu/gpu.hpp	/^        CV_EXPORTS void resetDevice();$/;"	p	namespace:cv::gpu	signature:()
resetValues	contrib/contrib.hpp	/^    void resetValues();$/;"	p	class:CvFuzzyFunction	access:public	signature:()
reset_block	flann/dynamic_bitset.h	/^    void reset_block(size_t index)$/;"	f	class:DynamicBitset	access:public	signature:(size_t index)
reset_histogram	legacy/legacy.hpp	/^    virtual void  reset_histogram();$/;"	p	class:CvCamShiftTracker	access:public	signature:()
reset_roi	legacy/legacy.hpp	/^    void reset_roi() { cvResetImageROI(image); }$/;"	f	class:CvImage	access:public	signature:()
reshape	core/core.hpp	/^    Mat reshape(int _cn, int _newndims, const int* _newsz) const;$/;"	p	class:cv::Mat	access:public	signature:(int _cn, int _newndims, const int* _newsz) const
reshape	core/core.hpp	/^    Mat reshape(int _cn, int _rows=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int _cn, int _rows=0) const
reshape	core/core.hpp	/^    Mat_ reshape(int _rows) const;$/;"	p	class:cv::Mat_	access:public	signature:(int _rows) const
reshape	core/core.hpp	/^    template<int m1, int n1> Matx<_Tp, m1, n1> reshape() const;$/;"	p	class:cv::Matx	access:public	signature:() const
reshape	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::reshape(int _rows) const$/;"	f	class:cv::Mat_	signature:(int _rows) const
reshape	core/operations.hpp	/^Matx<_Tp, m1, n1> Matx<_Tp, m, n>::reshape() const$/;"	f	class:cv::Matx	signature:() const
reshape	gpu/gpumat.hpp	/^        GpuMat reshape(int cn, int rows = 0) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int cn, int rows = 0) const
resize	core/core.hpp	/^    void resize(size_t sz);$/;"	p	class:cv::Mat	access:public	signature:(size_t sz)
resize	core/core.hpp	/^    void resize(size_t sz, const Scalar& s);$/;"	p	class:cv::Mat	access:public	signature:(size_t sz, const Scalar& s)
resize	core/operations.hpp	/^    void resize(size_t newSize)$/;"	f	class:cv::Vector	access:public	signature:(size_t newSize)
resize	flann/dynamic_bitset.h	/^    void resize(size_t size)$/;"	f	class:DynamicBitset	access:public	signature:(size_t size)
resize	gpu/gpu.hpp	/^        CV_EXPORTS void resize(const GpuMat& src, GpuMat& dst, Size dsize, double fx=0, double fy=0, int interpolation = INTER_LINEAR, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Size dsize, double fx=0, double fy=0, int interpolation = INTER_LINEAR, Stream& stream = Stream::Null())
resize	imgproc/imgproc.hpp	/^CV_EXPORTS_W void resize( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, Size dsize, double fx=0, double fy=0, int interpolation=INTER_LINEAR )
resizeHashTab	core/core.hpp	/^    void resizeHashTab(size_t newsize);$/;"	p	class:cv::SparseMat	access:public	signature:(size_t newsize)
resolution	contrib/contrib.hpp	/^        float resolution;$/;"	m	class:cv::Mesh3D	access:public
response	features2d/features2d.hpp	/^    CV_PROP_RW float response; \/\/!< the response by which the most strong keypoints have been selected. Can be used for the further sorting or subsampling$/;"	m	class:cv::KeyPoint	access:public
response	features2d/features2d.hpp	/^    float response;$/;"	m	struct:CvStarKeypoint	access:public
response	legacy/blobtrack.hpp	/^    float response;$/;"	m	struct:CvDetectedBlob	access:public
responseThreshold	features2d/features2d.hpp	/^    int responseThreshold;$/;"	m	struct:CvStarDetectorParams	access:public
response_idx	ml/ml.hpp	/^    int response_idx;$/;"	m	class:CvMLData	access:protected
response_out	ml/ml.hpp	/^    CvMat* response_out; \/\/ header$/;"	m	class:CvMLData	access:protected
responses	ml/ml.hpp	/^    const CvMat* responses;$/;"	m	struct:CvDTreeTrainData	access:public
responses_copy	ml/ml.hpp	/^    CvMat* responses_copy; \/\/ used in Boosting$/;"	m	struct:CvDTreeTrainData	access:public
result_data	gpu/gpu.hpp	/^            GpuMat image_block, templ_block, result_data;$/;"	m	struct:cv::gpu::ConvolveBuf	access:private
result_size	gpu/gpu.hpp	/^            Size result_size;$/;"	m	struct:cv::gpu::ConvolveBuf	access:private
result_spect	gpu/gpu.hpp	/^            GpuMat image_spect, templ_spect, result_spect;$/;"	m	struct:cv::gpu::ConvolveBuf	access:private
retrieve	highgui/highgui.hpp	/^    CV_WRAP virtual bool retrieve(CV_OUT Mat& image, int channel=0);$/;"	p	class:cv::VideoCapture	access:public	signature:(CV_OUT Mat& image, int channel=0)
rho	ml/ml.hpp	/^    double rho;$/;"	m	struct:CvSVMDecisionFunc	access:public
rho	ml/ml.hpp	/^    double rho;$/;"	m	struct:CvSVMSolutionInfo	access:public
riBuf	gpu/gpu.hpp	/^            GpuMat minSSD, leBuf, riBuf;$/;"	m	class:cv::gpu::StereoBM_GPU	access:private
right	calib3d/calib3d.hpp	/^    CvMat* right;$/;"	m	struct:CvStereoGCState	access:public
right	core/core.hpp	/^        int left, right;$/;"	m	struct:cv::KDTree::Node	access:public
right	flann/kdtree_single_index.h	/^    	int left, right;$/;"	m	struct:cvflann::KDTreeSingleIndex::Node	access:public
right	ml/ml.hpp	/^    CvDTreeNode* right;$/;"	m	struct:CvDTreeNode	access:public
right	objdetect/objdetect.hpp	/^            int right;$/;"	m	struct:cv::CascadeClassifier::Data::DTreeNode	access:public
right	objdetect/objdetect.hpp	/^    int* right;$/;"	m	struct:CvHaarClassifier	access:public
ringBuf	imgproc/imgproc.hpp	/^    vector<uchar> ringBuf;$/;"	m	class:cv::FilterEngine	access:public
rmEdgeDensityFuzzy	contrib/contrib.hpp	/^        rmEdgeDensityFuzzy      = 1,$/;"	e	enum:CvFuzzyMeanShiftTracker::ResizeMethod
rmEdgeDensityLinear	contrib/contrib.hpp	/^        rmEdgeDensityLinear     = 0,$/;"	e	enum:CvFuzzyMeanShiftTracker::ResizeMethod
rmInnerDensity	contrib/contrib.hpp	/^        rmInnerDensity          = 2$/;"	e	enum:CvFuzzyMeanShiftTracker::ResizeMethod
rng	ml/ml.hpp	/^    cv::RNG* rng;$/;"	m	class:CvANN_MLP	access:protected
rng	ml/ml.hpp	/^    cv::RNG* rng;$/;"	m	class:CvGBTrees	access:protected
rng	ml/ml.hpp	/^    cv::RNG* rng;$/;"	m	class:CvMLData	access:protected
rng	ml/ml.hpp	/^    cv::RNG* rng;$/;"	m	class:CvRTrees	access:protected
rng	ml/ml.hpp	/^    cv::RNG* rng;$/;"	m	struct:CvDTreeTrainData	access:public
roi	core/mat.hpp	/^    virtual void roi(const MatExpr& expr, const Range& rowRange,$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, const Range& rowRange, const Range& colRange, MatExpr& res) const
roi	core/types_c.h	/^    struct _IplROI *roi;    \/* Image ROI. If NULL, the whole image is selected. *\/$/;"	m	struct:_IplImage	typeref:struct:_IplImage::_IplROI	access:public
roi	imgproc/imgproc.hpp	/^    Rect roi;$/;"	m	class:cv::FilterEngine	access:public
roi	legacy/legacy.hpp	/^    CvRect roi() const$/;"	f	class:CvImage	access:public	signature:() const
roi1	calib3d/calib3d.hpp	/^    CvRect roi1, roi2;$/;"	m	struct:CvStereoBMState	access:public
roi2	calib3d/calib3d.hpp	/^    CvRect roi1, roi2;$/;"	m	struct:CvStereoBMState	access:public
roi_row	legacy/legacy.hpp	/^    const uchar* roi_row(int y) const$/;"	f	class:CvImage	access:public	signature:(int y) const
roi_row	legacy/legacy.hpp	/^    uchar* roi_row(int y)$/;"	f	class:CvImage	access:public	signature:(int y)
roi_size	legacy/legacy.hpp	/^    CvSize roi_size() const$/;"	f	class:CvImage	access:public	signature:() const
root	core/core.hpp	/^    CV_WRAP FileNode root(int streamidx=0) const;$/;"	p	class:cv::FileStorage	access:public	signature:(int streamidx=0) const
root	flann/hierarchical_clustering_index.h	/^    NodePtr* root;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
root	ml/ml.hpp	/^    CvDTreeNode* root;$/;"	m	class:CvDTree	access:protected
root_	flann/kmeans_index.h	/^    KMeansNodePtr root_;$/;"	m	class:cvflann::KMeansIndex	access:private
root_bbox_	flann/kdtree_single_index.h	/^    BoundingBox root_bbox_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
root_node_	flann/kdtree_single_index.h	/^    NodePtr root_node_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
rotMatr	legacy/legacy.hpp	/^    float   rotMatr[9];$/;"	m	struct:CvCamera	access:public
rotMatrix	legacy/legacy.hpp	/^    float rotMatrix[9];$/;"	m	struct:CvStereoCamera	access:public
rotate	gpu/gpu.hpp	/^        CV_EXPORTS void rotate(const GpuMat& src, GpuMat& dst, Size dsize, double angle, double xShift = 0, double yShift = 0, int interpolation = INTER_LINEAR, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, Size dsize, double angle, double xShift = 0, double yShift = 0, int interpolation = INTER_LINEAR, Stream& stream = Stream::Null())
rotateEdge	imgproc/imgproc.hpp	/^    CV_WRAP int rotateEdge(int edge, int rotate) const;$/;"	p	class:cv::Subdiv2D	access:public	signature:(int edge, int rotate) const
row	core/core.hpp	/^    Mat row(int y) const;$/;"	p	class:cv::Mat	access:public	signature:(int y) const
row	core/core.hpp	/^    Mat_ row(int y) const;$/;"	p	class:cv::Mat_	access:public	signature:(int y) const
row	core/core.hpp	/^    Matx<_Tp, 1, n> row(int i) const;$/;"	p	class:cv::Matx	access:public	signature:(int i) const
row	core/mat.hpp	/^    MatExpr row(int y) const;$/;"	p	class:cv::MatExpr	access:public	signature:(int y) const
row	core/mat.hpp	/^inline Mat Mat::row(int y) const { return Mat(*this, Range(y, y+1), Range::all()); }$/;"	f	class:cv::Mat	signature:(int y) const
row	core/mat.hpp	/^template<typename _Tp> inline Mat_<_Tp> Mat_<_Tp>::row(int y) const$/;"	f	class:cv::Mat_	signature:(int y) const
row	core/operations.hpp	/^Matx<_Tp, 1, n> Matx<_Tp, m, n>::row(int i) const$/;"	f	class:cv::Matx	signature:(int i) const
row	gpu/gpumat.hpp	/^        GpuMat row(int y) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int y) const
row	legacy/legacy.hpp	/^    const uchar* row(int i) const$/;"	f	class:CvMatrix	access:public	signature:(int i) const
row	legacy/legacy.hpp	/^    uchar* row(int i) { return !matrix ? 0 : matrix->data.ptr + i*matrix->step; }$/;"	f	class:CvMatrix	access:public	signature:(int i)
rowBorderType	imgproc/imgproc.hpp	/^    int rowBorderType, columnBorderType;$/;"	m	class:cv::FilterEngine	access:public
rowCount	imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
rowFilter	imgproc/imgproc.hpp	/^    Ptr<BaseRowFilter> rowFilter;$/;"	m	class:cv::FilterEngine	access:public
rowRange	core/core.hpp	/^    Mat rowRange(const Range& r) const;$/;"	p	class:cv::Mat	access:public	signature:(const Range& r) const
rowRange	core/core.hpp	/^    Mat rowRange(int startrow, int endrow) const;$/;"	p	class:cv::Mat	access:public	signature:(int startrow, int endrow) const
rowRange	core/mat.hpp	/^inline Mat Mat::rowRange(const Range& r) const$/;"	f	class:cv::Mat	signature:(const Range& r) const
rowRange	core/mat.hpp	/^inline Mat Mat::rowRange(int startrow, int endrow) const$/;"	f	class:cv::Mat	signature:(int startrow, int endrow) const
rowRange	gpu/gpumat.hpp	/^        GpuMat rowRange(const Range& r) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Range& r) const
rowRange	gpu/gpumat.hpp	/^        GpuMat rowRange(int startrow, int endrow) const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(int startrow, int endrow) const
rows	core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, rows = m, cols = n, channels = rows*cols,$/;"	e	enum:cv::Matx::__anon113
rows	core/core.hpp	/^    int rows, cols;$/;"	m	class:cv::Mat	access:public
rows	core/types_c.h	/^        int rows;$/;"	m	union:CvMat::__anon152	access:public
rows	core/types_c.h	/^    int rows;$/;"	m	struct:CvMat	access:public
rows	flann/matrix.h	/^    size_t rows;$/;"	m	class:cvflann::Matrix	access:public
rows	flann/matrix.h	/^    size_t rows;$/;"	m	class:cvflann::UntypedMatrix	access:public
rows	flann/saving.h	/^    size_t rows;$/;"	m	struct:cvflann::IndexHeader	access:public
rows	gpu/devmem2d.hpp	/^            int rows;$/;"	m	struct:cv::gpu::DevMem2D_	access:public
rows	gpu/gpu.hpp	/^            int rows, cols;$/;"	m	class:cv::gpu::CudaMem	access:public
rows	gpu/gpumat.hpp	/^        int rows, cols;$/;"	m	class:cv::gpu::GpuMat	access:public
rows	imgproc/imgproc.hpp	/^    vector<uchar*> rows;$/;"	m	class:cv::FilterEngine	access:public
rows	legacy/legacy.hpp	/^    int rows() const { return matrix ? matrix->rows : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
rows	ml/ml.hpp	/^    CvSVMKernelRow* rows;$/;"	m	class:CvSVMSolver	access:public
rp_dw0	ml/ml.hpp	/^    CV_PROP_RW double rp_dw0, rp_dw_plus, rp_dw_minus, rp_dw_min, rp_dw_max;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
rp_dw_max	ml/ml.hpp	/^    CV_PROP_RW double rp_dw0, rp_dw_plus, rp_dw_minus, rp_dw_min, rp_dw_max;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
rp_dw_min	ml/ml.hpp	/^    CV_PROP_RW double rp_dw0, rp_dw_plus, rp_dw_minus, rp_dw_min, rp_dw_max;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
rp_dw_minus	ml/ml.hpp	/^    CV_PROP_RW double rp_dw0, rp_dw_plus, rp_dw_minus, rp_dw_min, rp_dw_max;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
rp_dw_plus	ml/ml.hpp	/^    CV_PROP_RW double rp_dw0, rp_dw_plus, rp_dw_minus, rp_dw_min, rp_dw_max;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
rules	contrib/contrib.hpp	/^    std::vector<CvFuzzyRule*> rules;$/;"	m	class:CvFuzzyController	access:private
run	contrib/contrib.hpp	/^        virtual void run( int npoints, \/\/ number of points$/;"	p	class:cv::LevMarqSparse	access:public	signature:( int npoints, int ncameras, int nPointParams, int nCameraParams, int nErrParams, Mat& visibility, Mat& P0, Mat& X, TermCriteria criteria, void (CV_CDECL * fjac)(int i, int j, Mat& point_params, Mat& cam_params, Mat& A, Mat& B, void* data), void (CV_CDECL * func)(int i, int j, Mat& point_params, Mat& cam_params, Mat& estim, void* data), void* data )
run	contrib/retina.hpp	/^        void run(const Mat &inputImage);$/;"	p	class:cv::Retina	access:public	signature:(const Mat &inputImage)
runAt	objdetect/objdetect.hpp	/^    virtual int runAt( Ptr<FeatureEvaluator>&, Point, double& weight );$/;"	p	class:cv::CascadeClassifier	access:protected	signature:( Ptr<FeatureEvaluator>&, Point, double& weight )
runByImageBorder	features2d/features2d.hpp	/^    static void runByImageBorder( vector<KeyPoint>& keypoints, Size imageSize, int borderSize );$/;"	p	class:cv::KeyPointsFilter	access:public	signature:( vector<KeyPoint>& keypoints, Size imageSize, int borderSize )
runByKeypointSize	features2d/features2d.hpp	/^    static void runByKeypointSize( vector<KeyPoint>& keypoints, float minSize, float maxSize=std::numeric_limits<float>::max() );$/;"	p	class:cv::KeyPointsFilter	access:public	signature:( vector<KeyPoint>& keypoints, float minSize, float maxSize=std::numeric_limits<float>::max() )
runByPixelsMask	features2d/features2d.hpp	/^    static void runByPixelsMask( vector<KeyPoint>& keypoints, const Mat& mask );$/;"	p	class:cv::KeyPointsFilter	access:public	signature:( vector<KeyPoint>& keypoints, const Mat& mask )
run_em	ml/ml.hpp	/^    virtual double run_em( const CvVectors& train_data );$/;"	p	class:CvEM	access:protected	signature:( const CvVectors& train_data )
s	core/mat.hpp	/^    Scalar s;$/;"	m	class:cv::MatExpr	access:public
s	core/types_c.h	/^        short* s;$/;"	m	union:CvMat::__anon151	access:public
s	core/types_c.h	/^        short* s;$/;"	m	union:CvMatND::__anon154	access:public
s	legacy/legacy.hpp	/^    int* s; \/\/for selected candidate$/;"	m	struct:CvCliqueFinder	access:public
safeSignatureAlloc	features2d/features2d.hpp	/^  static inline uchar* safeSignatureAlloc(int num_sig=1, int sig_len=176);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(int num_sig=1, int sig_len=176)
safeSignatureAlloc	features2d/features2d.hpp	/^  static inline void safeSignatureAlloc(uchar **sig, int num_sig=1, int sig_len=176);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(uchar **sig, int num_sig=1, int sig_len=176)
sample_count	ml/ml.hpp	/^    int sample_count, var_all, var_count, max_c_count;$/;"	m	struct:CvDTreeTrainData	access:public
sample_count	ml/ml.hpp	/^    int sample_count;$/;"	m	class:CvSVMSolver	access:public
sample_count	ml/ml.hpp	/^    int sample_count;$/;"	m	struct:CvDTreeNode	access:public
sample_fraction_	flann/autotuned_index.h	/^    float sample_fraction_;$/;"	m	class:cvflann::AutotunedIndex	access:private
sample_idx	ml/ml.hpp	/^    CvMat* sample_idx;$/;"	m	class:CvGBTrees	access:protected
sample_idx	ml/ml.hpp	/^    int* sample_idx; \/\/ data of train_sample_idx and test_sample_idx$/;"	m	class:CvMLData	access:protected
sample_weights	ml/ml.hpp	/^    CvMat* sample_weights;$/;"	m	class:CvANN_MLP	access:protected
sampledDataset_	flann/autotuned_index.h	/^    Matrix<ElementType> sampledDataset_;$/;"	m	class:cvflann::AutotunedIndex	access:private
samples	ml/ml.hpp	/^    CvVectors* samples;$/;"	m	class:CvKNearest	access:protected
samples	ml/ml.hpp	/^    const float** samples;$/;"	m	class:CvSVMSolver	access:public
saturate_cast	core/operations.hpp	/^template<> inline int saturate_cast<int>(double v) { return cvRound(v); }$/;"	f	namespace:cv	signature:(double v)
saturate_cast	core/operations.hpp	/^template<> inline int saturate_cast<int>(float v) { return cvRound(v); }$/;"	f	namespace:cv	signature:(float v)
saturate_cast	core/operations.hpp	/^template<> inline schar saturate_cast<schar>(double v)$/;"	f	namespace:cv	signature:(double v)
saturate_cast	core/operations.hpp	/^template<> inline schar saturate_cast<schar>(float v)$/;"	f	namespace:cv	signature:(float v)
saturate_cast	core/operations.hpp	/^template<> inline schar saturate_cast<schar>(int v)$/;"	f	namespace:cv	signature:(int v)
saturate_cast	core/operations.hpp	/^template<> inline schar saturate_cast<schar>(short v)$/;"	f	namespace:cv	signature:(short v)
saturate_cast	core/operations.hpp	/^template<> inline schar saturate_cast<schar>(uchar v)$/;"	f	namespace:cv	signature:(uchar v)
saturate_cast	core/operations.hpp	/^template<> inline schar saturate_cast<schar>(unsigned v)$/;"	f	namespace:cv	signature:(unsigned v)
saturate_cast	core/operations.hpp	/^template<> inline schar saturate_cast<schar>(ushort v)$/;"	f	namespace:cv	signature:(ushort v)
saturate_cast	core/operations.hpp	/^template<> inline short saturate_cast<short>(double v)$/;"	f	namespace:cv	signature:(double v)
saturate_cast	core/operations.hpp	/^template<> inline short saturate_cast<short>(float v)$/;"	f	namespace:cv	signature:(float v)
saturate_cast	core/operations.hpp	/^template<> inline short saturate_cast<short>(int v)$/;"	f	namespace:cv	signature:(int v)
saturate_cast	core/operations.hpp	/^template<> inline short saturate_cast<short>(unsigned v)$/;"	f	namespace:cv	signature:(unsigned v)
saturate_cast	core/operations.hpp	/^template<> inline short saturate_cast<short>(ushort v)$/;"	f	namespace:cv	signature:(ushort v)
saturate_cast	core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(double v)$/;"	f	namespace:cv	signature:(double v)
saturate_cast	core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(float v)$/;"	f	namespace:cv	signature:(float v)
saturate_cast	core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(int v)$/;"	f	namespace:cv	signature:(int v)
saturate_cast	core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(schar v)$/;"	f	namespace:cv	signature:(schar v)
saturate_cast	core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(short v)$/;"	f	namespace:cv	signature:(short v)
saturate_cast	core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(unsigned v)$/;"	f	namespace:cv	signature:(unsigned v)
saturate_cast	core/operations.hpp	/^template<> inline uchar saturate_cast<uchar>(ushort v)$/;"	f	namespace:cv	signature:(ushort v)
saturate_cast	core/operations.hpp	/^template<> inline unsigned saturate_cast<unsigned>(double v) { return cvRound(v); }$/;"	f	namespace:cv	signature:(double v)
saturate_cast	core/operations.hpp	/^template<> inline unsigned saturate_cast<unsigned>(float v){ return cvRound(v); }$/;"	f	namespace:cv	signature:(float v)
saturate_cast	core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(double v)$/;"	f	namespace:cv	signature:(double v)
saturate_cast	core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(float v)$/;"	f	namespace:cv	signature:(float v)
saturate_cast	core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(int v)$/;"	f	namespace:cv	signature:(int v)
saturate_cast	core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(schar v)$/;"	f	namespace:cv	signature:(schar v)
saturate_cast	core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(short v)$/;"	f	namespace:cv	signature:(short v)
saturate_cast	core/operations.hpp	/^template<> inline ushort saturate_cast<ushort>(unsigned v)$/;"	f	namespace:cv	signature:(unsigned v)
saturate_cast	core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(double v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(double v)
saturate_cast	core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(float v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(float v)
saturate_cast	core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(int v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(int v)
saturate_cast	core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(schar v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(schar v)
saturate_cast	core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(short v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(short v)
saturate_cast	core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(uchar v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(uchar v)
saturate_cast	core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(unsigned v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(unsigned v)
saturate_cast	core/operations.hpp	/^template<typename _Tp> static inline _Tp saturate_cast(ushort v) { return _Tp(v); }$/;"	f	namespace:cv	signature:(ushort v)
save	flann/flann.hpp	/^	void save(std::string filename) $/;"	f	class:cv::flann::Index_	access:public	signature:(std::string filename)
save	flann/flann.hpp	/^        void save(std::string filename) { nnIndex->save(filename); }$/;"	f	class:cv::flann::GenericIndex	access:public	signature:(std::string filename)
save	flann/flann_base.hpp	/^    void save(std::string filename)$/;"	f	class:cvflann::Index	access:public	signature:(std::string filename)
save	flann/miniflann.hpp	/^    CV_WRAP virtual void save(const std::string& filename) const;$/;"	p	class:cv::flann::Index	access:public	signature:(const std::string& filename) const
save	legacy/legacy.hpp	/^    void save( const char* filename, const char* imgname, const int* params=0 );$/;"	p	class:CvImage	access:public	signature:( const char* filename, const char* imgname, const int* params=0 )
save	legacy/legacy.hpp	/^    void save( const char* filename, const char* matname, const int* params=0 );$/;"	p	class:CvMatrix	access:public	signature:( const char* filename, const char* matname, const int* params=0 )
save	ml/ml.hpp	/^    CV_WRAP virtual void save( const char* filename, const char* name=0 ) const;$/;"	p	class:CvStatModel	access:public	signature:( const char* filename, const char* name=0 ) const
save	objdetect/objdetect.hpp	/^    CV_WRAP virtual void save(const String& filename, const String& objname=String()) const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(const String& filename, const String& objname=String()) const
saveAllBytePosteriors	features2d/features2d.hpp	/^  void saveAllBytePosteriors(std::string file_url);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::string file_url)
saveAllFloatPosteriors	features2d/features2d.hpp	/^  void saveAllFloatPosteriors(std::string file_url);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::string file_url)
saveIndex	flann/autotuned_index.h	/^    virtual void saveIndex(FILE* stream)$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:(FILE* stream)
saveIndex	flann/composite_index.h	/^    void saveIndex(FILE* stream)$/;"	f	class:cvflann::CompositeIndex	access:public	signature:(FILE* stream)
saveIndex	flann/flann_base.hpp	/^    virtual void saveIndex(FILE* stream)$/;"	f	class:cvflann::Index	access:public	signature:(FILE* stream)
saveIndex	flann/hierarchical_clustering_index.h	/^    void saveIndex(FILE* stream)$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:public	signature:(FILE* stream)
saveIndex	flann/kdtree_index.h	/^    void saveIndex(FILE* stream)$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:(FILE* stream)
saveIndex	flann/kdtree_single_index.h	/^    void saveIndex(FILE* stream)$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:(FILE* stream)
saveIndex	flann/kmeans_index.h	/^    void saveIndex(FILE* stream)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:(FILE* stream)
saveIndex	flann/linear_index.h	/^    void saveIndex(FILE*)$/;"	f	class:cvflann::LinearIndex	access:public	signature:(FILE*)
saveIndex	flann/lsh_index.h	/^    void saveIndex(FILE* stream)$/;"	f	class:cvflann::LshIndex	access:public	signature:(FILE* stream)
saveIndex	flann/nn_index.h	/^    virtual void saveIndex(FILE* stream) = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:(FILE* stream)
savePosteriors	features2d/features2d.hpp	/^  void savePosteriors(std::string url, bool append=false);$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::string url, bool append=false)
savePosteriors2	features2d/features2d.hpp	/^  void savePosteriors2(std::string url, bool append=false);$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::string url, bool append=false)
saveWindowParameters	highgui/highgui.hpp	/^CV_EXPORTS void saveWindowParameters(const string& windowName);$/;"	p	namespace:cv	signature:(const string& windowName)
save_header	flann/saving.h	/^void save_header(FILE* stream, const NNIndex<Distance>& index)$/;"	f	namespace:cvflann	signature:(FILE* stream, const NNIndex<Distance>& index)
save_to_file	flann/hdf5.h	/^void save_to_file(const cvflann::Matrix<T>& dataset, const std::string& filename, const std::string& name)$/;"	f	namespace:cvflann	signature:(const cvflann::Matrix<T>& dataset, const std::string& filename, const std::string& name)
save_tree	flann/hierarchical_clustering_index.h	/^    void save_tree(FILE* stream, NodePtr node, int num)$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:private	signature:(FILE* stream, NodePtr node, int num)
save_tree	flann/kdtree_index.h	/^    void save_tree(FILE* stream, NodePtr tree)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(FILE* stream, NodePtr tree)
save_tree	flann/kdtree_single_index.h	/^    void save_tree(FILE* stream, NodePtr tree)$/;"	f	class:cvflann::KDTreeSingleIndex	access:private	signature:(FILE* stream, NodePtr tree)
save_tree	flann/kmeans_index.h	/^    void save_tree(FILE* stream, KMeansNodePtr node)$/;"	f	class:cvflann::KMeansIndex	access:private	signature:(FILE* stream, KMeansNodePtr node)
save_value	flann/saving.h	/^void save_value(FILE* stream, const T& value, size_t count = 1)$/;"	f	namespace:cvflann	signature:(FILE* stream, const T& value, size_t count = 1)
save_value	flann/saving.h	/^void save_value(FILE* stream, const cvflann::Matrix<T>& value)$/;"	f	namespace:cvflann	signature:(FILE* stream, const cvflann::Matrix<T>& value)
save_value	flann/saving.h	/^void save_value(FILE* stream, const std::vector<T>& value)$/;"	f	namespace:cvflann	signature:(FILE* stream, const std::vector<T>& value)
scalarToRawData	core/core.hpp	/^CV_EXPORTS void scalarToRawData(const Scalar& s, void* buf, int type, int unroll_to=0);$/;"	p	namespace:cv	signature:(const Scalar& s, void* buf, int type, int unroll_to=0)
scale	ml/ml.hpp	/^    virtual void scale( double s );$/;"	p	class:CvBoostTree	access:public	signature:( double s )
scale	objdetect/objdetect.hpp	/^    double scale;$/;"	m	struct:CvHaarClassifierCascade	access:public
scaleAdd	core/core.hpp	/^CV_EXPORTS_W void scaleAdd(InputArray src1, double alpha, InputArray src2, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src1, double alpha, InputArray src2, OutputArray dst)
scale_factor_	features2d/features2d.hpp	/^    float scale_factor_;$/;"	m	struct:cv::ORB::CommonParams	access:public
scale_input	ml/ml.hpp	/^    virtual void scale_input( const CvMat* _src, CvMat* _dst ) const;$/;"	p	class:CvANN_MLP	access:protected	signature:( const CvMat* _src, CvMat* _dst ) const
scale_max	features2d/features2d.hpp	/^    float scale_max;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
scale_min	features2d/features2d.hpp	/^    float scale_min;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
scale_output	ml/ml.hpp	/^    virtual void scale_output( const CvMat* _src, CvMat* _dst ) const;$/;"	p	class:CvANN_MLP	access:protected	signature:( const CvMat* _src, CvMat* _dst ) const
scale_step	features2d/features2d.hpp	/^    float scale_step;$/;"	m	class:cv::OneWayDescriptorBase	access:protected
scanner	core/core_c.h	/^CVAPI(int)  cvNextGraphItem( CvGraphScanner* scanner );$/;"	v
scanner	core/core_c.h	/^CVAPI(void) cvReleaseGraphScanner( CvGraphScanner** scanner );$/;"	v
scanner	imgproc/imgproc_c.h	/^CVAPI(CvSeq*)  cvEndFindContours( CvContourScanner* scanner );$/;"	v
scanner	imgproc/imgproc_c.h	/^CVAPI(CvSeq*)  cvFindNextContour( CvContourScanner scanner );$/;"	v
schar	core/types_c.h	/^typedef signed char schar;$/;"	t
score	objdetect/objdetect.hpp	/^	float score;$/;"	m	struct:CvObjectDetection	access:public
score_threshold	objdetect/objdetect.hpp	/^	float score_threshold;$/;"	m	struct:CvLatentSvmDetector	access:public
searchLevel	flann/kdtree_index.h	/^    void searchLevel(ResultSet<DistanceType>& result_set, const ElementType* vec, NodePtr node, DistanceType mindist, int& checkCount, int maxCheck,$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(ResultSet<DistanceType>& result_set, const ElementType* vec, NodePtr node, DistanceType mindist, int& checkCount, int maxCheck, float epsError, Heap<BranchSt>* heap, DynamicBitset& checked)
searchLevel	flann/kdtree_single_index.h	/^    void searchLevel(ResultSet<DistanceType>& result_set, const ElementType* vec, const NodePtr node, DistanceType mindistsq,$/;"	f	class:cvflann::KDTreeSingleIndex	access:private	signature:(ResultSet<DistanceType>& result_set, const ElementType* vec, const NodePtr node, DistanceType mindistsq, std::vector<DistanceType>& dists, const float epsError)
searchLevelExact	flann/kdtree_index.h	/^    void searchLevelExact(ResultSet<DistanceType>& result_set, const ElementType* vec, const NodePtr node, DistanceType mindist, const float epsError)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(ResultSet<DistanceType>& result_set, const ElementType* vec, const NodePtr node, DistanceType mindist, const float epsError)
searchMode	contrib/contrib.hpp	/^    int searchMode;$/;"	m	class:CvFuzzyMeanShiftTracker	access:public
searchParams	features2d/features2d.hpp	/^    Ptr<flann::SearchParams> searchParams;$/;"	m	class:cv::FlannBasedMatcher	access:protected
searchTimeCost	flann/autotuned_index.h	/^        float searchTimeCost;$/;"	m	struct:cvflann::AutotunedIndex::CostData	access:public
search_modules	core/types_c.h	/^    int search_modules;$/;"	m	struct:CvPluginFuncInfo	access:public
search_with_ground_truth	flann/index_testing.h	/^float search_with_ground_truth(NNIndex<Distance>& index, const Matrix<typename Distance::ElementType>& inputData,$/;"	f	namespace:cvflann	signature:(NNIndex<Distance>& index, const Matrix<typename Distance::ElementType>& inputData, const Matrix<typename Distance::ElementType>& testData, const Matrix<int>& matches, int nn, int checks, float& time, typename Distance::ResultType& dist, const Distance& distance, int skipMatches)
seed_random	flann/random.h	/^inline void seed_random(unsigned int seed)$/;"	f	namespace:cvflann	signature:(unsigned int seed)
seek	core/core.hpp	/^    void seek(const int* _idx, bool relative=false);$/;"	p	class:cv::MatConstIterator	access:public	signature:(const int* _idx, bool relative=false)
seek	core/core.hpp	/^    void seek(ptrdiff_t ofs, bool relative=false);$/;"	p	class:cv::MatConstIterator	access:public	signature:(ptrdiff_t ofs, bool relative=false)
seek	core/core.hpp	/^    void seek(size_t pos);$/;"	p	class:cv::SeqIterator	access:public	signature:(size_t pos)
seek	core/operations.hpp	/^template<typename _Tp> inline void SeqIterator<_Tp>::seek(size_t pos)$/;"	f	class:cv::SeqIterator	signature:(size_t pos)
seekEnd	core/core.hpp	/^    void seekEnd();$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:()
seekEnd	core/mat.hpp	/^inline void SparseMatConstIterator::seekEnd()$/;"	f	class:cv::SparseMatConstIterator	signature:()
segmentMotion	video/tracking.hpp	/^CV_EXPORTS_W void segmentMotion(InputArray mhi, OutputArray segmask,$/;"	p	namespace:cv	signature:(InputArray mhi, OutputArray segmask, CV_OUT vector<Rect>& boundingRects, double timestamp, double segThresh)
selectDivision	flann/kdtree_index.h	/^    int selectDivision(DistanceType* v)$/;"	f	class:cvflann::KDTreeIndex	access:private	signature:(DistanceType* v)
selectRandomSubset	contrib/contrib.hpp	/^        void selectRandomSubset(float ratio);$/;"	p	class:cv::SpinImageModel	access:public	signature:(float ratio)
select_working_set	ml/ml.hpp	/^    virtual bool select_working_set( int& i, int& j );$/;"	p	class:CvSVMSolver	access:public	signature:( int& i, int& j )
select_working_set_func	ml/ml.hpp	/^    SelectWorkingSet select_working_set_func;$/;"	m	class:CvSVMSolver	access:public
select_working_set_nu_svm	ml/ml.hpp	/^    virtual bool select_working_set_nu_svm( int& i, int& j );$/;"	p	class:CvSVMSolver	access:public	signature:( int& i, int& j )
sepFilter2D	gpu/gpu.hpp	/^        CV_EXPORTS void sepFilter2D(const GpuMat& src, GpuMat& dst, int ddepth, const Mat& kernelX, const Mat& kernelY,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, int ddepth, const Mat& kernelX, const Mat& kernelY, Point anchor = Point(-1,-1), int rowBorderType = BORDER_DEFAULT, int columnBorderType = -1, Stream& stream = Stream::Null())
sepFilter2D	imgproc/imgproc.hpp	/^CV_EXPORTS_W void sepFilter2D( InputArray src, OutputArray dst, int ddepth,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor=Point(-1,-1), double delta=0, int borderType=BORDER_DEFAULT )
seq	core/core.hpp	/^    CvSeq* seq;$/;"	m	class:cv::Seq	access:public
seq	core/core_c.h	/^CVAPI(void)  cvClearSeq( CvSeq* seq );$/;"	v
seq	core/core_c.h	/^CVAPI(void) cvSeqInvert( CvSeq* seq );$/;"	v
seq	core/types_c.h	/^        CvSeq* seq; \/* sequence (ordered collection of file nodes) *\/$/;"	m	union:CvFileNode::__anon157	access:public
seqInsertSlice	core/operations.hpp	/^CV_EXPORTS void  seqInsertSlice( CvSeq* seq, int before_index, const CvArr* from_arr );    $/;"	p	namespace:cv	signature:( CvSeq* seq, int before_index, const CvArr* from_arr )
seqPop	core/operations.hpp	/^CV_EXPORTS void  seqPop( CvSeq* seq, void* element=0);$/;"	p	namespace:cv	signature:( CvSeq* seq, void* element=0)
seqPopFront	core/operations.hpp	/^CV_EXPORTS void  seqPopFront( CvSeq* seq, void* element=0);$/;"	p	namespace:cv	signature:( CvSeq* seq, void* element=0)
seqPopMulti	core/operations.hpp	/^CV_EXPORTS void  seqPopMulti( CvSeq* seq, void* elements,$/;"	p	namespace:cv	signature:( CvSeq* seq, void* elements, int count, int in_front=0 )
seqPush	core/operations.hpp	/^CV_EXPORTS schar*  seqPush( CvSeq* seq, const void* element=0);$/;"	p	namespace:cv	signature:( CvSeq* seq, const void* element=0)
seqPushFront	core/operations.hpp	/^CV_EXPORTS schar*  seqPushFront( CvSeq* seq, const void* element=0);$/;"	p	namespace:cv	signature:( CvSeq* seq, const void* element=0)
seqRemove	core/operations.hpp	/^CV_EXPORTS void  seqRemove( CvSeq* seq, int index );$/;"	p	namespace:cv	signature:( CvSeq* seq, int index )
seqRemoveSlice	core/operations.hpp	/^CV_EXPORTS void  seqRemoveSlice( CvSeq* seq, CvSlice slice );$/;"	p	namespace:cv	signature:( CvSeq* seq, CvSlice slice )
set	core/operations.hpp	/^    void set(_Tp* _data, size_t _size, bool _copyData=false)$/;"	f	class:cv::Vector	access:public	signature:(_Tp* _data, size_t _size, bool _copyData=false)
set	features2d/features2d.hpp	/^        void set( const vector<Mat>& descriptors );$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:( const vector<Mat>& descriptors )
set	flann/dynamic_bitset.h	/^    void set(size_t index)$/;"	f	class:DynamicBitset	access:public	signature:(size_t index)
set	highgui/highgui.hpp	/^    CV_WRAP virtual bool set(int propId, double value);$/;"	p	class:cv::VideoCapture	access:public	signature:(int propId, double value)
set	legacy/legacy.hpp	/^    void set( CvMat* m, bool add_ref )$/;"	f	class:CvMatrix	access:public	signature:( CvMat* m, bool add_ref )
setAffineParam	features2d/features2d.hpp	/^    void setAffineParam(double lambda, double theta, double phi);$/;"	p	class:cv::PatchGenerator	access:public	signature:(double lambda, double theta, double phi)
setAlgorithm	flann/miniflann.hpp	/^    void setAlgorithm(int value);$/;"	p	struct:cv::flann::IndexParams	access:public	signature:(int value)
setBool	flann/miniflann.hpp	/^    void setBool(const std::string& key, bool value);$/;"	p	struct:cv::flann::IndexParams	access:public	signature:(const std::string& key, bool value)
setBreakOnError	core/core.hpp	/^CV_EXPORTS bool setBreakOnError(bool flag);$/;"	p	namespace:cv	signature:(bool flag)
setCentre	contrib/contrib.hpp	/^    void setCentre(double _centre);$/;"	p	class:CvFuzzyCurve	access:public	signature:(double _centre)
setDefault	core/operations.hpp	/^    static const Formatter* setDefault(const Formatter* fmt);$/;"	p	class:cv::Formatter	access:public	signature:(const Formatter* fmt)
setDestination	flann/logger.h	/^    static void setDestination(const char* name) { instance()._setDestination(name); }$/;"	f	class:cvflann::Logger	access:public	signature:(const char* name)
setDevice	gpu/gpu.hpp	/^        CV_EXPORTS void setDevice(int device);$/;"	p	namespace:cv::gpu	signature:(int device)
setDouble	flann/miniflann.hpp	/^    void setDouble(const std::string& key, double value);$/;"	p	struct:cv::flann::IndexParams	access:public	signature:(const std::string& key, double value)
setEdgePoints	imgproc/imgproc.hpp	/^    void setEdgePoints( int edge, int orgPt, int dstPt );$/;"	p	class:cv::Subdiv2D	access:protected	signature:( int edge, int orgPt, int dstPt )
setFloat	flann/miniflann.hpp	/^    void setFloat(const std::string& key, float value);$/;"	p	struct:cv::flann::IndexParams	access:public	signature:(const std::string& key, float value)
setFloatPosteriorsFromTextfile_176	features2d/features2d.hpp	/^  void setFloatPosteriorsFromTextfile_176(std::string url);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::string url)
setIdentity	core/core.hpp	/^CV_EXPORTS_W void setIdentity(InputOutputArray mtx, const Scalar& s=Scalar(1));$/;"	p	namespace:cv	signature:(InputOutputArray mtx, const Scalar& s=Scalar(1))
setImage	objdetect/objdetect.hpp	/^    bool setImage( Ptr<FeatureEvaluator>&, const Mat& );$/;"	p	class:cv::CascadeClassifier	access:protected	signature:( Ptr<FeatureEvaluator>&, const Mat& )
setImage	objdetect/objdetect.hpp	/^    bool setImage( const Mat& );$/;"	p	class:cv::CascadeClassifier	access:public	signature:( const Mat& )
setImage	objdetect/objdetect.hpp	/^    virtual bool setImage(const Mat&, Size origWinSize);$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(const Mat&, Size origWinSize)
setInt	flann/miniflann.hpp	/^    void setInt(const std::string& key, int value);$/;"	p	struct:cv::flann::IndexParams	access:public	signature:(const std::string& key, int value)
setLevel	flann/logger.h	/^    static void setLevel(int level) { instance().logLevel = level; }$/;"	f	class:cvflann::Logger	access:public	signature:(int level)
setLogger	contrib/contrib.hpp	/^        void setLogger(std::ostream* log);$/;"	p	class:cv::SpinImageModel	access:public	signature:(std::ostream* log)
setMouseCallback	highgui/highgui.hpp	/^CV_EXPORTS void setMouseCallback( const string& windowName, MouseCallback onMouse, void* param=0);$/;"	p	namespace:cv	signature:( const string& windowName, MouseCallback onMouse, void* param=0)
setNumThreads	core/core.hpp	/^CV_EXPORTS void setNumThreads(int nthreads);$/;"	p	namespace:cv	signature:(int nthreads)
setQuantization	features2d/features2d.hpp	/^  void setQuantization(int num_quant_bits);$/;"	p	class:cv::RTreeClassifier	access:public	signature:(int num_quant_bits)
setRule	contrib/contrib.hpp	/^    void setRule(CvFuzzyCurve *c1, CvFuzzyCurve *c2, CvFuzzyCurve *o1);$/;"	p	class:CvFuzzyRule	access:public	signature:(CvFuzzyCurve *c1, CvFuzzyCurve *c2, CvFuzzyCurve *o1)
setSVMDetector	gpu/gpu.hpp	/^            void setSVMDetector(const vector<float>& detector);$/;"	p	struct:cv::gpu::HOGDescriptor	access:public	signature:(const vector<float>& detector)
setSVMDetector	objdetect/objdetect.hpp	/^    CV_WRAP virtual void setSVMDetector(InputArray _svmdetector);$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(InputArray _svmdetector)
setSize	contrib/contrib.hpp	/^        void setSize(int _x, int _y, int _width, int _height);$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:(int _x, int _y, int _width, int _height)
setString	flann/miniflann.hpp	/^    void setString(const std::string& key, const std::string& value);$/;"	p	struct:cv::flann::IndexParams	access:public	signature:(const std::string& key, const std::string& value)
setSubset	contrib/contrib.hpp	/^        void setSubset(const vector<int>& subset);$/;"	p	class:cv::SpinImageModel	access:public	signature:(const vector<int>& subset)
setTo	core/core.hpp	/^    Mat& setTo(InputArray value, InputArray mask=noArray());$/;"	p	class:cv::Mat	access:public	signature:(InputArray value, InputArray mask=noArray())
setTo	gpu/gpumat.hpp	/^        GpuMat& setTo(const Scalar& s, const GpuMat& mask = GpuMat());$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const Scalar& s, const GpuMat& mask = GpuMat())
setTrackbarPos	highgui/highgui.hpp	/^CV_EXPORTS_W void setTrackbarPos( const string& trackbarname, const string& winname, int pos );$/;"	p	namespace:cv	signature:( const string& trackbarname, const string& winname, int pos )
setUseOptimized	core/core.hpp	/^CV_EXPORTS_W void setUseOptimized(bool onoff);$/;"	p	namespace:cv	signature:(bool onoff)
setValue	contrib/contrib.hpp	/^    void setValue(double _value);$/;"	p	class:CvFuzzyCurve	access:public	signature:(double _value)
setVerbose	features2d/features2d.hpp	/^    void setVerbose(bool verbose);$/;"	p	class:cv::FernClassifier	access:public	signature:(bool verbose)
setVerbose	features2d/features2d.hpp	/^    void setVerbose(bool verbose);$/;"	p	class:cv::LDetector	access:public	signature:(bool verbose)
setVerbose	objdetect/objdetect.hpp	/^    void setVerbose(bool verbose);$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(bool verbose)
setVocabulary	features2d/features2d.hpp	/^    void setVocabulary( const Mat& vocabulary );$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:( const Mat& vocabulary )
setWindow	objdetect/objdetect.hpp	/^    virtual bool setWindow(Point p);$/;"	p	class:cv::FeatureEvaluator	access:public	signature:(Point p)
setWindowProperty	highgui/highgui.hpp	/^CV_EXPORTS_W void setWindowProperty(const string& winname, int prop_id, double prop_value);\/\/YV$/;"	p	namespace:cv	signature:(const string& winname, int prop_id, double prop_value)
set_activ_func	ml/ml.hpp	/^    virtual void set_activ_func( int _activ_func=SIGMOID_SYM,$/;"	p	class:CvANN_MLP	access:protected	signature:( int _activ_func=SIGMOID_SYM, double _f_param1=0, double _f_param2=0 )
set_cb_index	flann/kmeans_index.h	/^    void set_cb_index( float index)$/;"	f	class:cvflann::KMeansIndex	access:public	signature:( float index)
set_coi	legacy/legacy.hpp	/^    void set_coi(int coi) { cvSetImageCOI(image,coi); }$/;"	f	class:CvImage	access:public	signature:(int coi)
set_data	legacy/legacy.hpp	/^    void set_data( void* data, int step=CV_AUTOSTEP )$/;"	f	class:CvMatrix	access:public	signature:( void* data, int step=CV_AUTOSTEP )
set_data	ml/ml.hpp	/^    virtual void set_data( const CvMat* trainData, int tflag,$/;"	p	struct:CvDTreeTrainData	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, const CvDTreeParams& params=CvDTreeParams(), bool _shared=false, bool _add_labels=false, bool _update_data=false )
set_data	ml/ml.hpp	/^    virtual void set_data( const CvMat* trainData, int tflag,$/;"	p	struct:CvERTreeTrainData	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, const CvDTreeParams& params=CvDTreeParams(), bool _shared=false, bool _add_labels=false, bool _update_data=false )
set_delimiter	ml/ml.hpp	/^    void set_delimiter( char ch );$/;"	p	class:CvMLData	access:public	signature:( char ch )
set_distance_type	flann/flann.hpp	/^    FLANN_DEPRECATED CV_EXPORTS void set_distance_type(flann_distance_t distance_type, int order);$/;"	p	namespace:cvflann	signature:(flann_distance_t distance_type, int order)
set_header	core/core_c.h	/^CVAPI(void)  cvClearSet( CvSet* set_header );$/;"	v
set_hist_bin_range	legacy/legacy.hpp	/^    bool    set_hist_bin_range( int dim, int min_val, int max_val );$/;"	p	class:CvCamShiftTracker	access:public	signature:( int dim, int min_val, int max_val )
set_hist_dims	legacy/legacy.hpp	/^    bool    set_hist_dims( int c_dims, int* dims );\/\/ set the histogram parameters$/;"	p	class:CvCamShiftTracker	access:public	signature:( int c_dims, int* dims )
set_max_ch_val	legacy/legacy.hpp	/^    bool    set_max_ch_val( int channel, int val ) \/\/ set the maximum allowed value of the specified channel$/;"	f	class:CvCamShiftTracker	access:public	signature:( int channel, int val )
set_min_ch_val	legacy/legacy.hpp	/^    bool    set_min_ch_val( int channel, int val ) \/\/ set the minimum allowed value of the specified channel$/;"	f	class:CvCamShiftTracker	access:public	signature:( int channel, int val )
set_miss_ch	ml/ml.hpp	/^    void set_miss_ch( char ch );$/;"	p	class:CvMLData	access:public	signature:( char ch )
set_num_valid	ml/ml.hpp	/^    void set_num_valid(int vi, int n) { if( num_valid ) num_valid[vi] = n; }$/;"	f	struct:CvDTreeNode	access:public	signature:(int vi, int n)
set_params	ml/ml.hpp	/^    virtual bool set_params( const CvBoostParams& params );$/;"	p	class:CvBoost	access:protected	signature:( const CvBoostParams& params )
set_params	ml/ml.hpp	/^    virtual bool set_params( const CvDTreeParams& params );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( const CvDTreeParams& params )
set_params	ml/ml.hpp	/^    virtual bool set_params( const CvSVMParams& params );$/;"	p	class:CvSVM	access:protected	signature:( const CvSVMParams& params )
set_params	ml/ml.hpp	/^    virtual void set_params( const CvEMParams& params,$/;"	p	class:CvEM	access:protected	signature:( const CvEMParams& params, const CvVectors& train_data )
set_postprocess_func	highgui/highgui_c.h	491;"	d
set_preprocess_func	highgui/highgui_c.h	490;"	d
set_response_idx	ml/ml.hpp	/^    void set_response_idx( int idx ); \/\/ old response become predictors, new response_idx = idx$/;"	p	class:CvMLData	access:public	signature:( int idx )
set_roi	legacy/legacy.hpp	/^    void set_roi(CvRect roi) { cvSetImageROI(image,roi); }$/;"	f	class:CvImage	access:public	signature:(CvRect roi)
set_threshold	legacy/legacy.hpp	/^    bool    set_threshold( int threshold ) \/\/ threshold applied to the histogram bins$/;"	f	class:CvCamShiftTracker	access:public	signature:( int threshold )
set_train_test_split	ml/ml.hpp	/^    void set_train_test_split( const CvTrainTestSplit * spl );$/;"	p	class:CvMLData	access:public	signature:( const CvTrainTestSplit * spl )
set_var_types	ml/ml.hpp	/^    void set_var_types( const char* str );  \/\/ str examples:$/;"	p	class:CvMLData	access:public	signature:( const char* str )
set_window	legacy/legacy.hpp	/^    bool    set_window( CvRect window)$/;"	f	class:CvCamShiftTracker	access:public	signature:( CvRect window)
setup	contrib/retina.hpp	/^        void setup(std::string retinaParameterFile="", const bool applyDefaultSetupOnFailure=true);$/;"	p	class:cv::Retina	access:public	signature:(std::string retinaParameterFile=, const bool applyDefaultSetupOnFailure=true)
setupIPLMagnoChannel	contrib/retina.hpp	/^        void setupIPLMagnoChannel(const bool normaliseOutput = true, const double parasolCells_beta=0, const double parasolCells_tau=0, const double parasolCells_k=7, const double amacrinCellsTemporalCutFrequency=1.2, const double V0CompressionParameter=0.95, const double localAdaptintegration_tau=0, const double localAdaptintegration_k=7);$/;"	p	class:cv::Retina	access:public	signature:(const bool normaliseOutput = true, const double parasolCells_beta=0, const double parasolCells_tau=0, const double parasolCells_k=7, const double amacrinCellsTemporalCutFrequency=1.2, const double V0CompressionParameter=0.95, const double localAdaptintegration_tau=0, const double localAdaptintegration_k=7)
setupOPLandIPLParvoChannel	contrib/retina.hpp	/^        void setupOPLandIPLParvoChannel(const bool colorMode=true, const bool normaliseOutput = true, const double photoreceptorsLocalAdaptationSensitivity=0.7, const double photoreceptorsTemporalConstant=0.5, const double photoreceptorsSpatialConstant=0.53, const double horizontalCellsGain=0, const double HcellsTemporalConstant=1, const double HcellsSpatialConstant=7, const double ganglionCellsSensitivity=0.7);$/;"	p	class:cv::Retina	access:public	signature:(const bool colorMode=true, const bool normaliseOutput = true, const double photoreceptorsLocalAdaptationSensitivity=0.7, const double photoreceptorsTemporalConstant=0.5, const double photoreceptorsSpatialConstant=0.53, const double horizontalCellsGain=0, const double HcellsTemporalConstant=1, const double HcellsSpatialConstant=7, const double ganglionCellsSensitivity=0.7)
shape	legacy/blobtrack.hpp	/^    enum {RECT, ELLIPSE} shape;$/;"	m	struct:CvDrawShape	typeref:enum:CvDrawShape::__anon177	access:public
shared	ml/ml.hpp	/^    bool shared;$/;"	m	struct:CvDTreeTrainData	access:public
shear	core/core_c.h	/^    float       shear; 			\/* slope coefficient: 0 - normal, >0 - italic *\/$/;"	m	struct:CvFont	access:public
shift	contrib/contrib.hpp	/^        bool shift();$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:()
shift1	legacy/blobtrack.hpp	/^    int shift1,shift2;$/;"	m	struct:CvTracksTimePos	access:public
shift2	legacy/blobtrack.hpp	/^    int shift1,shift2;$/;"	m	struct:CvTracksTimePos	access:public
show	legacy/legacy.hpp	/^    void show( const char* window_name );$/;"	p	class:CvImage	access:public	signature:( const char* window_name )
show	legacy/legacy.hpp	/^    void show( const char* window_name );$/;"	p	class:CvMatrix	access:public	signature:( const char* window_name )
shrinkage	ml/ml.hpp	/^    CV_PROP_RW float shrinkage;$/;"	m	struct:CvGBTreesParams	access:public
sift	features2d/features2d.hpp	/^    SIFT sift;$/;"	m	class:cv::SiftDescriptorExtractor	access:protected
sift	features2d/features2d.hpp	/^    SIFT sift;$/;"	m	class:cv::SiftFeatureDetector	access:protected
sigma	legacy/blobtrack.hpp	/^    float   sigma;$/;"	m	struct:CvBlobTrackerParamMS	access:public
sigma_range	gpu/gpu.hpp	/^            float sigma_range;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
signature	core/types_c.h	/^    int signature;$/;"	m	struct:CvMemStorage	access:public
signature	flann/saving.h	/^    char signature[16];$/;"	m	struct:cvflann::IndexHeader	access:public
signatureSize	features2d/features2d.hpp	/^        int signatureSize;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
signatureSize	features2d/features2d.hpp	/^    int signatureSize;$/;"	m	class:cv::FernClassifier	access:protected
size	core/core.hpp	/^        int size[CV_MAX_DIM];$/;"	m	struct:cv::SparseMat::Hdr	access:public
size	core/core.hpp	/^    CV_WRAP size_t size() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
size	core/core.hpp	/^    MSize size;$/;"	m	class:cv::Mat	access:public
size	core/core.hpp	/^    Size2f size;    \/\/< width and height of the rectangle$/;"	m	class:cv::RotatedRect	access:public
size	core/core.hpp	/^    Size_<_Tp> size() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
size	core/core.hpp	/^    const int* size() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
size	core/core.hpp	/^    int size() const;$/;"	p	class:cv::Range	access:public	signature:() const
size	core/core.hpp	/^    int size(int i) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i) const
size	core/core.hpp	/^    size_t size() const;$/;"	p	class:cv::Seq	access:public	signature:() const
size	core/core.hpp	/^    size_t size;$/;"	m	class:cv::AutoBuffer	access:protected
size	core/core.hpp	/^    size_t size;$/;"	m	class:cv::NAryMatIterator	access:public
size	core/core.hpp	/^    virtual Size size(int i=-1) const;$/;"	p	class:cv::_InputArray	access:public	signature:(int i=-1) const
size	core/core_c.h	/^    CvSize size; \/* maximal common linear size: { width = size, height = 1 } *\/$/;"	m	struct:CvNArrayIterator	access:public
size	core/core_c.h	/^CVAPI(void*)  cvAlloc( size_t size );$/;"	v
size	core/mat.hpp	/^    Size size() const;$/;"	p	class:cv::MatExpr	access:public	signature:() const
size	core/mat.hpp	/^    virtual Size size(const MatExpr& expr) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr) const
size	core/mat.hpp	/^inline const int* SparseMat::size() const$/;"	f	class:cv::SparseMat	signature:() const
size	core/mat.hpp	/^inline int SparseMat::size(int i) const$/;"	f	class:cv::SparseMat	signature:(int i) const
size	core/operations.hpp	/^        size_t size;$/;"	m	struct:cv::Vector::Hdr	access:public
size	core/operations.hpp	/^    size_t size() const { return hdr.size; }$/;"	f	class:cv::Vector	access:public	signature:() const
size	core/operations.hpp	/^inline int Range::size() const { return end - start; }$/;"	f	class:cv::Range	signature:() const
size	core/operations.hpp	/^inline size_t FileNode::size() const$/;"	f	class:cv::FileNode	signature:() const
size	core/operations.hpp	/^template<typename _Tp> inline Size_<_Tp> Rect_<_Tp>::size() const { return Size_<_Tp>(width, height); }$/;"	f	class:cv::Rect_	signature:() const
size	core/operations.hpp	/^template<typename _Tp> inline size_t Seq<_Tp>::size() const$/;"	f	class:cv::Seq	signature:() const
size	core/types_c.h	/^        int size;$/;"	m	struct:CvMatND::__anon155	access:public
size	core/types_c.h	/^    CvSize2D32f  size;    \/* Box width and length.                       *\/$/;"	m	struct:CvBox2D	access:public
size	core/types_c.h	/^    int size[CV_MAX_DIM];$/;"	m	struct:CvSparseMat	access:public
size	features2d/features2d.hpp	/^        int size() const;$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:() const
size	features2d/features2d.hpp	/^    CV_PROP_RW float size; \/\/!< diameter of the meaningful keypoint neighborhood$/;"	m	class:cv::KeyPoint	access:public
size	features2d/features2d.hpp	/^    int          size;$/;"	m	struct:CvSURFPoint	access:public
size	features2d/features2d.hpp	/^    int size;$/;"	m	class:cv::BOWTrainer	access:protected
size	features2d/features2d.hpp	/^    int size;$/;"	m	struct:CvStarKeypoint	access:public
size	flann/autotuned_index.h	/^    virtual size_t size() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
size	flann/composite_index.h	/^    size_t size() const$/;"	f	class:cvflann::CompositeIndex	access:public	signature:() const
size	flann/dynamic_bitset.h	/^    size_t size() const$/;"	f	class:DynamicBitset	access:public	signature:() const
size	flann/flann.hpp	/^	int size() const $/;"	f	class:cv::flann::Index_	access:public	signature:() const
size	flann/flann.hpp	/^        int size() const { return nnIndex->size(); }$/;"	f	class:cv::flann::GenericIndex	access:public	signature:() const
size	flann/flann_base.hpp	/^    size_t size() const$/;"	f	class:cvflann::Index	access:public	signature:() const
size	flann/heap.h	/^    int size()$/;"	f	class:cvflann::Heap	access:public	signature:()
size	flann/hierarchical_clustering_index.h	/^        int size;$/;"	m	struct:cvflann::HierarchicalClusteringIndex::Node	access:public
size	flann/hierarchical_clustering_index.h	/^    size_t size() const$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:public	signature:() const
size	flann/kdtree_index.h	/^    size_t size() const$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:() const
size	flann/kdtree_single_index.h	/^    size_t size() const$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:() const
size	flann/kmeans_index.h	/^        int size;$/;"	m	struct:cvflann::KMeansIndex::KMeansNode	access:public
size	flann/kmeans_index.h	/^    size_t size() const$/;"	f	class:cvflann::KMeansIndex	access:public	signature:() const
size	flann/linear_index.h	/^    size_t size() const$/;"	f	class:cvflann::LinearIndex	access:public	signature:() const
size	flann/lsh_index.h	/^    size_t size() const$/;"	f	class:cvflann::LshIndex	access:public	signature:() const
size	flann/nn_index.h	/^    virtual size_t size() const = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:() const
size	flann/result_set.h	/^    size_t size() const$/;"	f	class:cvflann::KNNResultSet	access:public	signature:() const
size	flann/result_set.h	/^    size_t size() const$/;"	f	class:cvflann::KNNSimpleResultSet	access:public	signature:() const
size	flann/result_set.h	/^    size_t size() const$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:() const
size	flann/result_set.h	/^    size_t size() const$/;"	f	class:cvflann::UniqueResultSet	access:public	signature:() const
size	gpu/NCV.hpp	/^    size_t size;$/;"	m	struct:NCVMemSegment	access:public
size	gpu/gpu.hpp	/^            Size size() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
size	gpu/gpumat.hpp	/^        Size size() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
size	gpu/matrix_operations.hpp	/^inline Size CudaMem::size() const { return Size(cols, rows); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
size	legacy/legacy.hpp	/^    CvSize size() const { return image ? cvSize(image->width, image->height) : cvSize(0,0); }$/;"	f	class:CvImage	access:public	signature:() const
size	legacy/legacy.hpp	/^    CvSize size() const$/;"	f	class:CvMatrix	access:public	signature:() const
size	video/background_segm.hpp	/^    CvSize size;$/;"	m	struct:CvBGCodeBookModel	access:public
sizeX	objdetect/objdetect.hpp	/^    int sizeX;$/;"	m	struct:__anon197	access:public
sizeY	objdetect/objdetect.hpp	/^    int sizeY;$/;"	m	struct:__anon197	access:public
size_	flann/dynamic_bitset.h	/^    size_t size_;$/;"	m	class:DynamicBitset	access:private
size_	flann/hierarchical_clustering_index.h	/^    size_t size_;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
size_	flann/kdtree_index.h	/^    size_t size_;$/;"	m	class:cvflann::KDTreeIndex	access:private
size_	flann/kdtree_single_index.h	/^    size_t size_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
size_	flann/kmeans_index.h	/^    size_t size_;$/;"	m	class:cvflann::KMeansIndex	access:private
size_	flann/random.h	/^    int size_;$/;"	m	class:cvflann::UniqueRandom	access:private
size_histogram_	flann/lsh_table.h	/^    std::vector<std::vector<unsigned int> > size_histogram_;$/;"	m	struct:cvflann::lsh::LshStats	access:public
size_type	core/core.hpp	/^    typedef size_t size_type;$/;"	t	class:cv::Allocator	access:public
sizeof	gpu/NCV.hpp	/^NCV_CT_ASSERT(sizeof(Ncv16s) == 2);$/;"	p	signature:(Ncv16s)
sizeof	gpu/NCV.hpp	/^NCV_CT_ASSERT(sizeof(Ncv16u) == 2);$/;"	p	signature:(Ncv16u)
sizeof	gpu/NCV.hpp	/^NCV_CT_ASSERT(sizeof(Ncv32f) == 4);$/;"	p	signature:(Ncv32f)
sizeof	gpu/NCV.hpp	/^NCV_CT_ASSERT(sizeof(Ncv32s) == 4);$/;"	p	signature:(Ncv32s)
sizeof	gpu/NCV.hpp	/^NCV_CT_ASSERT(sizeof(Ncv32u) == 4);$/;"	p	signature:(Ncv32u)
sizeof	gpu/NCV.hpp	/^NCV_CT_ASSERT(sizeof(Ncv64f) == 8);$/;"	p	signature:(Ncv64f)
sizeof	gpu/NCV.hpp	/^NCV_CT_ASSERT(sizeof(Ncv64s) == 8);$/;"	p	signature:(Ncv64s)
sizeof	gpu/NCV.hpp	/^NCV_CT_ASSERT(sizeof(Ncv64u) == 8);$/;"	p	signature:(Ncv64u)
sizeof	gpu/NCV.hpp	/^NCV_CT_ASSERT(sizeof(Ncv8s) == 1);$/;"	p	signature:(Ncv8s)
sizeof	gpu/NCV.hpp	/^NCV_CT_ASSERT(sizeof(Ncv8u) == 1);$/;"	p	signature:(Ncv8u)
sizeof	gpu/NCV.hpp	/^NCV_CT_ASSERT(sizeof(NcvBool) <= 4);$/;"	p	signature:(NcvBool)
sizeof	gpu/NCV.hpp	/^NCV_CT_ASSERT(sizeof(NcvRect32s) == 4 * sizeof(Ncv32s));$/;"	v
sizeof	gpu/NCV.hpp	/^NCV_CT_ASSERT(sizeof(NcvRect32u) == 4 * sizeof(Ncv32u));$/;"	v
sizeof	gpu/NCV.hpp	/^NCV_CT_ASSERT(sizeof(NcvRect8u) == sizeof(Ncv32u));$/;"	v
sizeof	gpu/NCV.hpp	/^NCV_CT_ASSERT(sizeof(NcvSize32u) == 2 * sizeof(Ncv32u));$/;"	v
skinHueHistogram	contrib/contrib.hpp	/^    Histogram histogramHueMotion, skinHueHistogram;$/;"	m	class:CvAdaptiveSkinDetector	access:private
sliceEnd	core/core.hpp	/^    uchar* sliceEnd;$/;"	m	class:cv::MatConstIterator	access:public
sliceStart	core/core.hpp	/^    uchar* sliceStart;$/;"	m	class:cv::MatConstIterator	access:public
slidingSumBuf	calib3d/calib3d.hpp	/^    CvMat* slidingSumBuf;$/;"	m	struct:CvStereoBMState	access:public
small	core/internal.hpp	67;"	d
smallSize	contrib/contrib.hpp	/^        int smallSize;$/;"	m	class:cv::SelfSimDescriptor	access:public
small_any_policy	flann/any.h	/^struct small_any_policy : typed_base_any_policy<T>$/;"	s	namespace:cdiggins::anyimpl	inherits:typed_base_any_policy
solve	core/core.hpp	/^    Matx<_Tp, n, 1> solve(const Matx<_Tp, m, 1>& rhs, int method) const;$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, 1>& rhs, int method) const
solve	core/core.hpp	/^    template<int l> Matx<_Tp, n, l> solve(const Matx<_Tp, m, l>& rhs, int flags=DECOMP_LU) const;$/;"	p	class:cv::Matx	access:public	signature:(const Matx<_Tp, m, l>& rhs, int flags=DECOMP_LU) const
solve	core/core.hpp	/^CV_EXPORTS_W bool solve(InputArray src1, InputArray src2,$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst, int flags=DECOMP_LU)
solve	core/operations.hpp	/^Matx<_Tp, n, l> Matx<_Tp, m, n>::solve(const Matx<_Tp, m, l>& rhs, int method) const$/;"	f	class:cv::Matx	signature:(const Matx<_Tp, m, l>& rhs, int method) const
solveCubic	core/core.hpp	/^CV_EXPORTS_W int solveCubic(InputArray coeffs, OutputArray roots);$/;"	p	namespace:cv	signature:(InputArray coeffs, OutputArray roots)
solvePnP	calib3d/calib3d.hpp	/^CV_EXPORTS_W void solvePnP( InputArray objectPoints, InputArray imagePoints,$/;"	p	namespace:cv	signature:( InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess=false )
solvePnPRansac	calib3d/calib3d.hpp	/^CV_EXPORTS_W void solvePnPRansac( InputArray objectPoints,$/;"	p	namespace:cv	signature:( InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess = false, int iterationsCount = 100, float reprojectionError = 8.0, int minInliersCount = 100, OutputArray inliers = noArray() )
solvePnPRansac	gpu/gpu.hpp	/^        CV_EXPORTS void solvePnPRansac(const Mat& object, const Mat& image, const Mat& camera_mat,$/;"	p	namespace:cv::gpu	signature:(const Mat& object, const Mat& image, const Mat& camera_mat, const Mat& dist_coef, Mat& rvec, Mat& tvec, bool use_extrinsic_guess=false, int num_iters=100, float max_dist=8.0, int min_inlier_count=100, vector<int>* inliers=NULL)
solvePoly	core/core.hpp	/^CV_EXPORTS_W double solvePoly(InputArray coeffs, OutputArray roots, int maxIters=300);$/;"	p	namespace:cv	signature:(InputArray coeffs, OutputArray roots, int maxIters=300)
solveZ	core/core.hpp	/^    static void solveZ( InputArray src, OutputArray dst );$/;"	p	class:cv::SVD	access:public	signature:( InputArray src, OutputArray dst )
solveZ	core/mat.hpp	/^inline void SVD::solveZ( InputArray m, OutputArray _dst )$/;"	f	class:cv::SVD	signature:( InputArray m, OutputArray _dst )
solve_c_svc	ml/ml.hpp	/^    virtual bool solve_c_svc( int count, int var_count, const float** samples, schar* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, schar* y, double Cp, double Cn, CvMemStorage* storage, CvSVMKernel* kernel, double* alpha, CvSVMSolutionInfo& si )
solve_eps_svr	ml/ml.hpp	/^    virtual bool solve_eps_svr( int count, int var_count, const float** samples, const float* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, const float* y, CvMemStorage* storage, CvSVMKernel* kernel, double* alpha, CvSVMSolutionInfo& si )
solve_generic	ml/ml.hpp	/^    virtual bool solve_generic( CvSVMSolutionInfo& si );$/;"	p	class:CvSVMSolver	access:public	signature:( CvSVMSolutionInfo& si )
solve_nu_svc	ml/ml.hpp	/^    virtual bool solve_nu_svc( int count, int var_count, const float** samples, schar* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, schar* y, CvMemStorage* storage, CvSVMKernel* kernel, double* alpha, CvSVMSolutionInfo& si )
solve_nu_svr	ml/ml.hpp	/^    virtual bool solve_nu_svr( int count, int var_count, const float** samples, const float* y,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, const float* y, CvMemStorage* storage, CvSVMKernel* kernel, double* alpha, CvSVMSolutionInfo& si )
solve_one_class	ml/ml.hpp	/^    virtual bool solve_one_class( int count, int var_count, const float** samples,$/;"	p	class:CvSVMSolver	access:public	signature:( int count, int var_count, const float** samples, CvMemStorage* storage, CvSVMKernel* kernel, double* alpha, CvSVMSolutionInfo& si )
solver	ml/ml.hpp	/^    CvSVMSolver* solver;$/;"	m	class:CvSVM	access:protected
sort	core/core.hpp	/^CV_EXPORTS_W void sort(InputArray src, OutputArray dst, int flags);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, int flags)
sort	core/operations.hpp	/^template<typename _Tp, class _LT> void sort( vector<_Tp>& vec, _LT LT=_LT() )$/;"	f	namespace:cv	signature:( vector<_Tp>& vec, _LT LT=_LT() )
sortAndCopy	flann/result_set.h	/^    virtual void sortAndCopy(int* indices, DistanceType* dist, int n_neighbors = -1) const$/;"	f	class:cvflann::UniqueResultSet	access:public	signature:(int* indices, DistanceType* dist, int n_neighbors = -1) const
sortIdx	core/core.hpp	/^CV_EXPORTS_W void sortIdx(InputArray src, OutputArray dst, int flags);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, int flags)
speckleRange	calib3d/calib3d.hpp	/^    CV_PROP_RW int speckleRange;$/;"	m	class:cv::StereoSGBM	access:public
speckleRange	calib3d/calib3d.hpp	/^    int speckleRange; \/\/ acceptable range of variation in window$/;"	m	struct:CvStereoBMState	access:public
speckleWindowSize	calib3d/calib3d.hpp	/^    CV_PROP_RW int speckleWindowSize;$/;"	m	class:cv::StereoSGBM	access:public
speckleWindowSize	calib3d/calib3d.hpp	/^    int speckleWindowSize; \/\/ disparity variation window$/;"	m	struct:CvStereoBMState	access:public
spect_len	gpu/gpu.hpp	/^            int spect_len;$/;"	m	struct:cv::gpu::ConvolveBuf	access:private
speed_level_	flann/lsh_table.h	/^    SpeedLevel speed_level_;$/;"	m	class:cvflann::lsh::LshTable	access:private
speedup_	flann/autotuned_index.h	/^    float speedup_;$/;"	m	class:cvflann::AutotunedIndex	access:private
spinCorrelation	contrib/contrib.hpp	/^        static bool spinCorrelation(const Mat& spin1, const Mat& spin2, float lambda, float& result);$/;"	p	class:cv::SpinImageModel	access:public	signature:(const Mat& spin1, const Mat& spin2, float lambda, float& result)
spinImages	contrib/contrib.hpp	/^        Mat spinImages;$/;"	m	class:cv::SpinImageModel	access:protected
splice	imgproc/imgproc.hpp	/^    void splice( int edgeA, int edgeB );$/;"	p	class:cv::Subdiv2D	access:protected	signature:( int edgeA, int edgeB )
split	core/core.hpp	/^CV_EXPORTS void split(const Mat& src, Mat* mvbegin);$/;"	p	namespace:cv	signature:(const Mat& src, Mat* mvbegin)
split	core/core.hpp	/^CV_EXPORTS_W void split(const Mat& m, CV_OUT vector<Mat>& mv);$/;"	p	namespace:cv	signature:(const Mat& m, CV_OUT vector<Mat>& mv)
split	core/mat.hpp	/^template<typename _Tp> void split(const Mat& src, vector<Mat_<_Tp> >& mv)$/;"	f	namespace:cv	signature:(const Mat& src, vector<Mat_<_Tp> >& mv)
split	gpu/gpu.hpp	/^        CV_EXPORTS void split(const GpuMat& src, GpuMat* dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat* dst, Stream& stream = Stream::Null())
split	gpu/gpu.hpp	/^        CV_EXPORTS void split(const GpuMat& src, vector<GpuMat>& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, vector<GpuMat>& dst, Stream& stream = Stream::Null())
split	ml/ml.hpp	/^    CvDTreeSplit* split;$/;"	m	struct:CvDTreeNode	access:public
split_buf	ml/ml.hpp	/^    CvMat* split_buf;$/;"	m	struct:CvDTreeTrainData	access:public
split_criteria	ml/ml.hpp	/^    CV_PROP_RW int split_criteria;$/;"	m	struct:CvBoostParams	access:public
split_heap	ml/ml.hpp	/^    CvSet* split_heap;$/;"	m	struct:CvDTreeTrainData	access:public
split_node_data	ml/ml.hpp	/^    virtual void split_node_data( CvDTreeNode* n );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n )
split_node_data	ml/ml.hpp	/^    virtual void split_node_data( CvDTreeNode* n );$/;"	p	class:CvForestERTree	access:protected	signature:( CvDTreeNode* n )
split_point	ml/ml.hpp	/^            int split_point;$/;"	m	struct:CvDTreeSplit::__anon77::__anon78	access:public
sqrIntegral	gpu/gpu.hpp	/^        CV_EXPORTS void sqrIntegral(const GpuMat& src, GpuMat& sqsum, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& sqsum, Stream& stream = Stream::Null())
sqrSum	gpu/gpu.hpp	/^        CV_EXPORTS Scalar sqrSum(const GpuMat& src);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src)
sqrSum	gpu/gpu.hpp	/^        CV_EXPORTS Scalar sqrSum(const GpuMat& src, GpuMat& buf);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& buf)
sqrt	core/core.hpp	/^CV_EXPORTS_W void sqrt(InputArray src, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst)
srcRow	imgproc/imgproc.hpp	/^    vector<uchar> srcRow;$/;"	m	class:cv::FilterEngine	access:public
srcType	imgproc/imgproc.hpp	/^    int srcType, dstType, bufType;$/;"	m	class:cv::FilterEngine	access:public
stack	core/core_c.h	/^    CvSeq*   stack;        \/* the graph vertex stack *\/$/;"	m	struct:CvGraphScanner	access:public
stack	core/core_c.h	/^    int stack[CV_MAX_DIM]; \/* for internal use *\/$/;"	m	struct:CvNArrayIterator	access:public
stageType	objdetect/objdetect.hpp	/^        int stageType;$/;"	m	class:cv::CascadeClassifier::Data	access:public
stage_classifier	objdetect/objdetect.hpp	/^    CvHaarStageClassifier* stage_classifier;$/;"	m	struct:CvHaarClassifierCascade	access:public
stages	objdetect/objdetect.hpp	/^        vector<Stage> stages;$/;"	m	class:cv::CascadeClassifier::Data	access:public
stale	video/background_segm.hpp	/^    int stale;$/;"	m	struct:CvBGCodeBookElem	access:public
star	features2d/features2d.hpp	/^    StarDetector star;$/;"	m	class:cv::StarFeatureDetector	access:protected
start	contrib/contrib.hpp	/^        void start();$/;"	p	class:cv::TickMeter	access:public	signature:()
start	core/core.hpp	/^    int start, end;$/;"	m	class:cv::Range	access:public
start	flann/timer.h	/^    void start()$/;"	f	class:cvflann::StartStopTimer	access:public	signature:()
start	imgproc/imgproc.hpp	/^    virtual int start(Size wholeSize, Rect roi, int maxBufRows=-1);$/;"	p	class:cv::FilterEngine	access:public	signature:(Size wholeSize, Rect roi, int maxBufRows=-1)
start	imgproc/imgproc.hpp	/^    virtual int start(const Mat& src, const Rect& srcRoi=Rect(0,0,-1,-1),$/;"	p	class:cv::FilterEngine	access:public	signature:(const Mat& src, const Rect& srcRoi=Rect(0,0,-1,-1), bool isolated=false, int maxBufRows=-1)
start	imgproc/types_c.h	/^    CvPoint* start; \/* point of the contour where the defect begins *\/$/;"	m	struct:CvConvexityDefect	access:public
startDistanceBucket	contrib/contrib.hpp	/^        int startDistanceBucket;$/;"	m	class:cv::SelfSimDescriptor	access:public
startIdxs	features2d/features2d.hpp	/^        vector<int> startIdxs;$/;"	m	class:cv::DescriptorMatcher::DescriptorCollection	access:protected
startIndices	features2d/features2d.hpp	/^        vector<int> startIndices;$/;"	m	class:cv::GenericDescriptorMatcher::KeyPointCollection	access:protected
startLoop	highgui/highgui.hpp	/^CV_EXPORTS  int startLoop(int (*pt2Func)(int argc, char *argv[]), int argc, char* argv[]);$/;"	p	namespace:cv	signature:(int (*pt2Func)(int argc, char *argv[]), int argc, char* argv[])
startTime	contrib/contrib.hpp	/^        int64 startTime;$/;"	m	class:cv::TickMeter	access:private
startTime	flann/timer.h	/^    clock_t startTime;$/;"	m	class:cvflann::StartStopTimer	access:private
startWindowThread	highgui/highgui.hpp	/^CV_EXPORTS_W int startWindowThread();$/;"	p	namespace:cv	signature:()
startY	imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
startY0	imgproc/imgproc.hpp	/^    int bufStep, startY, startY0, endY, rowCount, dstY;$/;"	m	class:cv::FilterEngine	access:public
start_index	core/types_c.h	/^    int  start_index, end_index;$/;"	m	struct:CvSlice	access:public
start_index	core/types_c.h	/^  int    start_index;         \/* Index of the first element in the block +  *\/$/;"	m	struct:CvSeqBlock	access:public
start_step	ml/ml.hpp	/^    CV_PROP_RW int start_step;$/;"	m	struct:CvEMParams	access:public
state	calib3d/calib3d.hpp	/^    Ptr<CvStereoBMState> state;$/;"	m	class:cv::StereoBM	access:public
state	calib3d/calib3d.hpp	/^    int state;$/;"	m	class:CvLevMarq	access:public
state	calib3d/calib3d.hpp	/^CVAPI(void) cvReleaseStereoBMState( CvStereoBMState** state );$/;"	v
state	calib3d/calib3d.hpp	/^CVAPI(void) cvReleaseStereoGCState( CvStereoGCState** state );$/;"	v
state	core/core.hpp	/^    int state; \/\/!< the writer state$/;"	m	class:cv::FileStorage	access:public
state	core/core.hpp	/^    uint64 state;$/;"	m	class:cv::RNG	access:public
state	legacy/compat.hpp	/^    CvRNG     state;    \/* RNG state (the current seed and carry)*\/$/;"	m	struct:CvRandState	access:public
state	legacy/legacy.hpp	/^        CvEHMMState* state; \/* if level == 0 points to real states array,$/;"	m	union:CvEHMM::__anon183	access:public
state	legacy/legacy.hpp	/^    int* state;\/* arr of pairs superstate\/state to which observation belong *\/$/;"	m	struct:CvImgObsInfo	access:public
statePost	video/tracking.hpp	/^    Mat statePost;          \/\/!< corrected state (x(k)): x(k)=x'(k)+K(k)*(z(k)-H*x'(k))$/;"	m	class:cv::KalmanFilter	access:public
statePre	video/tracking.hpp	/^    Mat statePre;           \/\/!< predicted state (x'(k)): x(k)=A*x(k-1)+B*u(k)$/;"	m	class:cv::KalmanFilter	access:public
state_post	video/tracking.hpp	/^    CvMat* state_post;          \/* corrected state (x(k)):$/;"	m	struct:CvKalman	access:public
state_pre	video/tracking.hpp	/^    CvMat* state_pre;           \/* predicted state (x'(k)):$/;"	m	struct:CvKalman	access:public
static_delete	flann/any.h	/^    virtual void static_delete(void** x) = 0;$/;"	p	struct:cdiggins::anyimpl::base_any_policy	access:public	signature:(void** x)
static_delete	flann/any.h	/^    virtual void static_delete(void** x)$/;"	f	struct:cdiggins::anyimpl::big_any_policy	access:public	signature:(void** x)
static_delete	flann/any.h	/^    virtual void static_delete(void**) { }$/;"	f	struct:cdiggins::anyimpl::small_any_policy	access:public	signature:(void**)
status	legacy/legacy.hpp	/^    int status;$/;"	m	struct:CvCliqueFinder	access:public
std_threshold	video/background_segm.hpp	/^    double  bg_threshold, std_threshold, minArea;$/;"	m	struct:CvGaussBGStatModelParams	access:public
step	calib3d/calib3d.hpp	/^    void step();$/;"	p	class:CvLevMarq	access:public	signature:()
step	core/core.hpp	/^    MStep step;$/;"	m	class:cv::Mat	access:public
step	core/core.hpp	/^    int step, elemSize;$/;"	m	class:cv::LineIterator	access:public
step	core/types_c.h	/^        int step;$/;"	m	struct:CvMatND::__anon155	access:public
step	core/types_c.h	/^    int step;$/;"	m	struct:CvMat	access:public
step	gpu/devmem2d.hpp	/^            size_t step;$/;"	m	struct:cv::gpu::DevMem2D_	access:public
step	gpu/devmem2d.hpp	/^            size_t step;$/;"	m	struct:cv::gpu::PtrStep_	access:public
step	gpu/gpu.hpp	/^            size_t step;$/;"	m	class:cv::gpu::CudaMem	access:public
step	gpu/gpumat.hpp	/^        size_t step;$/;"	m	class:cv::gpu::GpuMat	access:public
step	legacy/compat.hpp	/^    int     step;                   \/* distance between lines ( in elements of single   *\/$/;"	m	struct:_CvPixelPosition8u	access:public
step	legacy/compat.hpp	/^    int     step;$/;"	m	struct:_CvPixelPosition32f	access:public
step	legacy/compat.hpp	/^    int     step;$/;"	m	struct:_CvPixelPosition8s	access:public
step	legacy/legacy.hpp	/^    int step() const { return image ? image->widthStep : 0; }$/;"	f	class:CvImage	access:public	signature:() const
step	legacy/legacy.hpp	/^    int step() const { return matrix ? matrix->step : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
step	ml/ml.hpp	/^    CV_PROP_RW double step;$/;"	m	struct:CvParamGrid	access:public
step1	core/core.hpp	/^    size_t step1(int i=0) const;$/;"	p	class:cv::Mat	access:public	signature:(int i=0) const
step1	core/core.hpp	/^    size_t step1(int i=0) const;$/;"	p	class:cv::Mat_	access:public	signature:(int i=0) const
step1	core/mat.hpp	/^inline size_t Mat::step1(int i) const { return step.p[i]\/elemSize1(); }$/;"	f	class:cv::Mat	signature:(int i) const
step1	core/mat.hpp	/^template<typename _Tp> inline size_t Mat_<_Tp>::step1(int i) const { return step.p[i]\/elemSize1(); }$/;"	f	class:cv::Mat_	signature:(int i) const
step1	gpu/gpu.hpp	/^            size_t step1() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
step1	gpu/gpumat.hpp	/^        size_t step1() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
step1	gpu/gpumat.hpp	/^    inline size_t GpuMat::step1() const { return step\/elemSize1(); }$/;"	f	class:cv::gpu::GpuMat	signature:() const
step1	gpu/matrix_operations.hpp	/^inline size_t CudaMem::step1() const { return step\/elemSize1(); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
stepScale	features2d/features2d.hpp	/^        float minScale, maxScale, stepScale;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
stepT	core/core.hpp	/^    size_t stepT(int i=0) const;$/;"	p	class:cv::Mat_	access:public	signature:(int i=0) const
stepT	core/mat.hpp	/^template<typename _Tp> inline size_t Mat_<_Tp>::stepT(int i) const { return step.p[i]\/elemSize(); }$/;"	f	class:cv::Mat_	signature:(int i) const
step_arr	legacy/compat.hpp	/^    int     step_arr[3];            \/* array: ( 0, -step, step ). It is used for        *\/$/;"	m	struct:_CvPixelPosition8u	access:public
step_arr	legacy/compat.hpp	/^    int     step_arr[3];$/;"	m	struct:_CvPixelPosition32f	access:public
step_arr	legacy/compat.hpp	/^    int     step_arr[3];$/;"	m	struct:_CvPixelPosition8s	access:public
stereo	legacy/legacy.hpp	/^    CvStereoCamera stereo;$/;"	m	class:CvCalibFilter	access:protected
stereoCalibrate	calib3d/calib3d.hpp	/^CV_EXPORTS_W double stereoCalibrate( InputArrayOfArrays objectPoints,$/;"	p	namespace:cv	signature:( InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, CV_OUT InputOutputArray cameraMatrix1, CV_OUT InputOutputArray distCoeffs1, CV_OUT InputOutputArray cameraMatrix2, CV_OUT InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, TermCriteria criteria = TermCriteria(TermCriteria::COUNT+ TermCriteria::EPS, 30, 1e-6), int flags=CALIB_FIX_INTRINSIC )
stereoCamera	legacy/legacy.hpp	/^CVAPI(int) icvComputeCoeffForStereo(  CvStereoCamera* stereoCamera);$/;"	v
stereoCamera	legacy/legacy.hpp	/^CVAPI(void) icvComputeStereoParamsForCameras(CvStereoCamera* stereoCamera);$/;"	v
stereoCamera	legacy/legacy.hpp	/^CVAPI(void) icvGetQuadsTransformStruct(  CvStereoCamera* stereoCamera);$/;"	v
stereoRectify	calib3d/calib3d.hpp	/^CV_EXPORTS void stereoRectify( InputArray cameraMatrix1, InputArray distCoeffs1,$/;"	p	namespace:cv	signature:( InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags=CALIB_ZERO_DISPARITY, double alpha=-1, Size newImageSize=Size(), CV_OUT Rect* validPixROI1=0, CV_OUT Rect* validPixROI2=0 )
stereoRectifyUncalibrated	calib3d/calib3d.hpp	/^CV_EXPORTS_W bool stereoRectifyUncalibrated( InputArray points1, InputArray points2,$/;"	p	namespace:cv	signature:( InputArray points1, InputArray points2, InputArray F, Size imgSize, OutputArray H1, OutputArray H2, double threshold=5 )
stereoparams	legacy/legacy.hpp	/^CVAPI(int) icvComputeRestStereoParams(CvStereoCamera *stereoparams);$/;"	v
stop	contrib/contrib.hpp	/^        void stop();$/;"	p	class:cv::TickMeter	access:public	signature:()
stop	flann/timer.h	/^    void stop()$/;"	f	class:cvflann::StartStopTimer	access:public	signature:()
stopLoop	highgui/highgui.hpp	/^CV_EXPORTS  void stopLoop();$/;"	p	namespace:cv	signature:()
storage	core/core_c.h	/^CVAPI(void)  cvClearMemStorage( CvMemStorage* storage );$/;"	v
storage	core/core_c.h	/^CVAPI(void)  cvReleaseMemStorage( CvMemStorage** storage );$/;"	v
storage	legacy/legacy.hpp	/^    CvMemStorage* storage;$/;"	m	class:CvCalibFilter	access:protected
storage	ml/ml.hpp	/^    CvMemStorage* storage;$/;"	m	class:CvSVM	access:protected
storage	ml/ml.hpp	/^    CvMemStorage* storage;$/;"	m	class:CvSVMSolver	access:public
storage	video/background_segm.hpp	/^    CvMemStorage* storage;$/;"	m	struct:CvBGCodeBookModel	access:public
str	core/types_c.h	/^        CvString str; \/* text string *\/$/;"	m	union:CvFileNode::__anon157	access:public
str	core/types_c.h	/^    CvString str;$/;"	m	struct:CvStringHashNode	access:public
str_to_flt_elem	ml/ml.hpp	/^    void str_to_flt_elem( const char* token, float& flt_elem, int& type);$/;"	p	class:CvMLData	access:protected	signature:( const char* token, float& flt_elem, int& type)
strdup	legacy/blobtrack.hpp	56;"	d
stream	flann/logger.h	/^    FILE* stream;$/;"	m	class:cvflann::Logger	access:private
stricmp	legacy/blobtrack.hpp	57;"	d
stride	flann/matrix.h	/^    size_t stride;$/;"	m	class:cvflann::Matrix	access:public
stride	gpu/NCV.hpp	/^    Ncv32u stride() const$/;"	f	class:NCVMatrix	access:public	signature:() const
structSize	features2d/features2d.hpp	/^        int structSize;$/;"	m	class:cv::FernDescriptorMatcher::Params	access:public
structSize	features2d/features2d.hpp	/^    int structSize;$/;"	m	class:cv::FernClassifier	access:protected
structs	core/core.hpp	/^    vector<char> structs; \/\/!< the stack of written structures$/;"	m	class:cv::FileStorage	access:public
subdiv	imgproc/imgproc_c.h	/^CVAPI(void)  cvCalcSubdivVoronoi2D( CvSubdiv2D* subdiv );$/;"	v
subdiv	imgproc/imgproc_c.h	/^CVAPI(void)  cvClearSubdivVoronoi2D( CvSubdiv2D* subdiv );$/;"	v
subdiv	legacy/legacy.hpp	/^CVAPI(int)   icvSubdiv2DCheck( CvSubdiv2D* subdiv );$/;"	v
subsample_data	ml/ml.hpp	/^    virtual CvDTreeNode* subsample_data( const CvMat* _subsample_idx );$/;"	p	struct:CvDTreeTrainData	access:public	signature:( const CvMat* _subsample_idx )
subsample_data	ml/ml.hpp	/^    virtual CvDTreeNode* subsample_data( const CvMat* _subsample_idx );$/;"	p	struct:CvERTreeTrainData	access:public	signature:( const CvMat* _subsample_idx )
subsample_mask	ml/ml.hpp	/^    CvMat* subsample_mask;$/;"	m	class:CvBoost	access:protected
subsample_portion	ml/ml.hpp	/^    CV_PROP_RW float subsample_portion;$/;"	m	struct:CvGBTreesParams	access:public
subsample_test	ml/ml.hpp	/^    CvMat* subsample_test;$/;"	m	class:CvGBTrees	access:protected
subsample_train	ml/ml.hpp	/^    CvMat* subsample_train;$/;"	m	class:CvGBTrees	access:protected
subscribe	flann/object_factory.h	/^    bool subscribe(UniqueIdType id, ObjectCreator creator)$/;"	f	class:cvflann::ObjectFactory	access:public	signature:(UniqueIdType id, ObjectCreator creator)
subset	contrib/contrib.hpp	/^        vector<int> subset;$/;"	m	class:cv::SpinImageModel	access:protected
subset	ml/ml.hpp	/^        int subset[2];$/;"	m	union:CvDTreeSplit::__anon77	access:public
subsets	objdetect/objdetect.hpp	/^        vector<int> subsets;$/;"	m	class:cv::CascadeClassifier::Data	access:public
subtract	core/core.hpp	/^CV_EXPORTS_W void subtract(InputArray src1, InputArray src2, OutputArray dst,$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst, InputArray mask=noArray(), int dtype=-1)
subtract	core/mat.hpp	/^    virtual void subtract(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const
subtract	core/mat.hpp	/^    virtual void subtract(const Scalar& s, const MatExpr& expr, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const Scalar& s, const MatExpr& expr, MatExpr& res) const
subtract	gpu/gpu.hpp	/^        CV_EXPORTS void subtract(const GpuMat& a, const GpuMat& b, GpuMat& c, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const GpuMat& b, GpuMat& c, Stream& stream = Stream::Null())
subtract	gpu/gpu.hpp	/^        CV_EXPORTS void subtract(const GpuMat& a, const Scalar& sc, GpuMat& c, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& a, const Scalar& sc, GpuMat& c, Stream& stream = Stream::Null())
subtree_weights	ml/ml.hpp	/^    CvMat* subtree_weights;$/;"	m	class:CvBoost	access:protected
sum	core/core.hpp	/^CV_EXPORTS_AS(sumElems) Scalar sum(InputArray src); $/;"	p	namespace:cv	signature:(InputArray src)
sum	gpu/gpu.hpp	/^            GpuMat sum, mask1, maskSum, intBuffer;$/;"	m	class:cv::gpu::SURF_GPU	access:public
sum	gpu/gpu.hpp	/^        CV_EXPORTS Scalar sum(const GpuMat& src);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src)
sum	gpu/gpu.hpp	/^        CV_EXPORTS Scalar sum(const GpuMat& src, GpuMat& buf);$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& buf)
sum	ml/ml.hpp	/^    CvMat** sum;$/;"	m	class:CvNormalBayesClassifier	access:protected
sumTime	contrib/contrib.hpp	/^        int64 sumTime;$/;"	m	class:cv::TickMeter	access:private
sum_response	ml/ml.hpp	/^    CvMat* sum_response;$/;"	m	class:CvBoost	access:protected
sum_response	ml/ml.hpp	/^    CvMat* sum_response;$/;"	m	class:CvGBTrees	access:protected
sum_response_tmp	ml/ml.hpp	/^    CvMat* sum_response_tmp;$/;"	m	class:CvGBTrees	access:protected
supports	gpu/gpu.hpp	/^            bool supports(FeatureSet feature_set) const;$/;"	p	class:cv::gpu::DeviceInfo	access:public	signature:(FeatureSet feature_set) const
suppressNonmaxSize	features2d/features2d.hpp	/^    int suppressNonmaxSize;$/;"	m	struct:CvStarDetectorParams	access:public
surf	features2d/features2d.hpp	/^    SURF surf;$/;"	m	class:cv::SurfDescriptorExtractor	access:protected
surf	features2d/features2d.hpp	/^    SURF surf;$/;"	m	class:cv::SurfFeatureDetector	access:protected
sv	ml/ml.hpp	/^    float** sv;$/;"	m	class:CvSVM	access:protected
sv_count	ml/ml.hpp	/^    int sv_count;$/;"	m	struct:CvSVMDecisionFunc	access:public
sv_index	ml/ml.hpp	/^    int* sv_index;$/;"	m	struct:CvSVMDecisionFunc	access:public
sv_total	ml/ml.hpp	/^    int sv_total;$/;"	m	class:CvSVM	access:protected
svmDetector	objdetect/objdetect.hpp	/^    CV_PROP vector<float> svmDetector;$/;"	m	struct:cv::HOGDescriptor	access:public
svm_type	ml/ml.hpp	/^    CV_PROP_RW int         svm_type;$/;"	m	struct:CvSVMParams	access:public
swap	core/core.hpp	/^CV_EXPORTS void swap(Mat& a, Mat& b);$/;"	p	namespace:cv	signature:(Mat& a, Mat& b)
swap	flann/any.h	/^    any& swap(any& x)$/;"	f	struct:cdiggins::any	access:public	signature:(any& x)
swap	gpu/gpumat.hpp	/^        void swap(GpuMat& mat);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(GpuMat& mat)
swap	gpu/gpumat.hpp	/^    inline void swap(GpuMat& a, GpuMat& b) { a.swap(b); }$/;"	f	namespace:cv::gpu	signature:(GpuMat& a, GpuMat& b)
swapEdges	imgproc/imgproc.hpp	/^    void swapEdges( int edge );$/;"	p	class:cv::Subdiv2D	access:protected	signature:( int edge )
symEdge	imgproc/imgproc.hpp	/^    CV_WRAP int symEdge(int edge) const;$/;"	p	class:cv::Subdiv2D	access:public	signature:(int edge) const
sz	core/core.hpp	/^    Size sz;$/;"	m	class:cv::_InputArray	access:public
t	core/core.hpp	/^    MatExpr t() const;$/;"	p	class:cv::Mat	access:public	signature:() const
t	core/core.hpp	/^    Matx<_Tp, n, m> t() const;$/;"	p	class:cv::Matx	access:public	signature:() const
t	core/mat.hpp	/^    MatExpr t() const;$/;"	p	class:cv::MatExpr	access:public	signature:() const
t	core/operations.hpp	/^Matx<_Tp, n, m> Matx<_Tp, m, n>::t() const$/;"	f	class:cv::Matx	signature:() const
t	gpu/gpumat.hpp	/^        GpuMat t() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
t	video/background_segm.hpp	/^    int t;$/;"	m	struct:CvBGCodeBookModel	access:public
tLastUpdate	video/background_segm.hpp	/^    int tLastUpdate;$/;"	m	struct:CvBGCodeBookElem	access:public
table_color	gpu/gpu.hpp	/^            GpuMat table_color;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
table_number_	flann/lsh_index.h	/^    unsigned int table_number_;$/;"	m	class:cvflann::LshIndex	access:private
table_space	gpu/gpu.hpp	/^            GpuMat table_space;$/;"	m	class:cv::gpu::DisparityBilateralFilter	access:private
tables_	flann/lsh_index.h	/^    std::vector<lsh::LshTable<ElementType> > tables_;$/;"	m	class:cvflann::LshIndex	access:private
tag	core/types_c.h	/^    int tag;$/;"	m	struct:CvFileNode	access:public
target_precision_	flann/autotuned_index.h	/^    float target_precision_;$/;"	m	class:cvflann::AutotunedIndex	access:private
tell	core/core.hpp	/^    size_t tell() const;$/;"	p	class:cv::SeqIterator	access:public	signature:() const
tell	core/operations.hpp	/^template<typename _Tp> inline size_t SeqIterator<_Tp>::tell() const$/;"	f	class:cv::SeqIterator	signature:() const
temp	gpu/gpu.hpp	/^            GpuMat temp;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
temp1	video/tracking.hpp	/^    CvMat* temp1;               \/* temporary matrices *\/$/;"	m	struct:CvKalman	access:public
temp1	video/tracking.hpp	/^    Mat temp1;$/;"	m	class:cv::KalmanFilter	access:public
temp2	video/tracking.hpp	/^    CvMat* temp2;$/;"	m	struct:CvKalman	access:public
temp2	video/tracking.hpp	/^    Mat temp2;$/;"	m	class:cv::KalmanFilter	access:public
temp3	video/tracking.hpp	/^    CvMat* temp3;$/;"	m	struct:CvKalman	access:public
temp3	video/tracking.hpp	/^    Mat temp3;$/;"	m	class:cv::KalmanFilter	access:public
temp4	video/tracking.hpp	/^    CvMat* temp4;$/;"	m	struct:CvKalman	access:public
temp4	video/tracking.hpp	/^    Mat temp4;$/;"	m	class:cv::KalmanFilter	access:public
temp5	video/tracking.hpp	/^    CvMat* temp5;$/;"	m	struct:CvKalman	access:public
temp5	video/tracking.hpp	/^    Mat temp5;$/;"	m	class:cv::KalmanFilter	access:public
tempImg	legacy/legacy.hpp	/^    CvMat*  tempImg;$/;"	m	class:CvCalibFilter	access:protected
temp_storage	ml/ml.hpp	/^    CvMemStorage* temp_storage;$/;"	m	struct:CvDTreeTrainData	access:public
tempfile	core/core.hpp	/^CV_EXPORTS string tempfile( const char* suffix CV_DEFAULT(0));$/;"	p	namespace:cv	signature:( const char* suffix CV_DEFAULT(0))
templ_block	gpu/gpu.hpp	/^            GpuMat image_block, templ_block, result_data;$/;"	m	struct:cv::gpu::ConvolveBuf	access:private
templ_spect	gpu/gpu.hpp	/^            GpuMat image_spect, templ_spect, result_spect;$/;"	m	struct:cv::gpu::ConvolveBuf	access:private
term_crit	ml/ml.hpp	/^    CV_PROP_RW CvTermCriteria term_crit; \/\/ termination criteria$/;"	m	struct:CvSVMParams	access:public
term_crit	ml/ml.hpp	/^    CV_PROP_RW CvTermCriteria term_crit;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
term_crit	ml/ml.hpp	/^    CV_PROP_RW CvTermCriteria term_crit;$/;"	m	struct:CvEMParams	access:public
term_crit	ml/ml.hpp	/^    CV_PROP_RW CvTermCriteria term_crit;$/;"	m	struct:CvRTParams	access:public
termcrit	features2d/features2d.hpp	/^    TermCriteria termcrit;$/;"	m	class:cv::BOWKMeansTrainer	access:protected
test	flann/dynamic_bitset.h	/^    bool test(size_t index) const$/;"	f	class:DynamicBitset	access:public	signature:(size_t index) const
testDataset_	flann/autotuned_index.h	/^    Matrix<ElementType> testDataset_;$/;"	m	class:cvflann::AutotunedIndex	access:private
test_fn_	features2d/features2d.hpp	/^    PixelTestFn test_fn_;$/;"	m	class:cv::BriefDescriptorExtractor	access:protected
test_index_checks	flann/index_testing.h	/^float test_index_checks(NNIndex<Distance>& index, const Matrix<typename Distance::ElementType>& inputData,$/;"	f	namespace:cvflann	signature:(NNIndex<Distance>& index, const Matrix<typename Distance::ElementType>& inputData, const Matrix<typename Distance::ElementType>& testData, const Matrix<int>& matches, int checks, float& precision, const Distance& distance, int nn = 1, int skipMatches = 0)
test_index_precision	flann/index_testing.h	/^float test_index_precision(NNIndex<Distance>& index, const Matrix<typename Distance::ElementType>& inputData,$/;"	f	namespace:cvflann	signature:(NNIndex<Distance>& index, const Matrix<typename Distance::ElementType>& inputData, const Matrix<typename Distance::ElementType>& testData, const Matrix<int>& matches, float precision, int& checks, const Distance& distance, int nn = 1, int skipMatches = 0)
test_index_precisions	flann/index_testing.h	/^void test_index_precisions(NNIndex<Distance>& index, const Matrix<typename Distance::ElementType>& inputData,$/;"	f	namespace:cvflann	signature:(NNIndex<Distance>& index, const Matrix<typename Distance::ElementType>& inputData, const Matrix<typename Distance::ElementType>& testData, const Matrix<int>& matches, float* precisions, int precisions_length, const Distance& distance, int nn = 1, int skipMatches = 0, float maxTime = 0)
test_sample_idx	ml/ml.hpp	/^    CvMat* test_sample_idx;$/;"	m	class:CvMLData	access:protected
textureThreshold	calib3d/calib3d.hpp	/^    int textureThreshold;  \/\/ the disparity is only computed for pixels$/;"	m	struct:CvStereoBMState	access:public
tflag	ml/ml.hpp	/^    int tflag;$/;"	m	struct:CvDTreeTrainData	access:public
theRNG	core/core.hpp	/^CV_EXPORTS RNG& theRNG();$/;"	p	namespace:cv	signature:()
theta	features2d/features2d.hpp	/^    float theta;$/;"	m	class:cv::CvAffinePose	access:public
thetaMax	features2d/features2d.hpp	/^    double thetaMin, thetaMax;$/;"	m	class:cv::PatchGenerator	access:public
thetaMin	features2d/features2d.hpp	/^    double thetaMin, thetaMax;$/;"	m	class:cv::PatchGenerator	access:public
thickness	core/core_c.h	/^    int         thickness; 		\/\/Qt: weight               \/* letters thickness *\/$/;"	m	struct:CvFont	access:public
thresh	core/types_c.h	/^    float   thresh[CV_MAX_DIM][2];  \/* For uniform histograms.                      *\/$/;"	m	struct:CvHistogram	access:public
thresh2	core/types_c.h	/^    float** thresh2;                \/* For non-uniform histograms.                  *\/$/;"	m	struct:CvHistogram	access:public
thresh_	features2d/features2d.hpp	/^    double thresh_, init_thresh_, min_thresh_, max_thresh_;$/;"	m	class:cv::StarAdjuster	access:protected
thresh_	features2d/features2d.hpp	/^    double thresh_, init_thresh_, min_thresh_, max_thresh_;$/;"	m	class:cv::SurfAdjuster	access:protected
thresh_	features2d/features2d.hpp	/^    int thresh_;$/;"	m	class:cv::FastAdjuster	access:protected
threshold	features2d/features2d.hpp	/^        double threshold, edgeThreshold;$/;"	m	struct:cv::SIFT::DetectorParams	access:public
threshold	features2d/features2d.hpp	/^    int threshold;$/;"	m	class:cv::FastFeatureDetector	access:protected
threshold	features2d/features2d.hpp	/^    int threshold;$/;"	m	class:cv::LDetector	access:public
threshold	gpu/gpu.hpp	/^        CV_EXPORTS double threshold(const GpuMat& src, GpuMat& dst, double thresh, double maxval, int type, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, double thresh, double maxval, int type, Stream& stream = Stream::Null())
threshold	imgproc/imgproc.hpp	/^CV_EXPORTS_W double threshold( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, double thresh, double maxval, int type )
threshold	objdetect/objdetect.hpp	/^            float threshold; \/\/ for ordered features only$/;"	m	struct:cv::CascadeClassifier::Data::DTreeNode	access:public
threshold	objdetect/objdetect.hpp	/^            float threshold;$/;"	m	struct:cv::CascadeClassifier::Data::Stage	access:public
threshold	objdetect/objdetect.hpp	/^    float threshold;$/;"	m	struct:CvHaarStageClassifier	access:public
threshold	objdetect/objdetect.hpp	/^    float* threshold;$/;"	m	struct:CvHaarClassifier	access:public
thresholdStep	features2d/features2d.hpp	/^      float thresholdStep;$/;"	m	struct:cv::SimpleBlobDetector::Params	access:public
threshold_L2hys	gpu/gpu.hpp	/^            double threshold_L2hys;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
tileInfo	core/types_c.h	/^    struct _IplTileInfo *tileInfo;  \/* "           " *\/$/;"	m	struct:_IplImage	typeref:struct:_IplImage::_IplTileInfo	access:public
tilted	objdetect/objdetect.hpp	/^    int tilted;$/;"	m	struct:CvHaarFeature	access:public
tl	core/core.hpp	/^    Point_<_Tp> tl() const;$/;"	p	class:cv::Rect_	access:public	signature:() const
tl	core/operations.hpp	/^template<typename _Tp> inline Point_<_Tp> Rect_<_Tp>::tl() const { return Point_<_Tp>(x,y); }$/;"	f	class:cv::Rect_	signature:() const
toUtf16	core/core.hpp	/^CV_EXPORTS WString toUtf16(const string& str);$/;"	p	namespace:cv	signature:(const string& str)
tooFew	features2d/features2d.hpp	/^    virtual void tooFew(int min, int n_detected) = 0;$/;"	p	class:cv::AdjusterAdapter	access:public	signature:(int min, int n_detected)
tooFew	features2d/features2d.hpp	/^    virtual void tooFew(int min, int n_detected);$/;"	p	class:cv::FastAdjuster	access:public	signature:(int min, int n_detected)
tooFew	features2d/features2d.hpp	/^    virtual void tooFew(int min, int n_detected);$/;"	p	class:cv::StarAdjuster	access:public	signature:(int min, int n_detected)
tooFew	features2d/features2d.hpp	/^    virtual void tooFew(int min, int n_detected);$/;"	p	class:cv::SurfAdjuster	access:public	signature:(int min, int n_detected)
tooMany	features2d/features2d.hpp	/^    virtual void tooMany(int max, int n_detected) = 0;$/;"	p	class:cv::AdjusterAdapter	access:public	signature:(int max, int n_detected)
tooMany	features2d/features2d.hpp	/^    virtual void tooMany(int max, int n_detected);$/;"	p	class:cv::FastAdjuster	access:public	signature:(int max, int n_detected)
tooMany	features2d/features2d.hpp	/^    virtual void tooMany(int max, int n_detected);$/;"	p	class:cv::StarAdjuster	access:public	signature:(int max, int n_detected)
tooMany	features2d/features2d.hpp	/^    virtual void tooMany(int max, int n_detected);$/;"	p	class:cv::SurfAdjuster	access:public	signature:(int max, int n_detected)
top	core/types_c.h	/^    CvMemBlock* top;              \/* Current memory block - top of the stack. *\/$/;"	m	struct:CvMemStorage	access:public
top	core/types_c.h	/^    CvMemBlock* top;$/;"	m	struct:CvMemStoragePos	access:public
topLeft	imgproc/imgproc.hpp	/^    Point2f topLeft;$/;"	m	class:cv::Subdiv2D	access:protected
topline	legacy/compat.hpp	/^    float*  topline;$/;"	m	struct:_CvPixelPosition32f	access:public
topline	legacy/compat.hpp	/^    schar*  topline;$/;"	m	struct:_CvPixelPosition8s	access:public
topline	legacy/compat.hpp	/^    uchar*  topline;       \/* pointer to the start of the top pixel line       *\/$/;"	m	struct:_CvPixelPosition8u	access:public
total	core/core.hpp	/^    size_t total() const;$/;"	p	class:cv::Mat	access:public	signature:() const
total	core/core.hpp	/^    virtual size_t total(int i=-1) const;$/;"	p	class:cv::_InputArray	access:public	signature:(int i=-1) const
total	core/mat.hpp	/^inline size_t Mat::total() const$/;"	f	class:cv::Mat	signature:() const
total	ml/ml.hpp	/^    int total;$/;"	m	class:CvKNearest	access:protected
totalCost	flann/autotuned_index.h	/^        float totalCost;$/;"	m	struct:cvflann::AutotunedIndex::CostData	access:public
totalMemory	gpu/gpu.hpp	/^            size_t totalMemory() const;$/;"	p	class:cv::gpu::DeviceInfo	access:public	signature:() const
total_class_count	ml/ml.hpp	/^    int total_class_count;$/;"	m	class:CvMLData	access:protected
trace	core/core.hpp	/^CV_EXPORTS_W Scalar trace(InputArray mtx);$/;"	p	namespace:cv	signature:(InputArray mtx)
trace	core/operations.hpp	/^double trace(const Matx<_Tp, m, n>& a)$/;"	f	namespace:cv	signature:(const Matx<_Tp, m, n>& a)
trace	gpu/gpu.hpp	/^            GpuMat det, trace;$/;"	m	class:cv::gpu::SURF_GPU	access:public
track	contrib/contrib.hpp	/^    void track(IplImage *maskImage, IplImage *depthMap, int resizeMethod, bool resetSearch, int minKernelMass = MinKernelMass);$/;"	p	class:CvFuzzyMeanShiftTracker	access:public	signature:(IplImage *maskImage, IplImage *depthMap, int resizeMethod, bool resetSearch, int minKernelMass = MinKernelMass)
trackBuf1	gpu/gpu.hpp	/^            GpuMat trackBuf1, trackBuf2;$/;"	m	struct:cv::gpu::CannyBuf	access:public
trackBuf2	gpu/gpu.hpp	/^            GpuMat trackBuf1, trackBuf2;$/;"	m	struct:cv::gpu::CannyBuf	access:public
track_object	legacy/legacy.hpp	/^    virtual bool  track_object( const IplImage* cur_frame );$/;"	p	class:CvCamShiftTracker	access:public	signature:( const IplImage* cur_frame )
train	features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::DescriptorMatcher	access:public	signature:()
train	features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:()
train	features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:()
train	features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:()
train	features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:()
train	features2d/features2d.hpp	/^    virtual void train();$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:()
train	features2d/features2d.hpp	/^    virtual void train(const vector<vector<Point2f> >& points,$/;"	p	class:cv::FernClassifier	access:public	signature:(const vector<vector<Point2f> >& points, const vector<Mat>& refimgs, const vector<vector<int> >& labels=vector<vector<int> >(), int _nclasses=0, int _patchSize=PATCH_SIZE, int _signatureSize=DEFAULT_SIGNATURE_SIZE, int _nstructs=DEFAULT_STRUCTS, int _structSize=DEFAULT_STRUCT_SIZE, int _nviews=DEFAULT_VIEWS, int _compressionMethod=COMPRESSION_NONE, const PatchGenerator& patchGenerator=PatchGenerator())
train	features2d/features2d.hpp	/^  void train(std::vector<BaseKeypoint> const& base_set, RNG &rng,$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::vector<BaseKeypoint> const& base_set, RNG &rng, PatchGenerator &make_patch, int depth, int views, size_t reduced_num_dim, int num_quant_bits)
train	features2d/features2d.hpp	/^  void train(std::vector<BaseKeypoint> const& base_set, RNG &rng,$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::vector<BaseKeypoint> const& base_set, RNG &rng, int depth, int views, size_t reduced_num_dim, int num_quant_bits)
train	features2d/features2d.hpp	/^  void train(std::vector<BaseKeypoint> const& base_set,$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::vector<BaseKeypoint> const& base_set, RNG &rng, PatchGenerator &make_patch, int num_trees = RTreeClassifier::DEFAULT_TREES, int depth = RandomizedTree::DEFAULT_DEPTH, int views = RandomizedTree::DEFAULT_VIEWS, size_t reduced_num_dim = RandomizedTree::DEFAULT_REDUCED_NUM_DIM, int num_quant_bits = DEFAULT_NUM_QUANT_BITS)
train	features2d/features2d.hpp	/^  void train(std::vector<BaseKeypoint> const& base_set,$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::vector<BaseKeypoint> const& base_set, RNG &rng, int num_trees = RTreeClassifier::DEFAULT_TREES, int depth = RandomizedTree::DEFAULT_DEPTH, int views = RandomizedTree::DEFAULT_VIEWS, size_t reduced_num_dim = RandomizedTree::DEFAULT_REDUCED_NUM_DIM, int num_quant_bits = DEFAULT_NUM_QUANT_BITS)
train	ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& samples,$/;"	p	class:CvEM	access:public	signature:( const cv::Mat& samples, const cv::Mat& sampleIdx=cv::Mat(), CvEMParams params=CvEMParams(), CV_OUT cv::Mat* labels=0 )
train	ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvKNearest	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& sampleIdx=cv::Mat(), bool isRegression=false, int maxK=32, bool updateBase=false )
train	ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& varIdx = cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), bool update=false )
train	ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvSVM	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), CvSVMParams params=CvSVMParams() )
train	ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, int tflag,$/;"	p	class:CvBoost	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvBoostParams params=CvBoostParams(), bool update=false )
train	ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, int tflag,$/;"	p	class:CvDTree	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvDTreeParams params=CvDTreeParams() )
train	ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, int tflag,$/;"	p	class:CvERTrees	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvRTParams params=CvRTParams())
train	ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, int tflag,$/;"	p	class:CvGBTrees	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvGBTreesParams params=CvGBTreesParams(), bool update=false )
train	ml/ml.hpp	/^    CV_WRAP virtual bool train( const cv::Mat& trainData, int tflag,$/;"	p	class:CvRTrees	access:public	signature:( const cv::Mat& trainData, int tflag, const cv::Mat& responses, const cv::Mat& varIdx=cv::Mat(), const cv::Mat& sampleIdx=cv::Mat(), const cv::Mat& varType=cv::Mat(), const cv::Mat& missingDataMask=cv::Mat(), CvRTParams params=CvRTParams() )
train	ml/ml.hpp	/^    CV_WRAP virtual int train( const cv::Mat& inputs, const cv::Mat& outputs,$/;"	p	class:CvANN_MLP	access:public	signature:( const cv::Mat& inputs, const cv::Mat& outputs, const cv::Mat& sampleWeights, const cv::Mat& sampleIdx=cv::Mat(), CvANN_MLP_TrainParams params = CvANN_MLP_TrainParams(), int flags=0 )
train	ml/ml.hpp	/^    virtual bool train( CvDTreeTrainData* trainData, const CvMat* _subsample_idx );$/;"	p	class:CvBoostTree	access:public	signature:( CvDTreeTrainData* trainData, const CvMat* _subsample_idx )
train	ml/ml.hpp	/^    virtual bool train( CvDTreeTrainData* trainData, const CvMat* _subsample_idx );$/;"	p	class:CvForestTree	access:public	signature:( CvDTreeTrainData* trainData, const CvMat* _subsample_idx )
train	ml/ml.hpp	/^    virtual bool train( CvDTreeTrainData* trainData, const CvMat* _subsample_idx, CvRTrees* forest );$/;"	p	class:CvForestTree	access:public	signature:( CvDTreeTrainData* trainData, const CvMat* _subsample_idx, CvRTrees* forest )
train	ml/ml.hpp	/^    virtual bool train( CvDTreeTrainData* trainData, const CvMat* subsampleIdx );$/;"	p	class:CvDTree	access:public	signature:( CvDTreeTrainData* trainData, const CvMat* subsampleIdx )
train	ml/ml.hpp	/^    virtual bool train( CvDTreeTrainData* trainData,$/;"	p	class:CvBoostTree	access:public	signature:( CvDTreeTrainData* trainData, const CvMat* subsample_idx, CvBoost* ensemble )
train	ml/ml.hpp	/^    virtual bool train( CvMLData* data, CvRTParams params=CvRTParams() );$/;"	p	class:CvERTrees	access:public	signature:( CvMLData* data, CvRTParams params=CvRTParams() )
train	ml/ml.hpp	/^    virtual bool train( CvMLData* data, CvRTParams params=CvRTParams() );$/;"	p	class:CvRTrees	access:public	signature:( CvMLData* data, CvRTParams params=CvRTParams() )
train	ml/ml.hpp	/^    virtual bool train( CvMLData* data,$/;"	p	class:CvBoost	access:public	signature:( CvMLData* data, CvBoostParams params=CvBoostParams(), bool update=false )
train	ml/ml.hpp	/^    virtual bool train( CvMLData* data,$/;"	p	class:CvGBTrees	access:public	signature:( CvMLData* data, CvGBTreesParams params=CvGBTreesParams(), bool update=false )
train	ml/ml.hpp	/^    virtual bool train( CvMLData* trainData, CvDTreeParams params=CvDTreeParams() );$/;"	p	class:CvDTree	access:public	signature:( CvMLData* trainData, CvDTreeParams params=CvDTreeParams() )
train	ml/ml.hpp	/^    virtual bool train( const CvMat* samples, const CvMat* sampleIdx=0,$/;"	p	class:CvEM	access:public	signature:( const CvMat* samples, const CvMat* sampleIdx=0, CvEMParams params=CvEMParams(), CvMat* labels=0 )
train	ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvKNearest	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* sampleIdx=0, bool is_regression=false, int maxK=32, bool updateBase=false )
train	ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* varIdx = 0, const CvMat* sampleIdx=0, bool update=false )
train	ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvSVM	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, CvSVMParams params=CvSVMParams() )
train	ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvBoost	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvBoostParams params=CvBoostParams(), bool update=false )
train	ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvBoostTree	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvDTreeParams params=CvDTreeParams() )
train	ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvDTree	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvDTreeParams params=CvDTreeParams() )
train	ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvERTrees	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvRTParams params=CvRTParams())
train	ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvForestTree	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvDTreeParams params=CvDTreeParams() )
train	ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvGBTrees	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvGBTreesParams params=CvGBTreesParams(), bool update=false )
train	ml/ml.hpp	/^    virtual bool train( const CvMat* trainData, int tflag,$/;"	p	class:CvRTrees	access:public	signature:( const CvMat* trainData, int tflag, const CvMat* responses, const CvMat* varIdx=0, const CvMat* sampleIdx=0, const CvMat* varType=0, const CvMat* missingDataMask=0, CvRTParams params=CvRTParams() )
train	ml/ml.hpp	/^    virtual int train( const CvMat* inputs, const CvMat* outputs,$/;"	p	class:CvANN_MLP	access:public	signature:( const CvMat* inputs, const CvMat* outputs, const CvMat* sampleWeights, const CvMat* sampleIdx=0, CvANN_MLP_TrainParams params = CvANN_MLP_TrainParams(), int flags=0 )
train	objdetect/objdetect.hpp	/^    virtual void train(const vector<Mat>& pyr, const vector<KeyPoint>& keypoints,$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const vector<Mat>& pyr, const vector<KeyPoint>& keypoints, int _patchSize=FernClassifier::PATCH_SIZE, int _nstructs=FernClassifier::DEFAULT_STRUCTS, int _structSize=FernClassifier::DEFAULT_STRUCT_SIZE, int _nviews=FernClassifier::DEFAULT_VIEWS, const LDetector& detector=LDetector(), const PatchGenerator& patchGenerator=PatchGenerator())
train	objdetect/objdetect.hpp	/^    virtual void train(const vector<Mat>& pyr, int _npoints=300,$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(const vector<Mat>& pyr, int _npoints=300, int _patchSize=FernClassifier::PATCH_SIZE, int _nstructs=FernClassifier::DEFAULT_STRUCTS, int _structSize=FernClassifier::DEFAULT_STRUCT_SIZE, int _nviews=FernClassifier::DEFAULT_VIEWS, const LDetector& detector=LDetector(), const PatchGenerator& patchGenerator=PatchGenerator())
train1	ml/ml.hpp	/^    virtual bool train1( int sample_count, int var_count, const float** samples,$/;"	p	class:CvSVM	access:protected	signature:( int sample_count, int var_count, const float** samples, const void* responses, double Cp, double Cn, CvMemStorage* _storage, double* alpha, double& rho )
trainDescCollection	features2d/features2d.hpp	/^    vector<Mat> trainDescCollection;$/;"	m	class:cv::DescriptorMatcher	access:protected
trainDescCollection	gpu/gpu.hpp	/^            std::vector<GpuMat> trainDescCollection;$/;"	m	class:cv::gpu::BruteForceMatcher_GPU_base	access:private
trainFernClassifier	features2d/features2d.hpp	/^    void trainFernClassifier();$/;"	p	class:cv::FernDescriptorMatcher	access:protected	signature:()
trainFromSingleView	features2d/features2d.hpp	/^    virtual void trainFromSingleView(const Mat& image,$/;"	p	class:cv::FernClassifier	access:public	signature:(const Mat& image, const vector<KeyPoint>& keypoints, int _patchSize=PATCH_SIZE, int _signatureSize=DEFAULT_SIGNATURE_SIZE, int _nstructs=DEFAULT_STRUCTS, int _structSize=DEFAULT_STRUCT_SIZE, int _nviews=DEFAULT_VIEWS, int _compressionMethod=COMPRESSION_NONE, const PatchGenerator& patchGenerator=PatchGenerator())
trainIdx	features2d/features2d.hpp	/^    int trainIdx; \/\/ train descriptor index$/;"	m	struct:cv::DMatch	access:public
trainImagesList	features2d/features2d.hpp	/^        string trainImagesList;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
trainPath	features2d/features2d.hpp	/^        string trainPath;$/;"	m	class:cv::OneWayDescriptorMatcher::Params	access:public
trainPointCollection	features2d/features2d.hpp	/^    KeyPointCollection trainPointCollection;$/;"	m	class:cv::GenericDescriptorMatcher	access:protected
train_auto	ml/ml.hpp	/^    CV_WRAP virtual bool train_auto( const cv::Mat& trainData, const cv::Mat& responses,$/;"	p	class:CvSVM	access:public	signature:( const cv::Mat& trainData, const cv::Mat& responses, const cv::Mat& varIdx, const cv::Mat& sampleIdx, CvSVMParams params, int k_fold = 10, CvParamGrid Cgrid = CvSVM::get_default_grid(CvSVM::C), CvParamGrid gammaGrid = CvSVM::get_default_grid(CvSVM::GAMMA), CvParamGrid pGrid = CvSVM::get_default_grid(CvSVM::P), CvParamGrid nuGrid = CvSVM::get_default_grid(CvSVM::NU), CvParamGrid coeffGrid = CvSVM::get_default_grid(CvSVM::COEF), CvParamGrid degreeGrid = CvSVM::get_default_grid(CvSVM::DEGREE), bool balanced=false)
train_auto	ml/ml.hpp	/^    virtual bool train_auto( const CvMat* trainData, const CvMat* responses,$/;"	p	class:CvSVM	access:public	signature:( const CvMat* trainData, const CvMat* responses, const CvMat* varIdx, const CvMat* sampleIdx, CvSVMParams params, int kfold = 10, CvParamGrid Cgrid = get_default_grid(CvSVM::C), CvParamGrid gammaGrid = get_default_grid(CvSVM::GAMMA), CvParamGrid pGrid = get_default_grid(CvSVM::P), CvParamGrid nuGrid = get_default_grid(CvSVM::NU), CvParamGrid coeffGrid = get_default_grid(CvSVM::COEF), CvParamGrid degreeGrid = get_default_grid(CvSVM::DEGREE), bool balanced=false )
train_backprop	ml/ml.hpp	/^    virtual int train_backprop( CvVectors _ivecs, CvVectors _ovecs, const double* _sw );$/;"	p	class:CvANN_MLP	access:protected	signature:( CvVectors _ivecs, CvVectors _ovecs, const double* _sw )
train_data	ml/ml.hpp	/^    const CvMat* train_data;$/;"	m	struct:CvDTreeTrainData	access:public
train_method	ml/ml.hpp	/^    CV_PROP_RW int train_method;$/;"	m	struct:CvANN_MLP_TrainParams	access:public
train_rprop	ml/ml.hpp	/^    virtual int train_rprop( CvVectors _ivecs, CvVectors _ovecs, const double* _sw );$/;"	p	class:CvANN_MLP	access:protected	signature:( CvVectors _ivecs, CvVectors _ovecs, const double* _sw )
train_sample_count	ml/ml.hpp	/^    int train_sample_count;$/;"	m	class:CvMLData	access:protected
train_sample_idx	ml/ml.hpp	/^    CvMat* train_sample_idx;$/;"	m	class:CvMLData	access:protected
train_sample_part	ml/ml.hpp	/^    } train_sample_part;$/;"	m	struct:CvTrainTestSplit	typeref:union:CvTrainTestSplit::__anon85	access:public
train_sample_part_mode	ml/ml.hpp	/^    int train_sample_part_mode;$/;"	m	struct:CvTrainTestSplit	access:public
transP	legacy/legacy.hpp	/^    float*  transP;\/*transition probab. matrices for states *\/$/;"	m	struct:CvEHMM	access:public
transVect	legacy/legacy.hpp	/^    float   transVect[3]; \/* rotation matrix and transition vector relatively$/;"	m	struct:CvCamera	access:public
transVector	legacy/legacy.hpp	/^    float transVector[3];$/;"	m	struct:CvStereoCamera	access:public
transform	core/core.hpp	/^CV_EXPORTS_W void transform(InputArray src, OutputArray dst, InputArray m );$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst, InputArray m )
transformPoints	gpu/gpu.hpp	/^        CV_EXPORTS void transformPoints(const GpuMat& src, const Mat& rvec, const Mat& tvec,$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, const Mat& rvec, const Mat& tvec, GpuMat& dst, Stream& stream = Stream::Null())
transitionMatrix	video/tracking.hpp	/^    Mat transitionMatrix;   \/\/!< state transition matrix (A)$/;"	m	class:cv::KalmanFilter	access:public
transition_matrix	video/tracking.hpp	/^    CvMat* transition_matrix;   \/* state transition matrix (A) *\/$/;"	m	struct:CvKalman	access:public
transpose	core/core.hpp	/^CV_EXPORTS_W void transpose(InputArray src, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst)
transpose	core/mat.hpp	/^    virtual void transpose(const MatExpr& expr, MatExpr& res) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr, MatExpr& res) const
transpose	gpu/gpu.hpp	/^        CV_EXPORTS void transpose(const GpuMat& src1, GpuMat& dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src1, GpuMat& dst, Stream& stream = Stream::Null())
tree_error	ml/ml.hpp	/^    double node_risk, tree_risk, tree_error;$/;"	m	struct:CvDTreeNode	access:public
tree_iterator	core/core_c.h	/^CVAPI(void*) cvNextTreeNode( CvTreeNodeIterator* tree_iterator );$/;"	v
tree_iterator	core/core_c.h	/^CVAPI(void*) cvPrevTreeNode( CvTreeNodeIterator* tree_iterator );$/;"	v
tree_risk	ml/ml.hpp	/^    double node_risk, tree_risk, tree_error;$/;"	m	struct:CvDTreeNode	access:public
tree_roots_	flann/kdtree_index.h	/^    NodePtr* tree_roots_;$/;"	m	class:cvflann::KDTreeIndex	access:private
tree_storage	ml/ml.hpp	/^    CvMemStorage* tree_storage;$/;"	m	struct:CvDTreeTrainData	access:public
trees	ml/ml.hpp	/^    CvForestTree** trees;$/;"	m	class:CvRTrees	access:protected
trees_	features2d/features2d.hpp	/^  std::vector<RandomizedTree> trees_;$/;"	m	class:cv::RTreeClassifier	access:public
trees_	flann/hierarchical_clustering_index.h	/^    int trees_;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
trees_	flann/kdtree_index.h	/^    int trees_;$/;"	m	class:cvflann::KDTreeIndex	access:private
trim_weights	ml/ml.hpp	/^    virtual void trim_weights();$/;"	p	class:CvBoost	access:protected	signature:()
truncate_pruned_tree	ml/ml.hpp	/^    CV_PROP_RW bool  truncate_pruned_tree;$/;"	m	struct:CvDTreeParams	access:public
trySmallerWindows	calib3d/calib3d.hpp	/^    int trySmallerWindows; \/\/ if 1, the results may be more accurate,$/;"	m	struct:CvStereoBMState	access:public
try_split_node	ml/ml.hpp	/^    virtual void try_split_node( CvDTreeNode* n );$/;"	p	class:CvBoostTree	access:protected	signature:( CvDTreeNode* n )
try_split_node	ml/ml.hpp	/^    virtual void try_split_node( CvDTreeNode* n );$/;"	p	class:CvDTree	access:protected	signature:( CvDTreeNode* n )
tsDisabled	contrib/contrib.hpp	/^        tsDisabled      = 10$/;"	e	enum:CvFuzzyMeanShiftTracker::TrackingState
tsNone	contrib/contrib.hpp	/^        tsNone          = 0,$/;"	e	enum:CvFuzzyMeanShiftTracker::TrackingState
tsSearching	contrib/contrib.hpp	/^        tsSearching     = 1,$/;"	e	enum:CvFuzzyMeanShiftTracker::TrackingState
tsSetWindow	contrib/contrib.hpp	/^        tsSetWindow     = 3,$/;"	e	enum:CvFuzzyMeanShiftTracker::TrackingState
tsTracking	contrib/contrib.hpp	/^        tsTracking      = 2,$/;"	e	enum:CvFuzzyMeanShiftTracker::TrackingState
type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon116
type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon117
type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon118
type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon119
type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon120
type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon121
type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon122
type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon123
type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon124
type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon125
type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon126
type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon127
type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon128
type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon129
type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon130
type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon131
type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon132
type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon133
type	core/core.hpp	/^           type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::Matx::__anon113
type	core/core.hpp	/^        type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::DataType::__anon115
type	core/core.hpp	/^    CV_WRAP int type() const;$/;"	p	class:cv::FileNode	access:public	signature:() const
type	core/core.hpp	/^    enum { depth = DataDepth<_Tp>::value, channels = cn, type = CV_MAKETYPE(depth, channels) };$/;"	e	enum:cv::Vec::__anon114
type	core/core.hpp	/^    int type() const;$/;"	p	class:cv::Mat	access:public	signature:() const
type	core/core.hpp	/^    int type() const;$/;"	p	class:cv::Mat_	access:public	signature:() const
type	core/core.hpp	/^    int type() const;$/;"	p	class:cv::Seq	access:public	signature:() const
type	core/core.hpp	/^    int type() const;$/;"	p	class:cv::SparseMat	access:public	signature:() const
type	core/core.hpp	/^    int type() const;$/;"	p	class:cv::SparseMat_	access:public	signature:() const
type	core/core.hpp	/^    int type; \/\/!< the type of termination criteria: COUNT, EPS or COUNT + EPS$/;"	m	class:cv::TermCriteria	access:public
type	core/core.hpp	/^    virtual int type(int i=-1) const;$/;"	p	class:cv::_InputArray	access:public	signature:(int i=-1) const
type	core/mat.hpp	/^    int type() const;$/;"	p	class:cv::MatExpr	access:public	signature:() const
type	core/mat.hpp	/^    virtual int type(const MatExpr& expr) const;$/;"	p	class:cv::MatOp	access:public	signature:(const MatExpr& expr) const
type	core/mat.hpp	/^inline int Mat::type() const { return CV_MAT_TYPE(flags); }$/;"	f	class:cv::Mat	signature:() const
type	core/mat.hpp	/^inline int SparseMat::type() const$/;"	f	class:cv::SparseMat	signature:() const
type	core/mat.hpp	/^template<typename _Tp> inline int Mat_<_Tp>::type() const$/;"	f	class:cv::Mat_	signature:() const
type	core/mat.hpp	/^template<typename _Tp> inline int SparseMat_<_Tp>::type() const$/;"	f	class:cv::SparseMat_	signature:() const
type	core/operations.hpp	/^    int type() const { return DataType<_Tp>::type; }$/;"	f	class:cv::Vector	access:public	signature:() const
type	core/operations.hpp	/^inline int FileNode::type() const { return !node ? NONE : (node->tag & TYPE_MASK); }$/;"	f	class:cv::FileNode	signature:() const
type	core/operations.hpp	/^template<typename _Tp> inline int Seq<_Tp>::type() const$/;"	f	class:cv::Seq	signature:() const
type	core/types_c.h	/^    int     type;$/;"	m	struct:CvHistogram	access:public
type	core/types_c.h	/^    int    type;  \/* may be combination of$/;"	m	struct:CvTermCriteria	access:public
type	core/types_c.h	/^    int type;$/;"	m	struct:CvMat	access:public
type	core/types_c.h	/^    int type;$/;"	m	struct:CvMatND	access:public
type	core/types_c.h	/^    int type;$/;"	m	struct:CvSparseMat	access:public
type	flann/any.h	/^    const std::type_info& type() const$/;"	f	struct:cdiggins::any	access:public	signature:() const
type	flann/any.h	/^    typedef big_any_policy<T> type;$/;"	t	struct:cdiggins::anyimpl::choose_policy	access:public
type	flann/any.h	/^    typedef small_any_policy<T*> type;$/;"	t	struct:cdiggins::anyimpl::choose_policy	access:public
type	flann/any.h	/^    typedef void type;$/;"	t	struct:cdiggins::anyimpl::choose_policy	access:public
type	flann/any.h	/^    virtual const std::type_info& type() = 0;$/;"	p	struct:cdiggins::anyimpl::base_any_policy	access:public	signature:()
type	flann/any.h	/^    virtual const std::type_info& type() { return typeid(T); }$/;"	f	struct:cdiggins::anyimpl::typed_base_any_policy	access:public	signature:()
type	flann/flann.hpp	/^template <> struct CvType<char> { static int type() { return CV_8S; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
type	flann/flann.hpp	/^template <> struct CvType<double> { static int type() { return CV_64F; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
type	flann/flann.hpp	/^template <> struct CvType<float> { static int type() { return CV_32F; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
type	flann/flann.hpp	/^template <> struct CvType<int> { static int type() { return CV_32S; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
type	flann/flann.hpp	/^template <> struct CvType<short> { static int type() { return CV_16S; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
type	flann/flann.hpp	/^template <> struct CvType<unsigned char> { static int type() { return CV_8U; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
type	flann/flann.hpp	/^template <> struct CvType<unsigned short> { static int type() { return CV_16U; } };$/;"	f	struct:cv::flann::CvType	access:public	signature:()
type	flann/matrix.h	/^    flann_datatype_t type;$/;"	m	class:cvflann::UntypedMatrix	access:public
type	flann/matrix.h	/^    typedef T type;$/;"	t	class:cvflann::Matrix	access:public
type	flann/saving.h	/^struct Datatype<char> { static flann_datatype_t type() { return FLANN_INT8; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
type	flann/saving.h	/^struct Datatype<double> { static flann_datatype_t type() { return FLANN_FLOAT64; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
type	flann/saving.h	/^struct Datatype<float> { static flann_datatype_t type() { return FLANN_FLOAT32; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
type	flann/saving.h	/^struct Datatype<int> { static flann_datatype_t type() { return FLANN_INT32; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
type	flann/saving.h	/^struct Datatype<short> { static flann_datatype_t type() { return FLANN_INT16; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
type	flann/saving.h	/^struct Datatype<unsigned char> { static flann_datatype_t type() { return FLANN_UINT8; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
type	flann/saving.h	/^struct Datatype<unsigned int> { static flann_datatype_t type() { return FLANN_UINT32; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
type	flann/saving.h	/^struct Datatype<unsigned short> { static flann_datatype_t type() { return FLANN_UINT16; } };$/;"	f	struct:cvflann::Datatype	access:public	signature:()
type	gpu/gpu.hpp	/^            int type() const;$/;"	p	class:cv::gpu::CudaMem	access:public	signature:() const
type	gpu/gpumat.hpp	/^        int type() const;$/;"	p	class:cv::gpu::GpuMat	access:public	signature:() const
type	gpu/matrix_operations.hpp	/^inline int CudaMem::type() const { return CV_MAT_TYPE(flags); }$/;"	f	class:cv::gpu::CudaMem	signature:() const
type	imgproc/imgproc.hpp	/^        int type;$/;"	m	struct:cv::Subdiv2D::Vertex	access:public
type	legacy/legacy.hpp	/^    int type() const { return matrix ? CV_MAT_TYPE(matrix->type) : 0; }$/;"	f	class:CvMatrix	access:public	signature:() const
type	ml/ml.hpp	/^    int type;$/;"	m	struct:CvVectors	access:public
type_name	core/types_c.h	/^    const char* type_name;$/;"	m	struct:CvTypeInfo	access:public
typed_base_any_policy	flann/any.h	/^struct typed_base_any_policy : base_any_policy$/;"	s	namespace:cdiggins::anyimpl	inherits:base_any_policy
u	core/core.hpp	/^    Mat u, w, vt;$/;"	m	class:cv::SVD	access:public
u	core/types_c.h	/^    uint64 u;$/;"	m	union:Cv64suf	access:public
u	core/types_c.h	/^    unsigned u;$/;"	m	union:Cv32suf	access:public
u	gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
u	gpu/gpu.hpp	/^            GpuMat u[2], d[2], l[2], r[2];$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:private
u	legacy/legacy.hpp	/^    } u;$/;"	m	struct:CvEHMM	typeref:union:CvEHMM::__anon183	access:public
u	ml/ml.hpp	/^    unsigned short* u;$/;"	m	struct:CvPair16u32s	access:public
u2	gpu/gpu.hpp	/^            GpuMat u, d, l, r, u2, d2, l2, r2;$/;"	m	class:cv::gpu::StereoBeliefPropagation	access:private
u_max_	features2d/features2d.hpp	/^  std::vector<int> u_max_;$/;"	m	class:cv::ORB	access:private
uchar	core/types_c.h	/^typedef unsigned char uchar;$/;"	t
uint32_t	flann/dist.h	/^typedef unsigned uint32_t;$/;"	t
uint64	core/types_c.h	/^typedef uint64_t uint64;$/;"	t
uint64	core/types_c.h	/^typedef unsigned __int64 uint64;$/;"	t
uint64_t	flann/dist.h	/^typedef unsigned __int64 uint64_t;$/;"	t
undistImg	legacy/legacy.hpp	/^    CvMat*  undistImg;$/;"	m	class:CvCalibFilter	access:protected
undistMap	legacy/legacy.hpp	/^    CvMat*  undistMap[MAX_CAMERAS][2];$/;"	m	class:CvCalibFilter	access:protected
undistort	imgproc/imgproc.hpp	/^CV_EXPORTS_W void undistort( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray newCameraMatrix=noArray() )
undistortPoints	imgproc/imgproc.hpp	/^CV_EXPORTS void undistortPoints( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray R=noArray(), InputArray P=noArray())
uniform	core/core.hpp	/^    double uniform(double a, double b);$/;"	p	class:cv::RNG	access:public	signature:(double a, double b)
uniform	core/core.hpp	/^    float uniform(float a, float b);$/;"	p	class:cv::RNG	access:public	signature:(float a, float b)
uniform	core/core.hpp	/^    int uniform(int a, int b);$/;"	p	class:cv::RNG	access:public	signature:(int a, int b)
uniform	core/operations.hpp	/^inline double RNG::uniform(double a, double b) { return ((double)*this)*(b - a) + a; }$/;"	f	class:cv::RNG	signature:(double a, double b)
uniform	core/operations.hpp	/^inline float RNG::uniform(float a, float b) { return ((float)*this)*(b - a) + a; }$/;"	f	class:cv::RNG	signature:(float a, float b)
uniform	core/operations.hpp	/^inline int RNG::uniform(int a, int b) { return a == b ? a : next()%(b - a) + a; }$/;"	f	class:cv::RNG	signature:(int a, int b)
uniquenessRatio	calib3d/calib3d.hpp	/^    CV_PROP_RW int uniquenessRatio;$/;"	m	class:cv::StereoSGBM	access:public
uniquenessRatio	calib3d/calib3d.hpp	/^    int uniquenessRatio;   \/\/ accept the computed disparity d* only if$/;"	m	struct:CvStereoBMState	access:public
unregister	flann/object_factory.h	/^    bool unregister(UniqueIdType id)$/;"	f	class:cvflann::ObjectFactory	access:public	signature:(UniqueIdType id)
unregisterPageLocked	gpu/gpu.hpp	/^        CV_EXPORTS void unregisterPageLocked(Mat& m);$/;"	p	namespace:cv::gpu	signature:(Mat& m)
update	calib3d/calib3d.hpp	/^    bool update( const CvMat*& param, CvMat*& J, CvMat*& err );$/;"	p	class:CvLevMarq	access:public	signature:( const CvMat*& param, CvMat*& J, CvMat*& err )
updateAlt	calib3d/calib3d.hpp	/^    bool updateAlt( const CvMat*& param, CvMat*& JtJ, CvMat*& JtErr, double*& errNorm );$/;"	p	class:CvLevMarq	access:public	signature:( const CvMat*& param, CvMat*& JtJ, CvMat*& JtErr, double*& errNorm )
updateMotionHistory	video/tracking.hpp	/^CV_EXPORTS_W void updateMotionHistory( InputArray silhouette, InputOutputArray mhi,$/;"	p	namespace:cv	signature:( InputArray silhouette, InputOutputArray mhi, double timestamp, double duration )
update_histogram	legacy/legacy.hpp	/^    virtual bool  update_histogram( const IplImage* cur_frame );$/;"	p	class:CvCamShiftTracker	access:public	signature:( const IplImage* cur_frame )
update_tree_rnc	ml/ml.hpp	/^    virtual double update_tree_rnc( int T, int fold );$/;"	p	class:CvDTree	access:protected	signature:( int T, int fold )
update_weights	ml/ml.hpp	/^    virtual void update_weights( CvBoostTree* tree );$/;"	p	class:CvBoost	access:protected	signature:( CvBoostTree* tree )
upload	gpu/gpumat.hpp	/^        void upload(const CudaMem& m, Stream& stream);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const CudaMem& m, Stream& stream)
upload	gpu/gpumat.hpp	/^        void upload(const cv::Mat& m);$/;"	p	class:cv::gpu::GpuMat	access:public	signature:(const cv::Mat& m)
uploadKeypoints	gpu/gpu.hpp	/^            void uploadKeypoints(const vector<KeyPoint>& keypoints, GpuMat& keypointsGPU);$/;"	p	class:cv::gpu::SURF_GPU	access:public	signature:(const vector<KeyPoint>& keypoints, GpuMat& keypointsGPU)
upper_bound_n	ml/ml.hpp	/^    double upper_bound_n;$/;"	m	struct:CvSVMSolutionInfo	access:public
upper_bound_p	ml/ml.hpp	/^    double upper_bound_p;$/;"	m	struct:CvSVMSolutionInfo	access:public
upright	features2d/features2d.hpp	/^    int    upright;$/;"	m	struct:CvSURFParams	access:public
upsample	gpu/gpu.hpp	/^        CV_EXPORTS void upsample(const GpuMat& src, GpuMat &dst, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat &dst, Stream& stream = Stream::Null())
useHarrisDetector	features2d/features2d.hpp	/^        bool useHarrisDetector;$/;"	m	class:cv::GoodFeaturesToTrackDetector::Params	access:public
useOptimized	core/core.hpp	/^CV_EXPORTS_W bool useOptimized();$/;"	p	namespace:cv	signature:()
use_1se_rule	ml/ml.hpp	/^    CV_PROP_RW bool  use_1se_rule;$/;"	m	struct:CvDTreeParams	access:public
use_local_init_data_cost	gpu/gpu.hpp	/^            bool use_local_init_data_cost;$/;"	m	class:cv::gpu::StereoConstantSpaceBP	access:public
use_surrogates	ml/ml.hpp	/^    CV_PROP_RW bool  use_surrogates;$/;"	m	struct:CvDTreeParams	access:public
usedMemory	flann/allocator.h	/^    int     usedMemory;$/;"	m	class:cvflann::PooledAllocator	access:public
usedMemory	flann/autotuned_index.h	/^    virtual int usedMemory() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
usedMemory	flann/composite_index.h	/^    int usedMemory() const$/;"	f	class:cvflann::CompositeIndex	access:public	signature:() const
usedMemory	flann/flann_base.hpp	/^    virtual int usedMemory() const$/;"	f	class:cvflann::Index	access:public	signature:() const
usedMemory	flann/hierarchical_clustering_index.h	/^    int usedMemory() const$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:public	signature:() const
usedMemory	flann/kdtree_index.h	/^    int usedMemory() const$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:() const
usedMemory	flann/kdtree_single_index.h	/^    int usedMemory() const$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:() const
usedMemory	flann/kmeans_index.h	/^    int usedMemory() const$/;"	f	class:cvflann::KMeansIndex	access:public	signature:() const
usedMemory	flann/linear_index.h	/^    int usedMemory() const$/;"	f	class:cvflann::LinearIndex	access:public	signature:() const
usedMemory	flann/lsh_index.h	/^    int usedMemory() const$/;"	f	class:cvflann::LshIndex	access:public	signature:() const
usedMemory	flann/nn_index.h	/^    virtual int usedMemory() const = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:() const
user_data	contrib/contrib.hpp	/^        void* user_data;$/;"	m	class:cv::LevMarqSparse	access:public
ushort	core/types_c.h	/^typedef unsigned short ushort;$/;"	t
v	video/background_segm.hpp	/^    uchar          v[3];$/;"	m	struct:CvBGPixelCStatTable	access:public
v	video/background_segm.hpp	/^    uchar          v[6];$/;"	m	struct:CvBGPixelCCStatTable	access:public
val	core/core.hpp	/^    _Tp val[m*n]; \/\/< matrix elements$/;"	m	class:cv::Matx	access:public
val	core/types_c.h	/^    double val[4];$/;"	m	struct:CvScalar	access:public
valid	legacy/legacy.hpp	/^    CvBool valid;$/;"	m	struct:__anon187	access:public
validGeometry	imgproc/imgproc.hpp	/^    bool validGeometry;$/;"	m	class:cv::Subdiv2D	access:protected
validateDisparity	calib3d/calib3d.hpp	/^CV_EXPORTS_W void validateDisparity( InputOutputArray disparity, InputArray cost,$/;"	p	namespace:cv	signature:( InputOutputArray disparity, InputArray cost, int minDisparity, int numberOfDisparities, int disp12MaxDisp=1 )
valoffset	core/types_c.h	/^    int valoffset;$/;"	m	struct:CvSparseMat	access:public
vals_	flann/random.h	/^    std::vector<int> vals_;$/;"	m	class:cvflann::UniqueRandom	access:private
value	contrib/contrib.hpp	/^    double value, centre;$/;"	m	class:CvFuzzyCurve	access:private
value	contrib/contrib.hpp	/^    double x, y, value;$/;"	m	class:CvFuzzyPoint	access:public
value	core/core.hpp	/^    template<typename _Tp> _Tp value(const int* idx, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(const int* idx, size_t* hashval=0) const
value	core/core.hpp	/^    template<typename _Tp> _Tp value(int i0, int i1, int i2, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, int i2, size_t* hashval=0) const
value	core/core.hpp	/^    template<typename _Tp> _Tp value(int i0, int i1, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, int i1, size_t* hashval=0) const
value	core/core.hpp	/^    template<typename _Tp> _Tp value(int i0, size_t* hashval=0) const;$/;"	p	class:cv::SparseMat	access:public	signature:(int i0, size_t* hashval=0) const
value	core/core.hpp	/^    template<typename _Tp> _Tp& value() const;$/;"	p	class:cv::SparseMatIterator	access:public	signature:() const
value	core/core.hpp	/^    template<typename _Tp> _Tp& value(Node* n);$/;"	p	class:cv::SparseMat	access:public	signature:(Node* n)
value	core/core.hpp	/^    template<typename _Tp> const _Tp& value() const;$/;"	p	class:cv::SparseMatConstIterator	access:public	signature:() const
value	core/core.hpp	/^    template<typename _Tp> const _Tp& value(const Node* n) const;$/;"	p	class:cv::SparseMat	access:public	signature:(const Node* n) const
value	core/core.hpp	/^template<> class DataDepth<bool> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	e	enum:cv::DataDepth::__anon102
value	core/core.hpp	/^template<> class DataDepth<char> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	e	enum:cv::DataDepth::__anon105
value	core/core.hpp	/^template<> class DataDepth<double> { public: enum { value = CV_64F, fmt=(int)'d' }; };$/;"	e	enum:cv::DataDepth::__anon111
value	core/core.hpp	/^template<> class DataDepth<float> { public: enum { value = CV_32F, fmt=(int)'f' }; };$/;"	e	enum:cv::DataDepth::__anon110
value	core/core.hpp	/^template<> class DataDepth<int> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	e	enum:cv::DataDepth::__anon108
value	core/core.hpp	/^template<> class DataDepth<schar> { public: enum { value = CV_8S, fmt=(int)'c' }; };$/;"	e	enum:cv::DataDepth::__anon104
value	core/core.hpp	/^template<> class DataDepth<short> { public: enum { value = CV_16S, fmt=(int)'s' }; };$/;"	e	enum:cv::DataDepth::__anon107
value	core/core.hpp	/^template<> class DataDepth<uchar> { public: enum { value = CV_8U, fmt=(int)'u' }; };$/;"	e	enum:cv::DataDepth::__anon103
value	core/core.hpp	/^template<> class DataDepth<unsigned> { public: enum { value = CV_32S, fmt=(int)'i' }; };$/;"	e	enum:cv::DataDepth::__anon109
value	core/core.hpp	/^template<> class DataDepth<ushort> { public: enum { value = CV_16U, fmt=(int)'w' }; };$/;"	e	enum:cv::DataDepth::__anon106
value	core/core.hpp	/^template<typename _Tp> class DataDepth<_Tp*> { public: enum { value = CV_USRTYPE1, fmt=(int)'r' }; };$/;"	e	enum:cv::DataDepth::__anon112
value	core/mat.hpp	/^template<typename _Tp> inline _Tp SparseMat::value(const int* idx, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(const int* idx, size_t* hashval) const
value	core/mat.hpp	/^template<typename _Tp> inline _Tp SparseMat::value(int i0, int i1, int i2, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, int i2, size_t* hashval) const
value	core/mat.hpp	/^template<typename _Tp> inline _Tp SparseMat::value(int i0, int i1, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, int i1, size_t* hashval) const
value	core/mat.hpp	/^template<typename _Tp> inline _Tp SparseMat::value(int i0, size_t* hashval) const$/;"	f	class:cv::SparseMat	signature:(int i0, size_t* hashval) const
value	core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMat::value(Node* n)$/;"	f	class:cv::SparseMat	signature:(Node* n)
value	core/mat.hpp	/^template<typename _Tp> inline _Tp& SparseMatIterator::value() const$/;"	f	class:cv::SparseMatIterator	signature:() const
value	core/mat.hpp	/^template<typename _Tp> inline const _Tp& SparseMat::value(const Node* n) const$/;"	f	class:cv::SparseMat	signature:(const Node* n) const
value	core/mat.hpp	/^template<typename _Tp> inline const _Tp& SparseMatConstIterator::value() const$/;"	f	class:cv::SparseMatConstIterator	signature:() const
value	flann/timer.h	/^    double value;$/;"	m	class:cvflann::StartStopTimer	access:public
value	imgproc/types_c.h	/^    CvScalar value; \/* average color of the connected component *\/$/;"	m	struct:CvConnectedComp	access:public
value	ml/ml.hpp	/^    double value;$/;"	m	struct:CvDTreeNode	access:public
valueOffset	core/core.hpp	/^        int valueOffset;$/;"	m	struct:cv::SparseMat::Hdr	access:public
value_type	core/core.hpp	/^    typedef Complex<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
value_type	core/core.hpp	/^    typedef Point3_<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
value_type	core/core.hpp	/^    typedef Point_<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
value_type	core/core.hpp	/^    typedef Range value_type;$/;"	t	class:cv::DataType	access:public
value_type	core/core.hpp	/^    typedef Rect_<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
value_type	core/core.hpp	/^    typedef Scalar_<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
value_type	core/core.hpp	/^    typedef Size_<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
value_type	core/core.hpp	/^    typedef Vec<_Tp, cn> value_type;$/;"	t	class:cv::DataType	access:public
value_type	core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Allocator	access:public
value_type	core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::AutoBuffer	access:public
value_type	core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::DataType	access:public
value_type	core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::MatConstIterator_	access:public
value_type	core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Mat_	access:public
value_type	core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Matx	access:public
value_type	core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Point3_	access:public
value_type	core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Point_	access:public
value_type	core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Rect_	access:public
value_type	core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Size_	access:public
value_type	core/core.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Vec	access:public
value_type	core/core.hpp	/^    typedef bool value_type;$/;"	t	class:cv::DataType	access:public
value_type	core/core.hpp	/^    typedef double value_type;$/;"	t	class:cv::DataType	access:public
value_type	core/core.hpp	/^    typedef float value_type;$/;"	t	class:cv::DataType	access:public
value_type	core/core.hpp	/^    typedef int value_type;$/;"	t	class:cv::DataType	access:public
value_type	core/core.hpp	/^    typedef schar value_type;$/;"	t	class:cv::DataType	access:public
value_type	core/core.hpp	/^    typedef short value_type;$/;"	t	class:cv::DataType	access:public
value_type	core/core.hpp	/^    typedef std::complex<_Tp> value_type;$/;"	t	class:cv::DataType	access:public
value_type	core/core.hpp	/^    typedef uchar value_type;$/;"	t	class:cv::DataType	access:public
value_type	core/core.hpp	/^    typedef uchar* value_type;$/;"	t	class:cv::MatConstIterator	access:public
value_type	core/core.hpp	/^    typedef ushort value_type;$/;"	t	class:cv::DataType	access:public
value_type	core/operations.hpp	/^    typedef _Tp value_type;$/;"	t	class:cv::Vector	access:public
values	core/types_c.h	/^    float *values;$/;"	m	struct:_IplConvKernelFP	access:public
values	core/types_c.h	/^    int *values;$/;"	m	struct:_IplConvKernel	access:public
values	ml/ml.hpp	/^    CvMat* values;$/;"	m	class:CvMLData	access:protected
varThreshold	video/background_segm.hpp	/^    double varThreshold;$/;"	m	class:cv::BackgroundSubtractorMOG	access:public
varThreshold	video/background_segm.hpp	/^    float varThreshold;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
varThresholdGen	video/background_segm.hpp	/^    float varThresholdGen;$/;"	m	class:cv::BackgroundSubtractorMOG2	access:public
var_	flann/kdtree_index.h	/^    DistanceType* var_;$/;"	m	class:cvflann::KDTreeIndex	access:private
var_all	ml/ml.hpp	/^    int     var_count, var_all;$/;"	m	class:CvNormalBayesClassifier	access:protected
var_all	ml/ml.hpp	/^    int sample_count, var_all, var_count, max_c_count;$/;"	m	struct:CvDTreeTrainData	access:public
var_all	ml/ml.hpp	/^    int var_all;$/;"	m	class:CvSVM	access:protected
var_count	ml/ml.hpp	/^    int     var_count, var_all;$/;"	m	class:CvNormalBayesClassifier	access:protected
var_count	ml/ml.hpp	/^    int max_k, var_count;$/;"	m	class:CvKNearest	access:protected
var_count	ml/ml.hpp	/^    int sample_count, var_all, var_count, max_c_count;$/;"	m	struct:CvDTreeTrainData	access:public
var_count	ml/ml.hpp	/^    int var_count;$/;"	m	class:CvSVMSolver	access:public
var_idx	ml/ml.hpp	/^    CvMat*  var_idx;$/;"	m	class:CvNormalBayesClassifier	access:protected
var_idx	ml/ml.hpp	/^    CvMat* var_idx;$/;"	m	class:CvSVM	access:protected
var_idx	ml/ml.hpp	/^    CvMat* var_idx;$/;"	m	struct:CvDTreeTrainData	access:public
var_idx	ml/ml.hpp	/^    int var_idx;$/;"	m	struct:CvDTreeSplit	access:public
var_idx_mask	ml/ml.hpp	/^    CvMat* var_idx_mask;$/;"	m	class:CvMLData	access:protected
var_idx_out	ml/ml.hpp	/^    CvMat* var_idx_out; \/\/ mat$/;"	m	class:CvMLData	access:protected
var_importance	ml/ml.hpp	/^    CvMat* var_importance;$/;"	m	class:CvDTree	access:protected
var_importance	ml/ml.hpp	/^    CvMat* var_importance;$/;"	m	class:CvRTrees	access:protected
var_type	ml/ml.hpp	/^    CvMat* var_type; \/\/ i-th element =$/;"	m	struct:CvDTreeTrainData	access:public
var_types	ml/ml.hpp	/^    CvMat* var_types;$/;"	m	class:CvMLData	access:protected
var_types_out	ml/ml.hpp	/^    CvMat* var_types_out; \/\/ mat$/;"	m	class:CvMLData	access:protected
variance	flann/kmeans_index.h	/^        DistanceType variance;$/;"	m	struct:cvflann::KMeansIndex::KMeansNode	access:public
variance	video/background_segm.hpp	/^    double      variance[CV_BGFG_MOG_NCOLORS];$/;"	m	struct:CvGaussBGValues	access:public
variance_init	video/background_segm.hpp	/^    double  weight_init, variance_init;$/;"	m	struct:CvGaussBGStatModelParams	access:public
varyImgBoundWithScale	features2d/features2d.hpp	/^        bool varyImgBoundWithScale;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
varyXyStepWithScale	features2d/features2d.hpp	/^        bool varyXyStepWithScale;$/;"	m	class:cv::DenseFeatureDetector::Params	access:public
vconcat	core/core.hpp	/^CV_EXPORTS void vconcat(InputArray src1, InputArray src2, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src1, InputArray src2, OutputArray dst)
vconcat	core/core.hpp	/^CV_EXPORTS void vconcat(const Mat* src, size_t nsrc, OutputArray dst);$/;"	p	namespace:cv	signature:(const Mat* src, size_t nsrc, OutputArray dst)
vconcat	core/core.hpp	/^CV_EXPORTS_W void vconcat(InputArray src, OutputArray dst);$/;"	p	namespace:cv	signature:(InputArray src, OutputArray dst)
vec_type	core/core.hpp	/^    typedef Vec<channel_type, channels> vec_type;$/;"	t	class:cv::DataType	access:public
vec_type	core/core.hpp	/^    typedef value_type vec_type;$/;"	t	class:cv::DataType	access:public
veclen	flann/autotuned_index.h	/^    virtual size_t veclen() const$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:() const
veclen	flann/composite_index.h	/^    size_t veclen() const$/;"	f	class:cvflann::CompositeIndex	access:public	signature:() const
veclen	flann/flann.hpp	/^	int veclen() const $/;"	f	class:cv::flann::Index_	access:public	signature:() const
veclen	flann/flann.hpp	/^        int veclen() const { return nnIndex->veclen(); }$/;"	f	class:cv::flann::GenericIndex	access:public	signature:() const
veclen	flann/flann_base.hpp	/^    size_t veclen() const$/;"	f	class:cvflann::Index	access:public	signature:() const
veclen	flann/hierarchical_clustering_index.h	/^    size_t veclen() const$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:public	signature:() const
veclen	flann/kdtree_index.h	/^    size_t veclen() const$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:() const
veclen	flann/kdtree_single_index.h	/^    size_t veclen() const$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:() const
veclen	flann/kmeans_index.h	/^    size_t veclen() const$/;"	f	class:cvflann::KMeansIndex	access:public	signature:() const
veclen	flann/linear_index.h	/^    size_t veclen() const$/;"	f	class:cvflann::LinearIndex	access:public	signature:() const
veclen	flann/lsh_index.h	/^    size_t veclen() const$/;"	f	class:cvflann::LshIndex	access:public	signature:() const
veclen	flann/nn_index.h	/^    virtual size_t veclen() const = 0;$/;"	p	class:cvflann::NNIndex	access:public	signature:() const
veclen_	flann/hierarchical_clustering_index.h	/^    size_t veclen_;$/;"	m	class:cvflann::HierarchicalClusteringIndex	access:private
veclen_	flann/kdtree_index.h	/^    size_t veclen_;$/;"	m	class:cvflann::KDTreeIndex	access:private
veclen_	flann/kmeans_index.h	/^    size_t veclen_;$/;"	m	class:cvflann::KMeansIndex	access:private
vector_add	imgproc/imgproc.hpp	/^  virtual int vector_add(const void* data) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(const void* data)
vector_count	imgproc/imgproc.hpp	/^  virtual unsigned int vector_count() = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:()
vector_lookup	imgproc/imgproc.hpp	/^  virtual const void* vector_lookup(int i) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(int i)
vector_remove	imgproc/imgproc.hpp	/^  virtual void vector_remove(int i) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(int i)
vector_reserve	imgproc/imgproc.hpp	/^  virtual void vector_reserve(int n) = 0;$/;"	p	struct:CvLSHOperations	access:public	signature:(int n)
verbose	features2d/features2d.hpp	/^    bool verbose;$/;"	m	class:cv::FernClassifier	access:protected
verbose	features2d/features2d.hpp	/^    bool verbose;$/;"	m	class:cv::LDetector	access:public
verbose	objdetect/objdetect.hpp	/^    bool verbose;$/;"	m	class:cv::PlanarObjectDetector	access:protected
version	core/types_c.h	/^    const char* version;$/;"	m	struct:CvModuleInfo	access:public
version	flann/saving.h	/^    char version[16];$/;"	m	struct:cvflann::IndexHeader	access:public
vertex_weights	legacy/legacy.hpp	/^    float* vertex_weights;$/;"	m	struct:CvCliqueFinder	access:public
verticalEdgeLeft	contrib/contrib.hpp	/^        int verticalEdgeLeft, verticalEdgeRight, horizontalEdgeTop, horizontalEdgeBottom;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
verticalEdgeRight	contrib/contrib.hpp	/^        int verticalEdgeLeft, verticalEdgeRight, horizontalEdgeTop, horizontalEdgeBottom;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
vind_	flann/kdtree_index.h	/^    std::vector<int> vind_;$/;"	m	class:cvflann::KDTreeIndex	access:private
vind_	flann/kdtree_single_index.h	/^    std::vector<int> vind_;$/;"	m	class:cvflann::KDTreeSingleIndex	access:private
visualizeInPlace	gpu/gpu.hpp	/^            bool visualizeInPlace;$/;"	m	class:cv::gpu::CascadeClassifier_GPU	access:public
vocabulary	features2d/features2d.hpp	/^    Mat vocabulary;$/;"	m	class:cv::BOWImgDescriptorExtractor	access:protected
vscale	core/core_c.h	/^    float       hscale, vscale;$/;"	m	struct:CvFont	access:public
vt	core/core.hpp	/^    Mat u, w, vt;$/;"	m	class:cv::SVD	access:public
vtx	contrib/contrib.hpp	/^        vector<Point3f> vtx;$/;"	m	class:cv::Mesh3D	access:public
vtx	core/core_c.h	/^    CvGraphVtx* vtx;       \/* current graph vertex (or current edge origin) *\/$/;"	m	struct:CvGraphScanner	access:public
vtx	imgproc/imgproc.hpp	/^    vector<Vertex> vtx;$/;"	m	class:cv::Subdiv2D	access:protected
vtxBuf	calib3d/calib3d.hpp	/^    CvMat* vtxBuf;$/;"	m	struct:CvStereoGCState	access:public
w	core/core.hpp	/^    Mat u, w, vt;$/;"	m	class:cv::SVD	access:public
w	legacy/blobtrack.hpp	/^    float   w,h; \/* blob sizes      *\/$/;"	m	struct:CvBlob	access:public
waitForCompletion	gpu/gpu.hpp	/^            void waitForCompletion();$/;"	p	class:cv::gpu::Stream	access:public	signature:()
waitKey	highgui/highgui.hpp	/^CV_EXPORTS_W int waitKey(int delay=0);$/;"	p	namespace:cv	signature:(int delay=0)
warpAffine	gpu/gpu.hpp	/^        CV_EXPORTS void warpAffine(const GpuMat& src, GpuMat& dst, const Mat& M, Size dsize, int flags = INTER_LINEAR, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, const Mat& M, Size dsize, int flags = INTER_LINEAR, Stream& stream = Stream::Null())
warpAffine	imgproc/imgproc.hpp	/^CV_EXPORTS_W void warpAffine( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, InputArray M, Size dsize, int flags=INTER_LINEAR, int borderMode=BORDER_CONSTANT, const Scalar& borderValue=Scalar())
warpPerspective	gpu/gpu.hpp	/^        CV_EXPORTS void warpPerspective(const GpuMat& src, GpuMat& dst, const Mat& M, Size dsize, int flags = INTER_LINEAR, Stream& stream = Stream::Null());$/;"	p	namespace:cv::gpu	signature:(const GpuMat& src, GpuMat& dst, const Mat& M, Size dsize, int flags = INTER_LINEAR, Stream& stream = Stream::Null())
warpPerspective	imgproc/imgproc.hpp	/^CV_EXPORTS_W void warpPerspective( InputArray src, OutputArray dst,$/;"	p	namespace:cv	signature:( InputArray src, OutputArray dst, InputArray M, Size dsize, int flags=INTER_LINEAR, int borderMode=BORDER_CONSTANT, const Scalar& borderValue=Scalar())
warpSize	legacy/legacy.hpp	/^    CvSize warpSize;$/;"	m	struct:CvStereoCamera	access:public
warpWholeImage	features2d/features2d.hpp	/^    void warpWholeImage(const Mat& image, Mat& matT, Mat& buf,$/;"	p	class:cv::PatchGenerator	access:public	signature:(const Mat& image, Mat& matT, Mat& buf, CV_OUT Mat& warped, int border, RNG& rng) const
wastedMemory	flann/allocator.h	/^    int     wastedMemory;$/;"	m	class:cvflann::PooledAllocator	access:public
watershed	imgproc/imgproc.hpp	/^CV_EXPORTS_W void watershed( InputArray image, InputOutputArray markers );$/;"	p	namespace:cv	signature:( InputArray image, InputOutputArray markers )
wbuf	ml/ml.hpp	/^    CvMat* wbuf;$/;"	m	class:CvANN_MLP	access:protected
weak	ml/ml.hpp	/^    CvSeq* weak;$/;"	m	class:CvBoost	access:protected
weak	ml/ml.hpp	/^    CvSeq** weak;$/;"	m	class:CvGBTrees	access:protected
weak_count	ml/ml.hpp	/^    CV_PROP_RW int weak_count;$/;"	m	struct:CvBoostParams	access:public
weak_count	ml/ml.hpp	/^    CV_PROP_RW int weak_count;$/;"	m	struct:CvGBTreesParams	access:public
weak_eval	ml/ml.hpp	/^    CvMat* weak_eval;$/;"	m	class:CvBoost	access:protected
weight	legacy/legacy.hpp	/^    float* weight;      \/*array of mixture weights. Summ of all weights in state is 1. *\/$/;"	m	struct:CvEHMMState	access:public
weight	objdetect/objdetect.hpp	/^        float weight;$/;"	m	struct:CvHaarFeature::__anon195	access:public
weight	video/background_segm.hpp	/^    double      weight;$/;"	m	struct:CvGaussBGValues	access:public
weight_init	video/background_segm.hpp	/^    double  weight_init, variance_init;$/;"	m	struct:CvGaussBGStatModelParams	access:public
weight_trim_rate	ml/ml.hpp	/^    CV_PROP_RW double weight_trim_rate;$/;"	m	struct:CvBoostParams	access:public
weighted	legacy/legacy.hpp	/^    int weighted;$/;"	m	struct:CvCliqueFinder	access:public
weighted_edges	legacy/legacy.hpp	/^    int weighted_edges;    $/;"	m	struct:CvCliqueFinder	access:public
weights	ml/ml.hpp	/^    CvMat* weights;$/;"	m	class:CvBoost	access:protected
weights	ml/ml.hpp	/^    CvMat* weights;$/;"	m	class:CvEM	access:protected
weights	ml/ml.hpp	/^    const CvMat* weights;$/;"	m	struct:CvEMParams	access:public
weights	ml/ml.hpp	/^    double** weights;$/;"	m	class:CvANN_MLP	access:protected
what	core/core.hpp	/^    virtual const char *what() const throw();$/;"	p	class:cv::Exception	access:public	signature:() const
wholeSize	imgproc/imgproc.hpp	/^    Size wholeSize;$/;"	m	class:cv::FilterEngine	access:public
width	contrib/contrib.hpp	/^        int width, height, maxWidth, maxHeight, ellipseHeight, ellipseWidth;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
width	core/core.hpp	/^    _Tp width, height; \/\/ the width and the height$/;"	m	class:cv::Size_	access:public
width	core/core.hpp	/^    _Tp x, y, width, height; \/\/< the top-left corner, as well as width and height of the rectangle$/;"	m	class:cv::Rect_	access:public
width	core/types_c.h	/^        int width;$/;"	m	union:CvMat::__anon153	access:public
width	core/types_c.h	/^    float width;$/;"	m	struct:CvSize2D32f	access:public
width	core/types_c.h	/^    int  width;             \/* Image width in pixels.                           *\/$/;"	m	struct:_IplImage	access:public
width	core/types_c.h	/^    int  width;$/;"	m	struct:_IplROI	access:public
width	core/types_c.h	/^    int width;$/;"	m	struct:CvRect	access:public
width	core/types_c.h	/^    int width;$/;"	m	struct:__anon156	access:public
width	gpu/NCV.hpp	/^    Ncv32s width;      \/\/\/< Rectangle width.$/;"	m	struct:NcvRect32s	access:public
width	gpu/NCV.hpp	/^    Ncv32s width;  \/\/\/< Rectangle width.$/;"	m	struct:NcvSize32s	access:public
width	gpu/NCV.hpp	/^    Ncv32u width() const {return this->_width;}$/;"	f	class:NCVMatrix	access:public	signature:() const
width	gpu/NCV.hpp	/^    Ncv32u width;      \/\/\/< Rectangle width.$/;"	m	struct:NcvRect32u	access:public
width	gpu/NCV.hpp	/^    Ncv32u width;  \/\/\/< Rectangle width.$/;"	m	struct:NcvSize32u	access:public
width	gpu/NCV.hpp	/^    Ncv8u width;$/;"	m	struct:NcvRect8u	access:public
width	legacy/compat.hpp	/^    int     width;                  \/* width of the image  ( in pixels )                *\/$/;"	m	struct:_CvPixelPosition8u	access:public
width	legacy/compat.hpp	/^    int     width;$/;"	m	struct:_CvPixelPosition32f	access:public
width	legacy/compat.hpp	/^    int     width;$/;"	m	struct:_CvPixelPosition8s	access:public
width	legacy/legacy.hpp	/^    float width;$/;"	m	struct:CvLCMEdge	access:public
width	legacy/legacy.hpp	/^    int width() const { return image ? image->width : 0; }$/;"	f	class:CvImage	access:public	signature:() const
widthStep	core/types_c.h	/^    int  widthStep;         \/* Size of aligned image row in bytes.    *\/$/;"	m	struct:_IplImage	access:public
winSigma	objdetect/objdetect.hpp	/^    CV_PROP double winSigma;$/;"	m	struct:cv::HOGDescriptor	access:public
winSize	gpu/gpu.hpp	/^            int winSize;$/;"	m	class:cv::gpu::StereoBM_GPU	access:public
winSize	objdetect/objdetect.hpp	/^    CV_PROP Size winSize;$/;"	m	struct:cv::HOGDescriptor	access:public
win_sigma	gpu/gpu.hpp	/^            double win_sigma;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
win_size	gpu/gpu.hpp	/^            Size win_size;$/;"	m	struct:cv::gpu::HOGDescriptor	access:public
win_size	video/background_segm.hpp	/^    int     win_size;               \/* = 1\/alpha *\/$/;"	m	struct:CvGaussBGStatModelParams	access:public
windowedMatchingMask	features2d/features2d.hpp	/^CV_EXPORTS Mat windowedMatchingMask( const vector<KeyPoint>& keypoints1, const vector<KeyPoint>& keypoints2,$/;"	p	namespace:cv	signature:( const vector<KeyPoint>& keypoints1, const vector<KeyPoint>& keypoints2, float maxDeltaX, float maxDeltaY )
work_type	core/core.hpp	/^    typedef Point3_<typename DataType<_Tp>::work_type> work_type;$/;"	t	class:cv::DataType	access:public
work_type	core/core.hpp	/^    typedef Point_<typename DataType<_Tp>::work_type> work_type;$/;"	t	class:cv::DataType	access:public
work_type	core/core.hpp	/^    typedef Rect_<typename DataType<_Tp>::work_type> work_type;$/;"	t	class:cv::DataType	access:public
work_type	core/core.hpp	/^    typedef Scalar_<typename DataType<_Tp>::work_type> work_type;$/;"	t	class:cv::DataType	access:public
work_type	core/core.hpp	/^    typedef Size_<typename DataType<_Tp>::work_type> work_type;$/;"	t	class:cv::DataType	access:public
work_type	core/core.hpp	/^    typedef Vec<typename DataType<_Tp>::work_type, cn> work_type;$/;"	t	class:cv::DataType	access:public
work_type	core/core.hpp	/^    typedef int work_type;$/;"	t	class:cv::DataType	access:public
work_type	core/core.hpp	/^    typedef value_type work_type;$/;"	t	class:cv::DataType	access:public
work_var_count	ml/ml.hpp	/^    int ord_var_count, cat_var_count, work_var_count;$/;"	m	struct:CvDTreeTrainData	access:public
worstDist	flann/result_set.h	/^    DistanceType worstDist() const$/;"	f	class:cvflann::KNNResultSet	access:public	signature:() const
worstDist	flann/result_set.h	/^    DistanceType worstDist() const$/;"	f	class:cvflann::KNNSimpleResultSet	access:public	signature:() const
worstDist	flann/result_set.h	/^    DistanceType worstDist() const$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:() const
worstDist	flann/result_set.h	/^    inline DistanceType worstDist() const$/;"	f	class:cvflann::RadiusUniqueResultSet	access:public	signature:() const
worstDist	flann/result_set.h	/^    inline DistanceType worstDist() const$/;"	f	class:cvflann::UniqueResultSet	access:public	signature:() const
worstDist	flann/result_set.h	/^    virtual DistanceType worstDist() const = 0;$/;"	p	class:cvflann::ResultSet	access:public	signature:() const
worst_distance_	flann/result_set.h	/^    DistanceType worst_distance_;$/;"	m	class:cvflann::KNNResultSet	access:private
worst_distance_	flann/result_set.h	/^    DistanceType worst_distance_;$/;"	m	class:cvflann::KNNSimpleResultSet	access:private
worst_distance_	flann/result_set.h	/^    DistanceType worst_distance_;$/;"	m	class:cvflann::UniqueResultSet	access:protected
write	core/operations.hpp	/^    static void write(CvFileStorage* _fs, const char* name, const void* ptr, CvAttrList)$/;"	f	struct:cv::RTTIImpl	access:public	signature:(CvFileStorage* _fs, const char* name, const void* ptr, CvAttrList)
write	core/operations.hpp	/^    virtual void write(std::ostream& out, const Mat& m, const int* params=0, int nparams=0) const = 0;$/;"	p	class:cv::Formatter	access:public	signature:(std::ostream& out, const Mat& m, const int* params=0, int nparams=0) const
write	core/operations.hpp	/^    virtual void write(std::ostream& out, const void* data, int nelems, int type,$/;"	p	class:cv::Formatter	access:public	signature:(std::ostream& out, const void* data, int nelems, int type, const int* params=0, int nparams=0) const
write	core/operations.hpp	/^CV_EXPORTS void write( FileStorage& fs, const string& name, const SparseMat& value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, const SparseMat& value )
write	core/operations.hpp	/^CV_EXPORTS_W void write( FileStorage& fs, const string& name, const Mat& value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, const Mat& value )
write	core/operations.hpp	/^CV_EXPORTS_W void write( FileStorage& fs, const string& name, const string& value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, const string& value )
write	core/operations.hpp	/^CV_EXPORTS_W void write( FileStorage& fs, const string& name, double value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, double value )
write	core/operations.hpp	/^CV_EXPORTS_W void write( FileStorage& fs, const string& name, float value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, float value )
write	core/operations.hpp	/^CV_EXPORTS_W void write( FileStorage& fs, const string& name, int value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& name, int value )
write	core/operations.hpp	/^inline void write(FileStorage& fs, const Range& r )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Range& r )
write	core/operations.hpp	/^inline void write(FileStorage& fs, const string& name, const Range& r )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Range& r )
write	core/operations.hpp	/^template<> inline void write( FileStorage& fs, const double& value )$/;"	f	namespace:cv	signature:( FileStorage& fs, const double& value )
write	core/operations.hpp	/^template<> inline void write( FileStorage& fs, const float& value )$/;"	f	namespace:cv	signature:( FileStorage& fs, const float& value )
write	core/operations.hpp	/^template<> inline void write( FileStorage& fs, const int& value )$/;"	f	namespace:cv	signature:( FileStorage& fs, const int& value )
write	core/operations.hpp	/^template<> inline void write( FileStorage& fs, const string& value )$/;"	f	namespace:cv	signature:( FileStorage& fs, const string& value )
write	core/operations.hpp	/^template<typename _Tp, int cn> inline void write(FileStorage& fs, const Vec<_Tp, cn>& v )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Vec<_Tp, cn>& v )
write	core/operations.hpp	/^template<typename _Tp, int cn> inline void write(FileStorage& fs, const string& name, const Vec<_Tp, cn>& v )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Vec<_Tp, cn>& v )
write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Complex<_Tp>& c )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Complex<_Tp>& c )
write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Point3_<_Tp>& pt )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Point3_<_Tp>& pt )
write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Point_<_Tp>& pt )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Point_<_Tp>& pt )
write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Rect_<_Tp>& r )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Rect_<_Tp>& r )
write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Scalar_<_Tp>& s )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Scalar_<_Tp>& s )
write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const Size_<_Tp>& sz )$/;"	f	namespace:cv	signature:(FileStorage& fs, const Size_<_Tp>& sz )
write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const _Tp& value)$/;"	f	namespace:cv	signature:(FileStorage& fs, const _Tp& value)
write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Complex<_Tp>& c )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Complex<_Tp>& c )
write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Point3_<_Tp>& pt )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Point3_<_Tp>& pt )
write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Point_<_Tp>& pt )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Point_<_Tp>& pt )
write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Rect_<_Tp>& r )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Rect_<_Tp>& r )
write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Scalar_<_Tp>& s )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Scalar_<_Tp>& s )
write	core/operations.hpp	/^template<typename _Tp> inline void write(FileStorage& fs, const string& name, const Size_<_Tp>& sz )$/;"	f	namespace:cv	signature:(FileStorage& fs, const string& name, const Size_<_Tp>& sz )
write	core/operations.hpp	/^template<typename _Tp> static inline void write( FileStorage& fs, const vector<_Tp>& vec )$/;"	f	namespace:cv	signature:( FileStorage& fs, const vector<_Tp>& vec )
write	core/types_c.h	/^    CvWriteFunc write;$/;"	m	struct:CvTypeInfo	access:public
write	features2d/features2d.hpp	/^        void write( FileStorage& fs ) const;$/;"	p	class:cv::DenseFeatureDetector::Params	access:public	signature:( FileStorage& fs ) const
write	features2d/features2d.hpp	/^        void write( FileStorage& fs ) const;$/;"	p	class:cv::GoodFeaturesToTrackDetector::Params	access:public	signature:( FileStorage& fs ) const
write	features2d/features2d.hpp	/^      void write( FileStorage& fs ) const;$/;"	p	struct:cv::SimpleBlobDetector::Params	access:public	signature:( FileStorage& fs ) const
write	features2d/features2d.hpp	/^    virtual void write( FileStorage &fs ) const;$/;"	p	class:cv::CalonderDescriptorExtractor	access:public	signature:( FileStorage &fs ) const
write	features2d/features2d.hpp	/^    virtual void write( FileStorage &fs ) const;$/;"	p	class:cv::SiftDescriptorExtractor	access:public	signature:( FileStorage &fs ) const
write	features2d/features2d.hpp	/^    virtual void write( FileStorage &fs ) const;$/;"	p	class:cv::SurfDescriptorExtractor	access:public	signature:( FileStorage &fs ) const
write	features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::BriefDescriptorExtractor	access:public	signature:( FileStorage& ) const
write	features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::DescriptorExtractor	access:public	signature:( FileStorage& ) const
write	features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::DescriptorMatcher	access:public	signature:( FileStorage& ) const
write	features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::FeatureDetector	access:public	signature:( FileStorage& ) const
write	features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::FlannBasedMatcher	access:public	signature:( FileStorage& ) const
write	features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:( FileStorage& ) const
write	features2d/features2d.hpp	/^    virtual void write( FileStorage& ) const;$/;"	p	class:cv::OpponentColorDescriptorExtractor	access:public	signature:( FileStorage& ) const
write	features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::DenseFeatureDetector	access:public	signature:( FileStorage& fs ) const
write	features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::FastFeatureDetector	access:public	signature:( FileStorage& fs ) const
write	features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:( FileStorage& fs ) const
write	features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::GoodFeaturesToTrackDetector	access:public	signature:( FileStorage& fs ) const
write	features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::MserFeatureDetector	access:public	signature:( FileStorage& fs ) const
write	features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:( FileStorage& fs ) const
write	features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::SiftFeatureDetector	access:public	signature:( FileStorage& fs ) const
write	features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::StarFeatureDetector	access:public	signature:( FileStorage& fs ) const
write	features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::SurfFeatureDetector	access:public	signature:( FileStorage& fs ) const
write	features2d/features2d.hpp	/^    virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:( FileStorage& fs ) const
write	features2d/features2d.hpp	/^    virtual void write(FileStorage& fs, const String& name=String()) const;$/;"	p	class:cv::FernClassifier	access:public	signature:(FileStorage& fs, const String& name=String()) const
write	features2d/features2d.hpp	/^    void write(FileStorage& fs) const;$/;"	p	struct:cv::ORB::CommonParams	access:public	signature:(FileStorage& fs) const
write	features2d/features2d.hpp	/^    void write(FileStorage& fs, const String& name=String()) const;$/;"	p	class:cv::LDetector	access:public	signature:(FileStorage& fs, const String& name=String()) const
write	features2d/features2d.hpp	/^  virtual void write( FileStorage& fs ) const;$/;"	p	class:cv::SimpleBlobDetector	access:public	signature:( FileStorage& fs ) const
write	features2d/features2d.hpp	/^  virtual void write(cv::FileStorage&) const;$/;"	p	class:cv::OrbDescriptorExtractor	access:public	signature:(cv::FileStorage&) const
write	features2d/features2d.hpp	/^  virtual void write(cv::FileStorage&) const;$/;"	p	class:cv::OrbFeatureDetector	access:public	signature:(cv::FileStorage&) const
write	features2d/features2d.hpp	/^  void write(const char* file_name) const;$/;"	p	class:cv::RTreeClassifier	access:public	signature:(const char* file_name) const
write	features2d/features2d.hpp	/^  void write(const char* file_name) const;$/;"	p	class:cv::RandomizedTree	access:public	signature:(const char* file_name) const
write	features2d/features2d.hpp	/^  void write(std::ostream &os) const;$/;"	p	class:cv::RTreeClassifier	access:public	signature:(std::ostream &os) const
write	features2d/features2d.hpp	/^  void write(std::ostream &os) const;$/;"	p	class:cv::RandomizedTree	access:public	signature:(std::ostream &os) const
write	features2d/features2d.hpp	/^CV_EXPORTS void write(FileStorage& fs, const string& name, const vector<KeyPoint>& keypoints);$/;"	p	namespace:cv	signature:(FileStorage& fs, const string& name, const vector<KeyPoint>& keypoints)
write	features2d/features2d.hpp	/^void CalonderDescriptorExtractor<T>::write( FileStorage& ) const$/;"	f	class:cv::CalonderDescriptorExtractor	signature:( FileStorage& ) const
write	highgui/highgui.hpp	/^    CV_WRAP virtual void write(const Mat& image);$/;"	p	class:cv::VideoWriter	access:public	signature:(const Mat& image)
write	legacy/legacy.hpp	/^    void write( CvFileStorage* fs, const char* imgname );$/;"	p	class:CvImage	access:public	signature:( CvFileStorage* fs, const char* imgname )
write	legacy/legacy.hpp	/^    void write( CvFileStorage* fs, const char* matname );$/;"	p	class:CvMatrix	access:public	signature:( CvFileStorage* fs, const char* matname )
write	ml/ml.hpp	/^    virtual void write( CvFileStorage* fs ) const;$/;"	p	class:CvDTree	access:public	signature:( CvFileStorage* fs ) const
write	ml/ml.hpp	/^    virtual void write( CvFileStorage* fs, const char* name ) const;$/;"	p	class:CvDTree	access:public	signature:( CvFileStorage* fs, const char* name ) const
write	ml/ml.hpp	/^    virtual void write( CvFileStorage* fs, const char* name ) const;$/;"	p	class:CvEM	access:public	signature:( CvFileStorage* fs, const char* name ) const
write	ml/ml.hpp	/^    virtual void write( CvFileStorage* fs, const char* name ) const;$/;"	p	class:CvGBTrees	access:public	signature:( CvFileStorage* fs, const char* name ) const
write	ml/ml.hpp	/^    virtual void write( CvFileStorage* fs, const char* name ) const;$/;"	p	class:CvRTrees	access:public	signature:( CvFileStorage* fs, const char* name ) const
write	ml/ml.hpp	/^    virtual void write( CvFileStorage* storage, const char* name ) const;$/;"	p	class:CvANN_MLP	access:public	signature:( CvFileStorage* storage, const char* name ) const
write	ml/ml.hpp	/^    virtual void write( CvFileStorage* storage, const char* name ) const;$/;"	p	class:CvBoost	access:public	signature:( CvFileStorage* storage, const char* name ) const
write	ml/ml.hpp	/^    virtual void write( CvFileStorage* storage, const char* name ) const;$/;"	p	class:CvNormalBayesClassifier	access:public	signature:( CvFileStorage* storage, const char* name ) const
write	ml/ml.hpp	/^    virtual void write( CvFileStorage* storage, const char* name ) const;$/;"	p	class:CvSVM	access:public	signature:( CvFileStorage* storage, const char* name ) const
write	ml/ml.hpp	/^    virtual void write( CvFileStorage* storage, const char* name ) const;$/;"	p	class:CvStatModel	access:public	signature:( CvFileStorage* storage, const char* name ) const
write	objdetect/objdetect.hpp	/^    virtual void write(FileStorage& fs, const String& objname) const;$/;"	p	struct:cv::HOGDescriptor	access:public	signature:(FileStorage& fs, const String& objname) const
write	objdetect/objdetect.hpp	/^    void write(FileStorage& fs, const String& name=String()) const;$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:(FileStorage& fs, const String& name=String()) const
writeAsVrml	contrib/contrib.hpp	/^        void writeAsVrml(const String& file, const vector<Scalar>& colors = vector<Scalar>()) const;$/;"	p	class:cv::Mesh3D	access:public	signature:(const String& file, const vector<Scalar>& colors = vector<Scalar>()) const
writeObj	core/core.hpp	/^    void writeObj( const string& name, const void* obj );$/;"	p	class:cv::FileStorage	access:public	signature:( const string& name, const void* obj )
writeRaw	core/core.hpp	/^    void writeRaw( const string& fmt, const uchar* vec, size_t len );$/;"	p	class:cv::FileStorage	access:public	signature:( const string& fmt, const uchar* vec, size_t len )
writeScalar	core/operations.hpp	/^CV_EXPORTS void writeScalar( FileStorage& fs, const string& value );$/;"	p	namespace:cv	signature:( FileStorage& fs, const string& value )
writeScalar	core/operations.hpp	/^CV_EXPORTS void writeScalar( FileStorage& fs, double value );$/;"	p	namespace:cv	signature:( FileStorage& fs, double value )
writeScalar	core/operations.hpp	/^CV_EXPORTS void writeScalar( FileStorage& fs, float value );$/;"	p	namespace:cv	signature:( FileStorage& fs, float value )
writeScalar	core/operations.hpp	/^CV_EXPORTS void writeScalar( FileStorage& fs, int value );$/;"	p	namespace:cv	signature:( FileStorage& fs, int value )
write_node	ml/ml.hpp	/^    virtual void write_node( CvFileStorage* fs, CvDTreeNode* node ) const;$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs, CvDTreeNode* node ) const
write_params	ml/ml.hpp	/^    virtual void write_params( CvFileStorage* fs ) const;$/;"	p	class:CvANN_MLP	access:protected	signature:( CvFileStorage* fs ) const
write_params	ml/ml.hpp	/^    virtual void write_params( CvFileStorage* fs ) const;$/;"	p	class:CvBoost	access:protected	signature:( CvFileStorage* fs ) const
write_params	ml/ml.hpp	/^    virtual void write_params( CvFileStorage* fs ) const;$/;"	p	class:CvEM	access:public	signature:( CvFileStorage* fs ) const
write_params	ml/ml.hpp	/^    virtual void write_params( CvFileStorage* fs ) const;$/;"	p	class:CvGBTrees	access:protected	signature:( CvFileStorage* fs ) const
write_params	ml/ml.hpp	/^    virtual void write_params( CvFileStorage* fs ) const;$/;"	p	class:CvSVM	access:protected	signature:( CvFileStorage* fs ) const
write_params	ml/ml.hpp	/^    virtual void write_params( CvFileStorage* fs ) const;$/;"	p	struct:CvDTreeTrainData	access:public	signature:( CvFileStorage* fs ) const
write_results	ml/ml.hpp	/^    virtual float write_results( int k, int k1, int start, int end,$/;"	p	class:CvKNearest	access:public	signature:( int k, int k1, int start, int end, const float* neighbor_responses, const float* dist, CvMat* _results, CvMat* _neighbor_responses, CvMat* _dist, Cv32suf* sort_buf ) const
write_split	ml/ml.hpp	/^    virtual void write_split( CvFileStorage* fs, CvDTreeSplit* split ) const;$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs, CvDTreeSplit* split ) const
write_tree_nodes	ml/ml.hpp	/^    virtual void write_tree_nodes( CvFileStorage* fs ) const;$/;"	p	class:CvDTree	access:protected	signature:( CvFileStorage* fs ) const
writer	core/core_c.h	/^CVAPI(CvSeq*)  cvEndWriteSeq( CvSeqWriter* writer );$/;"	v
writer	core/core_c.h	/^CVAPI(void)   cvFlushSeqWriter( CvSeqWriter* writer );$/;"	v
writer	core/core_c.h	/^CVAPI(void)  cvCreateSeqBlock( CvSeqWriter* writer );$/;"	v
writer	highgui/highgui.hpp	/^    Ptr<CvVideoWriter> writer;$/;"	m	class:cv::VideoWriter	access:protected
writer	highgui/highgui_c.h	/^CVAPI(void) cvReleaseVideoWriter( CvVideoWriter** writer );$/;"	v
x	contrib/contrib.hpp	/^        int x, y;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
x	contrib/contrib.hpp	/^    double x, y, value;$/;"	m	class:CvFuzzyPoint	access:public
x	core/core.hpp	/^    _Tp x, y, width, height; \/\/< the top-left corner, as well as width and height of the rectangle$/;"	m	class:cv::Rect_	access:public
x	core/core.hpp	/^    _Tp x, y, z; \/\/< the point coordinates$/;"	m	class:cv::Point3_	access:public
x	core/core.hpp	/^    _Tp x, y; \/\/< the point coordinates$/;"	m	class:cv::Point_	access:public
x	core/types_c.h	/^    double x;$/;"	m	struct:CvPoint2D64f	access:public
x	core/types_c.h	/^    double x;$/;"	m	struct:CvPoint3D64f	access:public
x	core/types_c.h	/^    float x;$/;"	m	struct:CvPoint2D32f	access:public
x	core/types_c.h	/^    float x;$/;"	m	struct:CvPoint3D32f	access:public
x	core/types_c.h	/^    int x;$/;"	m	struct:CvPoint	access:public
x	core/types_c.h	/^    int x;$/;"	m	struct:CvRect	access:public
x	features2d/features2d.hpp	/^  int x;$/;"	m	struct:cv::BaseKeypoint	access:public
x	gpu/NCV.hpp	/^    Ncv32s x;          \/\/\/< x-coordinate of upper left corner.$/;"	m	struct:NcvRect32s	access:public
x	gpu/NCV.hpp	/^    Ncv32u x;          \/\/\/< x-coordinate of upper left corner.$/;"	m	struct:NcvRect32u	access:public
x	gpu/NCV.hpp	/^    Ncv8u x;$/;"	m	struct:NcvRect8u	access:public
x	legacy/blobtrack.hpp	/^    float   x,y; \/* blob position   *\/$/;"	m	struct:CvBlob	access:public
x	legacy/compat.hpp	/^    int     x;                      \/* current x coordinate ( in pixels )               *\/$/;"	m	struct:_CvPixelPosition8u	access:public
x	legacy/compat.hpp	/^    int     x;$/;"	m	struct:_CvPixelPosition32f	access:public
x	legacy/compat.hpp	/^    int     x;$/;"	m	struct:_CvPixelPosition8s	access:public
x	objdetect/objdetect.hpp	/^    int x;$/;"	m	struct:__anon196	access:public
x1	features2d/features2d.hpp	/^        uchar x1, y1, x2, y2;$/;"	m	struct:cv::FernClassifier::Feature	access:public
x2	features2d/features2d.hpp	/^        uchar x1, y1, x2, y2;$/;"	m	struct:cv::FernClassifier::Feature	access:public
xGc	contrib/contrib.hpp	/^        int xGc, yGc;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
xOffset	core/types_c.h	/^    int  xOffset;$/;"	m	struct:_IplROI	access:public
x_max	contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
x_min	contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
xor_masks_	flann/lsh_index.h	/^    std::vector<lsh::BucketKey> xor_masks_;$/;"	m	class:cvflann::LshIndex	access:private
y	contrib/contrib.hpp	/^        int x, y;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
y	contrib/contrib.hpp	/^    double x, y, value;$/;"	m	class:CvFuzzyPoint	access:public
y	core/core.hpp	/^    _Tp x, y, width, height; \/\/< the top-left corner, as well as width and height of the rectangle$/;"	m	class:cv::Rect_	access:public
y	core/core.hpp	/^    _Tp x, y, z; \/\/< the point coordinates$/;"	m	class:cv::Point3_	access:public
y	core/core.hpp	/^    _Tp x, y; \/\/< the point coordinates$/;"	m	class:cv::Point_	access:public
y	core/types_c.h	/^    double y;$/;"	m	struct:CvPoint2D64f	access:public
y	core/types_c.h	/^    double y;$/;"	m	struct:CvPoint3D64f	access:public
y	core/types_c.h	/^    float y;$/;"	m	struct:CvPoint2D32f	access:public
y	core/types_c.h	/^    float y;$/;"	m	struct:CvPoint3D32f	access:public
y	core/types_c.h	/^    int y;$/;"	m	struct:CvPoint	access:public
y	core/types_c.h	/^    int y;$/;"	m	struct:CvRect	access:public
y	features2d/features2d.hpp	/^  int y;$/;"	m	struct:cv::BaseKeypoint	access:public
y	gpu/NCV.hpp	/^    Ncv32s y;          \/\/\/< y-coordinate of upper left corner.$/;"	m	struct:NcvRect32s	access:public
y	gpu/NCV.hpp	/^    Ncv32u y;          \/\/\/< y-coordinate of upper left corner.$/;"	m	struct:NcvRect32u	access:public
y	gpu/NCV.hpp	/^    Ncv8u y;$/;"	m	struct:NcvRect8u	access:public
y	legacy/blobtrack.hpp	/^    float   x,y; \/* blob position   *\/$/;"	m	struct:CvBlob	access:public
y	ml/ml.hpp	/^    schar* y;$/;"	m	class:CvSVMSolver	access:public
y	objdetect/objdetect.hpp	/^    int y;$/;"	m	struct:__anon196	access:public
y1	features2d/features2d.hpp	/^        uchar x1, y1, x2, y2;$/;"	m	struct:cv::FernClassifier::Feature	access:public
y2	features2d/features2d.hpp	/^        uchar x1, y1, x2, y2;$/;"	m	struct:cv::FernClassifier::Feature	access:public
yGc	contrib/contrib.hpp	/^        int xGc, yGc;$/;"	m	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public
yOffset	core/types_c.h	/^    int  yOffset;$/;"	m	struct:_IplROI	access:public
y_max	contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
y_min	contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
z	core/core.hpp	/^    _Tp x, y, z; \/\/< the point coordinates$/;"	m	class:cv::Point3_	access:public
z	core/types_c.h	/^    double z;$/;"	m	struct:CvPoint3D64f	access:public
z	core/types_c.h	/^    float z;$/;"	m	struct:CvPoint3D32f	access:public
z_max	contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
z_min	contrib/contrib.hpp	/^            float x_min, x_max, y_min, y_max, z_min, z_max;$/;"	m	struct:cv::Octree::Node	access:public
zeros	core/core.hpp	/^    static MatExpr zeros(Size size);$/;"	p	class:cv::Mat_	access:public	signature:(Size size)
zeros	core/core.hpp	/^    static MatExpr zeros(Size size, int type);$/;"	p	class:cv::Mat	access:public	signature:(Size size, int type)
zeros	core/core.hpp	/^    static MatExpr zeros(int _ndims, const int* _sizes);$/;"	p	class:cv::Mat_	access:public	signature:(int _ndims, const int* _sizes)
zeros	core/core.hpp	/^    static MatExpr zeros(int ndims, const int* sz, int type);$/;"	p	class:cv::Mat	access:public	signature:(int ndims, const int* sz, int type)
zeros	core/core.hpp	/^    static MatExpr zeros(int rows, int cols);$/;"	p	class:cv::Mat_	access:public	signature:(int rows, int cols)
zeros	core/core.hpp	/^    static MatExpr zeros(int rows, int cols, int type);$/;"	p	class:cv::Mat	access:public	signature:(int rows, int cols, int type)
zeros	core/core.hpp	/^    static Matx zeros();$/;"	p	class:cv::Matx	access:public	signature:()
zeros	core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::zeros(Size sz)$/;"	f	class:cv::Mat_	signature:(Size sz)
zeros	core/mat.hpp	/^template<typename _Tp> inline MatExpr Mat_<_Tp>::zeros(int rows, int cols)$/;"	f	class:cv::Mat_	signature:(int rows, int cols)
zeros	core/operations.hpp	/^Matx<_Tp,m,n> Matx<_Tp,m,n>::zeros()$/;"	f	class:cv::Matx	signature:()
~AdjusterAdapter	features2d/features2d.hpp	/^    virtual ~AdjusterAdapter() {}$/;"	f	class:cv::AdjusterAdapter	access:public	signature:()
~Allocator	core/core.hpp	/^    ~Allocator() {}$/;"	f	class:cv::Allocator	access:public	signature:()
~AutoBuffer	core/core.hpp	/^    ~AutoBuffer();$/;"	p	class:cv::AutoBuffer	access:public	signature:()
~AutoBuffer	core/operations.hpp	/^template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>::~AutoBuffer()$/;"	f	class:cv::AutoBuffer	signature:()
~AutotunedIndex	flann/autotuned_index.h	/^    virtual ~AutotunedIndex()$/;"	f	class:cvflann::AutotunedIndex	access:public	signature:()
~BOWImgDescriptorExtractor	features2d/features2d.hpp	/^    virtual ~BOWImgDescriptorExtractor();$/;"	p	class:cv::BOWImgDescriptorExtractor	access:public	signature:()
~BOWKMeansTrainer	features2d/features2d.hpp	/^    virtual ~BOWKMeansTrainer();$/;"	p	class:cv::BOWKMeansTrainer	access:public	signature:()
~BOWTrainer	features2d/features2d.hpp	/^    virtual ~BOWTrainer();$/;"	p	class:cv::BOWTrainer	access:public	signature:()
~BackgroundSubtractor	video/background_segm.hpp	/^    virtual ~BackgroundSubtractor();$/;"	p	class:cv::BackgroundSubtractor	access:public	signature:()
~BackgroundSubtractorMOG	video/background_segm.hpp	/^    virtual ~BackgroundSubtractorMOG();$/;"	p	class:cv::BackgroundSubtractorMOG	access:public	signature:()
~BackgroundSubtractorMOG2	video/background_segm.hpp	/^    virtual ~BackgroundSubtractorMOG2();$/;"	p	class:cv::BackgroundSubtractorMOG2	access:public	signature:()
~BaseColumnFilter	imgproc/imgproc.hpp	/^    virtual ~BaseColumnFilter();$/;"	p	class:cv::BaseColumnFilter	access:public	signature:()
~BaseColumnFilter_GPU	gpu/gpu.hpp	/^            virtual ~BaseColumnFilter_GPU() {}$/;"	f	class:cv::gpu::BaseColumnFilter_GPU	access:public	signature:()
~BaseFilter	imgproc/imgproc.hpp	/^    virtual ~BaseFilter();$/;"	p	class:cv::BaseFilter	access:public	signature:()
~BaseFilter_GPU	gpu/gpu.hpp	/^            virtual ~BaseFilter_GPU() {}$/;"	f	class:cv::gpu::BaseFilter_GPU	access:public	signature:()
~BaseRowFilter	imgproc/imgproc.hpp	/^    virtual ~BaseRowFilter();$/;"	p	class:cv::BaseRowFilter	access:public	signature:()
~BaseRowFilter_GPU	gpu/gpu.hpp	/^            virtual ~BaseRowFilter_GPU() {}$/;"	f	class:cv::gpu::BaseRowFilter_GPU	access:public	signature:()
~BruteForceMatcher	features2d/features2d.hpp	/^    virtual ~BruteForceMatcher() {}$/;"	f	class:cv::BruteForceMatcher	access:public	signature:()
~CascadeClassifier	objdetect/objdetect.hpp	/^    virtual ~CascadeClassifier();$/;"	p	class:cv::CascadeClassifier	access:public	signature:()
~CascadeClassifier_GPU	gpu/gpu.hpp	/^            ~CascadeClassifier_GPU();$/;"	p	class:cv::gpu::CascadeClassifier_GPU	access:public	signature:()
~CompositeIndex	flann/composite_index.h	/^    virtual ~CompositeIndex()$/;"	f	class:cvflann::CompositeIndex	access:public	signature:()
~CudaMem	gpu/gpu.hpp	/^            ~CudaMem();$/;"	p	class:cv::gpu::CudaMem	access:public	signature:()
~CudaMem	gpu/matrix_operations.hpp	/^inline CudaMem::~CudaMem()$/;"	f	class:cv::gpu::CudaMem	signature:()
~CvANN_MLP	ml/ml.hpp	/^    virtual ~CvANN_MLP();$/;"	p	class:CvANN_MLP	access:public	signature:()
~CvANN_MLP_TrainParams	ml/ml.hpp	/^    ~CvANN_MLP_TrainParams();$/;"	p	struct:CvANN_MLP_TrainParams	access:public	signature:()
~CvAdaptiveSkinDetector	contrib/contrib.hpp	/^    virtual ~CvAdaptiveSkinDetector();$/;"	p	class:CvAdaptiveSkinDetector	access:public	signature:()
~CvBlobSeq	legacy/blobtrack.hpp	/^    virtual ~CvBlobSeq()$/;"	f	class:CvBlobSeq	access:public	signature:()
~CvBlobTrackAnalysisOne	legacy/blobtrack.hpp	/^    virtual ~CvBlobTrackAnalysisOne() {};$/;"	f	class:CvBlobTrackAnalysisOne	access:public	signature:()
~CvBlobTrackSeq	legacy/blobtrack.hpp	/^    virtual ~CvBlobTrackSeq();$/;"	p	class:CvBlobTrackSeq	access:public	signature:()
~CvBoost	ml/ml.hpp	/^    virtual ~CvBoost();$/;"	p	class:CvBoost	access:public	signature:()
~CvBoostTree	ml/ml.hpp	/^    virtual ~CvBoostTree();$/;"	p	class:CvBoostTree	access:public	signature:()
~CvCalibFilter	legacy/legacy.hpp	/^    virtual ~CvCalibFilter();$/;"	p	class:CvCalibFilter	access:public	signature:()
~CvCamShiftTracker	legacy/legacy.hpp	/^    virtual ~CvCamShiftTracker();$/;"	p	class:CvCamShiftTracker	access:public	signature:()
~CvDTree	ml/ml.hpp	/^    virtual ~CvDTree();$/;"	p	class:CvDTree	access:public	signature:()
~CvDTreeTrainData	ml/ml.hpp	/^    virtual ~CvDTreeTrainData();$/;"	p	struct:CvDTreeTrainData	access:public	signature:()
~CvEM	ml/ml.hpp	/^    virtual ~CvEM();$/;"	p	class:CvEM	access:public	signature:()
~CvERTrees	ml/ml.hpp	/^    virtual ~CvERTrees();$/;"	p	class:CvERTrees	access:public	signature:()
~CvForestTree	ml/ml.hpp	/^    virtual ~CvForestTree();$/;"	p	class:CvForestTree	access:public	signature:()
~CvFuzzyController	contrib/contrib.hpp	/^    ~CvFuzzyController();$/;"	p	class:CvFuzzyController	access:public	signature:()
~CvFuzzyCurve	contrib/contrib.hpp	/^    ~CvFuzzyCurve();$/;"	p	class:CvFuzzyCurve	access:public	signature:()
~CvFuzzyFunction	contrib/contrib.hpp	/^    ~CvFuzzyFunction();$/;"	p	class:CvFuzzyFunction	access:public	signature:()
~CvFuzzyMeanShiftTracker	contrib/contrib.hpp	/^    ~CvFuzzyMeanShiftTracker();$/;"	p	class:CvFuzzyMeanShiftTracker	access:public	signature:()
~CvFuzzyRule	contrib/contrib.hpp	/^    ~CvFuzzyRule();$/;"	p	class:CvFuzzyRule	access:public	signature:()
~CvGBTrees	ml/ml.hpp	/^    virtual ~CvGBTrees();$/;"	p	class:CvGBTrees	access:public	signature:()
~CvImage	legacy/legacy.hpp	/^    ~CvImage()$/;"	f	class:CvImage	access:public	signature:()
~CvImageDrawer	legacy/blobtrack.hpp	/^    ~CvImageDrawer() { cvReleaseImage( &m_image ); }$/;"	f	class:CvImageDrawer	access:public	signature:()
~CvKNearest	ml/ml.hpp	/^    virtual ~CvKNearest();$/;"	p	class:CvKNearest	access:public	signature:()
~CvLSHOperations	imgproc/imgproc.hpp	/^  virtual ~CvLSHOperations() {}$/;"	f	struct:CvLSHOperations	access:public	signature:()
~CvLevMarq	calib3d/calib3d.hpp	/^    ~CvLevMarq();$/;"	p	class:CvLevMarq	access:public	signature:()
~CvMLData	ml/ml.hpp	/^    virtual ~CvMLData();$/;"	p	class:CvMLData	access:public	signature:()
~CvMatrix	legacy/legacy.hpp	/^    ~CvMatrix()$/;"	f	class:CvMatrix	access:public	signature:()
~CvModule	core/core_c.h	/^    ~CvModule();$/;"	p	struct:CvModule	access:public	signature:()
~CvNormalBayesClassifier	ml/ml.hpp	/^    virtual ~CvNormalBayesClassifier();$/;"	p	class:CvNormalBayesClassifier	access:public	signature:()
~CvObjectDetector	legacy/blobtrack.hpp	/^    ~CvObjectDetector();$/;"	p	class:CvObjectDetector	access:public	signature:()
~CvProb	legacy/blobtrack.hpp	/^    virtual ~CvProb() {};$/;"	f	class:CvProb	access:public	signature:()
~CvRTrees	ml/ml.hpp	/^    virtual ~CvRTrees();$/;"	p	class:CvRTrees	access:public	signature:()
~CvSVM	ml/ml.hpp	/^    virtual ~CvSVM();$/;"	p	class:CvSVM	access:public	signature:()
~CvSVMKernel	ml/ml.hpp	/^    virtual ~CvSVMKernel();$/;"	p	struct:CvSVMKernel	access:public	signature:()
~CvSVMSolver	ml/ml.hpp	/^    virtual ~CvSVMSolver();$/;"	p	class:CvSVMSolver	access:public	signature:()
~CvStatModel	ml/ml.hpp	/^    virtual ~CvStatModel();$/;"	p	class:CvStatModel	access:public	signature:()
~CvType	core/core_c.h	/^    ~CvType();$/;"	p	struct:CvType	access:public	signature:()
~CvVSModule	legacy/blobtrack.hpp	/^    virtual ~CvVSModule();$/;"	p	class:CvVSModule	access:public	signature:()
~DefaultRngAuto	features2d/features2d.hpp	/^        ~DefaultRngAuto() { theRNG().state = old_state; }$/;"	f	struct:cv::DefaultRngAuto	access:public	signature:()
~DescriptorCollection	features2d/features2d.hpp	/^        virtual ~DescriptorCollection();$/;"	p	class:cv::DescriptorMatcher::DescriptorCollection	access:public	signature:()
~DescriptorExtractor	features2d/features2d.hpp	/^    virtual ~DescriptorExtractor();$/;"	p	class:cv::DescriptorExtractor	access:public	signature:()
~DescriptorMatcher	features2d/features2d.hpp	/^    virtual ~DescriptorMatcher();$/;"	p	class:cv::DescriptorMatcher	access:public	signature:()
~Exception	core/core.hpp	/^    virtual ~Exception() throw();$/;"	p	class:cv::Exception	access:public	signature:()
~FeatureDetector	features2d/features2d.hpp	/^    virtual ~FeatureDetector();$/;"	p	class:cv::FeatureDetector	access:public	signature:()
~FeatureEvaluator	objdetect/objdetect.hpp	/^    virtual ~FeatureEvaluator();$/;"	p	class:cv::FeatureEvaluator	access:public	signature:()
~FernClassifier	features2d/features2d.hpp	/^    virtual ~FernClassifier();$/;"	p	class:cv::FernClassifier	access:public	signature:()
~FernDescriptorMatcher	features2d/features2d.hpp	/^    virtual ~FernDescriptorMatcher();$/;"	p	class:cv::FernDescriptorMatcher	access:public	signature:()
~FileStorage	core/core.hpp	/^    virtual ~FileStorage();$/;"	p	class:cv::FileStorage	access:public	signature:()
~FilterEngine	imgproc/imgproc.hpp	/^    virtual ~FilterEngine();$/;"	p	class:cv::FilterEngine	access:public	signature:()
~FilterEngine_GPU	gpu/gpu.hpp	/^            virtual ~FilterEngine_GPU() {}$/;"	f	class:cv::gpu::FilterEngine_GPU	access:public	signature:()
~Formatter	core/operations.hpp	/^    virtual ~Formatter() {}$/;"	f	class:cv::Formatter	access:public	signature:()
~GenericDescriptorMatcher	features2d/features2d.hpp	/^    virtual ~GenericDescriptorMatcher();$/;"	p	class:cv::GenericDescriptorMatcher	access:public	signature:()
~GenericIndex	flann/flann.hpp	/^        ~GenericIndex();$/;"	p	class:cv::flann::GenericIndex	access:public	signature:()
~GenericIndex	flann/flann.hpp	/^GenericIndex<Distance>::~GenericIndex()$/;"	f	class:cv::flann::GenericIndex	signature:()
~GpuMat	gpu/gpumat.hpp	/^        ~GpuMat();$/;"	p	class:cv::gpu::GpuMat	access:public	signature:()
~GpuMat	gpu/gpumat.hpp	/^    inline GpuMat::~GpuMat() { release(); }$/;"	f	class:cv::gpu::GpuMat	signature:()
~HOGDescriptor	objdetect/objdetect.hpp	/^    virtual ~HOGDescriptor() {}$/;"	f	struct:cv::HOGDescriptor	access:public	signature:()
~HierarchicalClusteringIndex	flann/hierarchical_clustering_index.h	/^    virtual ~HierarchicalClusteringIndex()$/;"	f	class:cvflann::HierarchicalClusteringIndex	access:public	signature:()
~Histogram	contrib/contrib.hpp	/^        virtual ~Histogram();$/;"	p	class:CvAdaptiveSkinDetector::Histogram	access:public	signature:()
~INCVMemAllocator	gpu/NCV.hpp	/^    virtual ~INCVMemAllocator() = 0;$/;"	p	class:INCVMemAllocator	access:public	signature:()
~INCVMemAllocator	gpu/NCV.hpp	/^inline INCVMemAllocator::~INCVMemAllocator() {}$/;"	f	class:INCVMemAllocator	signature:()
~Index	flann/flann_base.hpp	/^    ~Index()$/;"	f	class:cvflann::Index	access:public	signature:()
~Index	flann/miniflann.hpp	/^    virtual ~Index();$/;"	p	class:cv::flann::Index	access:public	signature:()
~IndexParams	flann/miniflann.hpp	/^    ~IndexParams();$/;"	p	struct:cv::flann::IndexParams	access:public	signature:()
~Index_	flann/flann.hpp	/^	~Index_();$/;"	p	class:cv::flann::Index_	access:public	signature:()
~Index_	flann/flann.hpp	/^Index_<T>::~Index_()$/;"	f	class:cv::flann::Index_	signature:()
~KDTreeIndex	flann/kdtree_index.h	/^    ~KDTreeIndex()$/;"	f	class:cvflann::KDTreeIndex	access:public	signature:()
~KDTreeSingleIndex	flann/kdtree_single_index.h	/^    ~KDTreeSingleIndex()$/;"	f	class:cvflann::KDTreeSingleIndex	access:public	signature:()
~KMeansIndex	flann/kmeans_index.h	/^    virtual ~KMeansIndex()$/;"	f	class:cvflann::KMeansIndex	access:public	signature:()
~LevMarqSparse	contrib/contrib.hpp	/^        virtual ~LevMarqSparse();$/;"	p	class:cv::LevMarqSparse	access:public	signature:()
~Logger	flann/logger.h	/^    ~Logger()$/;"	f	class:cvflann::Logger	access:private	signature:()
~Mat	core/core.hpp	/^    ~Mat();$/;"	p	class:cv::Mat	access:public	signature:()
~Mat	core/mat.hpp	/^inline Mat::~Mat()$/;"	f	class:cv::Mat	signature:()
~MatAllocator	core/core.hpp	/^    virtual ~MatAllocator() {}$/;"	f	class:cv::MatAllocator	access:public	signature:()
~MatOp	core/mat.hpp	/^    virtual ~MatOp() {};$/;"	f	class:cv::MatOp	access:public	signature:()
~Mesh3D	contrib/contrib.hpp	/^        ~Mesh3D();$/;"	p	class:cv::Mesh3D	access:public	signature:()
~NCVMatrix	gpu/NCV.hpp	/^    virtual ~NCVMatrix() {}$/;"	f	class:NCVMatrix	access:public	signature:()
~NCVMatrixAlloc	gpu/NCV.hpp	/^    ~NCVMatrixAlloc()$/;"	f	class:NCVMatrixAlloc	access:public	signature:()
~NCVMemNativeAllocator	gpu/NCV.hpp	/^    virtual ~NCVMemNativeAllocator();$/;"	p	class:NCVMemNativeAllocator	access:public	signature:()
~NCVMemStackAllocator	gpu/NCV.hpp	/^    virtual ~NCVMemStackAllocator();$/;"	p	class:NCVMemStackAllocator	access:public	signature:()
~NCVVector	gpu/NCV.hpp	/^    virtual ~NCVVector() {}$/;"	f	class:NCVVector	access:public	signature:()
~NCVVectorAlloc	gpu/NCV.hpp	/^    ~NCVVectorAlloc()$/;"	f	class:NCVVectorAlloc	access:public	signature:()
~NNIndex	flann/nn_index.h	/^    virtual ~NNIndex() {}$/;"	f	class:cvflann::NNIndex	access:public	signature:()
~ORB	features2d/features2d.hpp	/^  ~ORB();$/;"	p	class:cv::ORB	access:public	signature:()
~Octree	contrib/contrib.hpp	/^        virtual ~Octree();$/;"	p	class:cv::Octree	access:public	signature:()
~OneWayDescriptor	features2d/features2d.hpp	/^    ~OneWayDescriptor();$/;"	p	class:cv::OneWayDescriptor	access:public	signature:()
~OneWayDescriptorBase	features2d/features2d.hpp	/^    virtual ~OneWayDescriptorBase();$/;"	p	class:cv::OneWayDescriptorBase	access:public	signature:()
~OneWayDescriptorMatcher	features2d/features2d.hpp	/^    virtual ~OneWayDescriptorMatcher();$/;"	p	class:cv::OneWayDescriptorMatcher	access:public	signature:()
~OneWayDescriptorObject	features2d/features2d.hpp	/^    virtual ~OneWayDescriptorObject();$/;"	p	class:cv::OneWayDescriptorObject	access:public	signature:()
~OrbDescriptorExtractor	features2d/features2d.hpp	/^  ~OrbDescriptorExtractor()$/;"	f	class:cv::OrbDescriptorExtractor	access:public	signature:()
~PlanarObjectDetector	objdetect/objdetect.hpp	/^    virtual ~PlanarObjectDetector();$/;"	p	class:cv::PlanarObjectDetector	access:public	signature:()
~PooledAllocator	flann/allocator.h	/^    ~PooledAllocator()$/;"	f	class:cvflann::PooledAllocator	access:public	signature:()
~Ptr	core/core.hpp	/^    ~Ptr();$/;"	p	class:cv::Ptr	access:public	signature:()
~Ptr	core/operations.hpp	/^template<typename _Tp> inline Ptr<_Tp>::~Ptr() { release(); }$/;"	f	class:cv::Ptr	signature:()
~RadiusResultSet	flann/result_set.h	/^    ~RadiusResultSet()$/;"	f	class:cvflann::RadiusResultSet	access:public	signature:()
~RandomizedTree	features2d/features2d.hpp	/^  ~RandomizedTree();$/;"	p	class:cv::RandomizedTree	access:public	signature:()
~ResultSet	flann/result_set.h	/^    virtual ~ResultSet() {}$/;"	f	class:cvflann::ResultSet	access:public	signature:()
~Retina	contrib/retina.hpp	/^        virtual ~Retina();$/;"	p	class:cv::Retina	access:public	signature:()
~SearchWindow	contrib/contrib.hpp	/^        ~SearchWindow();$/;"	p	class:CvFuzzyMeanShiftTracker::SearchWindow	access:public	signature:()
~SelfSimDescriptor	contrib/contrib.hpp	/^        virtual ~SelfSimDescriptor();$/;"	p	class:cv::SelfSimDescriptor	access:public	signature:()
~SparseMat	core/core.hpp	/^    ~SparseMat();$/;"	p	class:cv::SparseMat	access:public	signature:()
~SparseMat	core/mat.hpp	/^inline SparseMat::~SparseMat()$/;"	f	class:cv::SparseMat	signature:()
~SpinImageModel	contrib/contrib.hpp	/^        ~SpinImageModel();$/;"	p	class:cv::SpinImageModel	access:public	signature:()
~StereoSGBM	calib3d/calib3d.hpp	/^    virtual ~StereoSGBM();$/;"	p	class:cv::StereoSGBM	access:public	signature:()
~StereoVar	contrib/contrib.hpp	/^        virtual ~StereoVar();$/;"	p	class:cv::StereoVar	access:public	signature:()
~Stream	gpu/gpu.hpp	/^            ~Stream();$/;"	p	class:cv::gpu::Stream	access:public	signature:()
~UntypedMatrix	flann/matrix.h	/^    ~UntypedMatrix()$/;"	f	class:cvflann::UntypedMatrix	access:public	signature:()
~Vector	core/operations.hpp	/^    ~Vector()  { release(); }$/;"	f	class:cv::Vector	access:public	signature:()
~VectorDescriptorMatcher	features2d/features2d.hpp	/^    virtual ~VectorDescriptorMatcher();$/;"	p	class:cv::VectorDescriptorMatcher	access:public	signature:()
~VideoCapture	highgui/highgui.hpp	/^    virtual ~VideoCapture();$/;"	p	class:cv::VideoCapture	access:public	signature:()
~VideoWriter	highgui/highgui.hpp	/^    virtual ~VideoWriter();$/;"	p	class:cv::VideoWriter	access:public	signature:()
~WImage	core/wimage.hpp	/^    virtual ~WImage() = 0;$/;"	p	class:cv::WImage	access:public	signature:()
~WImage	core/wimage.hpp	/^template<typename T> inline WImage<T>::~WImage() {}$/;"	f	class:cv::WImage	signature:()
~WImageBuffer	core/wimage.hpp	/^    ~WImageBuffer() {$/;"	f	class:cv::WImageBuffer	access:public	signature:()
~WImageBufferC	core/wimage.hpp	/^    ~WImageBufferC() {$/;"	f	class:cv::WImageBufferC	access:public	signature:()
~WImageC	core/wimage.hpp	/^    virtual ~WImageC() = 0;$/;"	p	class:cv::WImageC	access:public	signature:()
~WImageC	core/wimage.hpp	/^template<typename T, int C> inline WImageC<T, C>::~WImageC() {}$/;"	f	class:cv::WImageC	signature:()
~WImageViewC	core/wimage.hpp	/^    virtual ~WImageViewC() {}$/;"	f	class:cv::WImageViewC	access:public	signature:()
~WriteStructContext	core/operations.hpp	/^    ~WriteStructContext();$/;"	p	class:cv::WriteStructContext	access:public	signature:()
~any	flann/any.h	/^    ~any()$/;"	f	struct:cdiggins::any	access:public	signature:()
